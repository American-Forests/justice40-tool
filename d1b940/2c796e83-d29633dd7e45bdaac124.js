(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[634],{2974:function(module,__unused_webpack_exports,__webpack_require__){eval('__webpack_require__(5438);\n\n/* Mapbox GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/mapbox/mapbox-gl-js/blob/v1.13.1/LICENSE.txt */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  \'use strict\';\n  /* eslint-disable */\n\n  var shared, worker, mapboxgl; // define gets called three times: one for each chunk. we rely on the order\n  // they\'re imported to know which is which\n\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \'var sharedChunk = {}; (\' + shared + \')(sharedChunk); (\' + worker + \')(sharedChunk);\';\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n\n      if (typeof window !== \'undefined\') {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: \'text/javascript\'\n        }));\n      }\n    }\n  }\n\n  define(["exports"], function (t) {\n    "use strict";\n\n    function e(t, e) {\n      return t(e = {\n        exports: {}\n      }, e.exports), e.exports;\n    }\n\n    var r = n;\n\n    function n(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;\n    }\n\n    n.prototype.sampleCurveX = function (t) {\n      return ((this.ax * t + this.bx) * t + this.cx) * t;\n    }, n.prototype.sampleCurveY = function (t) {\n      return ((this.ay * t + this.by) * t + this.cy) * t;\n    }, n.prototype.sampleCurveDerivativeX = function (t) {\n      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n    }, n.prototype.solveCurveX = function (t, e) {\n      var r, n, i, a, o;\n\n      for (void 0 === e && (e = 1e-6), i = t, o = 0; o < 8; o++) {\n        if (a = this.sampleCurveX(i) - t, Math.abs(a) < e) return i;\n        var s = this.sampleCurveDerivativeX(i);\n        if (Math.abs(s) < 1e-6) break;\n        i -= a / s;\n      }\n\n      if ((i = t) < (r = 0)) return r;\n      if (i > (n = 1)) return n;\n\n      for (; r < n;) {\n        if (a = this.sampleCurveX(i), Math.abs(a - t) < e) return i;\n        t > a ? r = i : n = i, i = .5 * (n - r) + r;\n      }\n\n      return i;\n    }, n.prototype.solve = function (t, e) {\n      return this.sampleCurveY(this.solveCurveX(t, e));\n    };\n    var i = a;\n\n    function a(t, e) {\n      this.x = t, this.y = e;\n    }\n\n    a.prototype = {\n      clone: function clone() {\n        return new a(this.x, this.y);\n      },\n      add: function add(t) {\n        return this.clone()._add(t);\n      },\n      sub: function sub(t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function multByPoint(t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function divByPoint(t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function mult(t) {\n        return this.clone()._mult(t);\n      },\n      div: function div(t) {\n        return this.clone()._div(t);\n      },\n      rotate: function rotate(t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function rotateAround(t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function matMult(t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function unit() {\n        return this.clone()._unit();\n      },\n      perp: function perp() {\n        return this.clone()._perp();\n      },\n      round: function round() {\n        return this.clone()._round();\n      },\n      mag: function mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function equals(t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function dist(t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function distSqr(t) {\n        var e = t.x - this.x,\n            r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function angle() {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function angleTo(t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function angleWith(t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function angleWithSep(t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function _matMult(t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function _add(t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function _sub(t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function _mult(t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function _div(t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function _multByPoint(t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function _divByPoint(t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function _unit() {\n        return this._div(this.mag()), this;\n      },\n      _perp: function _perp() {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function _rotate(t) {\n        var e = Math.cos(t),\n            r = Math.sin(t),\n            n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function _rotateAround(t, e) {\n        var r = Math.cos(t),\n            n = Math.sin(t),\n            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function _round() {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, a.convert = function (t) {\n      return t instanceof a ? t : Array.isArray(t) ? new a(t[0], t[1]) : t;\n    };\n    var o = "undefined" != typeof self ? self : {},\n        s = Math.pow(2, 53) - 1;\n\n    function u(t, e, n, i) {\n      var a = new r(t, e, n, i);\n      return function (t) {\n        return a.solve(t);\n      };\n    }\n\n    var l = u(.25, .1, .25, 1);\n\n    function p(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n\n    function c(t, e, r) {\n      var n = r - e,\n          i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n\n    function h(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n\n        for (var o in a) {\n          t[o] = a[o];\n        }\n      }\n\n      return t;\n    }\n\n    var f = 1;\n\n    function y() {\n      return f++;\n    }\n\n    function d() {\n      return function t(e) {\n        return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n\n    function m(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n\n    function v(t, e) {\n      t.forEach(function (t) {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n\n    function g(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n\n    function x(t, e, r) {\n      var n = {};\n\n      for (var i in t) {\n        n[i] = e.call(r || this, t[i], i, t);\n      }\n\n      return n;\n    }\n\n    function b(t, e, r) {\n      var n = {};\n\n      for (var i in t) {\n        e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n      }\n\n      return n;\n    }\n\n    function w(t) {\n      return Array.isArray(t) ? t.map(w) : "object" == typeof t && t ? x(t, w) : t;\n    }\n\n    var _ = {};\n\n    function A(t) {\n      _[t] || ("undefined" != typeof console && console.warn(t), _[t] = !0);\n    }\n\n    function S(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n\n    function k(t) {\n      for (var e = 0, r = 0, n = t.length, i = n - 1, a = void 0, o = void 0; r < n; i = r++) {\n        e += ((o = t[i]).x - (a = t[r]).x) * (a.y + o.y);\n      }\n\n      return e;\n    }\n\n    function I() {\n      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;\n    }\n\n    function z(t) {\n      var e = {};\n\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\"((?:[^"\\\\]|\\\\.)*)\\")))?/g, function (t, r, n, i) {\n        var a = n || i;\n        return e[r] = !a || a.toLowerCase(), "";\n      }), e["max-age"]) {\n        var r = parseInt(e["max-age"], 10);\n        isNaN(r) ? delete e["max-age"] : e["max-age"] = r;\n      }\n\n      return e;\n    }\n\n    var C = null;\n\n    function E(t) {\n      if (null == C) {\n        var e = t.navigator ? t.navigator.userAgent : null;\n        C = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match("Safari") && !e.match("Chrome")));\n      }\n\n      return C;\n    }\n\n    function P(t) {\n      try {\n        var e = o[t];\n        return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    var M,\n        B,\n        T,\n        V,\n        F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date),\n        D = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame,\n        L = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame,\n        O = {\n      now: F,\n      frame: function frame(t) {\n        var e = D(t);\n        return {\n          cancel: function cancel() {\n            return L(e);\n          }\n        };\n      },\n      getImageData: function getImageData(t, e) {\n        void 0 === e && (e = 0);\n        var r = o.document.createElement("canvas"),\n            n = r.getContext("2d");\n        if (!n) throw new Error("failed to create canvas 2d context");\n        return r.width = t.width, r.height = t.height, n.drawImage(t, 0, 0, t.width, t.height), n.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);\n      },\n      resolveURL: function resolveURL(t) {\n        return M || (M = o.document.createElement("a")), M.href = t, M.href;\n      },\n      hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4,\n\n      get devicePixelRatio() {\n        return o.devicePixelRatio;\n      },\n\n      get prefersReducedMotion() {\n        return !!o.matchMedia && (null == B && (B = o.matchMedia("(prefers-reduced-motion: reduce)")), B.matches);\n      }\n\n    },\n        R = {\n      API_URL: "https://api.mapbox.com",\n\n      get EVENTS_URL() {\n        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;\n      },\n\n      FEEDBACK_URL: "https://apps.mapbox.com/feedback",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      MAX_PARALLEL_IMAGE_REQUESTS: 16\n    },\n        U = {\n      supported: !1,\n      testSupport: function testSupport(t) {\n        !j && V && (q ? N(t) : T = t);\n      }\n    },\n        j = !1,\n        q = !1;\n\n    function N(t) {\n      var e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, V), t.isContextLost()) return;\n        U.supported = !0;\n      } catch (t) {}\n\n      t.deleteTexture(e), j = !0;\n    }\n\n    o.document && ((V = o.document.createElement("img")).onload = function () {\n      T && N(T), T = null, q = !0;\n    }, V.onerror = function () {\n      j = !0, T = null;\n    }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");\n\n    var K = "01",\n        G = function G(t, e) {\n      this._transformRequestFn = t, this._customAccessToken = e, this._createSkuToken();\n    };\n\n    function Z(t) {\n      return 0 === t.indexOf("mapbox:");\n    }\n\n    G.prototype._createSkuToken = function () {\n      var t = function () {\n        for (var t = "", e = 0; e < 10; e++) {\n          t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];\n        }\n\n        return {\n          token: ["1", K, t].join(""),\n          tokenExpiresAt: Date.now() + 432e5\n        };\n      }();\n\n      this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n    }, G.prototype._isSkuTokenExpired = function () {\n      return Date.now() > this._skuTokenExpiresAt;\n    }, G.prototype.transformRequest = function (t, e) {\n      return this._transformRequestFn && this._transformRequestFn(t, e) || {\n        url: t\n      };\n    }, G.prototype.normalizeStyleURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/styles/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeGlyphsURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/fonts/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSourceURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/v4/" + r.authority + ".json", r.params.push("secure"), this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSpriteURL = function (t, e, r, n) {\n      var i = Y(t);\n      return Z(t) ? (i.path = "/styles/v1" + i.path + "/sprite" + e + r, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += "" + e + r, $(i));\n    }, G.prototype.normalizeTileURL = function (t, e) {\n      if (this._isSkuTokenExpired() && this._createSkuToken(), t && !Z(t)) return t;\n      var r = Y(t);\n      r.path = r.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, (O.devicePixelRatio >= 2 || 512 === e ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r.path = r.path.replace(/^.+\\/v4\\//, "/"), r.path = "/v4" + r.path;\n\n      var n = this._customAccessToken || function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          var n = r[e].match(/^access_token=(.*)$/);\n          if (n) return n[1];\n        }\n\n        return null;\n      }(r.params) || R.ACCESS_TOKEN;\n\n      return R.REQUIRE_ACCESS_TOKEN && n && this._skuToken && r.params.push("sku=" + this._skuToken), this._makeAPIURL(r, n);\n    }, G.prototype.canonicalizeTileURL = function (t, e) {\n      var r = Y(t);\n      if (!r.path.match(/(^\\/v4\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n      var n = "mapbox://tiles/";\n      n += r.path.replace("/v4/", "");\n      var i = r.params;\n      return e && (i = i.filter(function (t) {\n        return !t.match(/^access_token=/);\n      })), i.length && (n += "?" + i.join("&")), n;\n    }, G.prototype.canonicalizeTileset = function (t, e) {\n      for (var r = !!e && Z(e), n = [], i = 0, a = t.tiles || []; i < a.length; i += 1) {\n        var o = a[i];\n        J(o) ? n.push(this.canonicalizeTileURL(o, r)) : n.push(o);\n      }\n\n      return n;\n    }, G.prototype._makeAPIURL = function (t, e) {\n      var r = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",\n          n = Y(R.API_URL);\n\n      if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {\n        var i = t.params.indexOf("secure");\n        i >= 0 && t.params.splice(i, 1);\n      }\n\n      if ("/" !== n.path && (t.path = "" + n.path + t.path), !R.REQUIRE_ACCESS_TOKEN) return $(t);\n      if (!(e = e || R.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + r);\n      if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r);\n      return t.params = t.params.filter(function (t) {\n        return -1 === t.indexOf("access_token");\n      }), t.params.push("access_token=" + e), $(t);\n    };\n    var X = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n\n    function J(t) {\n      return X.test(t);\n    }\n\n    var H = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\n    function Y(t) {\n      var e = t.match(H);\n      if (!e) throw new Error("Unable to parse URL object");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || "/",\n        params: e[4] ? e[4].split("&") : []\n      };\n    }\n\n    function $(t) {\n      var e = t.params.length ? "?" + t.params.join("&") : "";\n      return t.protocol + "://" + t.authority + t.path + e;\n    }\n\n    function W(t) {\n      if (!t) return null;\n      var e = t.split(".");\n      if (!e || 3 !== e.length) return null;\n\n      try {\n        return JSON.parse(decodeURIComponent(o.atob(e[1]).split("").map(function (t) {\n          return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2);\n        }).join("")));\n      } catch (t) {\n        return null;\n      }\n    }\n\n    var Q = function Q(t) {\n      this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n    };\n\n    Q.prototype.getStorageKey = function (t) {\n      var e,\n          r = W(R.ACCESS_TOKEN);\n      return e = r && r.u ? o.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, function (t, e) {\n        return String.fromCharCode(Number("0x" + e));\n      })) : R.ACCESS_TOKEN || "", t ? "mapbox.eventData." + t + ":" + e : "mapbox.eventData:" + e;\n    }, Q.prototype.fetchEventData = function () {\n      var t = P("localStorage"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey("uuid");\n      if (t) try {\n        var n = o.localStorage.getItem(e);\n        n && (this.eventData = JSON.parse(n));\n        var i = o.localStorage.getItem(r);\n        i && (this.anonId = i);\n      } catch (t) {\n        A("Unable to read from LocalStorage");\n      }\n    }, Q.prototype.saveEventData = function () {\n      var t = P("localStorage"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey("uuid");\n      if (t) try {\n        o.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e, JSON.stringify(this.eventData));\n      } catch (t) {\n        A("Unable to write to LocalStorage");\n      }\n    }, Q.prototype.processRequests = function (t) {}, Q.prototype.postEvent = function (t, e, r, n) {\n      var i = this;\n\n      if (R.EVENTS_URL) {\n        var a = Y(R.EVENTS_URL);\n        a.params.push("access_token=" + (n || R.ACCESS_TOKEN || ""));\n        var o = {\n          event: this.type,\n          created: new Date(t).toISOString(),\n          sdkIdentifier: "mapbox-gl-js",\n          sdkVersion: "1.13.1",\n          skuId: K,\n          userId: this.anonId\n        },\n            s = e ? h(o, e) : o,\n            u = {\n          url: $(a),\n          headers: {\n            "Content-Type": "text/plain"\n          },\n          body: JSON.stringify([s])\n        };\n        this.pendingRequest = wt(u, function (t) {\n          i.pendingRequest = null, r(t), i.saveEventData(), i.processRequests(n);\n        });\n      }\n    }, Q.prototype.queueRequest = function (t, e) {\n      this.queue.push(t), this.processRequests(e);\n    };\n\n    var tt,\n        et,\n        rt = function (t) {\n      function e() {\n        t.call(this, "map.load"), this.success = {}, this.skuToken = "";\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postMapLoadEvent = function (t, e, r, n) {\n        this.skuToken = r, (R.EVENTS_URL && n || R.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n          return Z(t) || J(t);\n        })) && this.queueRequest({\n          id: e,\n          timestamp: Date.now()\n        }, n);\n      }, e.prototype.processRequests = function (t) {\n        var e = this;\n\n        if (!this.pendingRequest && 0 !== this.queue.length) {\n          var r = this.queue.shift(),\n              n = r.id,\n              i = r.timestamp;\n          n && this.success[n] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i, {\n            skuToken: this.skuToken\n          }, function (t) {\n            t || n && (e.success[n] = !0);\n          }, t));\n        }\n      }, e;\n    }(Q),\n        nt = new (function (t) {\n      function e(e) {\n        t.call(this, "appUserTurnstile"), this._customAccessToken = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postTurnstileEvent = function (t, e) {\n        R.EVENTS_URL && R.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n          return Z(t) || J(t);\n        }) && this.queueRequest(Date.now(), e);\n      }, e.prototype.processRequests = function (t) {\n        var e = this;\n\n        if (!this.pendingRequest && 0 !== this.queue.length) {\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          var r = W(R.ACCESS_TOKEN),\n              n = r ? r.u : R.ACCESS_TOKEN,\n              i = n !== this.eventData.tokenU;\n          m(this.anonId) || (this.anonId = d(), i = !0);\n          var a = this.queue.shift();\n\n          if (this.eventData.lastSuccess) {\n            var o = new Date(this.eventData.lastSuccess),\n                s = new Date(a),\n                u = (a - this.eventData.lastSuccess) / 864e5;\n            i = i || u >= 1 || u < -1 || o.getDate() !== s.getDate();\n          } else i = !0;\n\n          if (!i) return this.processRequests();\n          this.postEvent(a, {\n            "enabled.telemetry": !1\n          }, function (t) {\n            t || (e.eventData.lastSuccess = a, e.eventData.tokenU = n);\n          }, t);\n        }\n      }, e;\n    }(Q))(),\n        it = nt.postTurnstileEvent.bind(nt),\n        at = new rt(),\n        ot = at.postMapLoadEvent.bind(at),\n        st = 500,\n        ut = 50;\n\n    function lt() {\n      o.caches && !tt && (tt = o.caches.open("mapbox-tiles"));\n    }\n\n    function pt(t) {\n      var e = t.indexOf("?");\n      return e < 0 ? t : t.slice(0, e);\n    }\n\n    var ct,\n        ht = 1 / 0;\n\n    function ft() {\n      return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;\n    }\n\n    var yt = {\n      Unknown: "Unknown",\n      Style: "Style",\n      Source: "Source",\n      Tile: "Tile",\n      Glyphs: "Glyphs",\n      SpriteImage: "SpriteImage",\n      SpriteJSON: "SpriteJSON",\n      Image: "Image"\n    };\n    "function" == typeof Object.freeze && Object.freeze(yt);\n\n    var dt = function (t) {\n      function e(e, r, n) {\n        401 === r && J(n) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t.call(this, e), this.status = r, this.url = n, this.name = this.constructor.name, this.message = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.toString = function () {\n        return this.name + ": " + this.message + " (" + this.status + "): " + this.url;\n      }, e;\n    }(Error),\n        mt = I() ? function () {\n      return self.worker && self.worker.referrer;\n    } : function () {\n      return ("blob:" === o.location.protocol ? o.parent : o).location.href;\n    };\n\n    var vt,\n        gt,\n        xt = function xt(t, e) {\n      if (!(/^file:/.test(r = t.url) || /^file:/.test(mt()) && !/^\\w+:/.test(r))) {\n        if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal")) return function (t, e) {\n          var r,\n              n = new o.AbortController(),\n              i = new o.Request(t.url, {\n            method: t.method || "GET",\n            body: t.body,\n            credentials: t.credentials,\n            headers: t.headers,\n            referrer: mt(),\n            signal: n.signal\n          }),\n              a = !1,\n              s = !1,\n              u = (r = i.url).indexOf("sku=") > 0 && J(r);\n          "json" === t.type && i.headers.set("Accept", "application/json");\n\n          var l = function l(r, n, a) {\n            if (!s) {\n              if (r && "SecurityError" !== r.message && A(r), n && a) return p(n);\n              var l = Date.now();\n              o.fetch(i).then(function (r) {\n                if (r.ok) {\n                  var n = u ? r.clone() : null;\n                  return p(r, n, l);\n                }\n\n                return e(new dt(r.statusText, r.status, t.url));\n              }).catch(function (t) {\n                20 !== t.code && e(new Error(t.message));\n              });\n            }\n          },\n              p = function p(r, n, u) {\n            ("arrayBuffer" === t.type ? r.arrayBuffer() : "json" === t.type ? r.json() : r.text()).then(function (t) {\n              s || (n && u && function (t, e, r) {\n                if (lt(), tt) {\n                  var n = {\n                    status: e.status,\n                    statusText: e.statusText,\n                    headers: new o.Headers()\n                  };\n                  e.headers.forEach(function (t, e) {\n                    return n.headers.set(e, t);\n                  });\n                  var i = z(e.headers.get("Cache-Control") || "");\n                  i["no-store"] || (i["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * i["max-age"]).toUTCString()), new Date(n.headers.get("Expires")).getTime() - r < 42e4 || function (t, e) {\n                    if (void 0 === et) try {\n                      new Response(new ReadableStream()), et = !0;\n                    } catch (t) {\n                      et = !1;\n                    }\n                    et ? e(t.body) : t.blob().then(e);\n                  }(e, function (e) {\n                    var r = new o.Response(e, n);\n                    lt(), tt && tt.then(function (e) {\n                      return e.put(pt(t.url), r);\n                    }).catch(function (t) {\n                      return A(t.message);\n                    });\n                  }));\n                }\n              }(i, n, u), a = !0, e(null, t, r.headers.get("Cache-Control"), r.headers.get("Expires")));\n            }).catch(function (t) {\n              s || e(new Error(t.message));\n            });\n          };\n\n          return u ? function (t, e) {\n            if (lt(), !tt) return e(null);\n            var r = pt(t.url);\n            tt.then(function (t) {\n              t.match(r).then(function (n) {\n                var i = function (t) {\n                  if (!t) return !1;\n                  var e = new Date(t.headers.get("Expires") || 0),\n                      r = z(t.headers.get("Cache-Control") || "");\n                  return e > Date.now() && !r["no-cache"];\n                }(n);\n\n                t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n              }).catch(e);\n            }).catch(e);\n          }(i, l) : l(null, null), {\n            cancel: function cancel() {\n              s = !0, a || n.abort();\n            }\n          };\n        }(t, e);\n        if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0);\n      }\n\n      var r;\n      return function (t, e) {\n        var r = new o.XMLHttpRequest();\n\n        for (var n in r.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (r.responseType = "arraybuffer"), t.headers) {\n          r.setRequestHeader(n, t.headers[n]);\n        }\n\n        return "json" === t.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t.credentials, r.onerror = function () {\n          e(new Error(r.statusText));\n        }, r.onload = function () {\n          if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n            var n = r.response;\n            if ("json" === t.type) try {\n              n = JSON.parse(r.response);\n            } catch (t) {\n              return e(t);\n            }\n            e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));\n          } else e(new dt(r.statusText, r.status, t.url));\n        }, r.send(t.body), {\n          cancel: function cancel() {\n            return r.abort();\n          }\n        };\n      }(t, e);\n    },\n        bt = function bt(t, e) {\n      return xt(h(t, {\n        type: "arrayBuffer"\n      }), e);\n    },\n        wt = function wt(t, e) {\n      return xt(h(t, {\n        method: "POST"\n      }), e);\n    },\n        _t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";\n\n    vt = [], gt = 0;\n\n    var At = function At(t, e) {\n      if (U.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), gt >= R.MAX_PARALLEL_IMAGE_REQUESTS) {\n        var r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n          cancel: function cancel() {\n            this.cancelled = !0;\n          }\n        };\n        return vt.push(r), r;\n      }\n\n      gt++;\n\n      var n = !1,\n          i = function i() {\n        if (!n) for (n = !0, gt--; vt.length && gt < R.MAX_PARALLEL_IMAGE_REQUESTS;) {\n          var t = vt.shift();\n          t.cancelled || (t.cancel = At(t.requestParameters, t.callback).cancel);\n        }\n      },\n          a = bt(t, function (t, r, n, a) {\n        i(), t ? e(t) : r && (ft() ? function (t, e) {\n          var r = new o.Blob([new Uint8Array(t)], {\n            type: "image/png"\n          });\n          o.createImageBitmap(r).then(function (t) {\n            e(null, t);\n          }).catch(function (t) {\n            e(new Error("Could not load image because of " + t.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n          });\n        }(r, e) : function (t, e, r, n) {\n          var i = new o.Image(),\n              a = o.URL;\n          i.onload = function () {\n            e(null, i), a.revokeObjectURL(i.src), i.onload = null, o.requestAnimationFrame(function () {\n              i.src = _t;\n            });\n          }, i.onerror = function () {\n            return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n          };\n          var s = new o.Blob([new Uint8Array(t)], {\n            type: "image/png"\n          });\n          i.cacheControl = r, i.expires = n, i.src = t.byteLength ? a.createObjectURL(s) : _t;\n        }(r, e, n, a));\n      });\n\n      return {\n        cancel: function cancel() {\n          a.cancel(), i();\n        }\n      };\n    };\n\n    function St(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n\n    function kt(t, e, r) {\n      if (r && r[t]) {\n        var n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n\n    var It = function It(t, e) {\n      void 0 === e && (e = {}), h(this, e), this.type = t;\n    },\n        zt = function (t) {\n      function e(e, r) {\n        void 0 === r && (r = {}), t.call(this, "error", h({\n          error: e\n        }, r));\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(It),\n        Ct = function Ct() {};\n\n    Ct.prototype.on = function (t, e) {\n      return this._listeners = this._listeners || {}, St(t, e, this._listeners), this;\n    }, Ct.prototype.off = function (t, e) {\n      return kt(t, e, this._listeners), kt(t, e, this._oneTimeListeners), this;\n    }, Ct.prototype.once = function (t, e) {\n      return this._oneTimeListeners = this._oneTimeListeners || {}, St(t, e, this._oneTimeListeners), this;\n    }, Ct.prototype.fire = function (t, e) {\n      "string" == typeof t && (t = new It(t, e || {}));\n      var r = t.type;\n\n      if (this.listens(r)) {\n        t.target = this;\n\n        for (var n = 0, i = this._listeners && this._listeners[r] ? this._listeners[r].slice() : []; n < i.length; n += 1) {\n          i[n].call(this, t);\n        }\n\n        for (var a = 0, o = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []; a < o.length; a += 1) {\n          var s = o[a];\n          kt(r, s, this._oneTimeListeners), s.call(this, t);\n        }\n\n        var u = this._eventedParent;\n        u && (h(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u.fire(t));\n      } else t instanceof zt && console.error(t.error);\n\n      return this;\n    }, Ct.prototype.listens = function (t) {\n      return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);\n    }, Ct.prototype.setEventedParent = function (t, e) {\n      return this._eventedParent = t, this._eventedParentData = e, this;\n    };\n\n    var Et = {\n      $version: 8,\n      $root: {\n        version: {\n          required: !0,\n          type: "enum",\n          values: [8]\n        },\n        name: {\n          type: "string"\n        },\n        metadata: {\n          type: "*"\n        },\n        center: {\n          type: "array",\n          value: "number"\n        },\n        zoom: {\n          type: "number"\n        },\n        bearing: {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees"\n        },\n        pitch: {\n          type: "number",\n          default: 0,\n          units: "degrees"\n        },\n        light: {\n          type: "light"\n        },\n        sources: {\n          required: !0,\n          type: "sources"\n        },\n        sprite: {\n          type: "string"\n        },\n        glyphs: {\n          type: "string"\n        },\n        transition: {\n          type: "transition"\n        },\n        layers: {\n          required: !0,\n          type: "array",\n          value: "layer"\n        }\n      },\n      sources: {\n        "*": {\n          type: "source"\n        }\n      },\n      source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],\n      source_vector: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            vector: {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        scheme: {\n          type: "enum",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: "xyz"\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        attribution: {\n          type: "string"\n        },\n        promoteId: {\n          type: "promoteId"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_raster: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            raster: {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        tileSize: {\n          type: "number",\n          default: 512,\n          units: "pixels"\n        },\n        scheme: {\n          type: "enum",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: "xyz"\n        },\n        attribution: {\n          type: "string"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_raster_dem: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            "raster-dem": {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        tileSize: {\n          type: "number",\n          default: 512,\n          units: "pixels"\n        },\n        attribution: {\n          type: "string"\n        },\n        encoding: {\n          type: "enum",\n          values: {\n            terrarium: {},\n            mapbox: {}\n          },\n          default: "mapbox"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_geojson: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            geojson: {}\n          }\n        },\n        data: {\n          type: "*"\n        },\n        maxzoom: {\n          type: "number",\n          default: 18\n        },\n        attribution: {\n          type: "string"\n        },\n        buffer: {\n          type: "number",\n          default: 128,\n          maximum: 512,\n          minimum: 0\n        },\n        filter: {\n          type: "*"\n        },\n        tolerance: {\n          type: "number",\n          default: .375\n        },\n        cluster: {\n          type: "boolean",\n          default: !1\n        },\n        clusterRadius: {\n          type: "number",\n          default: 50,\n          minimum: 0\n        },\n        clusterMaxZoom: {\n          type: "number"\n        },\n        clusterMinPoints: {\n          type: "number"\n        },\n        clusterProperties: {\n          type: "*"\n        },\n        lineMetrics: {\n          type: "boolean",\n          default: !1\n        },\n        generateId: {\n          type: "boolean",\n          default: !1\n        },\n        promoteId: {\n          type: "promoteId"\n        }\n      },\n      source_video: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            video: {}\n          }\n        },\n        urls: {\n          required: !0,\n          type: "array",\n          value: "string"\n        },\n        coordinates: {\n          required: !0,\n          type: "array",\n          length: 4,\n          value: {\n            type: "array",\n            length: 2,\n            value: "number"\n          }\n        }\n      },\n      source_image: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            image: {}\n          }\n        },\n        url: {\n          required: !0,\n          type: "string"\n        },\n        coordinates: {\n          required: !0,\n          type: "array",\n          length: 4,\n          value: {\n            type: "array",\n            length: 2,\n            value: "number"\n          }\n        }\n      },\n      layer: {\n        id: {\n          type: "string",\n          required: !0\n        },\n        type: {\n          type: "enum",\n          values: {\n            fill: {},\n            line: {},\n            symbol: {},\n            circle: {},\n            heatmap: {},\n            "fill-extrusion": {},\n            raster: {},\n            hillshade: {},\n            background: {}\n          },\n          required: !0\n        },\n        metadata: {\n          type: "*"\n        },\n        source: {\n          type: "string"\n        },\n        "source-layer": {\n          type: "string"\n        },\n        minzoom: {\n          type: "number",\n          minimum: 0,\n          maximum: 24\n        },\n        maxzoom: {\n          type: "number",\n          minimum: 0,\n          maximum: 24\n        },\n        filter: {\n          type: "filter"\n        },\n        layout: {\n          type: "layout"\n        },\n        paint: {\n          type: "paint"\n        }\n      },\n      layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],\n      layout_background: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_fill: {\n        "fill-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_circle: {\n        "circle-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_heatmap: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      "layout_fill-extrusion": {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_line: {\n        "line-cap": {\n          type: "enum",\n          values: {\n            butt: {},\n            round: {},\n            square: {}\n          },\n          default: "butt",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-join": {\n          type: "enum",\n          values: {\n            bevel: {},\n            round: {},\n            miter: {}\n          },\n          default: "miter",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-miter-limit": {\n          type: "number",\n          default: 2,\n          requires: [{\n            "line-join": "miter"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-round-limit": {\n          type: "number",\n          default: 1.05,\n          requires: [{\n            "line-join": "round"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_symbol: {\n        "symbol-placement": {\n          type: "enum",\n          values: {\n            point: {},\n            line: {},\n            "line-center": {}\n          },\n          default: "point",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-spacing": {\n          type: "number",\n          default: 250,\n          minimum: 1,\n          units: "pixels",\n          requires: [{\n            "symbol-placement": "line"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-avoid-edges": {\n          type: "boolean",\n          default: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "symbol-z-order": {\n          type: "enum",\n          values: {\n            auto: {},\n            "viewport-y": {},\n            source: {}\n          },\n          default: "auto",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-allow-overlap": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-ignore-placement": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-optional": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image", "text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-rotation-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-size": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          units: "factor of the original icon size",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-text-fit": {\n          type: "enum",\n          values: {\n            none: {},\n            width: {},\n            height: {},\n            both: {}\n          },\n          default: "none",\n          requires: ["icon-image", "text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-text-fit-padding": {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [0, 0, 0, 0],\n          units: "pixels",\n          requires: ["icon-image", "text-field", {\n            "icon-text-fit": ["both", "width", "height"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-image": {\n          type: "resolvedImage",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-padding": {\n          type: "number",\n          default: 2,\n          minimum: 0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-keep-upright": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image", {\n            "icon-rotation-alignment": "map"\n          }, {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-offset": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-anchor": {\n          type: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          default: "center",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-rotation-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-field": {\n          type: "formatted",\n          default: "",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-font": {\n          type: "array",\n          value: "string",\n          default: ["Open Sans Regular", "Arial Unicode MS Regular"],\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-size": {\n          type: "number",\n          default: 16,\n          minimum: 0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-max-width": {\n          type: "number",\n          default: 10,\n          minimum: 0,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-line-height": {\n          type: "number",\n          default: 1.2,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-letter-spacing": {\n          type: "number",\n          default: 0,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-justify": {\n          type: "enum",\n          values: {\n            auto: {},\n            left: {},\n            center: {},\n            right: {}\n          },\n          default: "center",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-radial-offset": {\n          type: "number",\n          units: "ems",\n          default: 0,\n          requires: ["text-field"],\n          "property-type": "data-driven",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          }\n        },\n        "text-variable-anchor": {\n          type: "array",\n          value: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          requires: ["text-field", {\n            "symbol-placement": ["point"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-anchor": {\n          type: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          default: "center",\n          requires: ["text-field", {\n            "!": "text-variable-anchor"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-max-angle": {\n          type: "number",\n          default: 45,\n          units: "degrees",\n          requires: ["text-field", {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-writing-mode": {\n          type: "array",\n          value: "enum",\n          values: {\n            horizontal: {},\n            vertical: {}\n          },\n          requires: ["text-field", {\n            "symbol-placement": ["point"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-padding": {\n          type: "number",\n          default: 2,\n          minimum: 0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-keep-upright": {\n          type: "boolean",\n          default: !0,\n          requires: ["text-field", {\n            "text-rotation-alignment": "map"\n          }, {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-transform": {\n          type: "enum",\n          values: {\n            none: {},\n            uppercase: {},\n            lowercase: {}\n          },\n          default: "none",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-offset": {\n          type: "array",\n          value: "number",\n          units: "ems",\n          length: 2,\n          default: [0, 0],\n          requires: ["text-field", {\n            "!": "text-radial-offset"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-allow-overlap": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-ignore-placement": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-optional": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field", "icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_raster: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_hillshade: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      filter: {\n        type: "array",\n        value: "*"\n      },\n      filter_operator: {\n        type: "enum",\n        values: {\n          "==": {},\n          "!=": {},\n          ">": {},\n          ">=": {},\n          "<": {},\n          "<=": {},\n          in: {},\n          "!in": {},\n          all: {},\n          any: {},\n          none: {},\n          has: {},\n          "!has": {},\n          within: {}\n        }\n      },\n      geometry_type: {\n        type: "enum",\n        values: {\n          Point: {},\n          LineString: {},\n          Polygon: {}\n        }\n      },\n      function: {\n        expression: {\n          type: "expression"\n        },\n        stops: {\n          type: "array",\n          value: "function_stop"\n        },\n        base: {\n          type: "number",\n          default: 1,\n          minimum: 0\n        },\n        property: {\n          type: "string",\n          default: "$zoom"\n        },\n        type: {\n          type: "enum",\n          values: {\n            identity: {},\n            exponential: {},\n            interval: {},\n            categorical: {}\n          },\n          default: "exponential"\n        },\n        colorSpace: {\n          type: "enum",\n          values: {\n            rgb: {},\n            lab: {},\n            hcl: {}\n          },\n          default: "rgb"\n        },\n        default: {\n          type: "*",\n          required: !1\n        }\n      },\n      function_stop: {\n        type: "array",\n        minimum: 0,\n        maximum: 24,\n        value: ["number", "color"],\n        length: 2\n      },\n      expression: {\n        type: "array",\n        value: "*",\n        minimum: 1\n      },\n      light: {\n        anchor: {\n          type: "enum",\n          default: "viewport",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          "property-type": "data-constant",\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          }\n        },\n        position: {\n          type: "array",\n          default: [1.15, 210, 30],\n          length: 3,\n          value: "number",\n          "property-type": "data-constant",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          }\n        },\n        color: {\n          type: "color",\n          "property-type": "data-constant",\n          default: "#ffffff",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          transition: !0\n        },\n        intensity: {\n          type: "number",\n          "property-type": "data-constant",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          transition: !0\n        }\n      },\n      paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],\n      paint_fill: {\n        "fill-antialias": {\n          type: "boolean",\n          default: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "fill-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-outline-color": {\n          type: "color",\n          transition: !0,\n          requires: [{\n            "!": "fill-pattern"\n          }, {\n            "fill-antialias": !0\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["fill-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        }\n      },\n      "paint_fill-extrusion": {\n        "fill-extrusion-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "fill-extrusion-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["fill-extrusion-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        },\n        "fill-extrusion-height": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "meters",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-base": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "meters",\n          transition: !0,\n          requires: ["fill-extrusion-height"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-vertical-gradient": {\n          type: "boolean",\n          default: !0,\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_line: {\n        "line-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "line-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["line-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-width": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-gap-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-offset": {\n          type: "number",\n          default: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-dasharray": {\n          type: "array",\n          value: "number",\n          minimum: 0,\n          transition: !0,\n          units: "line widths",\n          requires: [{\n            "!": "line-pattern"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "cross-faded"\n        },\n        "line-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        },\n        "line-gradient": {\n          type: "color",\n          transition: !1,\n          requires: [{\n            "!": "line-dasharray"\n          }, {\n            "!": "line-pattern"\n          }, {\n            source: "geojson",\n            has: {\n              lineMetrics: !0\n            }\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["line-progress"]\n          },\n          "property-type": "color-ramp"\n        }\n      },\n      paint_circle: {\n        "circle-radius": {\n          type: "number",\n          default: 5,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-blur": {\n          type: "number",\n          default: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["circle-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-pitch-scale": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "viewport",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-stroke-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-stroke-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-stroke-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        }\n      },\n      paint_heatmap: {\n        "heatmap-radius": {\n          type: "number",\n          default: 30,\n          minimum: 1,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "heatmap-weight": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "heatmap-intensity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "heatmap-color": {\n          type: "color",\n          default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["heatmap-density"]\n          },\n          "property-type": "color-ramp"\n        },\n        "heatmap-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_symbol: {\n        "icon-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-color": {\n          type: "color",\n          default: "rgba(0, 0, 0, 0)",\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["icon-image", "icon-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          overridable: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-color": {\n          type: "color",\n          default: "rgba(0, 0, 0, 0)",\n          transition: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["text-field", "text-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_raster: {\n        "raster-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-hue-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          transition: !0,\n          units: "degrees",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-brightness-min": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-brightness-max": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-saturation": {\n          type: "number",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-contrast": {\n          type: "number",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-resampling": {\n          type: "enum",\n          values: {\n            linear: {},\n            nearest: {}\n          },\n          default: "linear",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-fade-duration": {\n          type: "number",\n          default: 300,\n          minimum: 0,\n          transition: !1,\n          units: "milliseconds",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_hillshade: {\n        "hillshade-illumination-direction": {\n          type: "number",\n          default: 335,\n          minimum: 0,\n          maximum: 359,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-illumination-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "viewport",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-exaggeration": {\n          type: "number",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-shadow-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-highlight-color": {\n          type: "color",\n          default: "#FFFFFF",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-accent-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_background: {\n        "background-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "background-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "background-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "cross-faded"\n        },\n        "background-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      transition: {\n        duration: {\n          type: "number",\n          default: 300,\n          minimum: 0,\n          units: "milliseconds"\n        },\n        delay: {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "milliseconds"\n        }\n      },\n      "property-type": {\n        "data-driven": {\n          type: "property-type"\n        },\n        "cross-faded": {\n          type: "property-type"\n        },\n        "cross-faded-data-driven": {\n          type: "property-type"\n        },\n        "color-ramp": {\n          type: "property-type"\n        },\n        "data-constant": {\n          type: "property-type"\n        },\n        constant: {\n          type: "property-type"\n        }\n      },\n      promoteId: {\n        "*": {\n          type: "string"\n        }\n      }\n    },\n        Pt = function Pt(t, e, r, n) {\n      this.message = (t ? t + ": " : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n    };\n\n    function Mt(t) {\n      var e = t.value;\n      return e ? [new Pt(t.key, e, "constants have been deprecated as of v8")] : [];\n    }\n\n    function Bt(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n\n        for (var o in a) {\n          t[o] = a[o];\n        }\n      }\n\n      return t;\n    }\n\n    function Tt(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n\n    function Vt(t) {\n      if (Array.isArray(t)) return t.map(Vt);\n\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        var e = {};\n\n        for (var r in t) {\n          e[r] = Vt(t[r]);\n        }\n\n        return e;\n      }\n\n      return Tt(t);\n    }\n\n    var Ft = function (t) {\n      function e(e, r) {\n        t.call(this, r), this.message = r, this.key = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Error),\n        Dt = function Dt(t, e) {\n      void 0 === e && (e = []), this.parent = t, this.bindings = {};\n\n      for (var r = 0, n = e; r < n.length; r += 1) {\n        var i = n[r];\n        this.bindings[i[0]] = i[1];\n      }\n    };\n\n    Dt.prototype.concat = function (t) {\n      return new Dt(this, t);\n    }, Dt.prototype.get = function (t) {\n      if (this.bindings[t]) return this.bindings[t];\n      if (this.parent) return this.parent.get(t);\n      throw new Error(t + " not found in scope.");\n    }, Dt.prototype.has = function (t) {\n      return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n    };\n    var Lt = {\n      kind: "null"\n    },\n        Ot = {\n      kind: "number"\n    },\n        Rt = {\n      kind: "string"\n    },\n        Ut = {\n      kind: "boolean"\n    },\n        jt = {\n      kind: "color"\n    },\n        qt = {\n      kind: "object"\n    },\n        Nt = {\n      kind: "value"\n    },\n        Kt = {\n      kind: "collator"\n    },\n        Gt = {\n      kind: "formatted"\n    },\n        Zt = {\n      kind: "resolvedImage"\n    };\n\n    function Xt(t, e) {\n      return {\n        kind: "array",\n        itemType: t,\n        N: e\n      };\n    }\n\n    function Jt(t) {\n      if ("array" === t.kind) {\n        var e = Jt(t.itemType);\n        return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">";\n      }\n\n      return t.kind;\n    }\n\n    var Ht = [Lt, Ot, Rt, Ut, jt, Gt, qt, Xt(Nt), Zt];\n\n    function Yt(t, e) {\n      if ("error" === e.kind) return null;\n\n      if ("array" === t.kind) {\n        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Yt(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if ("value" === t.kind) for (var r = 0, n = Ht; r < n.length; r += 1) {\n          if (!Yt(n[r], e)) return null;\n        }\n      }\n\n      return "Expected " + Jt(t) + " but found " + Jt(e) + " instead.";\n    }\n\n    function $t(t, e) {\n      return e.some(function (e) {\n        return e.kind === t.kind;\n      });\n    }\n\n    function Wt(t, e) {\n      return e.some(function (e) {\n        return "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t;\n      });\n    }\n\n    var Qt = e(function (t, e) {\n      var r = {\n        transparent: [0, 0, 0, 0],\n        aliceblue: [240, 248, 255, 1],\n        antiquewhite: [250, 235, 215, 1],\n        aqua: [0, 255, 255, 1],\n        aquamarine: [127, 255, 212, 1],\n        azure: [240, 255, 255, 1],\n        beige: [245, 245, 220, 1],\n        bisque: [255, 228, 196, 1],\n        black: [0, 0, 0, 1],\n        blanchedalmond: [255, 235, 205, 1],\n        blue: [0, 0, 255, 1],\n        blueviolet: [138, 43, 226, 1],\n        brown: [165, 42, 42, 1],\n        burlywood: [222, 184, 135, 1],\n        cadetblue: [95, 158, 160, 1],\n        chartreuse: [127, 255, 0, 1],\n        chocolate: [210, 105, 30, 1],\n        coral: [255, 127, 80, 1],\n        cornflowerblue: [100, 149, 237, 1],\n        cornsilk: [255, 248, 220, 1],\n        crimson: [220, 20, 60, 1],\n        cyan: [0, 255, 255, 1],\n        darkblue: [0, 0, 139, 1],\n        darkcyan: [0, 139, 139, 1],\n        darkgoldenrod: [184, 134, 11, 1],\n        darkgray: [169, 169, 169, 1],\n        darkgreen: [0, 100, 0, 1],\n        darkgrey: [169, 169, 169, 1],\n        darkkhaki: [189, 183, 107, 1],\n        darkmagenta: [139, 0, 139, 1],\n        darkolivegreen: [85, 107, 47, 1],\n        darkorange: [255, 140, 0, 1],\n        darkorchid: [153, 50, 204, 1],\n        darkred: [139, 0, 0, 1],\n        darksalmon: [233, 150, 122, 1],\n        darkseagreen: [143, 188, 143, 1],\n        darkslateblue: [72, 61, 139, 1],\n        darkslategray: [47, 79, 79, 1],\n        darkslategrey: [47, 79, 79, 1],\n        darkturquoise: [0, 206, 209, 1],\n        darkviolet: [148, 0, 211, 1],\n        deeppink: [255, 20, 147, 1],\n        deepskyblue: [0, 191, 255, 1],\n        dimgray: [105, 105, 105, 1],\n        dimgrey: [105, 105, 105, 1],\n        dodgerblue: [30, 144, 255, 1],\n        firebrick: [178, 34, 34, 1],\n        floralwhite: [255, 250, 240, 1],\n        forestgreen: [34, 139, 34, 1],\n        fuchsia: [255, 0, 255, 1],\n        gainsboro: [220, 220, 220, 1],\n        ghostwhite: [248, 248, 255, 1],\n        gold: [255, 215, 0, 1],\n        goldenrod: [218, 165, 32, 1],\n        gray: [128, 128, 128, 1],\n        green: [0, 128, 0, 1],\n        greenyellow: [173, 255, 47, 1],\n        grey: [128, 128, 128, 1],\n        honeydew: [240, 255, 240, 1],\n        hotpink: [255, 105, 180, 1],\n        indianred: [205, 92, 92, 1],\n        indigo: [75, 0, 130, 1],\n        ivory: [255, 255, 240, 1],\n        khaki: [240, 230, 140, 1],\n        lavender: [230, 230, 250, 1],\n        lavenderblush: [255, 240, 245, 1],\n        lawngreen: [124, 252, 0, 1],\n        lemonchiffon: [255, 250, 205, 1],\n        lightblue: [173, 216, 230, 1],\n        lightcoral: [240, 128, 128, 1],\n        lightcyan: [224, 255, 255, 1],\n        lightgoldenrodyellow: [250, 250, 210, 1],\n        lightgray: [211, 211, 211, 1],\n        lightgreen: [144, 238, 144, 1],\n        lightgrey: [211, 211, 211, 1],\n        lightpink: [255, 182, 193, 1],\n        lightsalmon: [255, 160, 122, 1],\n        lightseagreen: [32, 178, 170, 1],\n        lightskyblue: [135, 206, 250, 1],\n        lightslategray: [119, 136, 153, 1],\n        lightslategrey: [119, 136, 153, 1],\n        lightsteelblue: [176, 196, 222, 1],\n        lightyellow: [255, 255, 224, 1],\n        lime: [0, 255, 0, 1],\n        limegreen: [50, 205, 50, 1],\n        linen: [250, 240, 230, 1],\n        magenta: [255, 0, 255, 1],\n        maroon: [128, 0, 0, 1],\n        mediumaquamarine: [102, 205, 170, 1],\n        mediumblue: [0, 0, 205, 1],\n        mediumorchid: [186, 85, 211, 1],\n        mediumpurple: [147, 112, 219, 1],\n        mediumseagreen: [60, 179, 113, 1],\n        mediumslateblue: [123, 104, 238, 1],\n        mediumspringgreen: [0, 250, 154, 1],\n        mediumturquoise: [72, 209, 204, 1],\n        mediumvioletred: [199, 21, 133, 1],\n        midnightblue: [25, 25, 112, 1],\n        mintcream: [245, 255, 250, 1],\n        mistyrose: [255, 228, 225, 1],\n        moccasin: [255, 228, 181, 1],\n        navajowhite: [255, 222, 173, 1],\n        navy: [0, 0, 128, 1],\n        oldlace: [253, 245, 230, 1],\n        olive: [128, 128, 0, 1],\n        olivedrab: [107, 142, 35, 1],\n        orange: [255, 165, 0, 1],\n        orangered: [255, 69, 0, 1],\n        orchid: [218, 112, 214, 1],\n        palegoldenrod: [238, 232, 170, 1],\n        palegreen: [152, 251, 152, 1],\n        paleturquoise: [175, 238, 238, 1],\n        palevioletred: [219, 112, 147, 1],\n        papayawhip: [255, 239, 213, 1],\n        peachpuff: [255, 218, 185, 1],\n        peru: [205, 133, 63, 1],\n        pink: [255, 192, 203, 1],\n        plum: [221, 160, 221, 1],\n        powderblue: [176, 224, 230, 1],\n        purple: [128, 0, 128, 1],\n        rebeccapurple: [102, 51, 153, 1],\n        red: [255, 0, 0, 1],\n        rosybrown: [188, 143, 143, 1],\n        royalblue: [65, 105, 225, 1],\n        saddlebrown: [139, 69, 19, 1],\n        salmon: [250, 128, 114, 1],\n        sandybrown: [244, 164, 96, 1],\n        seagreen: [46, 139, 87, 1],\n        seashell: [255, 245, 238, 1],\n        sienna: [160, 82, 45, 1],\n        silver: [192, 192, 192, 1],\n        skyblue: [135, 206, 235, 1],\n        slateblue: [106, 90, 205, 1],\n        slategray: [112, 128, 144, 1],\n        slategrey: [112, 128, 144, 1],\n        snow: [255, 250, 250, 1],\n        springgreen: [0, 255, 127, 1],\n        steelblue: [70, 130, 180, 1],\n        tan: [210, 180, 140, 1],\n        teal: [0, 128, 128, 1],\n        thistle: [216, 191, 216, 1],\n        tomato: [255, 99, 71, 1],\n        turquoise: [64, 224, 208, 1],\n        violet: [238, 130, 238, 1],\n        wheat: [245, 222, 179, 1],\n        white: [255, 255, 255, 1],\n        whitesmoke: [245, 245, 245, 1],\n        yellow: [255, 255, 0, 1],\n        yellowgreen: [154, 205, 50, 1]\n      };\n\n      function n(t) {\n        return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n      }\n\n      function i(t) {\n        return n("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n      }\n\n      function a(t) {\n        return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n        var e;\n      }\n\n      function o(t, e, r) {\n        return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n      }\n\n      try {\n        e.parseCSSColor = function (t) {\n          var e,\n              s = t.replace(/ /g, "").toLowerCase();\n          if (s in r) return r[s].slice();\n          if ("#" === s[0]) return 4 === s.length ? (e = parseInt(s.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === s.length && (e = parseInt(s.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n          var u = s.indexOf("("),\n              l = s.indexOf(")");\n\n          if (-1 !== u && l + 1 === s.length) {\n            var p = s.substr(0, u),\n                c = s.substr(u + 1, l - (u + 1)).split(","),\n                h = 1;\n\n            switch (p) {\n              case "rgba":\n                if (4 !== c.length) return null;\n                h = a(c.pop());\n\n              case "rgb":\n                return 3 !== c.length ? null : [i(c[0]), i(c[1]), i(c[2]), h];\n\n              case "hsla":\n                if (4 !== c.length) return null;\n                h = a(c.pop());\n\n              case "hsl":\n                if (3 !== c.length) return null;\n                var f = (parseFloat(c[0]) % 360 + 360) % 360 / 360,\n                    y = a(c[1]),\n                    d = a(c[2]),\n                    m = d <= .5 ? d * (y + 1) : d + y - d * y,\n                    v = 2 * d - m;\n                return [n(255 * o(v, m, f + 1 / 3)), n(255 * o(v, m, f)), n(255 * o(v, m, f - 1 / 3)), h];\n\n              default:\n                return null;\n            }\n          }\n\n          return null;\n        };\n      } catch (t) {}\n    }).parseCSSColor,\n        te = function te(t, e, r, n) {\n      void 0 === n && (n = 1), this.r = t, this.g = e, this.b = r, this.a = n;\n    };\n\n    te.parse = function (t) {\n      if (t) {\n        if (t instanceof te) return t;\n\n        if ("string" == typeof t) {\n          var e = Qt(t);\n          if (e) return new te(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]);\n        }\n      }\n    }, te.prototype.toString = function () {\n      var t = this.toArray(),\n          e = t[1],\n          r = t[2],\n          n = t[3];\n      return "rgba(" + Math.round(t[0]) + "," + Math.round(e) + "," + Math.round(r) + "," + n + ")";\n    }, te.prototype.toArray = function () {\n      var t = this.a;\n      return 0 === t ? [0, 0, 0, 0] : [255 * this.r / t, 255 * this.g / t, 255 * this.b / t, t];\n    }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1);\n\n    var ee = function ee(t, e, r) {\n      this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n        sensitivity: this.sensitivity,\n        usage: "search"\n      });\n    };\n\n    ee.prototype.compare = function (t, e) {\n      return this.collator.compare(t, e);\n    }, ee.prototype.resolvedLocale = function () {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    };\n\n    var re = function re(t, e, r, n, i) {\n      this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n    },\n        ne = function ne(t) {\n      this.sections = t;\n    };\n\n    ne.fromString = function (t) {\n      return new ne([new re(t, null, null, null, null)]);\n    }, ne.prototype.isEmpty = function () {\n      return 0 === this.sections.length || !this.sections.some(function (t) {\n        return 0 !== t.text.length || t.image && 0 !== t.image.name.length;\n      });\n    }, ne.factory = function (t) {\n      return t instanceof ne ? t : ne.fromString(t);\n    }, ne.prototype.toString = function () {\n      return 0 === this.sections.length ? "" : this.sections.map(function (t) {\n        return t.text;\n      }).join("");\n    }, ne.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        if (n.image) t.push(["image", n.image.name]);else {\n          t.push(n.text);\n          var i = {};\n          n.fontStack && (i["text-font"] = ["literal", n.fontStack.split(",")]), n.scale && (i["font-scale"] = n.scale), n.textColor && (i["text-color"] = ["rgba"].concat(n.textColor.toArray())), t.push(i);\n        }\n      }\n\n      return t;\n    };\n\n    var ie = function ie(t) {\n      this.name = t.name, this.available = t.available;\n    };\n\n    function ae(t, e, r, n) {\n      return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : "Invalid rgba value [" + [t, e, r, n].join(", ") + "]: \'a\' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ") + "]: \'r\', \'g\', and \'b\' must be between 0 and 255.";\n    }\n\n    function oe(t) {\n      if (null === t) return !0;\n      if ("string" == typeof t) return !0;\n      if ("boolean" == typeof t) return !0;\n      if ("number" == typeof t) return !0;\n      if (t instanceof te) return !0;\n      if (t instanceof ee) return !0;\n      if (t instanceof ne) return !0;\n      if (t instanceof ie) return !0;\n\n      if (Array.isArray(t)) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          if (!oe(r[e])) return !1;\n        }\n\n        return !0;\n      }\n\n      if ("object" == typeof t) {\n        for (var n in t) {\n          if (!oe(t[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      return !1;\n    }\n\n    function se(t) {\n      if (null === t) return Lt;\n      if ("string" == typeof t) return Rt;\n      if ("boolean" == typeof t) return Ut;\n      if ("number" == typeof t) return Ot;\n      if (t instanceof te) return jt;\n      if (t instanceof ee) return Kt;\n      if (t instanceof ne) return Gt;\n      if (t instanceof ie) return Zt;\n\n      if (Array.isArray(t)) {\n        for (var e, r = t.length, n = 0, i = t; n < i.length; n += 1) {\n          var a = se(i[n]);\n\n          if (e) {\n            if (e === a) continue;\n            e = Nt;\n            break;\n          }\n\n          e = a;\n        }\n\n        return Xt(e || Nt, r);\n      }\n\n      return qt;\n    }\n\n    function ue(t) {\n      var e = typeof t;\n      return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof te || t instanceof ne || t instanceof ie ? t.toString() : JSON.stringify(t);\n    }\n\n    ie.prototype.toString = function () {\n      return this.name;\n    }, ie.fromString = function (t) {\n      return t ? new ie({\n        name: t,\n        available: !1\n      }) : null;\n    }, ie.prototype.serialize = function () {\n      return ["image", this.name];\n    };\n\n    var le = function le(t, e) {\n      this.type = t, this.value = e;\n    };\n\n    le.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'literal\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n      if (!oe(t[1])) return e.error("invalid value");\n      var r = t[1],\n          n = se(r),\n          i = e.expectedType;\n      return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new le(n, r);\n    }, le.prototype.evaluate = function () {\n      return this.value;\n    }, le.prototype.eachChild = function () {}, le.prototype.outputDefined = function () {\n      return !0;\n    }, le.prototype.serialize = function () {\n      return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ne ? this.value.serialize() : this.value;\n    };\n\n    var pe = function pe(t) {\n      this.name = "ExpressionEvaluationError", this.message = t;\n    };\n\n    pe.prototype.toJSON = function () {\n      return this.message;\n    };\n\n    var ce = {\n      string: Rt,\n      number: Ot,\n      boolean: Ut,\n      object: qt\n    },\n        he = function he(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    he.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r,\n          n = 1,\n          i = t[0];\n\n      if ("array" === i) {\n        var a, o;\n\n        if (t.length > 2) {\n          var s = t[1];\n          if ("string" != typeof s || !(s in ce) || "object" === s) return e.error(\'The item type argument of "array" must be one of string, number, boolean\', 1);\n          a = ce[s], n++;\n        } else a = Nt;\n\n        if (t.length > 3) {\n          if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error(\'The length argument to "array" must be a positive integer literal\', 2);\n          o = t[2], n++;\n        }\n\n        r = Xt(a, o);\n      } else r = ce[i];\n\n      for (var u = []; n < t.length; n++) {\n        var l = e.parse(t[n], n, Nt);\n        if (!l) return null;\n        u.push(l);\n      }\n\n      return new he(r, u);\n    }, he.prototype.evaluate = function (t) {\n      for (var e = 0; e < this.args.length; e++) {\n        var r = this.args[e].evaluate(t);\n        if (!Yt(this.type, se(r))) return r;\n        if (e === this.args.length - 1) throw new pe("Expected value to be of type " + Jt(this.type) + ", but found " + Jt(se(r)) + " instead.");\n      }\n\n      return null;\n    }, he.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, he.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, he.prototype.serialize = function () {\n      var t = this.type,\n          e = [t.kind];\n\n      if ("array" === t.kind) {\n        var r = t.itemType;\n\n        if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {\n          e.push(r.kind);\n          var n = t.N;\n          ("number" == typeof n || this.args.length > 1) && e.push(n);\n        }\n      }\n\n      return e.concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    };\n\n    var fe = function fe(t) {\n      this.type = Gt, this.sections = t;\n    };\n\n    fe.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[1];\n      if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");\n\n      for (var n = [], i = !1, a = 1; a <= t.length - 1; ++a) {\n        var o = t[a];\n\n        if (i && "object" == typeof o && !Array.isArray(o)) {\n          i = !1;\n          var s = null;\n          if (o["font-scale"] && !(s = e.parse(o["font-scale"], 1, Ot))) return null;\n          var u = null;\n          if (o["text-font"] && !(u = e.parse(o["text-font"], 1, Xt(Rt)))) return null;\n          var l = null;\n          if (o["text-color"] && !(l = e.parse(o["text-color"], 1, jt))) return null;\n          var p = n[n.length - 1];\n          p.scale = s, p.font = u, p.textColor = l;\n        } else {\n          var c = e.parse(t[a], 1, Nt);\n          if (!c) return null;\n          var h = c.type.kind;\n          if ("string" !== h && "value" !== h && "null" !== h && "resolvedImage" !== h) return e.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");\n          i = !0, n.push({\n            content: c,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n\n      return new fe(n);\n    }, fe.prototype.evaluate = function (t) {\n      return new ne(this.sections.map(function (e) {\n        var r = e.content.evaluate(t);\n        return se(r) === Zt ? new re("", r, null, null, null) : new re(ue(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);\n      }));\n    }, fe.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);\n      }\n    }, fe.prototype.outputDefined = function () {\n      return !1;\n    }, fe.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n.content.serialize());\n        var i = {};\n        n.scale && (i["font-scale"] = n.scale.serialize()), n.font && (i["text-font"] = n.font.serialize()), n.textColor && (i["text-color"] = n.textColor.serialize()), t.push(i);\n      }\n\n      return t;\n    };\n\n    var ye = function ye(t) {\n      this.type = Zt, this.input = t;\n    };\n\n    ye.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Rt);\n      return r ? new ye(r) : e.error("No image name provided.");\n    }, ye.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n          r = ie.fromString(e);\n      return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n    }, ye.prototype.eachChild = function (t) {\n      t(this.input);\n    }, ye.prototype.outputDefined = function () {\n      return !1;\n    }, ye.prototype.serialize = function () {\n      return ["image", this.input.serialize()];\n    };\n\n    var de = {\n      "to-boolean": Ut,\n      "to-color": jt,\n      "to-number": Ot,\n      "to-string": Rt\n    },\n        me = function me(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    me.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[0];\n      if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");\n\n      for (var n = de[r], i = [], a = 1; a < t.length; a++) {\n        var o = e.parse(t[a], a, Nt);\n        if (!o) return null;\n        i.push(o);\n      }\n\n      return new me(n, i);\n    }, me.prototype.evaluate = function (t) {\n      if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n\n      if ("color" === this.type.kind) {\n        for (var e, r, n = 0, i = this.args; n < i.length; n += 1) {\n          if (r = null, (e = i[n].evaluate(t)) instanceof te) return e;\n\n          if ("string" == typeof e) {\n            var a = t.parseColor(e);\n            if (a) return a;\n          } else if (Array.isArray(e) && !(r = e.length < 3 || e.length > 4 ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : ae(e[0], e[1], e[2], e[3]))) return new te(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n        }\n\n        throw new pe(r || "Could not parse color from value \'" + ("string" == typeof e ? e : String(JSON.stringify(e))) + "\'");\n      }\n\n      if ("number" === this.type.kind) {\n        for (var o = null, s = 0, u = this.args; s < u.length; s += 1) {\n          if (null === (o = u[s].evaluate(t))) return 0;\n          var l = Number(o);\n          if (!isNaN(l)) return l;\n        }\n\n        throw new pe("Could not convert " + JSON.stringify(o) + " to number.");\n      }\n\n      return "formatted" === this.type.kind ? ne.fromString(ue(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? ie.fromString(ue(this.args[0].evaluate(t))) : ue(this.args[0].evaluate(t));\n    }, me.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, me.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, me.prototype.serialize = function () {\n      if ("formatted" === this.type.kind) return new fe([{\n        content: this.args[0],\n        scale: null,\n        font: null,\n        textColor: null\n      }]).serialize();\n      if ("resolvedImage" === this.type.kind) return new ye(this.args[0]).serialize();\n      var t = ["to-" + this.type.kind];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var ve = ["Unknown", "Point", "LineString", "Polygon"],\n        ge = function ge() {\n      this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n    };\n\n    ge.prototype.id = function () {\n      return this.feature && "id" in this.feature ? this.feature.id : null;\n    }, ge.prototype.geometryType = function () {\n      return this.feature ? "number" == typeof this.feature.type ? ve[this.feature.type] : this.feature.type : null;\n    }, ge.prototype.geometry = function () {\n      return this.feature && "geometry" in this.feature ? this.feature.geometry : null;\n    }, ge.prototype.canonicalID = function () {\n      return this.canonical;\n    }, ge.prototype.properties = function () {\n      return this.feature && this.feature.properties || {};\n    }, ge.prototype.parseColor = function (t) {\n      var e = this._parseColorCache[t];\n      return e || (e = this._parseColorCache[t] = te.parse(t)), e;\n    };\n\n    var xe = function xe(t, e, r, n) {\n      this.name = t, this.type = e, this._evaluate = r, this.args = n;\n    };\n\n    xe.prototype.evaluate = function (t) {\n      return this._evaluate(t, this.args);\n    }, xe.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, xe.prototype.outputDefined = function () {\n      return !1;\n    }, xe.prototype.serialize = function () {\n      return [this.name].concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    }, xe.parse = function (t, e) {\n      var r,\n          n = t[0],\n          i = xe.definitions[n];\n      if (!i) return e.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n\n      for (var a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s = o.filter(function (e) {\n        var r = e[0];\n        return !Array.isArray(r) || r.length === t.length - 1;\n      }), u = null, l = 0, p = s; l < p.length; l += 1) {\n        var c = p[l],\n            h = c[0],\n            f = c[1];\n        u = new je(e.registry, e.path, null, e.scope);\n\n        for (var y = [], d = !1, m = 1; m < t.length; m++) {\n          var v = t[m],\n              g = Array.isArray(h) ? h[m - 1] : h.type,\n              x = u.parse(v, 1 + y.length, g);\n\n          if (!x) {\n            d = !0;\n            break;\n          }\n\n          y.push(x);\n        }\n\n        if (!d) if (Array.isArray(h) && h.length !== y.length) u.error("Expected " + h.length + " arguments, but found " + y.length + " instead.");else {\n          for (var b = 0; b < y.length; b++) {\n            var w = Array.isArray(h) ? h[b] : h.type,\n                _ = y[b];\n            u.concat(b + 1).checkSubtype(w, _.type);\n          }\n\n          if (0 === u.errors.length) return new xe(n, a, f, y);\n        }\n      }\n\n      if (1 === s.length) (r = e.errors).push.apply(r, u.errors);else {\n        for (var A = (s.length ? s : o).map(function (t) {\n          var e;\n          return e = t[0], Array.isArray(e) ? "(" + e.map(Jt).join(", ") + ")" : "(" + Jt(e.type) + "...)";\n        }).join(" | "), S = [], k = 1; k < t.length; k++) {\n          var I = e.parse(t[k], 1 + S.length);\n          if (!I) return null;\n          S.push(Jt(I.type));\n        }\n\n        e.error("Expected arguments of type " + A + ", but found (" + S.join(", ") + ") instead.");\n      }\n      return null;\n    }, xe.register = function (t, e) {\n      for (var r in xe.definitions = e, e) {\n        t[r] = xe;\n      }\n    };\n\n    var be = function be(t, e, r) {\n      this.type = Kt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n    };\n\n    function we(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n\n    function _e(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n\n    function Ae(t, e) {\n      var r = (180 + t[0]) / 360,\n          n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n          i = Math.pow(2, e.z);\n      return [Math.round(r * i * 8192), Math.round(n * i * 8192)];\n    }\n\n    function Se(t, e, r) {\n      return e[1] > t[1] != r[1] > t[1] && t[0] < (r[0] - e[0]) * (t[1] - e[1]) / (r[1] - e[1]) + e[0];\n    }\n\n    function ke(t, e) {\n      for (var r, n, i, a, o, s, u, l = !1, p = 0, c = e.length; p < c; p++) {\n        for (var h = e[p], f = 0, y = h.length; f < y - 1; f++) {\n          if ((a = (r = t)[0] - (n = h[f])[0]) * (u = r[1] - (i = h[f + 1])[1]) - (s = r[0] - i[0]) * (o = r[1] - n[1]) == 0 && a * s <= 0 && o * u <= 0) return !1;\n          Se(t, h[f], h[f + 1]) && (l = !l);\n        }\n      }\n\n      return l;\n    }\n\n    function Ie(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        if (ke(t, e[r])) return !0;\n      }\n\n      return !1;\n    }\n\n    function ze(t, e, r, n) {\n      var i = n[0] - r[0],\n          a = n[1] - r[1],\n          o = (t[0] - r[0]) * a - i * (t[1] - r[1]),\n          s = (e[0] - r[0]) * a - i * (e[1] - r[1]);\n      return o > 0 && s < 0 || o < 0 && s > 0;\n    }\n\n    function Ce(t, e, r) {\n      for (var n = 0, i = r; n < i.length; n += 1) {\n        for (var a = i[n], o = 0; o < a.length - 1; ++o) {\n          if (0 != (c = [(p = a[o + 1])[0] - (l = a[o])[0], p[1] - l[1]])[0] * (h = [(u = e)[0] - (s = t)[0], u[1] - s[1]])[1] - c[1] * h[0] && ze(s, u, l, p) && ze(l, p, s, u)) return !0;\n        }\n      }\n\n      var s, u, l, p, c, h;\n      return !1;\n    }\n\n    function Ee(t, e) {\n      for (var r = 0; r < t.length; ++r) {\n        if (!ke(t[r], e)) return !1;\n      }\n\n      for (var n = 0; n < t.length - 1; ++n) {\n        if (Ce(t[n], t[n + 1], e)) return !1;\n      }\n\n      return !0;\n    }\n\n    function Pe(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        if (Ee(t, e[r])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Me(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        for (var a = [], o = 0; o < t[i].length; o++) {\n          var s = Ae(t[i][o], r);\n          we(e, s), a.push(s);\n        }\n\n        n.push(a);\n      }\n\n      return n;\n    }\n\n    function Be(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        var a = Me(t[i], e, r);\n        n.push(a);\n      }\n\n      return n;\n    }\n\n    function Te(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        var i = .5 * n,\n            a = t[0] - r[0] > i ? -n : r[0] - t[0] > i ? n : 0;\n        0 === a && (a = t[0] - r[2] > i ? -n : r[2] - t[0] > i ? n : 0), t[0] += a;\n      }\n\n      we(e, t);\n    }\n\n    function Ve(t, e, r, n) {\n      for (var i = 8192 * Math.pow(2, n.z), a = [8192 * n.x, 8192 * n.y], o = [], s = 0, u = t; s < u.length; s += 1) {\n        for (var l = 0, p = u[s]; l < p.length; l += 1) {\n          var c = p[l],\n              h = [c.x + a[0], c.y + a[1]];\n          Te(h, e, r, i), o.push(h);\n        }\n      }\n\n      return o;\n    }\n\n    function Fe(t, e, r, n) {\n      for (var i, a = 8192 * Math.pow(2, n.z), o = [8192 * n.x, 8192 * n.y], s = [], u = 0, l = t; u < l.length; u += 1) {\n        for (var p = [], c = 0, h = l[u]; c < h.length; c += 1) {\n          var f = h[c],\n              y = [f.x + o[0], f.y + o[1]];\n          we(e, y), p.push(y);\n        }\n\n        s.push(p);\n      }\n\n      if (e[2] - e[0] <= a / 2) {\n        (i = e)[0] = i[1] = 1 / 0, i[2] = i[3] = -1 / 0;\n\n        for (var d = 0, m = s; d < m.length; d += 1) {\n          for (var v = 0, g = m[d]; v < g.length; v += 1) {\n            Te(g[v], e, r, a);\n          }\n        }\n      }\n\n      return s;\n    }\n\n    be.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected one argument.");\n      var r = t[1];\n      if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");\n      var n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, Ut);\n      if (!n) return null;\n      var i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, Ut);\n      if (!i) return null;\n      var a = null;\n      return r.locale && !(a = e.parse(r.locale, 1, Rt)) ? null : new be(n, i, a);\n    }, be.prototype.evaluate = function (t) {\n      return new ee(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n    }, be.prototype.eachChild = function (t) {\n      t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n    }, be.prototype.outputDefined = function () {\n      return !1;\n    }, be.prototype.serialize = function () {\n      var t = {};\n      return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];\n    };\n\n    var De = function De(t, e) {\n      this.type = Ut, this.geojson = t, this.geometries = e;\n    };\n\n    function Le(t) {\n      if (t instanceof xe) {\n        if ("get" === t.name && 1 === t.args.length) return !1;\n        if ("feature-state" === t.name) return !1;\n        if ("has" === t.name && 1 === t.args.length) return !1;\n        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n\n      if (t instanceof De) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Le(t) && (e = !1);\n      }), e;\n    }\n\n    function Oe(t) {\n      if (t instanceof xe && "feature-state" === t.name) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Oe(t) && (e = !1);\n      }), e;\n    }\n\n    function Re(t, e) {\n      if (t instanceof xe && e.indexOf(t.name) >= 0) return !1;\n      var r = !0;\n      return t.eachChild(function (t) {\n        r && !Re(t, e) && (r = !1);\n      }), r;\n    }\n\n    De.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'within\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n\n      if (oe(t[1])) {\n        var r = t[1];\n        if ("FeatureCollection" === r.type) for (var n = 0; n < r.features.length; ++n) {\n          var i = r.features[n].geometry.type;\n          if ("Polygon" === i || "MultiPolygon" === i) return new De(r, r.features[n].geometry);\n        } else if ("Feature" === r.type) {\n          var a = r.geometry.type;\n          if ("Polygon" === a || "MultiPolygon" === a) return new De(r, r.geometry);\n        } else if ("Polygon" === r.type || "MultiPolygon" === r.type) return new De(r, r);\n      }\n\n      return e.error("\'within\' expression requires valid geojson object that contains polygon geometry type.");\n    }, De.prototype.evaluate = function (t) {\n      if (null != t.geometry() && null != t.canonicalID()) {\n        if ("Point" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n\n          if ("Polygon" === e.type) {\n            var a = Me(e.coordinates, n, i),\n                o = Ve(t.geometry(), r, n, i);\n            if (!_e(r, n)) return !1;\n\n            for (var s = 0, u = o; s < u.length; s += 1) {\n              if (!ke(u[s], a)) return !1;\n            }\n          }\n\n          if ("MultiPolygon" === e.type) {\n            var l = Be(e.coordinates, n, i),\n                p = Ve(t.geometry(), r, n, i);\n            if (!_e(r, n)) return !1;\n\n            for (var c = 0, h = p; c < h.length; c += 1) {\n              if (!Ie(h[c], l)) return !1;\n            }\n          }\n\n          return !0;\n        }(t, this.geometries);\n        if ("LineString" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n\n          if ("Polygon" === e.type) {\n            var a = Me(e.coordinates, n, i),\n                o = Fe(t.geometry(), r, n, i);\n            if (!_e(r, n)) return !1;\n\n            for (var s = 0, u = o; s < u.length; s += 1) {\n              if (!Ee(u[s], a)) return !1;\n            }\n          }\n\n          if ("MultiPolygon" === e.type) {\n            var l = Be(e.coordinates, n, i),\n                p = Fe(t.geometry(), r, n, i);\n            if (!_e(r, n)) return !1;\n\n            for (var c = 0, h = p; c < h.length; c += 1) {\n              if (!Pe(h[c], l)) return !1;\n            }\n          }\n\n          return !0;\n        }(t, this.geometries);\n      }\n\n      return !1;\n    }, De.prototype.eachChild = function () {}, De.prototype.outputDefined = function () {\n      return !0;\n    }, De.prototype.serialize = function () {\n      return ["within", this.geojson];\n    };\n\n    var Ue = function Ue(t, e) {\n      this.type = e.type, this.name = t, this.boundExpression = e;\n    };\n\n    Ue.parse = function (t, e) {\n      if (2 !== t.length || "string" != typeof t[1]) return e.error("\'var\' expression requires exactly one string literal argument.");\n      var r = t[1];\n      return e.scope.has(r) ? new Ue(r, e.scope.get(r)) : e.error(\'Unknown variable "\' + r + \'". Make sure "\' + r + \'" has been bound in an enclosing "let" expression before using it.\', 1);\n    }, Ue.prototype.evaluate = function (t) {\n      return this.boundExpression.evaluate(t);\n    }, Ue.prototype.eachChild = function () {}, Ue.prototype.outputDefined = function () {\n      return !1;\n    }, Ue.prototype.serialize = function () {\n      return ["var", this.name];\n    };\n\n    var je = function je(t, e, r, n, i) {\n      void 0 === e && (e = []), void 0 === n && (n = new Dt()), void 0 === i && (i = []), this.registry = t, this.path = e, this.key = e.map(function (t) {\n        return "[" + t + "]";\n      }).join(""), this.scope = n, this.errors = i, this.expectedType = r;\n    };\n\n    function qe(t, e) {\n      for (var r, n = t.length - 1, i = 0, a = n, o = 0; i <= a;) {\n        if ((r = t[o = Math.floor((i + a) / 2)]) <= e) {\n          if (o === n || e < t[o + 1]) return o;\n          i = o + 1;\n        } else {\n          if (!(r > e)) throw new pe("Input is not a number.");\n          a = o - 1;\n        }\n      }\n\n      return 0;\n    }\n\n    je.prototype.parse = function (t, e, r, n, i) {\n      return void 0 === i && (i = {}), e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n    }, je.prototype._parse = function (t, e) {\n      function r(t, e, r) {\n        return "assert" === r ? new he(e, [t]) : "coerce" === r ? new me(e, [t]) : t;\n      }\n\n      if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {\n        if (0 === t.length) return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');\n        var n = t[0];\n        if ("string" != typeof n) return this.error("Expression name must be a string, but found " + typeof n + \' instead. If you wanted a literal array, use ["literal", [...]].\', 0), null;\n        var i = this.registry[n];\n\n        if (i) {\n          var a = i.parse(t, this);\n          if (!a) return null;\n\n          if (this.expectedType) {\n            var o = this.expectedType,\n                s = a.type;\n            if ("string" !== o.kind && "number" !== o.kind && "boolean" !== o.kind && "object" !== o.kind && "array" !== o.kind || "value" !== s.kind) {\n              if ("color" !== o.kind && "formatted" !== o.kind && "resolvedImage" !== o.kind || "value" !== s.kind && "string" !== s.kind) {\n                if (this.checkSubtype(o, s)) return null;\n              } else a = r(a, o, e.typeAnnotation || "coerce");\n            } else a = r(a, o, e.typeAnnotation || "assert");\n          }\n\n          if (!(a instanceof le) && "resolvedImage" !== a.type.kind && function t(e) {\n            if (e instanceof Ue) return t(e.boundExpression);\n            if (e instanceof xe && "error" === e.name) return !1;\n            if (e instanceof be) return !1;\n            if (e instanceof De) return !1;\n            var r = e instanceof me || e instanceof he,\n                n = !0;\n            return e.eachChild(function (e) {\n              n = r ? n && t(e) : n && e instanceof le;\n            }), !!n && Le(e) && Re(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);\n          }(a)) {\n            var u = new ge();\n\n            try {\n              a = new le(a.type, a.evaluate(u));\n            } catch (t) {\n              return this.error(t.message), null;\n            }\n          }\n\n          return a;\n        }\n\n        return this.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n      }\n\n      return this.error(void 0 === t ? "\'undefined\' value invalid. Use null instead." : "object" == typeof t ? \'Bare objects invalid. Use ["literal", {...}] instead.\' : "Expected an array, but found " + typeof t + " instead.");\n    }, je.prototype.concat = function (t, e, r) {\n      var n = "number" == typeof t ? this.path.concat(t) : this.path,\n          i = r ? this.scope.concat(r) : this.scope;\n      return new je(this.registry, n, e || null, i, this.errors);\n    }, je.prototype.error = function (t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      var n = "" + this.key + e.map(function (t) {\n        return "[" + t + "]";\n      }).join("");\n      this.errors.push(new Ft(n, t));\n    }, je.prototype.checkSubtype = function (t, e) {\n      var r = Yt(t, e);\n      return r && this.error(r), r;\n    };\n\n    var Ne = function Ne(t, e, r) {\n      this.type = t, this.input = e, this.labels = [], this.outputs = [];\n\n      for (var n = 0, i = r; n < i.length; n += 1) {\n        var a = i[n],\n            o = a[1];\n        this.labels.push(a[0]), this.outputs.push(o);\n      }\n    };\n\n    function Ke(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n\n    Ne.parse = function (t, e) {\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = [],\n          i = null;\n      e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);\n\n      for (var a = 1; a < t.length; a += 2) {\n        var o = 1 === a ? -1 / 0 : t[a],\n            s = t[a + 1],\n            u = a,\n            l = a + 1;\n        if ("number" != typeof o) return e.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', u);\n        if (n.length && n[n.length - 1][0] >= o) return e.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\', u);\n        var p = e.parse(s, l, i);\n        if (!p) return null;\n        i = i || p.type, n.push([o, p]);\n      }\n\n      return new Ne(i, r, n);\n    }, Ne.prototype.evaluate = function (t) {\n      var e = this.labels,\n          r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[qe(e, n)].evaluate(t);\n    }, Ne.prototype.eachChild = function (t) {\n      t(this.input);\n\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) {\n        t(r[e]);\n      }\n    }, Ne.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, Ne.prototype.serialize = function () {\n      for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++) {\n        e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n      }\n\n      return t;\n    };\n    var Ge = Object.freeze({\n      __proto__: null,\n      number: Ke,\n      color: function color(t, e, r) {\n        return new te(Ke(t.r, e.r, r), Ke(t.g, e.g, r), Ke(t.b, e.b, r), Ke(t.a, e.a, r));\n      },\n      array: function array(t, e, r) {\n        return t.map(function (t, n) {\n          return Ke(t, e[n], r);\n        });\n      }\n    }),\n        Ze = 6 / 29 * 3 * (6 / 29),\n        Xe = Math.PI / 180,\n        Je = 180 / Math.PI;\n\n    function He(t) {\n      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Ze + 4 / 29;\n    }\n\n    function Ye(t) {\n      return t > 6 / 29 ? t * t * t : Ze * (t - 4 / 29);\n    }\n\n    function $e(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n\n    function We(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n\n    function Qe(t) {\n      var e = We(t.r),\n          r = We(t.g),\n          n = We(t.b),\n          i = He((.4124564 * e + .3575761 * r + .1804375 * n) / .95047),\n          a = He((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * a - 16,\n        a: 500 * (i - a),\n        b: 200 * (a - He((.0193339 * e + .119192 * r + .9503041 * n) / 1.08883)),\n        alpha: t.a\n      };\n    }\n\n    function tr(t) {\n      var e = (t.l + 16) / 116,\n          r = isNaN(t.a) ? e : e + t.a / 500,\n          n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Ye(e), r = .95047 * Ye(r), n = 1.08883 * Ye(n), new te($e(3.2404542 * r - 1.5371385 * e - .4985314 * n), $e(-.969266 * r + 1.8760108 * e + .041556 * n), $e(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n\n    function er(t, e, r) {\n      var n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n\n    var rr = {\n      forward: Qe,\n      reverse: tr,\n      interpolate: function interpolate(t, e, r) {\n        return {\n          l: Ke(t.l, e.l, r),\n          a: Ke(t.a, e.a, r),\n          b: Ke(t.b, e.b, r),\n          alpha: Ke(t.alpha, e.alpha, r)\n        };\n      }\n    },\n        nr = {\n      forward: function forward(t) {\n        var e = Qe(t),\n            r = e.l,\n            n = e.a,\n            i = e.b,\n            a = Math.atan2(i, n) * Je;\n        return {\n          h: a < 0 ? a + 360 : a,\n          c: Math.sqrt(n * n + i * i),\n          l: r,\n          alpha: t.a\n        };\n      },\n      reverse: function reverse(t) {\n        var e = t.h * Xe,\n            r = t.c;\n        return tr({\n          l: t.l,\n          a: Math.cos(e) * r,\n          b: Math.sin(e) * r,\n          alpha: t.alpha\n        });\n      },\n      interpolate: function interpolate(t, e, r) {\n        return {\n          h: er(t.h, e.h, r),\n          c: Ke(t.c, e.c, r),\n          l: Ke(t.l, e.l, r),\n          alpha: Ke(t.alpha, e.alpha, r)\n        };\n      }\n    },\n        ir = Object.freeze({\n      __proto__: null,\n      lab: rr,\n      hcl: nr\n    }),\n        ar = function ar(t, e, r, n, i) {\n      this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n\n      for (var a = 0, o = i; a < o.length; a += 1) {\n        var s = o[a],\n            u = s[1];\n        this.labels.push(s[0]), this.outputs.push(u);\n      }\n    };\n\n    function or(t, e, r, n) {\n      var i = n - r,\n          a = t - r;\n      return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n    }\n\n    ar.interpolationFactor = function (t, e, n, i) {\n      var a = 0;\n      if ("exponential" === t.name) a = or(e, t.base, n, i);else if ("linear" === t.name) a = or(e, 1, n, i);else if ("cubic-bezier" === t.name) {\n        var o = t.controlPoints;\n        a = new r(o[0], o[1], o[2], o[3]).solve(or(e, 1, n, i));\n      }\n      return a;\n    }, ar.parse = function (t, e) {\n      var r = t[0],\n          n = t[1],\n          i = t[2],\n          a = t.slice(3);\n      if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);\n      if ("linear" === n[0]) n = {\n        name: "linear"\n      };else if ("exponential" === n[0]) {\n        var o = n[1];\n        if ("number" != typeof o) return e.error("Exponential interpolation requires a numeric base.", 1, 1);\n        n = {\n          name: "exponential",\n          base: o\n        };\n      } else {\n        if ("cubic-bezier" !== n[0]) return e.error("Unknown interpolation type " + String(n[0]), 1, 0);\n        var s = n.slice(1);\n        if (4 !== s.length || s.some(function (t) {\n          return "number" != typeof t || t < 0 || t > 1;\n        })) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);\n        n = {\n          name: "cubic-bezier",\n          controlPoints: s\n        };\n      }\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      if (!(i = e.parse(i, 2, Ot))) return null;\n      var u = [],\n          l = null;\n      "interpolate-hcl" === r || "interpolate-lab" === r ? l = jt : e.expectedType && "value" !== e.expectedType.kind && (l = e.expectedType);\n\n      for (var p = 0; p < a.length; p += 2) {\n        var c = a[p],\n            h = a[p + 1],\n            f = p + 3,\n            y = p + 4;\n        if ("number" != typeof c) return e.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', f);\n        if (u.length && u[u.length - 1][0] >= c) return e.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\', f);\n        var d = e.parse(h, y, l);\n        if (!d) return null;\n        l = l || d.type, u.push([c, d]);\n      }\n\n      return "number" === l.kind || "color" === l.kind || "array" === l.kind && "number" === l.itemType.kind && "number" == typeof l.N ? new ar(l, r, n, i, u) : e.error("Type " + Jt(l) + " is not interpolatable.");\n    }, ar.prototype.evaluate = function (t) {\n      var e = this.labels,\n          r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n      var a = qe(e, n),\n          o = ar.interpolationFactor(this.interpolation, n, e[a], e[a + 1]),\n          s = r[a].evaluate(t),\n          u = r[a + 1].evaluate(t);\n      return "interpolate" === this.operator ? Ge[this.type.kind.toLowerCase()](s, u, o) : "interpolate-hcl" === this.operator ? nr.reverse(nr.interpolate(nr.forward(s), nr.forward(u), o)) : rr.reverse(rr.interpolate(rr.forward(s), rr.forward(u), o));\n    }, ar.prototype.eachChild = function (t) {\n      t(this.input);\n\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) {\n        t(r[e]);\n      }\n    }, ar.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, ar.prototype.serialize = function () {\n      var t;\n      t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);\n\n      for (var e = [this.operator, t, this.input.serialize()], r = 0; r < this.labels.length; r++) {\n        e.push(this.labels[r], this.outputs[r].serialize());\n      }\n\n      return e;\n    };\n\n    var sr = function sr(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    sr.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expectected at least one argument.");\n      var r = null,\n          n = e.expectedType;\n      n && "value" !== n.kind && (r = n);\n\n      for (var i = [], a = 0, o = t.slice(1); a < o.length; a += 1) {\n        var s = e.parse(o[a], 1 + i.length, r, void 0, {\n          typeAnnotation: "omit"\n        });\n        if (!s) return null;\n        r = r || s.type, i.push(s);\n      }\n\n      var u = n && i.some(function (t) {\n        return Yt(n, t.type);\n      });\n      return new sr(u ? Nt : r, i);\n    }, sr.prototype.evaluate = function (t) {\n      for (var e, r = null, n = 0, i = 0, a = this.args; i < a.length && (n++, (r = a[i].evaluate(t)) && r instanceof ie && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null === r); i += 1) {\n        ;\n      }\n\n      return r;\n    }, sr.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, sr.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, sr.prototype.serialize = function () {\n      var t = ["coalesce"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var ur = function ur(t, e) {\n      this.type = e.type, this.bindings = [].concat(t), this.result = e;\n    };\n\n    ur.prototype.evaluate = function (t) {\n      return this.result.evaluate(t);\n    }, ur.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.bindings; e < r.length; e += 1) {\n        t(r[e][1]);\n      }\n\n      t(this.result);\n    }, ur.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead.");\n\n      for (var r = [], n = 1; n < t.length - 1; n += 2) {\n        var i = t[n];\n        if ("string" != typeof i) return e.error("Expected string, but found " + typeof i + " instead.", n);\n        if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or \'_\'.", n);\n        var a = e.parse(t[n + 1], n + 1);\n        if (!a) return null;\n        r.push([i, a]);\n      }\n\n      var o = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n      return o ? new ur(r, o) : null;\n    }, ur.prototype.outputDefined = function () {\n      return this.result.outputDefined();\n    }, ur.prototype.serialize = function () {\n      for (var t = ["let"], e = 0, r = this.bindings; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n[0], n[1].serialize());\n      }\n\n      return t.push(this.result.serialize()), t;\n    };\n\n    var lr = function lr(t, e, r) {\n      this.type = t, this.index = e, this.input = r;\n    };\n\n    lr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Ot),\n          n = e.parse(t[2], 2, Xt(e.expectedType || Nt));\n      return r && n ? new lr(n.type.itemType, r, n) : null;\n    }, lr.prototype.evaluate = function (t) {\n      var e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n      if (e < 0) throw new pe("Array index out of bounds: " + e + " < 0.");\n      if (e >= r.length) throw new pe("Array index out of bounds: " + e + " > " + (r.length - 1) + ".");\n      if (e !== Math.floor(e)) throw new pe("Array index must be an integer, but found " + e + " instead.");\n      return r[e];\n    }, lr.prototype.eachChild = function (t) {\n      t(this.index), t(this.input);\n    }, lr.prototype.outputDefined = function () {\n      return !1;\n    }, lr.prototype.serialize = function () {\n      return ["at", this.index.serialize(), this.input.serialize()];\n    };\n\n    var pr = function pr(t, e) {\n      this.type = Ut, this.needle = t, this.haystack = e;\n    };\n\n    pr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Nt),\n          n = e.parse(t[2], 2, Nt);\n      return r && n ? $t(r.type, [Ut, Rt, Ot, Lt, Nt]) ? new pr(r, n) : e.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r.type) + " instead") : null;\n    }, pr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n      if (!r) return !1;\n      if (!Wt(e, ["boolean", "string", "number", "null"])) throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e)) + " instead.");\n      if (!Wt(r, ["string", "array"])) throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r)) + " instead.");\n      return r.indexOf(e) >= 0;\n    }, pr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack);\n    }, pr.prototype.outputDefined = function () {\n      return !0;\n    }, pr.prototype.serialize = function () {\n      return ["in", this.needle.serialize(), this.haystack.serialize()];\n    };\n\n    var cr = function cr(t, e, r) {\n      this.type = Ot, this.needle = t, this.haystack = e, this.fromIndex = r;\n    };\n\n    cr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Nt),\n          n = e.parse(t[2], 2, Nt);\n      if (!r || !n) return null;\n      if (!$t(r.type, [Ut, Rt, Ot, Lt, Nt])) return e.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r.type) + " instead");\n\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new cr(r, n, i) : null;\n      }\n\n      return new cr(r, n);\n    }, cr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n      if (!Wt(e, ["boolean", "string", "number", "null"])) throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e)) + " instead.");\n      if (!Wt(r, ["string", "array"])) throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r)) + " instead.");\n\n      if (this.fromIndex) {\n        var n = this.fromIndex.evaluate(t);\n        return r.indexOf(e, n);\n      }\n\n      return r.indexOf(e);\n    }, cr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n    }, cr.prototype.outputDefined = function () {\n      return !1;\n    }, cr.prototype.serialize = function () {\n      if (null != this.fromIndex && void 0 !== this.fromIndex) {\n        var t = this.fromIndex.serialize();\n        return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];\n      }\n\n      return ["index-of", this.needle.serialize(), this.haystack.serialize()];\n    };\n\n    var hr = function hr(t, e, r, n, i, a) {\n      this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;\n    };\n\n    hr.parse = function (t, e) {\n      if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");\n      var r, n;\n      e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);\n\n      for (var i = {}, a = [], o = 2; o < t.length - 1; o += 2) {\n        var s = t[o],\n            u = t[o + 1];\n        Array.isArray(s) || (s = [s]);\n        var l = e.concat(o);\n        if (0 === s.length) return l.error("Expected at least one branch label.");\n\n        for (var p = 0, c = s; p < c.length; p += 1) {\n          var h = c[p];\n          if ("number" != typeof h && "string" != typeof h) return l.error("Branch labels must be numbers or strings.");\n          if ("number" == typeof h && Math.abs(h) > Number.MAX_SAFE_INTEGER) return l.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");\n          if ("number" == typeof h && Math.floor(h) !== h) return l.error("Numeric branch labels must be integer values.");\n\n          if (r) {\n            if (l.checkSubtype(r, se(h))) return null;\n          } else r = se(h);\n\n          if (void 0 !== i[String(h)]) return l.error("Branch labels must be unique.");\n          i[String(h)] = a.length;\n        }\n\n        var f = e.parse(u, o, n);\n        if (!f) return null;\n        n = n || f.type, a.push(f);\n      }\n\n      var y = e.parse(t[1], 1, Nt);\n      if (!y) return null;\n      var d = e.parse(t[t.length - 1], t.length - 1, n);\n      return d ? "value" !== y.type.kind && e.concat(1).checkSubtype(r, y.type) ? null : new hr(r, n, y, i, a, d) : null;\n    }, hr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      return (se(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n    }, hr.prototype.eachChild = function (t) {\n      t(this.input), this.outputs.forEach(t), t(this.otherwise);\n    }, hr.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, hr.prototype.serialize = function () {\n      for (var t = this, e = ["match", this.input.serialize()], r = [], n = {}, i = 0, a = Object.keys(this.cases).sort(); i < a.length; i += 1) {\n        var o = a[i];\n        void 0 === (c = n[this.cases[o]]) ? (n[this.cases[o]] = r.length, r.push([this.cases[o], [o]])) : r[c][1].push(o);\n      }\n\n      for (var s = function s(e) {\n        return "number" === t.inputType.kind ? Number(e) : e;\n      }, u = 0, l = r; u < l.length; u += 1) {\n        var p = l[u],\n            c = p[0],\n            h = p[1];\n        e.push(1 === h.length ? s(h[0]) : h.map(s)), e.push(this.outputs[outputIndex$1].serialize());\n      }\n\n      return e.push(this.otherwise.serialize()), e;\n    };\n\n    var fr = function fr(t, e, r) {\n      this.type = t, this.branches = e, this.otherwise = r;\n    };\n\n    fr.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");\n      var r;\n      e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);\n\n      for (var n = [], i = 1; i < t.length - 1; i += 2) {\n        var a = e.parse(t[i], i, Ut);\n        if (!a) return null;\n        var o = e.parse(t[i + 1], i + 1, r);\n        if (!o) return null;\n        n.push([a, o]), r = r || o.type;\n      }\n\n      var s = e.parse(t[t.length - 1], t.length - 1, r);\n      return s ? new fr(r, n, s) : null;\n    }, fr.prototype.evaluate = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n            i = n[1];\n        if (n[0].evaluate(t)) return i.evaluate(t);\n      }\n\n      return this.otherwise.evaluate(t);\n    }, fr.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n            i = n[1];\n        t(n[0]), t(i);\n      }\n\n      t(this.otherwise);\n    }, fr.prototype.outputDefined = function () {\n      return this.branches.every(function (t) {\n        return t[1].outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, fr.prototype.serialize = function () {\n      var t = ["case"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var yr = function yr(t, e, r, n) {\n      this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n    };\n\n    function dr(t, e) {\n      return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;\n    }\n\n    function mr(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n\n    function vr(t, e, r) {\n      var n = "==" !== t && "!=" !== t;\n      return function () {\n        function i(t, e, r) {\n          this.type = Ut, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;\n        }\n\n        return i.parse = function (t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");\n          var r = t[0],\n              a = e.parse(t[1], 1, Nt);\n          if (!a) return null;\n          if (!dr(r, a.type)) return e.concat(1).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Jt(a.type) + "\'.");\n          var o = e.parse(t[2], 2, Nt);\n          if (!o) return null;\n          if (!dr(r, o.type)) return e.concat(2).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Jt(o.type) + "\'.");\n          if (a.type.kind !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot compare types \'" + Jt(a.type) + "\' and \'" + Jt(o.type) + "\'.");\n          n && ("value" === a.type.kind && "value" !== o.type.kind ? a = new he(o.type, [a]) : "value" !== a.type.kind && "value" === o.type.kind && (o = new he(a.type, [o])));\n          var s = null;\n\n          if (4 === t.length) {\n            if ("string" !== a.type.kind && "string" !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot use collator to compare non-string types.");\n            if (!(s = e.parse(t[3], 3, Kt))) return null;\n          }\n\n          return new i(a, o, s);\n        }, i.prototype.evaluate = function (i) {\n          var a = this.lhs.evaluate(i),\n              o = this.rhs.evaluate(i);\n\n          if (n && this.hasUntypedArgument) {\n            var s = se(a),\n                u = se(o);\n            if (s.kind !== u.kind || "string" !== s.kind && "number" !== s.kind) throw new pe(\'Expected arguments for "\' + t + \'" to be (string, string) or (number, number), but found (\' + s.kind + ", " + u.kind + ") instead.");\n          }\n\n          if (this.collator && !n && this.hasUntypedArgument) {\n            var l = se(a),\n                p = se(o);\n            if ("string" !== l.kind || "string" !== p.kind) return e(i, a, o);\n          }\n\n          return this.collator ? r(i, a, o, this.collator.evaluate(i)) : e(i, a, o);\n        }, i.prototype.eachChild = function (t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }, i.prototype.outputDefined = function () {\n          return !0;\n        }, i.prototype.serialize = function () {\n          var e = [t];\n          return this.eachChild(function (t) {\n            e.push(t.serialize());\n          }), e;\n        }, i;\n      }();\n    }\n\n    yr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Nt),\n          n = e.parse(t[2], 2, Ot);\n      if (!r || !n) return null;\n      if (!$t(r.type, [Xt(Nt), Rt, Nt])) return e.error("Expected first argument to be of type array or string, but found " + Jt(r.type) + " instead");\n\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new yr(r.type, r, n, i) : null;\n      }\n\n      return new yr(r.type, r, n);\n    }, yr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n      if (!Wt(e, ["string", "array"])) throw new pe("Expected first argument to be of type array or string, but found " + Jt(se(e)) + " instead.");\n\n      if (this.endIndex) {\n        var n = this.endIndex.evaluate(t);\n        return e.slice(r, n);\n      }\n\n      return e.slice(r);\n    }, yr.prototype.eachChild = function (t) {\n      t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n    }, yr.prototype.outputDefined = function () {\n      return !1;\n    }, yr.prototype.serialize = function () {\n      if (null != this.endIndex && void 0 !== this.endIndex) {\n        var t = this.endIndex.serialize();\n        return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];\n      }\n\n      return ["slice", this.input.serialize(), this.beginIndex.serialize()];\n    };\n\n    var gr = vr("==", function (t, e, r) {\n      return e === r;\n    }, mr),\n        xr = vr("!=", function (t, e, r) {\n      return e !== r;\n    }, function (t, e, r, n) {\n      return !mr(0, e, r, n);\n    }),\n        br = vr("<", function (t, e, r) {\n      return e < r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) < 0;\n    }),\n        wr = vr(">", function (t, e, r) {\n      return e > r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) > 0;\n    }),\n        _r = vr("<=", function (t, e, r) {\n      return e <= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) <= 0;\n    }),\n        Ar = vr(">=", function (t, e, r) {\n      return e >= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) >= 0;\n    }),\n        Sr = function Sr(t, e, r, n, i) {\n      this.type = Rt, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n    };\n\n    Sr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = t[2];\n      if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");\n      var i = null;\n      if (n.locale && !(i = e.parse(n.locale, 1, Rt))) return null;\n      var a = null;\n      if (n.currency && !(a = e.parse(n.currency, 1, Rt))) return null;\n      var o = null;\n      if (n["min-fraction-digits"] && !(o = e.parse(n["min-fraction-digits"], 1, Ot))) return null;\n      var s = null;\n      return n["max-fraction-digits"] && !(s = e.parse(n["max-fraction-digits"], 1, Ot)) ? null : new Sr(r, i, a, o, s);\n    }, Sr.prototype.evaluate = function (t) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n        style: this.currency ? "currency" : "decimal",\n        currency: this.currency ? this.currency.evaluate(t) : void 0,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n      }).format(this.number.evaluate(t));\n    }, Sr.prototype.eachChild = function (t) {\n      t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n    }, Sr.prototype.outputDefined = function () {\n      return !1;\n    }, Sr.prototype.serialize = function () {\n      var t = {};\n      return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];\n    };\n\n    var kr = function kr(t) {\n      this.type = Ot, this.input = t;\n    };\n\n    kr.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1);\n      return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error("Expected argument of type string or array, but found " + Jt(r.type) + " instead.") : new kr(r) : null;\n    }, kr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      if ("string" == typeof e) return e.length;\n      if (Array.isArray(e)) return e.length;\n      throw new pe("Expected value to be of type string or array, but found " + Jt(se(e)) + " instead.");\n    }, kr.prototype.eachChild = function (t) {\n      t(this.input);\n    }, kr.prototype.outputDefined = function () {\n      return !1;\n    }, kr.prototype.serialize = function () {\n      var t = ["length"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var Ir = {\n      "==": gr,\n      "!=": xr,\n      ">": wr,\n      "<": br,\n      ">=": Ar,\n      "<=": _r,\n      array: he,\n      at: lr,\n      boolean: he,\n      case: fr,\n      coalesce: sr,\n      collator: be,\n      format: fe,\n      image: ye,\n      in: pr,\n      "index-of": cr,\n      interpolate: ar,\n      "interpolate-hcl": ar,\n      "interpolate-lab": ar,\n      length: kr,\n      let: ur,\n      literal: le,\n      match: hr,\n      number: he,\n      "number-format": Sr,\n      object: he,\n      slice: yr,\n      step: Ne,\n      string: he,\n      "to-boolean": me,\n      "to-color": me,\n      "to-number": me,\n      "to-string": me,\n      var: Ue,\n      within: De\n    };\n\n    function zr(t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = e[3];\n      r = r.evaluate(t), n = n.evaluate(t), i = i.evaluate(t);\n      var o = a ? a.evaluate(t) : 1,\n          s = ae(r, n, i, o);\n      if (s) throw new pe(s);\n      return new te(r / 255 * o, n / 255 * o, i / 255 * o, o);\n    }\n\n    function Cr(t, e) {\n      return t in e;\n    }\n\n    function Er(t, e) {\n      var r = e[t];\n      return void 0 === r ? null : r;\n    }\n\n    function Pr(t) {\n      return {\n        type: t\n      };\n    }\n\n    function Mr(t) {\n      return {\n        result: "success",\n        value: t\n      };\n    }\n\n    function Br(t) {\n      return {\n        result: "error",\n        value: t\n      };\n    }\n\n    function Tr(t) {\n      return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"];\n    }\n\n    function Vr(t) {\n      return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;\n    }\n\n    function Fr(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n\n    function Dr(t) {\n      return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;\n    }\n\n    function Lr(t) {\n      return "object" == typeof t && null !== t && !Array.isArray(t);\n    }\n\n    function Or(t) {\n      return t;\n    }\n\n    function Rr(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n\n    function Ur(t, e, r, n, i) {\n      return Rr(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n\n    function jr(t, e, r) {\n      if ("number" !== Dr(r)) return Rr(t.default, e.default);\n      var n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      var i = qe(t.stops.map(function (t) {\n        return t[0];\n      }), r);\n      return t.stops[i][1];\n    }\n\n    function qr(t, e, r) {\n      var n = void 0 !== t.base ? t.base : 1;\n      if ("number" !== Dr(r)) return Rr(t.default, e.default);\n      var i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n\n      var a = qe(t.stops.map(function (t) {\n        return t[0];\n      }), r),\n          o = function (t, e, r, n) {\n        var i = n - r,\n            a = t - r;\n        return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n      }(r, n, t.stops[a][0], t.stops[a + 1][0]),\n          s = t.stops[a][1],\n          u = t.stops[a + 1][1],\n          l = Ge[e.type] || Or;\n\n      if (t.colorSpace && "rgb" !== t.colorSpace) {\n        var p = ir[t.colorSpace];\n\n        l = function l(t, e) {\n          return p.reverse(p.interpolate(p.forward(t), p.forward(e), o));\n        };\n      }\n\n      return "function" == typeof s.evaluate ? {\n        evaluate: function evaluate() {\n          for (var t = [], e = arguments.length; e--;) {\n            t[e] = arguments[e];\n          }\n\n          var r = s.evaluate.apply(void 0, t),\n              n = u.evaluate.apply(void 0, t);\n          if (void 0 !== r && void 0 !== n) return l(r, n, o);\n        }\n      } : l(s, u, o);\n    }\n\n    function Nr(t, e, r) {\n      return "color" === e.type ? r = te.parse(r) : "formatted" === e.type ? r = ne.fromString(r.toString()) : "resolvedImage" === e.type ? r = ie.fromString(r.toString()) : Dr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Rr(r, t.default, e.default);\n    }\n\n    xe.register(Ir, {\n      error: [{\n        kind: "error"\n      }, [Rt], function (t, e) {\n        throw new pe(e[0].evaluate(t));\n      }],\n      typeof: [Rt, [Nt], function (t, e) {\n        return Jt(se(e[0].evaluate(t)));\n      }],\n      "to-rgba": [Xt(Ot, 4), [jt], function (t, e) {\n        return e[0].evaluate(t).toArray();\n      }],\n      rgb: [jt, [Ot, Ot, Ot], zr],\n      rgba: [jt, [Ot, Ot, Ot, Ot], zr],\n      has: {\n        type: Ut,\n        overloads: [[[Rt], function (t, e) {\n          return Cr(e[0].evaluate(t), t.properties());\n        }], [[Rt, qt], function (t, e) {\n          var r = e[1];\n          return Cr(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      get: {\n        type: Nt,\n        overloads: [[[Rt], function (t, e) {\n          return Er(e[0].evaluate(t), t.properties());\n        }], [[Rt, qt], function (t, e) {\n          var r = e[1];\n          return Er(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      "feature-state": [Nt, [Rt], function (t, e) {\n        return Er(e[0].evaluate(t), t.featureState || {});\n      }],\n      properties: [qt, [], function (t) {\n        return t.properties();\n      }],\n      "geometry-type": [Rt, [], function (t) {\n        return t.geometryType();\n      }],\n      id: [Nt, [], function (t) {\n        return t.id();\n      }],\n      zoom: [Ot, [], function (t) {\n        return t.globals.zoom;\n      }],\n      "heatmap-density": [Ot, [], function (t) {\n        return t.globals.heatmapDensity || 0;\n      }],\n      "line-progress": [Ot, [], function (t) {\n        return t.globals.lineProgress || 0;\n      }],\n      accumulated: [Nt, [], function (t) {\n        return void 0 === t.globals.accumulated ? null : t.globals.accumulated;\n      }],\n      "+": [Ot, Pr(Ot), function (t, e) {\n        for (var r = 0, n = 0, i = e; n < i.length; n += 1) {\n          r += i[n].evaluate(t);\n        }\n\n        return r;\n      }],\n      "*": [Ot, Pr(Ot), function (t, e) {\n        for (var r = 1, n = 0, i = e; n < i.length; n += 1) {\n          r *= i[n].evaluate(t);\n        }\n\n        return r;\n      }],\n      "-": {\n        type: Ot,\n        overloads: [[[Ot, Ot], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) - r.evaluate(t);\n        }], [[Ot], function (t, e) {\n          return -e[0].evaluate(t);\n        }]]\n      },\n      "/": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) / r.evaluate(t);\n      }],\n      "%": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) % r.evaluate(t);\n      }],\n      ln2: [Ot, [], function () {\n        return Math.LN2;\n      }],\n      pi: [Ot, [], function () {\n        return Math.PI;\n      }],\n      e: [Ot, [], function () {\n        return Math.E;\n      }],\n      "^": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return Math.pow(e[0].evaluate(t), r.evaluate(t));\n      }],\n      sqrt: [Ot, [Ot], function (t, e) {\n        return Math.sqrt(e[0].evaluate(t));\n      }],\n      log10: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN10;\n      }],\n      ln: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t));\n      }],\n      log2: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN2;\n      }],\n      sin: [Ot, [Ot], function (t, e) {\n        return Math.sin(e[0].evaluate(t));\n      }],\n      cos: [Ot, [Ot], function (t, e) {\n        return Math.cos(e[0].evaluate(t));\n      }],\n      tan: [Ot, [Ot], function (t, e) {\n        return Math.tan(e[0].evaluate(t));\n      }],\n      asin: [Ot, [Ot], function (t, e) {\n        return Math.asin(e[0].evaluate(t));\n      }],\n      acos: [Ot, [Ot], function (t, e) {\n        return Math.acos(e[0].evaluate(t));\n      }],\n      atan: [Ot, [Ot], function (t, e) {\n        return Math.atan(e[0].evaluate(t));\n      }],\n      min: [Ot, Pr(Ot), function (t, e) {\n        return Math.min.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      max: [Ot, Pr(Ot), function (t, e) {\n        return Math.max.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      abs: [Ot, [Ot], function (t, e) {\n        return Math.abs(e[0].evaluate(t));\n      }],\n      round: [Ot, [Ot], function (t, e) {\n        var r = e[0].evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [Ot, [Ot], function (t, e) {\n        return Math.floor(e[0].evaluate(t));\n      }],\n      ceil: [Ot, [Ot], function (t, e) {\n        return Math.ceil(e[0].evaluate(t));\n      }],\n      "filter-==": [Ut, [Rt, Nt], function (t, e) {\n        var r = e[0],\n            n = e[1];\n        return t.properties()[r.value] === n.value;\n      }],\n      "filter-id-==": [Ut, [Nt], function (t, e) {\n        var r = e[0];\n        return t.id() === r.value;\n      }],\n      "filter-type-==": [Ut, [Rt], function (t, e) {\n        var r = e[0];\n        return t.geometryType() === r.value;\n      }],\n      "filter-<": [Ut, [Rt, Nt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i < a;\n      }],\n      "filter-id-<": [Ut, [Nt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      "filter->": [Ut, [Rt, Nt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i > a;\n      }],\n      "filter-id->": [Ut, [Nt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      "filter-<=": [Ut, [Rt, Nt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i <= a;\n      }],\n      "filter-id-<=": [Ut, [Nt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      "filter->=": [Ut, [Rt, Nt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i >= a;\n      }],\n      "filter-id->=": [Ut, [Nt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      "filter-has": [Ut, [Nt], function (t, e) {\n        return e[0].value in t.properties();\n      }],\n      "filter-has-id": [Ut, [], function (t) {\n        return null !== t.id() && void 0 !== t.id();\n      }],\n      "filter-type-in": [Ut, [Xt(Rt)], function (t, e) {\n        return e[0].value.indexOf(t.geometryType()) >= 0;\n      }],\n      "filter-id-in": [Ut, [Xt(Nt)], function (t, e) {\n        return e[0].value.indexOf(t.id()) >= 0;\n      }],\n      "filter-in-small": [Ut, [Rt, Xt(Nt)], function (t, e) {\n        var r = e[0];\n        return e[1].value.indexOf(t.properties()[r.value]) >= 0;\n      }],\n      "filter-in-large": [Ut, [Rt, Xt(Nt)], function (t, e) {\n        var r = e[0],\n            n = e[1];\n        return function (t, e, r, n) {\n          for (; r <= n;) {\n            var i = r + n >> 1;\n            if (e[i] === t) return !0;\n            e[i] > t ? n = i - 1 : r = i + 1;\n          }\n\n          return !1;\n        }(t.properties()[r.value], n.value, 0, n.value.length - 1);\n      }],\n      all: {\n        type: Ut,\n        overloads: [[[Ut, Ut], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) && r.evaluate(t);\n        }], [Pr(Ut), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) {\n            if (!n[r].evaluate(t)) return !1;\n          }\n\n          return !0;\n        }]]\n      },\n      any: {\n        type: Ut,\n        overloads: [[[Ut, Ut], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) || r.evaluate(t);\n        }], [Pr(Ut), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) {\n            if (n[r].evaluate(t)) return !0;\n          }\n\n          return !1;\n        }]]\n      },\n      "!": [Ut, [Ut], function (t, e) {\n        return !e[0].evaluate(t);\n      }],\n      "is-supported-script": [Ut, [Rt], function (t, e) {\n        var r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e[0].evaluate(t));\n      }],\n      upcase: [Rt, [Rt], function (t, e) {\n        return e[0].evaluate(t).toUpperCase();\n      }],\n      downcase: [Rt, [Rt], function (t, e) {\n        return e[0].evaluate(t).toLowerCase();\n      }],\n      concat: [Rt, Pr(Nt), function (t, e) {\n        return e.map(function (e) {\n          return ue(e.evaluate(t));\n        }).join("");\n      }],\n      "resolved-locale": [Rt, [Kt], function (t, e) {\n        return e[0].evaluate(t).resolvedLocale();\n      }]\n    });\n\n    var Kr = function Kr(t, e) {\n      this.expression = t, this._warningHistory = {}, this._evaluator = new ge(), this._defaultValue = e ? function (t) {\n        return "color" === t.type && Lr(t.default) ? new te(0, 0, 0, 0) : "color" === t.type ? te.parse(t.default) || null : void 0 === t.default ? null : t.default;\n      }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;\n    };\n\n    function Gr(t) {\n      return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in Ir;\n    }\n\n    function Zr(t, e) {\n      var r = new je(Ir, [], e ? function (t) {\n        var e = {\n          color: jt,\n          string: Rt,\n          number: Ot,\n          enum: Rt,\n          boolean: Ut,\n          formatted: Gt,\n          resolvedImage: Zt\n        };\n        return "array" === t.type ? Xt(e[t.value] || Nt, t.length) : e[t.type];\n      }(e) : void 0),\n          n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {\n        typeAnnotation: "coerce"\n      } : void 0);\n      return n ? Mr(new Kr(n, e)) : Br(r.errors);\n    }\n\n    Kr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);\n    }, Kr.prototype.evaluate = function (t, e, r, n, i, a) {\n      this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null;\n\n      try {\n        var o = this.expression.evaluate(this._evaluator);\n        if (null == o || "number" == typeof o && o != o) return this._defaultValue;\n        if (this._enumValues && !(o in this._enumValues)) throw new pe("Expected value to be one of " + Object.keys(this._enumValues).map(function (t) {\n          return JSON.stringify(t);\n        }).join(", ") + ", but found " + JSON.stringify(o) + " instead.");\n        return o;\n      } catch (t) {\n        return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;\n      }\n    };\n\n    var Xr = function Xr(t, e) {\n      this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Oe(e.expression);\n    };\n\n    Xr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Xr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    };\n\n    var Jr = function Jr(t, e, r, n) {\n      this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Oe(e.expression), this.interpolationType = n;\n    };\n\n    function Hr(t, e) {\n      if ("error" === (t = Zr(t, e)).result) return t;\n      var r = t.value.expression,\n          n = Le(r);\n      if (!n && !Tr(e)) return Br([new Ft("", "data expressions not supported")]);\n      var i = Re(r, ["zoom"]);\n      if (!i && !Vr(e)) return Br([new Ft("", "zoom expressions not supported")]);\n\n      var a = function t(e) {\n        var r = null;\n        if (e instanceof ur) r = t(e.result);else if (e instanceof sr) for (var n = 0, i = e.args; n < i.length && !(r = t(i[n])); n += 1) {\n          ;\n        } else (e instanceof Ne || e instanceof ar) && e.input instanceof xe && "zoom" === e.input.name && (r = e);\n        return r instanceof Ft || e.eachChild(function (e) {\n          var n = t(e);\n          n instanceof Ft ? r = n : !r && n ? r = new Ft("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\') : r && n && r !== n && (r = new Ft("", \'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'));\n        }), r;\n      }(r);\n\n      return a || i ? a instanceof Ft ? Br([a]) : a instanceof ar && !Fr(e) ? Br([new Ft("", \'"interpolate" expressions cannot be used with this property\')]) : Mr(a ? new Jr(n ? "camera" : "composite", t.value, a.labels, a instanceof ar ? a.interpolation : void 0) : new Xr(n ? "constant" : "source", t.value)) : Br([new Ft("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);\n    }\n\n    Jr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Jr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    }, Jr.prototype.interpolationFactor = function (t, e, r) {\n      return this.interpolationType ? ar.interpolationFactor(this.interpolationType, t, e, r) : 0;\n    };\n\n    var Yr = function Yr(t, e) {\n      this._parameters = t, this._specification = e, Bt(this, function t(e, r) {\n        var n,\n            i,\n            a,\n            o = "color" === r.type,\n            s = e.stops && "object" == typeof e.stops[0][0],\n            u = s || !(s || void 0 !== e.property),\n            l = e.type || (Fr(r) ? "exponential" : "interval");\n        if (o && ((e = Bt({}, e)).stops && (e.stops = e.stops.map(function (t) {\n          return [t[0], te.parse(t[1])];\n        })), e.default = te.parse(e.default ? e.default : r.default)), e.colorSpace && "rgb" !== e.colorSpace && !ir[e.colorSpace]) throw new Error("Unknown color space: " + e.colorSpace);\n        if ("exponential" === l) n = qr;else if ("interval" === l) n = jr;else if ("categorical" === l) {\n          n = Ur, i = Object.create(null);\n\n          for (var p = 0, c = e.stops; p < c.length; p += 1) {\n            var h = c[p];\n            i[h[0]] = h[1];\n          }\n\n          a = typeof e.stops[0][0];\n        } else {\n          if ("identity" !== l) throw new Error(\'Unknown function type "\' + l + \'"\');\n          n = Nr;\n        }\n\n        if (s) {\n          for (var f = {}, y = [], d = 0; d < e.stops.length; d++) {\n            var m = e.stops[d],\n                v = m[0].zoom;\n            void 0 === f[v] && (f[v] = {\n              zoom: v,\n              type: e.type,\n              property: e.property,\n              default: e.default,\n              stops: []\n            }, y.push(v)), f[v].stops.push([m[0].value, m[1]]);\n          }\n\n          for (var g = [], x = 0, b = y; x < b.length; x += 1) {\n            var w = b[x];\n            g.push([f[w].zoom, t(f[w], r)]);\n          }\n\n          var _ = {\n            name: "linear"\n          };\n          return {\n            kind: "composite",\n            interpolationType: _,\n            interpolationFactor: ar.interpolationFactor.bind(void 0, _),\n            zoomStops: g.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function evaluate(t, n) {\n              var i = t.zoom;\n              return qr({\n                stops: g,\n                base: e.base\n              }, r, i).evaluate(i, n);\n            }\n          };\n        }\n\n        if (u) {\n          var A = "exponential" === l ? {\n            name: "exponential",\n            base: void 0 !== e.base ? e.base : 1\n          } : null;\n          return {\n            kind: "camera",\n            interpolationType: A,\n            interpolationFactor: ar.interpolationFactor.bind(void 0, A),\n            zoomStops: e.stops.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function evaluate(t) {\n              return n(e, r, t.zoom, i, a);\n            }\n          };\n        }\n\n        return {\n          kind: "source",\n          evaluate: function evaluate(t, o) {\n            var s = o && o.properties ? o.properties[e.property] : void 0;\n            return void 0 === s ? Rr(e.default, r.default) : n(e, r, s, i, a);\n          }\n        };\n      }(this._parameters, this._specification));\n    };\n\n    function $r(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec || {},\n          i = t.objectElementValidators || {},\n          a = t.style,\n          o = t.styleSpec,\n          s = [],\n          u = Dr(r);\n      if ("object" !== u) return [new Pt(e, r, "object expected, " + u + " found")];\n\n      for (var l in r) {\n        var p = l.split(".")[0],\n            c = n[p] || n["*"],\n            h = void 0;\n        if (i[p]) h = i[p];else if (n[p]) h = An;else if (i["*"]) h = i["*"];else {\n          if (!n["*"]) {\n            s.push(new Pt(e, r[l], \'unknown property "\' + l + \'"\'));\n            continue;\n          }\n\n          h = An;\n        }\n        s = s.concat(h({\n          key: (e ? e + "." : e) + l,\n          value: r[l],\n          valueSpec: c,\n          style: a,\n          styleSpec: o,\n          object: r,\n          objectKey: l\n        }, r));\n      }\n\n      for (var f in n) {\n        i[f] || n[f].required && void 0 === n[f].default && void 0 === r[f] && s.push(new Pt(e, r, \'missing required property "\' + f + \'"\'));\n      }\n\n      return s;\n    }\n\n    function Wr(t) {\n      var e = t.value,\n          r = t.valueSpec,\n          n = t.style,\n          i = t.styleSpec,\n          a = t.key,\n          o = t.arrayElementValidator || An;\n      if ("array" !== Dr(e)) return [new Pt(a, e, "array expected, " + Dr(e) + " found")];\n      if (r.length && e.length !== r.length) return [new Pt(a, e, "array length " + r.length + " expected, length " + e.length + " found")];\n      if (r["min-length"] && e.length < r["min-length"]) return [new Pt(a, e, "array length at least " + r["min-length"] + " expected, length " + e.length + " found")];\n      var s = {\n        type: r.value,\n        values: r.values\n      };\n      i.$version < 7 && (s.function = r.function), "object" === Dr(r.value) && (s = r.value);\n\n      for (var u = [], l = 0; l < e.length; l++) {\n        u = u.concat(o({\n          array: e,\n          arrayIndex: l,\n          value: e[l],\n          valueSpec: s,\n          style: n,\n          styleSpec: i,\n          key: a + "[" + l + "]"\n        }));\n      }\n\n      return u;\n    }\n\n    function Qr(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec,\n          i = Dr(r);\n      return "number" === i && r != r && (i = "NaN"), "number" !== i ? [new Pt(e, r, "number expected, " + i + " found")] : "minimum" in n && r < n.minimum ? [new Pt(e, r, r + " is less than the minimum value " + n.minimum)] : "maximum" in n && r > n.maximum ? [new Pt(e, r, r + " is greater than the maximum value " + n.maximum)] : [];\n    }\n\n    function tn(t) {\n      var e,\n          r,\n          n,\n          i = t.valueSpec,\n          a = Tt(t.value.type),\n          o = {},\n          s = "categorical" !== a && void 0 === t.value.property,\n          u = !s,\n          l = "array" === Dr(t.value.stops) && "array" === Dr(t.value.stops[0]) && "object" === Dr(t.value.stops[0][0]),\n          p = $r({\n        key: t.key,\n        value: t.value,\n        valueSpec: t.styleSpec.function,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          stops: function stops(t) {\n            if ("identity" === a) return [new Pt(t.key, t.value, \'identity function may not have a "stops" property\')];\n            var e = [],\n                r = t.value;\n            return e = e.concat(Wr({\n              key: t.key,\n              value: r,\n              valueSpec: t.valueSpec,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              arrayElementValidator: c\n            })), "array" === Dr(r) && 0 === r.length && e.push(new Pt(t.key, r, "array must have at least one stop")), e;\n          },\n          default: function _default(t) {\n            return An({\n              key: t.key,\n              value: t.value,\n              valueSpec: i,\n              style: t.style,\n              styleSpec: t.styleSpec\n            });\n          }\n        }\n      });\n      return "identity" === a && s && p.push(new Pt(t.key, t.value, \'missing required property "property"\')), "identity" === a || t.value.stops || p.push(new Pt(t.key, t.value, \'missing required property "stops"\')), "exponential" === a && t.valueSpec.expression && !Fr(t.valueSpec) && p.push(new Pt(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (u && !Tr(t.valueSpec) ? p.push(new Pt(t.key, t.value, "property functions not supported")) : s && !Vr(t.valueSpec) && p.push(new Pt(t.key, t.value, "zoom functions not supported"))), "categorical" !== a && !l || void 0 !== t.value.property || p.push(new Pt(t.key, t.value, \'"property" property is required\')), p;\n\n      function c(t) {\n        var e = [],\n            a = t.value,\n            s = t.key;\n        if ("array" !== Dr(a)) return [new Pt(s, a, "array expected, " + Dr(a) + " found")];\n        if (2 !== a.length) return [new Pt(s, a, "array length 2 expected, length " + a.length + " found")];\n\n        if (l) {\n          if ("object" !== Dr(a[0])) return [new Pt(s, a, "object expected, " + Dr(a[0]) + " found")];\n          if (void 0 === a[0].zoom) return [new Pt(s, a, "object stop key must have zoom")];\n          if (void 0 === a[0].value) return [new Pt(s, a, "object stop key must have value")];\n          if (n && n > Tt(a[0].zoom)) return [new Pt(s, a[0].zoom, "stop zoom values must appear in ascending order")];\n          Tt(a[0].zoom) !== n && (n = Tt(a[0].zoom), r = void 0, o = {}), e = e.concat($r({\n            key: s + "[0]",\n            value: a[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: Qr,\n              value: h\n            }\n          }));\n        } else e = e.concat(h({\n          key: s + "[0]",\n          value: a[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, a));\n\n        return Gr(Vt(a[1])) ? e.concat([new Pt(s + "[1]", a[1], "expressions are not allowed in function stops.")]) : e.concat(An({\n          key: s + "[1]",\n          value: a[1],\n          valueSpec: i,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n\n      function h(t, n) {\n        var s = Dr(t.value),\n            u = Tt(t.value),\n            l = null !== t.value ? t.value : n;\n\n        if (e) {\n          if (s !== e) return [new Pt(t.key, l, s + " stop domain type must match previous stop domain type " + e)];\n        } else e = s;\n\n        if ("number" !== s && "string" !== s && "boolean" !== s) return [new Pt(t.key, l, "stop domain value must be a number, string, or boolean")];\n\n        if ("number" !== s && "categorical" !== a) {\n          var p = "number expected, " + s + " found";\n          return Tr(i) && void 0 === a && (p += \'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\'), [new Pt(t.key, l, p)];\n        }\n\n        return "categorical" !== a || "number" !== s || isFinite(u) && Math.floor(u) === u ? "categorical" !== a && "number" === s && void 0 !== r && u < r ? [new Pt(t.key, l, "stop domain values must appear in ascending order")] : (r = u, "categorical" === a && u in o ? [new Pt(t.key, l, "stop domain values must be unique")] : (o[u] = !0, [])) : [new Pt(t.key, l, "integer expected, found " + u)];\n      }\n    }\n\n    function en(t) {\n      var e = ("property" === t.expressionContext ? Hr : Zr)(Vt(t.value), t.valueSpec);\n      if ("error" === e.result) return e.value.map(function (e) {\n        return new Pt("" + t.key + e.key, t.value, e.message);\n      });\n      var r = e.value.expression || e.value._styleExpression.expression;\n      if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new Pt(t.key, t.value, \'Invalid data expression for "\' + t.propertyKey + \'". Output values must be contained as literals within the expression.\')];\n      if ("property" === t.expressionContext && "layout" === t.propertyType && !Oe(r)) return [new Pt(t.key, t.value, \'"feature-state" data expressions are not supported with layout properties.\')];\n      if ("filter" === t.expressionContext && !Oe(r)) return [new Pt(t.key, t.value, \'"feature-state" data expressions are not supported with filters.\')];\n\n      if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {\n        if (!Re(r, ["zoom", "feature-state"])) return [new Pt(t.key, t.value, \'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];\n        if ("cluster-initial" === t.expressionContext && !Le(r)) return [new Pt(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];\n      }\n\n      return [];\n    }\n\n    function rn(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec,\n          i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(Tt(r)) && i.push(new Pt(e, r, "expected one of [" + n.values.join(", ") + "], " + JSON.stringify(r) + " found")) : -1 === Object.keys(n.values).indexOf(Tt(r)) && i.push(new Pt(e, r, "expected one of [" + Object.keys(n.values).join(", ") + "], " + JSON.stringify(r) + " found")), i;\n    }\n\n    function nn(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n\n      switch (t[0]) {\n        case "has":\n          return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];\n\n        case "in":\n          return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));\n\n        case "!in":\n        case "!has":\n        case "none":\n          return !1;\n\n        case "==":\n        case "!=":\n        case ">":\n        case ">=":\n        case "<":\n        case "<=":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n\n        case "any":\n        case "all":\n          for (var e = 0, r = t.slice(1); e < r.length; e += 1) {\n            var n = r[e];\n            if (!nn(n) && "boolean" != typeof n) return !1;\n          }\n\n          return !0;\n\n        default:\n          return !0;\n      }\n    }\n\n    Yr.deserialize = function (t) {\n      return new Yr(t._parameters, t._specification);\n    }, Yr.serialize = function (t) {\n      return {\n        _parameters: t._parameters,\n        _specification: t._specification\n      };\n    };\n    var an = {\n      type: "boolean",\n      default: !1,\n      transition: !1,\n      "property-type": "data-driven",\n      expression: {\n        interpolated: !1,\n        parameters: ["zoom", "feature"]\n      }\n    };\n\n    function on(t) {\n      if (null == t) return {\n        filter: function filter() {\n          return !0;\n        },\n        needGeometry: !1\n      };\n      nn(t) || (t = un(t));\n      var e = Zr(t, an);\n      if ("error" === e.result) throw new Error(e.value.map(function (t) {\n        return t.key + ": " + t.message;\n      }).join(", "));\n      return {\n        filter: function filter(t, r, n) {\n          return e.value.evaluate(t, r, {}, n);\n        },\n        needGeometry: function t(e) {\n          if (!Array.isArray(e)) return !1;\n          if ("within" === e[0]) return !0;\n\n          for (var r = 1; r < e.length; r++) {\n            if (t(e[r])) return !0;\n          }\n\n          return !1;\n        }(t)\n      };\n    }\n\n    function sn(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function un(t) {\n      if (!t) return !0;\n      var e,\n          r = t[0];\n      return t.length <= 1 ? "any" !== r : "==" === r ? ln(t[1], t[2], "==") : "!=" === r ? hn(ln(t[1], t[2], "==")) : "<" === r || ">" === r || "<=" === r || ">=" === r ? ln(t[1], t[2], r) : "any" === r ? (e = t.slice(1), ["any"].concat(e.map(un))) : "all" === r ? ["all"].concat(t.slice(1).map(un)) : "none" === r ? ["all"].concat(t.slice(1).map(un).map(hn)) : "in" === r ? pn(t[1], t.slice(2)) : "!in" === r ? hn(pn(t[1], t.slice(2))) : "has" === r ? cn(t[1]) : "!has" === r ? hn(cn(t[1])) : "within" !== r || t;\n    }\n\n    function ln(t, e, r) {\n      switch (t) {\n        case "$type":\n          return ["filter-type-" + r, e];\n\n        case "$id":\n          return ["filter-id-" + r, e];\n\n        default:\n          return ["filter-" + r, t, e];\n      }\n    }\n\n    function pn(t, e) {\n      if (0 === e.length) return !1;\n\n      switch (t) {\n        case "$type":\n          return ["filter-type-in", ["literal", e]];\n\n        case "$id":\n          return ["filter-id-in", ["literal", e]];\n\n        default:\n          return e.length > 200 && !e.some(function (t) {\n            return typeof t != typeof e[0];\n          }) ? ["filter-in-large", t, ["literal", e.sort(sn)]] : ["filter-in-small", t, ["literal", e]];\n      }\n    }\n\n    function cn(t) {\n      switch (t) {\n        case "$type":\n          return !0;\n\n        case "$id":\n          return ["filter-has-id"];\n\n        default:\n          return ["filter-has", t];\n      }\n    }\n\n    function hn(t) {\n      return ["!", t];\n    }\n\n    function fn(t) {\n      return nn(Vt(t.value)) ? en(Bt({}, t, {\n        expressionContext: "filter",\n        valueSpec: {\n          value: "boolean"\n        }\n      })) : function t(e) {\n        var r = e.value,\n            n = e.key;\n        if ("array" !== Dr(r)) return [new Pt(n, r, "array expected, " + Dr(r) + " found")];\n        var i,\n            a = e.styleSpec,\n            o = [];\n        if (r.length < 1) return [new Pt(n, r, "filter array must have at least 1 element")];\n\n        switch (o = o.concat(rn({\n          key: n + "[0]",\n          value: r[0],\n          valueSpec: a.filter_operator,\n          style: e.style,\n          styleSpec: e.styleSpec\n        })), Tt(r[0])) {\n          case "<":\n          case "<=":\n          case ">":\n          case ">=":\n            r.length >= 2 && "$type" === Tt(r[1]) && o.push(new Pt(n, r, \'"$type" cannot be use with operator "\' + r[0] + \'"\'));\n\n          case "==":\n          case "!=":\n            3 !== r.length && o.push(new Pt(n, r, \'filter array for operator "\' + r[0] + \'" must have 3 elements\'));\n\n          case "in":\n          case "!in":\n            r.length >= 2 && "string" !== (i = Dr(r[1])) && o.push(new Pt(n + "[1]", r[1], "string expected, " + i + " found"));\n\n            for (var s = 2; s < r.length; s++) {\n              i = Dr(r[s]), "$type" === Tt(r[1]) ? o = o.concat(rn({\n                key: n + "[" + s + "]",\n                value: r[s],\n                valueSpec: a.geometry_type,\n                style: e.style,\n                styleSpec: e.styleSpec\n              })) : "string" !== i && "number" !== i && "boolean" !== i && o.push(new Pt(n + "[" + s + "]", r[s], "string, number, or boolean expected, " + i + " found"));\n            }\n\n            break;\n\n          case "any":\n          case "all":\n          case "none":\n            for (var u = 1; u < r.length; u++) {\n              o = o.concat(t({\n                key: n + "[" + u + "]",\n                value: r[u],\n                style: e.style,\n                styleSpec: e.styleSpec\n              }));\n            }\n\n            break;\n\n          case "has":\n          case "!has":\n            i = Dr(r[1]), 2 !== r.length ? o.push(new Pt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "string" !== i && o.push(new Pt(n + "[1]", r[1], "string expected, " + i + " found"));\n            break;\n\n          case "within":\n            i = Dr(r[1]), 2 !== r.length ? o.push(new Pt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "object" !== i && o.push(new Pt(n + "[1]", r[1], "object expected, " + i + " found"));\n        }\n\n        return o;\n      }(t);\n    }\n\n    function yn(t, e) {\n      var r = t.key,\n          n = t.style,\n          i = t.styleSpec,\n          a = t.value,\n          o = t.objectKey,\n          s = i[e + "_" + t.layerType];\n      if (!s) return [];\n      var u = o.match(/^(.*)-transition$/);\n      if ("paint" === e && u && s[u[1]] && s[u[1]].transition) return An({\n        key: r,\n        value: a,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      var l,\n          p = t.valueSpec || s[o];\n      if (!p) return [new Pt(r, a, \'unknown property "\' + o + \'"\')];\n      if ("string" === Dr(a) && Tr(p) && !p.tokens && (l = /^{([^}]+)}$/.exec(a))) return [new Pt(r, a, \'"\' + o + \'" does not support interpolation syntax\\nUse an identity property function instead: `{ "type": "identity", "property": \' + JSON.stringify(l[1]) + " }`.")];\n      var c = [];\n      return "symbol" === t.layerType && ("text-field" === o && n && !n.glyphs && c.push(new Pt(r, a, \'use of "text-field" requires a style "glyphs" property\')), "text-font" === o && Lr(Vt(a)) && "identity" === Tt(a.type) && c.push(new Pt(r, a, \'"text-font" does not support identity functions\'))), c.concat(An({\n        key: t.key,\n        value: a,\n        valueSpec: p,\n        style: n,\n        styleSpec: i,\n        expressionContext: "property",\n        propertyType: e,\n        propertyKey: o\n      }));\n    }\n\n    function dn(t) {\n      return yn(t, "paint");\n    }\n\n    function mn(t) {\n      return yn(t, "layout");\n    }\n\n    function vn(t) {\n      var e = [],\n          r = t.value,\n          n = t.key,\n          i = t.style,\n          a = t.styleSpec;\n      r.type || r.ref || e.push(new Pt(n, r, \'either "type" or "ref" is required\'));\n      var o,\n          s = Tt(r.type),\n          u = Tt(r.ref);\n      if (r.id) for (var l = Tt(r.id), p = 0; p < t.arrayIndex; p++) {\n        var c = i.layers[p];\n        Tt(c.id) === l && e.push(new Pt(n, r.id, \'duplicate layer id "\' + r.id + \'", previously used at line \' + c.id.__line__));\n      }\n      if ("ref" in r) ["type", "source", "source-layer", "filter", "layout"].forEach(function (t) {\n        t in r && e.push(new Pt(n, r[t], \'"\' + t + \'" is prohibited for ref layers\'));\n      }), i.layers.forEach(function (t) {\n        Tt(t.id) === u && (o = t);\n      }), o ? o.ref ? e.push(new Pt(n, r.ref, "ref cannot reference another ref layer")) : s = Tt(o.type) : e.push(new Pt(n, r.ref, \'ref layer "\' + u + \'" not found\'));else if ("background" !== s) if (r.source) {\n        var h = i.sources && i.sources[r.source],\n            f = h && Tt(h.type);\n        h ? "vector" === f && "raster" === s ? e.push(new Pt(n, r.source, \'layer "\' + r.id + \'" requires a raster source\')) : "raster" === f && "raster" !== s ? e.push(new Pt(n, r.source, \'layer "\' + r.id + \'" requires a vector source\')) : "vector" !== f || r["source-layer"] ? "raster-dem" === f && "hillshade" !== s ? e.push(new Pt(n, r.source, "raster-dem source can only be used with layer type \'hillshade\'.")) : "line" !== s || !r.paint || !r.paint["line-gradient"] || "geojson" === f && h.lineMetrics || e.push(new Pt(n, r, \'layer "\' + r.id + \'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.\')) : e.push(new Pt(n, r, \'layer "\' + r.id + \'" must specify a "source-layer"\')) : e.push(new Pt(n, r.source, \'source "\' + r.source + \'" not found\'));\n      } else e.push(new Pt(n, r, \'missing required property "source"\'));\n      return e = e.concat($r({\n        key: n,\n        value: r,\n        valueSpec: a.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          "*": function _() {\n            return [];\n          },\n          type: function type() {\n            return An({\n              key: n + ".type",\n              value: r.type,\n              valueSpec: a.layer.type,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              object: r,\n              objectKey: "type"\n            });\n          },\n          filter: fn,\n          layout: function layout(t) {\n            return $r({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function _(t) {\n                  return mn(Bt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          },\n          paint: function paint(t) {\n            return $r({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function _(t) {\n                  return dn(Bt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          }\n        }\n      }));\n    }\n\n    function gn(t) {\n      var e = t.value,\n          r = t.key,\n          n = Dr(e);\n      return "string" !== n ? [new Pt(r, e, "string expected, " + n + " found")] : [];\n    }\n\n    var xn = {\n      promoteId: function promoteId(t) {\n        var e = t.key,\n            r = t.value;\n        if ("string" === Dr(r)) return gn({\n          key: e,\n          value: r\n        });\n        var n = [];\n\n        for (var i in r) {\n          n.push.apply(n, gn({\n            key: e + "." + i,\n            value: r[i]\n          }));\n        }\n\n        return n;\n      }\n    };\n\n    function bn(t) {\n      var e = t.value,\n          r = t.key,\n          n = t.styleSpec,\n          i = t.style;\n      if (!e.type) return [new Pt(r, e, \'"type" is required\')];\n      var a,\n          o = Tt(e.type);\n\n      switch (o) {\n        case "vector":\n        case "raster":\n        case "raster-dem":\n          return $r({\n            key: r,\n            value: e,\n            valueSpec: n["source_" + o.replace("-", "_")],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: xn\n          });\n\n        case "geojson":\n          if (a = $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: xn\n          }), e.cluster) for (var s in e.clusterProperties) {\n            var u = e.clusterProperties[s],\n                l = u[0],\n                p = "string" == typeof l ? [l, ["accumulated"], ["get", s]] : l;\n            a.push.apply(a, en({\n              key: r + "." + s + ".map",\n              value: u[1],\n              expressionContext: "cluster-map"\n            })), a.push.apply(a, en({\n              key: r + "." + s + ".reduce",\n              value: p,\n              expressionContext: "cluster-reduce"\n            }));\n          }\n          return a;\n\n        case "video":\n          return $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n\n        case "image":\n          return $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n\n        case "canvas":\n          return [new Pt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];\n\n        default:\n          return rn({\n            key: r + ".type",\n            value: e.type,\n            valueSpec: {\n              values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n\n    function wn(t) {\n      var e = t.value,\n          r = t.styleSpec,\n          n = r.light,\n          i = t.style,\n          a = [],\n          o = Dr(e);\n      if (void 0 === e) return a;\n      if ("object" !== o) return a.concat([new Pt("light", e, "object expected, " + o + " found")]);\n\n      for (var s in e) {\n        var u = s.match(/^(.*)-transition$/);\n        a = a.concat(u && n[u[1]] && n[u[1]].transition ? An({\n          key: s,\n          value: e[s],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[s] ? An({\n          key: s,\n          value: e[s],\n          valueSpec: n[s],\n          style: i,\n          styleSpec: r\n        }) : [new Pt(s, e[s], \'unknown property "\' + s + \'"\')]);\n      }\n\n      return a;\n    }\n\n    var _n = {\n      "*": function _() {\n        return [];\n      },\n      array: Wr,\n      boolean: function boolean(t) {\n        var e = t.value,\n            r = t.key,\n            n = Dr(e);\n        return "boolean" !== n ? [new Pt(r, e, "boolean expected, " + n + " found")] : [];\n      },\n      number: Qr,\n      color: function color(t) {\n        var e = t.key,\n            r = t.value,\n            n = Dr(r);\n        return "string" !== n ? [new Pt(e, r, "color expected, " + n + " found")] : null === Qt(r) ? [new Pt(e, r, \'color expected, "\' + r + \'" found\')] : [];\n      },\n      constants: Mt,\n      enum: rn,\n      filter: fn,\n      function: tn,\n      layer: vn,\n      object: $r,\n      source: bn,\n      light: wn,\n      string: gn,\n      formatted: function formatted(t) {\n        return 0 === gn(t).length ? [] : en(t);\n      },\n      resolvedImage: function resolvedImage(t) {\n        return 0 === gn(t).length ? [] : en(t);\n      }\n    };\n\n    function An(t) {\n      var e = t.value,\n          r = t.valueSpec,\n          n = t.styleSpec;\n      return r.expression && Lr(Tt(e)) ? tn(t) : r.expression && Gr(Vt(e)) ? en(t) : r.type && _n[r.type] ? _n[r.type](t) : $r(Bt({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n\n    function Sn(t) {\n      var e = t.value,\n          r = t.key,\n          n = gn(t);\n      return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Pt(r, e, \'"glyphs" url must include a "{fontstack}" token\')), -1 === e.indexOf("{range}") && n.push(new Pt(r, e, \'"glyphs" url must include a "{range}" token\'))), n;\n    }\n\n    function kn(t, e) {\n      void 0 === e && (e = Et);\n      var r = [];\n      return r = r.concat(An({\n        key: "",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: Sn,\n          "*": function _() {\n            return [];\n          }\n        }\n      })), t.constants && (r = r.concat(Mt({\n        key: "constants",\n        value: t.constants,\n        style: t,\n        styleSpec: e\n      }))), In(r);\n    }\n\n    function In(t) {\n      return [].concat(t).sort(function (t, e) {\n        return t.line - e.line;\n      });\n    }\n\n    function zn(t) {\n      return function () {\n        for (var e = [], r = arguments.length; r--;) {\n          e[r] = arguments[r];\n        }\n\n        return In(t.apply(this, e));\n      };\n    }\n\n    kn.source = zn(bn), kn.light = zn(wn), kn.layer = zn(vn), kn.filter = zn(fn), kn.paintProperty = zn(dn), kn.layoutProperty = zn(mn);\n    var Cn = kn,\n        En = Cn.light,\n        Pn = Cn.paintProperty,\n        Mn = Cn.layoutProperty;\n\n    function Bn(t, e) {\n      var r = !1;\n      if (e && e.length) for (var n = 0, i = e; n < i.length; n += 1) {\n        t.fire(new zt(new Error(i[n].message))), r = !0;\n      }\n      return r;\n    }\n\n    var Tn = Vn;\n\n    function Vn(t, e, r) {\n      var n = this.cells = [];\n\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n\n        for (var a = 0; a < this.d * this.d; a++) {\n          var o = i[3 + a],\n              s = i[3 + a + 1];\n          n.push(o === s ? null : i.subarray(o, s));\n        }\n\n        var u = i[3 + n.length + 1];\n        this.keys = i.subarray(i[3 + n.length], u), this.bboxes = i.subarray(u), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n\n        for (var l = 0; l < this.d * this.d; l++) {\n          n.push([]);\n        }\n\n        this.keys = [], this.bboxes = [];\n      }\n\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var p = r / e * t;\n      this.min = -p, this.max = t + p;\n    }\n\n    Vn.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, Vn.prototype._insertReadonly = function () {\n      throw "Cannot insert into a GridIndex created from an ArrayBuffer.";\n    }, Vn.prototype._insertCell = function (t, e, r, n, i, a) {\n      this.cells[i].push(a);\n    }, Vn.prototype.query = function (t, e, r, n, i) {\n      var a = this.min,\n          o = this.max;\n      if (t <= a && e <= a && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);\n      var s = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, s, {}, i), s;\n    }, Vn.prototype._queryCell = function (t, e, r, n, i, a, o, s) {\n      var u = this.cells[i];\n      if (null !== u) for (var l = this.keys, p = this.bboxes, c = 0; c < u.length; c++) {\n        var h = u[c];\n\n        if (void 0 === o[h]) {\n          var f = 4 * h;\n          (s ? s(p[f + 0], p[f + 1], p[f + 2], p[f + 3]) : t <= p[f + 2] && e <= p[f + 3] && r >= p[f + 0] && n >= p[f + 1]) ? (o[h] = !0, a.push(l[h])) : o[h] = !1;\n        }\n      }\n    }, Vn.prototype._forEachCell = function (t, e, r, n, i, a, o, s) {\n      for (var u = this._convertToCellCoord(t), l = this._convertToCellCoord(e), p = this._convertToCellCoord(r), c = this._convertToCellCoord(n), h = u; h <= p; h++) {\n        for (var f = l; f <= c; f++) {\n          var y = this.d * f + h;\n          if ((!s || s(this._convertFromCellCoord(h), this._convertFromCellCoord(f), this._convertFromCellCoord(h + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, y, a, o, s)) return;\n        }\n      }\n    }, Vn.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, Vn.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, Vn.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n\n      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) {\n        r += this.cells[n].length;\n      }\n\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n\n      for (var a = e, o = 0; o < t.length; o++) {\n        var s = t[o];\n        i[3 + o] = a, i.set(s, a), a += s.length;\n      }\n\n      return i[3 + t.length] = a, i.set(this.keys, a), i[3 + t.length + 1] = a += this.keys.length, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;\n    };\n    var Fn = o.ImageData,\n        Dn = o.ImageBitmap,\n        Ln = {};\n\n    function On(t, e, r) {\n      void 0 === r && (r = {}), Object.defineProperty(e, "_classRegistryKey", {\n        value: t,\n        writeable: !1\n      }), Ln[t] = {\n        klass: e,\n        omit: r.omit || [],\n        shallow: r.shallow || []\n      };\n    }\n\n    for (var Rn in On("Object", Object), Tn.serialize = function (t, e) {\n      var r = t.toArrayBuffer();\n      return e && e.push(r), {\n        buffer: r\n      };\n    }, Tn.deserialize = function (t) {\n      return new Tn(t.buffer);\n    }, On("Grid", Tn), On("Color", te), On("Error", Error), On("ResolvedImage", ie), On("StylePropertyFunction", Yr), On("StyleExpression", Kr, {\n      omit: ["_evaluator"]\n    }), On("ZoomDependentExpression", Jr), On("ZoomConstantExpression", Xr), On("CompoundExpression", xe, {\n      omit: ["_evaluate"]\n    }), Ir) {\n      Ir[Rn]._classRegistryKey || On("Expression_" + Rn, Ir[Rn]);\n    }\n\n    function Un(t) {\n      return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);\n    }\n\n    function jn(t) {\n      return Dn && t instanceof Dn;\n    }\n\n    function qn(t, e) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (Un(t) || jn(t)) return e && e.push(t), t;\n\n      if (ArrayBuffer.isView(t)) {\n        var r = t;\n        return e && e.push(r.buffer), r;\n      }\n\n      if (t instanceof Fn) return e && e.push(t.data.buffer), t;\n\n      if (Array.isArray(t)) {\n        for (var n = [], i = 0, a = t; i < a.length; i += 1) {\n          n.push(qn(a[i], e));\n        }\n\n        return n;\n      }\n\n      if ("object" == typeof t) {\n        var o = t.constructor,\n            s = o._classRegistryKey;\n        if (!s) throw new Error("can\'t serialize object of unregistered class");\n        var u = o.serialize ? o.serialize(t, e) : {};\n\n        if (!o.serialize) {\n          for (var l in t) {\n            if (t.hasOwnProperty(l) && !(Ln[s].omit.indexOf(l) >= 0)) {\n              var p = t[l];\n              u[l] = Ln[s].shallow.indexOf(l) >= 0 ? p : qn(p, e);\n            }\n          }\n\n          t instanceof Error && (u.message = t.message);\n        }\n\n        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");\n        return "Object" !== s && (u.$name = s), u;\n      }\n\n      throw new Error("can\'t serialize object of type " + typeof t);\n    }\n\n    function Nn(t) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Un(t) || jn(t) || ArrayBuffer.isView(t) || t instanceof Fn) return t;\n      if (Array.isArray(t)) return t.map(Nn);\n\n      if ("object" == typeof t) {\n        var e = t.$name || "Object",\n            r = Ln[e].klass;\n        if (!r) throw new Error("can\'t deserialize unregistered class " + e);\n        if (r.deserialize) return r.deserialize(t);\n\n        for (var n = Object.create(r.prototype), i = 0, a = Object.keys(t); i < a.length; i += 1) {\n          var o = a[i];\n\n          if ("$name" !== o) {\n            var s = t[o];\n            n[o] = Ln[e].shallow.indexOf(o) >= 0 ? s : Nn(s);\n          }\n        }\n\n        return n;\n      }\n\n      throw new Error("can\'t deserialize object of type " + typeof t);\n    }\n\n    var Kn = function Kn() {\n      this.first = !0;\n    };\n\n    Kn.prototype.update = function (t, e) {\n      var r = Math.floor(t);\n      return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n    };\n\n    var Gn = {\n      "Latin-1 Supplement": function Latin1Supplement(t) {\n        return t >= 128 && t <= 255;\n      },\n      Arabic: function Arabic(t) {\n        return t >= 1536 && t <= 1791;\n      },\n      "Arabic Supplement": function ArabicSupplement(t) {\n        return t >= 1872 && t <= 1919;\n      },\n      "Arabic Extended-A": function ArabicExtendedA(t) {\n        return t >= 2208 && t <= 2303;\n      },\n      "Hangul Jamo": function HangulJamo(t) {\n        return t >= 4352 && t <= 4607;\n      },\n      "Unified Canadian Aboriginal Syllabics": function UnifiedCanadianAboriginalSyllabics(t) {\n        return t >= 5120 && t <= 5759;\n      },\n      Khmer: function Khmer(t) {\n        return t >= 6016 && t <= 6143;\n      },\n      "Unified Canadian Aboriginal Syllabics Extended": function UnifiedCanadianAboriginalSyllabicsExtended(t) {\n        return t >= 6320 && t <= 6399;\n      },\n      "General Punctuation": function GeneralPunctuation(t) {\n        return t >= 8192 && t <= 8303;\n      },\n      "Letterlike Symbols": function LetterlikeSymbols(t) {\n        return t >= 8448 && t <= 8527;\n      },\n      "Number Forms": function NumberForms(t) {\n        return t >= 8528 && t <= 8591;\n      },\n      "Miscellaneous Technical": function MiscellaneousTechnical(t) {\n        return t >= 8960 && t <= 9215;\n      },\n      "Control Pictures": function ControlPictures(t) {\n        return t >= 9216 && t <= 9279;\n      },\n      "Optical Character Recognition": function OpticalCharacterRecognition(t) {\n        return t >= 9280 && t <= 9311;\n      },\n      "Enclosed Alphanumerics": function EnclosedAlphanumerics(t) {\n        return t >= 9312 && t <= 9471;\n      },\n      "Geometric Shapes": function GeometricShapes(t) {\n        return t >= 9632 && t <= 9727;\n      },\n      "Miscellaneous Symbols": function MiscellaneousSymbols(t) {\n        return t >= 9728 && t <= 9983;\n      },\n      "Miscellaneous Symbols and Arrows": function MiscellaneousSymbolsAndArrows(t) {\n        return t >= 11008 && t <= 11263;\n      },\n      "CJK Radicals Supplement": function CJKRadicalsSupplement(t) {\n        return t >= 11904 && t <= 12031;\n      },\n      "Kangxi Radicals": function KangxiRadicals(t) {\n        return t >= 12032 && t <= 12255;\n      },\n      "Ideographic Description Characters": function IdeographicDescriptionCharacters(t) {\n        return t >= 12272 && t <= 12287;\n      },\n      "CJK Symbols and Punctuation": function CJKSymbolsAndPunctuation(t) {\n        return t >= 12288 && t <= 12351;\n      },\n      Hiragana: function Hiragana(t) {\n        return t >= 12352 && t <= 12447;\n      },\n      Katakana: function Katakana(t) {\n        return t >= 12448 && t <= 12543;\n      },\n      Bopomofo: function Bopomofo(t) {\n        return t >= 12544 && t <= 12591;\n      },\n      "Hangul Compatibility Jamo": function HangulCompatibilityJamo(t) {\n        return t >= 12592 && t <= 12687;\n      },\n      Kanbun: function Kanbun(t) {\n        return t >= 12688 && t <= 12703;\n      },\n      "Bopomofo Extended": function BopomofoExtended(t) {\n        return t >= 12704 && t <= 12735;\n      },\n      "CJK Strokes": function CJKStrokes(t) {\n        return t >= 12736 && t <= 12783;\n      },\n      "Katakana Phonetic Extensions": function KatakanaPhoneticExtensions(t) {\n        return t >= 12784 && t <= 12799;\n      },\n      "Enclosed CJK Letters and Months": function EnclosedCJKLettersAndMonths(t) {\n        return t >= 12800 && t <= 13055;\n      },\n      "CJK Compatibility": function CJKCompatibility(t) {\n        return t >= 13056 && t <= 13311;\n      },\n      "CJK Unified Ideographs Extension A": function CJKUnifiedIdeographsExtensionA(t) {\n        return t >= 13312 && t <= 19903;\n      },\n      "Yijing Hexagram Symbols": function YijingHexagramSymbols(t) {\n        return t >= 19904 && t <= 19967;\n      },\n      "CJK Unified Ideographs": function CJKUnifiedIdeographs(t) {\n        return t >= 19968 && t <= 40959;\n      },\n      "Yi Syllables": function YiSyllables(t) {\n        return t >= 40960 && t <= 42127;\n      },\n      "Yi Radicals": function YiRadicals(t) {\n        return t >= 42128 && t <= 42191;\n      },\n      "Hangul Jamo Extended-A": function HangulJamoExtendedA(t) {\n        return t >= 43360 && t <= 43391;\n      },\n      "Hangul Syllables": function HangulSyllables(t) {\n        return t >= 44032 && t <= 55215;\n      },\n      "Hangul Jamo Extended-B": function HangulJamoExtendedB(t) {\n        return t >= 55216 && t <= 55295;\n      },\n      "Private Use Area": function PrivateUseArea(t) {\n        return t >= 57344 && t <= 63743;\n      },\n      "CJK Compatibility Ideographs": function CJKCompatibilityIdeographs(t) {\n        return t >= 63744 && t <= 64255;\n      },\n      "Arabic Presentation Forms-A": function ArabicPresentationFormsA(t) {\n        return t >= 64336 && t <= 65023;\n      },\n      "Vertical Forms": function VerticalForms(t) {\n        return t >= 65040 && t <= 65055;\n      },\n      "CJK Compatibility Forms": function CJKCompatibilityForms(t) {\n        return t >= 65072 && t <= 65103;\n      },\n      "Small Form Variants": function SmallFormVariants(t) {\n        return t >= 65104 && t <= 65135;\n      },\n      "Arabic Presentation Forms-B": function ArabicPresentationFormsB(t) {\n        return t >= 65136 && t <= 65279;\n      },\n      "Halfwidth and Fullwidth Forms": function HalfwidthAndFullwidthForms(t) {\n        return t >= 65280 && t <= 65519;\n      }\n    };\n\n    function Zn(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) {\n        if (Xn(r[e].charCodeAt(0))) return !0;\n      }\n\n      return !1;\n    }\n\n    function Xn(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(Gn["Bopomofo Extended"](t) || Gn.Bopomofo(t) || Gn["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Gn["CJK Compatibility Ideographs"](t) || Gn["CJK Compatibility"](t) || Gn["CJK Radicals Supplement"](t) || Gn["CJK Strokes"](t) || !(!Gn["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Gn["CJK Unified Ideographs Extension A"](t) || Gn["CJK Unified Ideographs"](t) || Gn["Enclosed CJK Letters and Months"](t) || Gn["Hangul Compatibility Jamo"](t) || Gn["Hangul Jamo Extended-A"](t) || Gn["Hangul Jamo Extended-B"](t) || Gn["Hangul Jamo"](t) || Gn["Hangul Syllables"](t) || Gn.Hiragana(t) || Gn["Ideographic Description Characters"](t) || Gn.Kanbun(t) || Gn["Kangxi Radicals"](t) || Gn["Katakana Phonetic Extensions"](t) || Gn.Katakana(t) && 12540 !== t || !(!Gn["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Gn["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Gn["Unified Canadian Aboriginal Syllabics"](t) || Gn["Unified Canadian Aboriginal Syllabics Extended"](t) || Gn["Vertical Forms"](t) || Gn["Yijing Hexagram Symbols"](t) || Gn["Yi Syllables"](t) || Gn["Yi Radicals"](t))));\n    }\n\n    function Jn(t) {\n      return !(Xn(t) || function (t) {\n        return !!(Gn["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Gn["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Gn["Letterlike Symbols"](t) || Gn["Number Forms"](t) || Gn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Gn["Control Pictures"](t) && 9251 !== t || Gn["Optical Character Recognition"](t) || Gn["Enclosed Alphanumerics"](t) || Gn["Geometric Shapes"](t) || Gn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Gn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Gn["CJK Symbols and Punctuation"](t) || Gn.Katakana(t) || Gn["Private Use Area"](t) || Gn["CJK Compatibility Forms"](t) || Gn["Small Form Variants"](t) || Gn["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n\n    function Hn(t) {\n      return t >= 1424 && t <= 2303 || Gn["Arabic Presentation Forms-A"](t) || Gn["Arabic Presentation Forms-B"](t);\n    }\n\n    function Yn(t, e) {\n      return !(!e && Hn(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Gn.Khmer(t));\n    }\n\n    function $n(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) {\n        if (Hn(r[e].charCodeAt(0))) return !0;\n      }\n\n      return !1;\n    }\n\n    var Wn = null,\n        Qn = "unavailable",\n        ti = null,\n        ei = function ei(t) {\n      t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Qn = "error"), Wn && Wn(t);\n    };\n\n    function ri() {\n      ni.fire(new It("pluginStateChange", {\n        pluginStatus: Qn,\n        pluginURL: ti\n      }));\n    }\n\n    var ni = new Ct(),\n        ii = function ii() {\n      return Qn;\n    },\n        ai = function ai() {\n      if ("deferred" !== Qn || !ti) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");\n      Qn = "loading", ri(), ti && bt({\n        url: ti\n      }, function (t) {\n        t ? ei(t) : (Qn = "loaded", ri());\n      });\n    },\n        oi = {\n      applyArabicShaping: null,\n      processBidirectionalText: null,\n      processStyledBidirectionalText: null,\n      isLoaded: function isLoaded() {\n        return "loaded" === Qn || null != oi.applyArabicShaping;\n      },\n      isLoading: function isLoading() {\n        return "loading" === Qn;\n      },\n      setState: function setState(t) {\n        Qn = t.pluginStatus, ti = t.pluginURL;\n      },\n      isParsed: function isParsed() {\n        return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;\n      },\n      getPluginURL: function getPluginURL() {\n        return ti;\n      }\n    },\n        si = function si(t, e) {\n      this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Kn(), this.transition = {});\n    };\n\n    si.prototype.isSupportedScript = function (t) {\n      return function (t, e) {\n        for (var r = 0, n = t; r < n.length; r += 1) {\n          if (!Yn(n[r].charCodeAt(0), e)) return !1;\n        }\n\n        return !0;\n      }(t, oi.isLoaded());\n    }, si.prototype.crossFadingFactor = function () {\n      return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n    }, si.prototype.getCrossfadeParameters = function () {\n      var t = this.zoom,\n          e = t - Math.floor(t),\n          r = this.crossFadingFactor();\n      return t > this.zoomHistory.lastIntegerZoom ? {\n        fromScale: 2,\n        toScale: 1,\n        t: e + (1 - e) * r\n      } : {\n        fromScale: .5,\n        toScale: 1,\n        t: 1 - (1 - r) * e\n      };\n    };\n\n    var ui = function ui(t, e) {\n      this.property = t, this.value = e, this.expression = function (t, e) {\n        if (Lr(t)) return new Yr(t, e);\n\n        if (Gr(t)) {\n          var r = Hr(t, e);\n          if ("error" === r.result) throw new Error(r.value.map(function (t) {\n            return t.key + ": " + t.message;\n          }).join(", "));\n          return r.value;\n        }\n\n        var n = t;\n        return "string" == typeof t && "color" === e.type && (n = te.parse(t)), {\n          kind: "constant",\n          evaluate: function evaluate() {\n            return n;\n          }\n        };\n      }(void 0 === e ? t.specification.default : e, t.specification);\n    };\n\n    ui.prototype.isDataDriven = function () {\n      return "source" === this.expression.kind || "composite" === this.expression.kind;\n    }, ui.prototype.possiblyEvaluate = function (t, e, r) {\n      return this.property.possiblyEvaluate(this, t, e, r);\n    };\n\n    var li = function li(t) {\n      this.property = t, this.value = new ui(t, void 0);\n    };\n\n    li.prototype.transitioned = function (t, e) {\n      return new ci(this.property, this.value, e, h({}, t.transition, this.transition), t.now);\n    }, li.prototype.untransitioned = function () {\n      return new ci(this.property, this.value, null, {}, 0);\n    };\n\n    var pi = function pi(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n    };\n\n    pi.prototype.getValue = function (t) {\n      return w(this._values[t].value.value);\n    }, pi.prototype.setValue = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new li(this._values[t].property)), this._values[t].value = new ui(this._values[t].property, null === e ? void 0 : w(e));\n    }, pi.prototype.getTransition = function (t) {\n      return w(this._values[t].transition);\n    }, pi.prototype.setTransition = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new li(this._values[t].property)), this._values[t].transition = w(e) || void 0;\n    }, pi.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n            i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n        var a = this.getTransition(n);\n        void 0 !== a && (t[n + "-transition"] = a);\n      }\n\n      return t;\n    }, pi.prototype.transitioned = function (t, e) {\n      for (var r = new hi(this._properties), n = 0, i = Object.keys(this._values); n < i.length; n += 1) {\n        var a = i[n];\n        r._values[a] = this._values[a].transitioned(t, e._values[a]);\n      }\n\n      return r;\n    }, pi.prototype.untransitioned = function () {\n      for (var t = new hi(this._properties), e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e];\n        t._values[n] = this._values[n].untransitioned();\n      }\n\n      return t;\n    };\n\n    var ci = function ci(t, e, r, n, i) {\n      this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n    };\n\n    ci.prototype.possiblyEvaluate = function (t, e, r) {\n      var n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          a = this.prior;\n\n      if (a) {\n        if (n > this.end) return this.prior = null, i;\n        if (this.value.isDataDriven()) return this.prior = null, i;\n        if (n < this.begin) return a.possiblyEvaluate(t, e, r);\n        var o = (n - this.begin) / (this.end - this.begin);\n        return this.property.interpolate(a.possiblyEvaluate(t, e, r), i, function (t) {\n          if (t <= 0) return 0;\n          if (t >= 1) return 1;\n          var e = t * t,\n              r = e * t;\n          return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n        }(o));\n      }\n\n      return i;\n    };\n\n    var hi = function hi(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n    };\n\n    hi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new di(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n\n      return n;\n    }, hi.prototype.hasTransition = function () {\n      for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1) {\n        if (this._values[e[t]].prior) return !0;\n      }\n\n      return !1;\n    };\n\n    var fi = function fi(t) {\n      this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n    };\n\n    fi.prototype.getValue = function (t) {\n      return w(this._values[t].value);\n    }, fi.prototype.setValue = function (t, e) {\n      this._values[t] = new ui(this._values[t].property, null === e ? void 0 : w(e));\n    }, fi.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n            i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n      }\n\n      return t;\n    }, fi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new di(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n\n      return n;\n    };\n\n    var yi = function yi(t, e, r) {\n      this.property = t, this.value = e, this.parameters = r;\n    };\n\n    yi.prototype.isConstant = function () {\n      return "constant" === this.value.kind;\n    }, yi.prototype.constantOr = function (t) {\n      return "constant" === this.value.kind ? this.value.value : t;\n    }, yi.prototype.evaluate = function (t, e, r, n) {\n      return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n    };\n\n    var di = function di(t) {\n      this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n    };\n\n    di.prototype.get = function (t) {\n      return this._values[t];\n    };\n\n    var mi = function mi(t) {\n      this.specification = t;\n    };\n\n    mi.prototype.possiblyEvaluate = function (t, e) {\n      return t.expression.evaluate(e);\n    }, mi.prototype.interpolate = function (t, e, r) {\n      var n = Ge[this.specification.type];\n      return n ? n(t, e, r) : t;\n    };\n\n    var vi = function vi(t, e) {\n      this.specification = t, this.overrides = e;\n    };\n\n    vi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return new yi(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {\n        kind: "constant",\n        value: t.expression.evaluate(e, null, {}, r, n)\n      } : t.expression, e);\n    }, vi.prototype.interpolate = function (t, e, r) {\n      if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;\n      if (void 0 === t.value.value || void 0 === e.value.value) return new yi(this, {\n        kind: "constant",\n        value: void 0\n      }, t.parameters);\n      var n = Ge[this.specification.type];\n      return n ? new yi(this, {\n        kind: "constant",\n        value: n(t.value.value, e.value.value, r)\n      }, t.parameters) : t;\n    }, vi.prototype.evaluate = function (t, e, r, n, i, a) {\n      return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, a);\n    };\n\n    var gi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (t, e, r, n) {\n        if (void 0 === t.value) return new yi(this, {\n          kind: "constant",\n          value: void 0\n        }, e);\n\n        if ("constant" === t.expression.kind) {\n          var i = t.expression.evaluate(e, null, {}, r, n),\n              a = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i,\n              o = this._calculate(a, a, a, e);\n\n          return new yi(this, {\n            kind: "constant",\n            value: o\n          }, e);\n        }\n\n        if ("camera" === t.expression.kind) {\n          var s = this._calculate(t.expression.evaluate({\n            zoom: e.zoom - 1\n          }), t.expression.evaluate({\n            zoom: e.zoom\n          }), t.expression.evaluate({\n            zoom: e.zoom + 1\n          }), e);\n\n          return new yi(this, {\n            kind: "constant",\n            value: s\n          }, e);\n        }\n\n        return new yi(this, t.expression, e);\n      }, e.prototype.evaluate = function (t, e, r, n, i, a) {\n        if ("source" === t.kind) {\n          var o = t.evaluate(e, r, n, i, a);\n          return this._calculate(o, o, o, e);\n        }\n\n        return "composite" === t.kind ? this._calculate(t.evaluate({\n          zoom: Math.floor(e.zoom) - 1\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom)\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom) + 1\n        }, r, n), e) : t.value;\n      }, e.prototype._calculate = function (t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e\n        } : {\n          from: r,\n          to: e\n        };\n      }, e.prototype.interpolate = function (t) {\n        return t;\n      }, e;\n    }(vi),\n        xi = function xi(t) {\n      this.specification = t;\n    };\n\n    xi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      if (void 0 !== t.value) {\n        if ("constant" === t.expression.kind) {\n          var i = t.expression.evaluate(e, null, {}, r, n);\n          return this._calculate(i, i, i, e);\n        }\n\n        return this._calculate(t.expression.evaluate(new si(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new si(Math.floor(e.zoom), e)), t.expression.evaluate(new si(Math.floor(e.zoom + 1), e)), e);\n      }\n    }, xi.prototype._calculate = function (t, e, r, n) {\n      return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n        from: t,\n        to: e\n      } : {\n        from: r,\n        to: e\n      };\n    }, xi.prototype.interpolate = function (t) {\n      return t;\n    };\n\n    var bi = function bi(t) {\n      this.specification = t;\n    };\n\n    bi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return !!t.expression.evaluate(e, null, {}, r, n);\n    }, bi.prototype.interpolate = function () {\n      return !1;\n    };\n\n    var wi = function wi(t) {\n      for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t) {\n        var r = t[e];\n        r.specification.overridable && this.overridableProperties.push(e);\n        var n = this.defaultPropertyValues[e] = new ui(r, void 0),\n            i = this.defaultTransitionablePropertyValues[e] = new li(r);\n        this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n      }\n    };\n\n    On("DataDrivenProperty", vi), On("DataConstantProperty", mi), On("CrossFadedDataDrivenProperty", gi), On("CrossFadedProperty", xi), On("ColorRampProperty", bi);\n\n    var _i = function (t) {\n      function e(e, r) {\n        if (t.call(this), this.id = e.id, this.type = e.type, this._featureFilter = {\n          filter: function filter() {\n            return !0;\n          },\n          needGeometry: !1\n        }, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), r.layout && (this._unevaluatedLayout = new fi(r.layout)), r.paint)) {\n          for (var n in this._transitionablePaint = new pi(r.paint), e.paint) {\n            this.setPaintProperty(n, e.paint[n], {\n              validate: !1\n            });\n          }\n\n          for (var i in e.layout) {\n            this.setLayoutProperty(i, e.layout[i], {\n              validate: !1\n            });\n          }\n\n          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new di(r.paint);\n        }\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getCrossfadeParameters = function () {\n        return this._crossfadeParameters;\n      }, e.prototype.getLayoutProperty = function (t) {\n        return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }, e.prototype.setLayoutProperty = function (t, e, r) {\n        void 0 === r && (r = {}), null != e && this._validate(Mn, "layers." + this.id + ".layout." + t, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n      }, e.prototype.getPaintProperty = function (t) {\n        return g(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t);\n      }, e.prototype.setPaintProperty = function (t, e, r) {\n        if (void 0 === r && (r = {}), null != e && this._validate(Pn, "layers." + this.id + ".paint." + t, t, e, r)) return !1;\n        if (g(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1;\n        var n = this._transitionablePaint._values[t],\n            i = "cross-faded-data-driven" === n.property.specification["property-type"],\n            a = n.value.isDataDriven(),\n            o = n.value;\n        this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n        var s = this._transitionablePaint._values[t].value;\n        return s.isDataDriven() || a || i || this._handleOverridablePaintPropertyUpdate(t, o, s);\n      }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {}, e.prototype._handleOverridablePaintPropertyUpdate = function (t, e, r) {\n        return !1;\n      }, e.prototype.isHidden = function (t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;\n      }, e.prototype.updateTransitions = function (t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }, e.prototype.hasTransition = function () {\n        return this._transitioningPaint.hasTransition();\n      }, e.prototype.recalculate = function (t, e) {\n        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }, e.prototype.serialize = function () {\n        var t = {\n          id: this.id,\n          type: this.type,\n          source: this.source,\n          "source-layer": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), b(t, function (t, e) {\n          return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length);\n        });\n      }, e.prototype._validate = function (t, e, r, n, i) {\n        return void 0 === i && (i = {}), (!i || !1 !== i.validate) && Bn(this, t.call(Cn, {\n          key: e,\n          layerType: this.type,\n          objectKey: r,\n          value: n,\n          styleSpec: Et,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          }\n        }));\n      }, e.prototype.is3D = function () {\n        return !1;\n      }, e.prototype.isTileClipped = function () {\n        return !1;\n      }, e.prototype.hasOffscreenPass = function () {\n        return !1;\n      }, e.prototype.resize = function () {}, e.prototype.isStateDependent = function () {\n        for (var t in this.paint._values) {\n          var e = this.paint.get(t);\n          if (e instanceof yi && Tr(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n\n        return !1;\n      }, e;\n    }(Ct),\n        Ai = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    },\n        Si = function Si(t, e) {\n      this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n    },\n        ki = function ki() {\n      this.isTransferred = !1, this.capacity = -1, this.resize(0);\n    };\n\n    function Ii(t, e) {\n      void 0 === e && (e = 1);\n      var r = 0,\n          n = 0;\n      return {\n        members: t.map(function (t) {\n          var i = Ai[t.type].BYTES_PER_ELEMENT,\n              a = r = zi(r, Math.max(e, i)),\n              o = t.components || 1;\n          return n = Math.max(n, i), r += i * o, {\n            name: t.name,\n            type: t.type,\n            components: o,\n            offset: a\n          };\n        }),\n        size: zi(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n\n    function zi(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n\n    ki.serialize = function (t, e) {\n      return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n        length: t.length,\n        arrayBuffer: t.arrayBuffer\n      };\n    }, ki.deserialize = function (t) {\n      var e = Object.create(this.prototype);\n      return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n    }, ki.prototype._trim = function () {\n      this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n    }, ki.prototype.clear = function () {\n      this.length = 0;\n    }, ki.prototype.resize = function (t) {\n      this.reserve(t), this.length = t;\n    }, ki.prototype.reserve = function (t) {\n      if (t > this.capacity) {\n        this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n        var e = this.uint8;\n        this._refreshViews(), e && this.uint8.set(e);\n      }\n    }, ki.prototype._refreshViews = function () {\n      throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");\n    };\n\n    var Ci = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }, e;\n    }(ki);\n\n    Ci.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ci);\n\n    var Ei = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t;\n      }, e;\n    }(ki);\n\n    Ei.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Ei);\n\n    var Pi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(ki);\n\n    Pi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Pi);\n\n    var Mi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 4 * t,\n            u = 8 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = a, this.uint8[u + 7] = o, t;\n      }, e;\n    }(ki);\n\n    Mi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Mi);\n\n    var Bi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }, e;\n    }(ki);\n\n    Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Bi);\n\n    var Ti = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, a, o, s, u, l);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p) {\n        var c = 10 * t;\n        return this.uint16[c + 0] = e, this.uint16[c + 1] = r, this.uint16[c + 2] = n, this.uint16[c + 3] = i, this.uint16[c + 4] = a, this.uint16[c + 5] = o, this.uint16[c + 6] = s, this.uint16[c + 7] = u, this.uint16[c + 8] = l, this.uint16[c + 9] = p, t;\n      }, e;\n    }(ki);\n\n    Ti.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Ti);\n\n    var Vi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        var h = this.length;\n        return this.resize(h + 1), this.emplace(h, t, e, r, n, i, a, o, s, u, l, p, c);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h) {\n        var f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = o, this.uint16[f + 6] = s, this.uint16[f + 7] = u, this.int16[f + 8] = l, this.int16[f + 9] = p, this.int16[f + 10] = c, this.int16[f + 11] = h, t;\n      }, e;\n    }(ki);\n\n    Vi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Vi);\n\n    var Fi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }, e;\n    }(ki);\n\n    Fi.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Fi);\n\n    var Di = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }, e;\n    }(ki);\n\n    Di.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Di);\n\n    var Li = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u) {\n        var l = this.length;\n        return this.resize(l + 1), this.emplace(l, t, e, r, n, i, a, o, s, u);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = 10 * t,\n            c = 5 * t;\n        return this.int16[p + 0] = e, this.int16[p + 1] = r, this.int16[p + 2] = n, this.int16[p + 3] = i, this.int16[p + 4] = a, this.int16[p + 5] = o, this.uint32[c + 3] = s, this.uint16[p + 8] = u, this.uint16[p + 9] = l, t;\n      }, e;\n    }(ki);\n\n    Li.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Li);\n\n    var Oi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(ki);\n\n    Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);\n\n    var Ri = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i) {\n        var a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }, e.prototype.emplace = function (t, e, r, n, i, a) {\n        var o = 4 * t,\n            s = 8 * t;\n        return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[s + 6] = i, this.int16[s + 7] = a, t;\n      }, e;\n    }(ki);\n\n    Ri.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ri);\n\n    var Ui = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 12 * t,\n            o = 3 * t;\n        return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[o + 1] = n, this.float32[o + 2] = i, t;\n      }, e;\n    }(ki);\n\n    Ui.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ui);\n\n    var ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }, e;\n    }(ki);\n\n    ji.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", ji);\n\n    var qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m) {\n        var v = this.length;\n        return this.resize(v + 1), this.emplace(v, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v) {\n        var g = 24 * t,\n            x = 12 * t,\n            b = 48 * t;\n        return this.int16[g + 0] = e, this.int16[g + 1] = r, this.uint16[g + 2] = n, this.uint16[g + 3] = i, this.uint32[x + 2] = a, this.uint32[x + 3] = o, this.uint32[x + 4] = s, this.uint16[g + 10] = u, this.uint16[g + 11] = l, this.uint16[g + 12] = p, this.float32[x + 7] = c, this.float32[x + 8] = h, this.uint8[b + 36] = f, this.uint8[b + 37] = y, this.uint8[b + 38] = d, this.uint32[x + 10] = m, this.int16[g + 22] = v, t;\n      }, e;\n    }(ki);\n\n    qi.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", qi);\n\n    var Ni = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z) {\n        var C = this.length;\n        return this.resize(C + 1), this.emplace(C, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z, C) {\n        var E = 34 * t,\n            P = 17 * t;\n        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.int16[E + 3] = i, this.int16[E + 4] = a, this.int16[E + 5] = o, this.int16[E + 6] = s, this.int16[E + 7] = u, this.uint16[E + 8] = l, this.uint16[E + 9] = p, this.uint16[E + 10] = c, this.uint16[E + 11] = h, this.uint16[E + 12] = f, this.uint16[E + 13] = y, this.uint16[E + 14] = d, this.uint16[E + 15] = m, this.uint16[E + 16] = v, this.uint16[E + 17] = g, this.uint16[E + 18] = x, this.uint16[E + 19] = b, this.uint16[E + 20] = w, this.uint16[E + 21] = _, this.uint16[E + 22] = A, this.uint32[P + 12] = S, this.float32[P + 13] = k, this.float32[P + 14] = I, this.float32[P + 15] = z, this.float32[P + 16] = C, t;\n      }, e;\n    }(ki);\n\n    Ni.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ni);\n\n    var Ki = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }, e;\n    }(ki);\n\n    Ki.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Ki);\n\n    var Gi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }, e;\n    }(ki);\n\n    Gi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Gi);\n\n    var Zi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 4 * t;\n        return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t;\n      }, e;\n    }(ki);\n\n    Zi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Zi);\n\n    var Xi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }, e;\n    }(ki);\n\n    Xi.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Xi);\n\n    var Ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }, e;\n    }(ki);\n\n    Ji.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Ji);\n\n    var Hi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t;\n      }, e;\n    }(ki);\n\n    Hi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Hi);\n\n    var Yi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorPointX: {\n          configurable: !0\n        },\n        anchorPointY: {\n          configurable: !0\n        },\n        x1: {\n          configurable: !0\n        },\n        y1: {\n          configurable: !0\n        },\n        x2: {\n          configurable: !0\n        },\n        y2: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        },\n        anchorPoint: {\n          configurable: !0\n        }\n      };\n      return r.anchorPointX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorPointY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.x1.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.y1.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.x2.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.y2.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.anchorPoint.get = function () {\n        return new i(this.anchorPointX, this.anchorPointY);\n      }, Object.defineProperties(e.prototype, r), e;\n    }(Si);\n\n    Yi.prototype.size = 20;\n\n    var $i = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new Yi(this, t);\n      }, e;\n    }(Li);\n\n    On("CollisionBoxArray", $i);\n\n    var Wi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        glyphStartIndex: {\n          configurable: !0\n        },\n        numGlyphs: {\n          configurable: !0\n        },\n        vertexStartIndex: {\n          configurable: !0\n        },\n        lineStartIndex: {\n          configurable: !0\n        },\n        lineLength: {\n          configurable: !0\n        },\n        segment: {\n          configurable: !0\n        },\n        lowerSize: {\n          configurable: !0\n        },\n        upperSize: {\n          configurable: !0\n        },\n        lineOffsetX: {\n          configurable: !0\n        },\n        lineOffsetY: {\n          configurable: !0\n        },\n        writingMode: {\n          configurable: !0\n        },\n        placedOrientation: {\n          configurable: !0\n        },\n        hidden: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        associatedIconIndex: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.glyphStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.numGlyphs.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, r.vertexStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 2];\n      }, r.lineStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.lineLength.get = function () {\n        return this._structArray.uint32[this._pos4 + 4];\n      }, r.segment.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.lowerSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.upperSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.lineOffsetX.get = function () {\n        return this._structArray.float32[this._pos4 + 7];\n      }, r.lineOffsetY.get = function () {\n        return this._structArray.float32[this._pos4 + 8];\n      }, r.writingMode.get = function () {\n        return this._structArray.uint8[this._pos1 + 36];\n      }, r.placedOrientation.get = function () {\n        return this._structArray.uint8[this._pos1 + 37];\n      }, r.placedOrientation.set = function (t) {\n        this._structArray.uint8[this._pos1 + 37] = t;\n      }, r.hidden.get = function () {\n        return this._structArray.uint8[this._pos1 + 38];\n      }, r.hidden.set = function (t) {\n        this._structArray.uint8[this._pos1 + 38] = t;\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 10];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 10] = t;\n      }, r.associatedIconIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 22];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(Si);\n\n    Wi.prototype.size = 48;\n\n    var Qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new Wi(this, t);\n      }, e;\n    }(qi);\n\n    On("PlacedSymbolArray", Qi);\n\n    var ta = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        rightJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        centerJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        leftJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedTextSymbolIndex: {\n          configurable: !0\n        },\n        placedIconSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedIconSymbolIndex: {\n          configurable: !0\n        },\n        key: {\n          configurable: !0\n        },\n        textBoxStartIndex: {\n          configurable: !0\n        },\n        textBoxEndIndex: {\n          configurable: !0\n        },\n        verticalTextBoxStartIndex: {\n          configurable: !0\n        },\n        verticalTextBoxEndIndex: {\n          configurable: !0\n        },\n        iconBoxStartIndex: {\n          configurable: !0\n        },\n        iconBoxEndIndex: {\n          configurable: !0\n        },\n        verticalIconBoxStartIndex: {\n          configurable: !0\n        },\n        verticalIconBoxEndIndex: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        numHorizontalGlyphVertices: {\n          configurable: !0\n        },\n        numVerticalGlyphVertices: {\n          configurable: !0\n        },\n        numIconVertices: {\n          configurable: !0\n        },\n        numVerticalIconVertices: {\n          configurable: !0\n        },\n        useRuntimeCollisionCircles: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        textBoxScale: {\n          configurable: !0\n        },\n        textOffset0: {\n          configurable: !0\n        },\n        textOffset1: {\n          configurable: !0\n        },\n        collisionCircleDiameter: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.rightJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.centerJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.leftJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.verticalPlacedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.placedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 6];\n      }, r.verticalPlacedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 7];\n      }, r.key.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.textBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.textBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.verticalTextBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.verticalTextBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.iconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 13];\n      }, r.iconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 14];\n      }, r.verticalIconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 15];\n      }, r.verticalIconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 16];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 17];\n      }, r.numHorizontalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 18];\n      }, r.numVerticalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 19];\n      }, r.numIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 20];\n      }, r.numVerticalIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 21];\n      }, r.useRuntimeCollisionCircles.get = function () {\n        return this._structArray.uint16[this._pos2 + 22];\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 12];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 12] = t;\n      }, r.textBoxScale.get = function () {\n        return this._structArray.float32[this._pos4 + 13];\n      }, r.textOffset0.get = function () {\n        return this._structArray.float32[this._pos4 + 14];\n      }, r.textOffset1.get = function () {\n        return this._structArray.float32[this._pos4 + 15];\n      }, r.collisionCircleDiameter.get = function () {\n        return this._structArray.float32[this._pos4 + 16];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(Si);\n\n    ta.prototype.size = 68;\n\n    var ea = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new ta(this, t);\n      }, e;\n    }(Ni);\n\n    On("SymbolInstanceArray", ea);\n\n    var ra = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getoffsetX = function (t) {\n        return this.float32[1 * t + 0];\n      }, e;\n    }(Ki);\n\n    On("GlyphOffsetArray", ra);\n\n    var na = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getx = function (t) {\n        return this.int16[3 * t + 0];\n      }, e.prototype.gety = function (t) {\n        return this.int16[3 * t + 1];\n      }, e.prototype.gettileUnitDistanceFromAnchor = function (t) {\n        return this.int16[3 * t + 2];\n      }, e;\n    }(Gi);\n\n    On("SymbolLineVertexArray", na);\n\n    var ia = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        }\n      };\n      return r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 0];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(Si);\n\n    ia.prototype.size = 8;\n\n    var aa = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new ia(this, t);\n      }, e;\n    }(Zi);\n\n    On("FeatureIndexArray", aa);\n\n    var oa = Ii([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }], 4).members,\n        sa = function sa(t) {\n      void 0 === t && (t = []), this.segments = t;\n    };\n\n    function ua(t, e) {\n      return 256 * (t = p(Math.floor(t), 0, 255)) + p(Math.floor(e), 0, 255);\n    }\n\n    sa.prototype.prepareSegment = function (t, e, r, n) {\n      var i = this.segments[this.segments.length - 1];\n      return t > sa.MAX_VERTEX_ARRAY_LENGTH && A("Max vertices per segment is " + sa.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!i || i.vertexLength + t > sa.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n        vertexOffset: e.length,\n        primitiveOffset: r.length,\n        vertexLength: 0,\n        primitiveLength: 0\n      }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n    }, sa.prototype.get = function () {\n      return this.segments;\n    }, sa.prototype.destroy = function () {\n      for (var t = 0, e = this.segments; t < e.length; t += 1) {\n        var r = e[t];\n\n        for (var n in r.vaos) {\n          r.vaos[n].destroy();\n        }\n      }\n    }, sa.simpleSegment = function (t, e, r, n) {\n      return new sa([{\n        vertexOffset: t,\n        primitiveOffset: e,\n        vertexLength: r,\n        primitiveLength: n,\n        vaos: {},\n        sortKey: 0\n      }]);\n    }, sa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", sa);\n    var la = Ii([{\n      name: "a_pattern_from",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pattern_to",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pixel_ratio_from",\n      components: 1,\n      type: "Uint16"\n    }, {\n      name: "a_pixel_ratio_to",\n      components: 1,\n      type: "Uint16"\n    }]),\n        pa = e(function (t) {\n      t.exports = function (t, e) {\n        var r, n, i, a, o, s, u, l;\n\n        for (n = t.length - (r = 3 & t.length), i = e, o = 3432918353, s = 461845907, l = 0; l < n;) {\n          u = 255 & t.charCodeAt(l) | (255 & t.charCodeAt(++l)) << 8 | (255 & t.charCodeAt(++l)) << 16 | (255 & t.charCodeAt(++l)) << 24, ++l, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= u = (65535 & (u = (u = (65535 & u) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);\n        }\n\n        switch (u = 0, r) {\n          case 3:\n            u ^= (255 & t.charCodeAt(l + 2)) << 16;\n\n          case 2:\n            u ^= (255 & t.charCodeAt(l + 1)) << 8;\n\n          case 1:\n            i ^= u = (65535 & (u = (u = (65535 & (u ^= 255 & t.charCodeAt(l))) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295;\n        }\n\n        return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n      };\n    }),\n        ca = e(function (t) {\n      t.exports = function (t, e) {\n        for (var r, n = t.length, i = e ^ n, a = 0; n >= 4;) {\n          r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;\n        }\n\n        switch (n) {\n          case 3:\n            i ^= (255 & t.charCodeAt(a + 2)) << 16;\n\n          case 2:\n            i ^= (255 & t.charCodeAt(a + 1)) << 8;\n\n          case 1:\n            i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n        }\n\n        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n      };\n    }),\n        ha = pa,\n        fa = ca;\n    ha.murmur3 = pa, ha.murmur2 = fa;\n\n    var ya = function ya() {\n      this.ids = [], this.positions = [], this.indexed = !1;\n    };\n\n    ya.prototype.add = function (t, e, r, n) {\n      this.ids.push(ma(t)), this.positions.push(e, r, n);\n    }, ya.prototype.getPositions = function (t) {\n      for (var e = ma(t), r = 0, n = this.ids.length - 1; r < n;) {\n        var i = r + n >> 1;\n        this.ids[i] >= e ? n = i : r = i + 1;\n      }\n\n      for (var a = []; this.ids[r] === e;) {\n        a.push({\n          index: this.positions[3 * r],\n          start: this.positions[3 * r + 1],\n          end: this.positions[3 * r + 2]\n        }), r++;\n      }\n\n      return a;\n    }, ya.serialize = function (t, e) {\n      var r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n      return function t(e, r, n, i) {\n        for (; n < i;) {\n          for (var a = e[n + i >> 1], o = n - 1, s = i + 1;;) {\n            do {\n              o++;\n            } while (e[o] < a);\n\n            do {\n              s--;\n            } while (e[s] > a);\n\n            if (o >= s) break;\n            va(e, o, s), va(r, 3 * o, 3 * s), va(r, 3 * o + 1, 3 * s + 1), va(r, 3 * o + 2, 3 * s + 2);\n          }\n\n          s - n < i - s ? (t(e, r, n, s), n = s + 1) : (t(e, r, s + 1, i), i = s);\n        }\n      }(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n        ids: r,\n        positions: n\n      };\n    }, ya.deserialize = function (t) {\n      var e = new ya();\n      return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n    };\n    var da = Math.pow(2, 53) - 1;\n\n    function ma(t) {\n      var e = +t;\n      return !isNaN(e) && e <= da ? e : ha(String(t));\n    }\n\n    function va(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    On("FeaturePositionMap", ya);\n\n    var ga = function ga(t, e) {\n      this.gl = t.gl, this.location = e;\n    },\n        xa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));\n      }, e;\n    }(ga),\n        ba = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n      }, e;\n    }(ga),\n        wa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));\n      }, e;\n    }(ga),\n        _a = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));\n      }, e;\n    }(ga),\n        Aa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0, 0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n      }, e;\n    }(ga),\n        Sa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = te.transparent;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n      }, e;\n    }(ga),\n        ka = new Float32Array(16),\n        Ia = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = ka;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);\n\n        for (var e = 1; e < 16; e++) {\n          if (t[e] !== this.current[e]) {\n            this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);\n            break;\n          }\n        }\n      }, e;\n    }(ga);\n\n    function za(t) {\n      return [ua(255 * t.r, 255 * t.g), ua(255 * t.b, 255 * t.a)];\n    }\n\n    var Ca = function Ca(t, e, r) {\n      this.value = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.type = r;\n    };\n\n    Ca.prototype.setUniform = function (t, e, r) {\n      t.set(r.constantOr(this.value));\n    }, Ca.prototype.getBinding = function (t, e, r) {\n      return "color" === this.type ? new Sa(t, e) : new ba(t, e);\n    };\n\n    var Ea = function Ea(t, e) {\n      this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n    };\n\n    Ea.prototype.setConstantPatternPositions = function (t, e) {\n      this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr;\n    }, Ea.prototype.setUniform = function (t, e, r, n) {\n      var i = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;\n      i && t.set(i);\n    }, Ea.prototype.getBinding = function (t, e, r) {\n      return "u_pattern" === r.substr(0, 9) ? new Aa(t, e) : new ba(t, e);\n    };\n\n    var Pa = function Pa(t, e, r, n) {\n      this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 2 : 1,\n          offset: 0\n        };\n      }), this.paintVertexArray = new n();\n    };\n\n    Pa.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.paintVertexArray.length,\n          o = this.expression.evaluate(new si(0), e, {}, n, [], i);\n      this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);\n    }, Pa.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n        zoom: 0\n      }, r, n);\n\n      this._setPaintValue(t, e, i);\n    }, Pa.prototype._setPaintValue = function (t, e, r) {\n      if ("color" === this.type) for (var n = za(r), i = t; i < e; i++) {\n        this.paintVertexArray.emplace(i, n[0], n[1]);\n      } else {\n        for (var a = t; a < e; a++) {\n          this.paintVertexArray.emplace(a, r);\n        }\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r));\n      }\n    }, Pa.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Pa.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    };\n\n    var Ma = function Ma(t, e, r, n, i, a) {\n      this.expression = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t + "_t";\n      }), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 4 : 2,\n          offset: 0\n        };\n      }), this.paintVertexArray = new a();\n    };\n\n    Ma.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.expression.evaluate(new si(this.zoom), e, {}, n, [], i),\n          o = this.expression.evaluate(new si(this.zoom + 1), e, {}, n, [], i),\n          s = this.paintVertexArray.length;\n      this.paintVertexArray.resize(t), this._setPaintValue(s, t, a, o);\n    }, Ma.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n        zoom: this.zoom\n      }, r, n),\n          a = this.expression.evaluate({\n        zoom: this.zoom + 1\n      }, r, n);\n\n      this._setPaintValue(t, e, i, a);\n    }, Ma.prototype._setPaintValue = function (t, e, r, n) {\n      if ("color" === this.type) for (var i = za(r), a = za(n), o = t; o < e; o++) {\n        this.paintVertexArray.emplace(o, i[0], i[1], a[0], a[1]);\n      } else {\n        for (var s = t; s < e; s++) {\n          this.paintVertexArray.emplace(s, r, n);\n        }\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n      }\n    }, Ma.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Ma.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    }, Ma.prototype.setUniform = function (t, e) {\n      var r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n          n = p(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n      t.set(n);\n    }, Ma.prototype.getBinding = function (t, e, r) {\n      return new ba(t, e);\n    };\n\n    var Ba = function Ba(t, e, r, n, i, a) {\n      this.expression = t, this.type = e, this.useIntegerZoom = r, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new i(), this.zoomOutPaintVertexArray = new i();\n    };\n\n    Ba.prototype.populatePaintArray = function (t, e, r) {\n      var n = this.zoomInPaintVertexArray.length;\n      this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n    }, Ba.prototype.updatePaintArray = function (t, e, r, n, i) {\n      this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i);\n    }, Ba.prototype._setPaintValues = function (t, e, r, n) {\n      if (n && r) {\n        var i = n[r.min],\n            a = n[r.mid],\n            o = n[r.max];\n        if (i && a && o) for (var s = t; s < e; s++) {\n          this.zoomInPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], i.tl[0], i.tl[1], i.br[0], i.br[1], a.pixelRatio, i.pixelRatio), this.zoomOutPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], a.pixelRatio, o.pixelRatio);\n        }\n      }\n    }, Ba.prototype.upload = function (t) {\n      this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, la.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, la.members, this.expression.isStateDependent));\n    }, Ba.prototype.destroy = function () {\n      this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n    };\n\n    var Ta = function Ta(t, e, r) {\n      this.binders = {}, this._buffers = [];\n      var n = [];\n\n      for (var i in t.paint._values) {\n        if (r(i)) {\n          var a = t.paint.get(i);\n\n          if (a instanceof yi && Tr(a.property.specification)) {\n            var o = Fa(i, t.type),\n                s = a.value,\n                u = a.property.specification.type,\n                l = a.property.useIntegerZoom,\n                p = a.property.specification["property-type"],\n                c = "cross-faded" === p || "cross-faded-data-driven" === p;\n            if ("constant" === s.kind) this.binders[i] = c ? new Ea(s.value, o) : new Ca(s.value, o, u), n.push("/u_" + i);else if ("source" === s.kind || c) {\n              var h = Da(i, u, "source");\n              this.binders[i] = c ? new Ba(s, u, l, e, h, t.id) : new Pa(s, o, u, h), n.push("/a_" + i);\n            } else {\n              var f = Da(i, u, "composite");\n              this.binders[i] = new Ma(s, o, u, l, e, f), n.push("/z_" + i);\n            }\n          }\n        }\n      }\n\n      this.cacheKey = n.sort().join("");\n    };\n\n    Ta.prototype.getMaxValue = function (t) {\n      var e = this.binders[t];\n      return e instanceof Pa || e instanceof Ma ? e.maxValue : 0;\n    }, Ta.prototype.populatePaintArrays = function (t, e, r, n, i) {\n      for (var a in this.binders) {\n        var o = this.binders[a];\n        (o instanceof Pa || o instanceof Ma || o instanceof Ba) && o.populatePaintArray(t, e, r, n, i);\n      }\n    }, Ta.prototype.setConstantPatternPositions = function (t, e) {\n      for (var r in this.binders) {\n        var n = this.binders[r];\n        n instanceof Ea && n.setConstantPatternPositions(t, e);\n      }\n    }, Ta.prototype.updatePaintArrays = function (t, e, r, n, i) {\n      var a = !1;\n\n      for (var o in t) {\n        for (var s = 0, u = e.getPositions(o); s < u.length; s += 1) {\n          var l = u[s],\n              p = r.feature(l.index);\n\n          for (var c in this.binders) {\n            var h = this.binders[c];\n\n            if ((h instanceof Pa || h instanceof Ma || h instanceof Ba) && !0 === h.expression.isStateDependent) {\n              var f = n.paint.get(c);\n              h.expression = f.value, h.updatePaintArray(l.start, l.end, p, t[o], i), a = !0;\n            }\n          }\n        }\n      }\n\n      return a;\n    }, Ta.prototype.defines = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Ca || r instanceof Ea) && t.push.apply(t, r.uniformNames.map(function (t) {\n          return "#define HAS_UNIFORM_" + t;\n        }));\n      }\n\n      return t;\n    }, Ta.prototype.getBinderAttributes = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Pa || r instanceof Ma) for (var n = 0; n < r.paintVertexAttributes.length; n++) {\n          t.push(r.paintVertexAttributes[n].name);\n        } else if (r instanceof Ba) for (var i = 0; i < la.members.length; i++) {\n          t.push(la.members[i].name);\n        }\n      }\n\n      return t;\n    }, Ta.prototype.getBinderUniforms = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Ca || r instanceof Ea || r instanceof Ma) for (var n = 0, i = r.uniformNames; n < i.length; n += 1) {\n          t.push(i[n]);\n        }\n      }\n\n      return t;\n    }, Ta.prototype.getPaintVertexBuffers = function () {\n      return this._buffers;\n    }, Ta.prototype.getUniforms = function (t, e) {\n      var r = [];\n\n      for (var n in this.binders) {\n        var i = this.binders[n];\n        if (i instanceof Ca || i instanceof Ea || i instanceof Ma) for (var a = 0, o = i.uniformNames; a < o.length; a += 1) {\n          var s = o[a];\n\n          if (e[s]) {\n            var u = i.getBinding(t, e[s], s);\n            r.push({\n              name: s,\n              property: n,\n              binding: u\n            });\n          }\n        }\n      }\n\n      return r;\n    }, Ta.prototype.setUniforms = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) {\n        var o = a[i],\n            s = o.name,\n            u = o.property;\n        this.binders[u].setUniform(o.binding, n, r.get(u), s);\n      }\n    }, Ta.prototype.updatePaintBuffers = function (t) {\n      for (var e in this._buffers = [], this.binders) {\n        var r = this.binders[e];\n\n        if (t && r instanceof Ba) {\n          var n = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n          n && this._buffers.push(n);\n        } else (r instanceof Pa || r instanceof Ma) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n      }\n    }, Ta.prototype.upload = function (t) {\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Pa || r instanceof Ma || r instanceof Ba) && r.upload(t);\n      }\n\n      this.updatePaintBuffers();\n    }, Ta.prototype.destroy = function () {\n      for (var t in this.binders) {\n        var e = this.binders[t];\n        (e instanceof Pa || e instanceof Ma || e instanceof Ba) && e.destroy();\n      }\n    };\n\n    var Va = function Va(t, e, r) {\n      void 0 === r && (r = function r() {\n        return !0;\n      }), this.programConfigurations = {};\n\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        this.programConfigurations[a.id] = new Ta(a, e, r);\n      }\n\n      this.needsUpload = !1, this._featureMap = new ya(), this._bufferOffset = 0;\n    };\n\n    function Fa(t, e) {\n      return {\n        "text-opacity": ["opacity"],\n        "icon-opacity": ["opacity"],\n        "text-color": ["fill_color"],\n        "icon-color": ["fill_color"],\n        "text-halo-color": ["halo_color"],\n        "icon-halo-color": ["halo_color"],\n        "text-halo-blur": ["halo_blur"],\n        "icon-halo-blur": ["halo_blur"],\n        "text-halo-width": ["halo_width"],\n        "icon-halo-width": ["halo_width"],\n        "line-gap-width": ["gapwidth"],\n        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]\n      }[t] || [t.replace(e + "-", "").replace(/-/g, "_")];\n    }\n\n    function Da(t, e, r) {\n      var n = {\n        color: {\n          source: Bi,\n          composite: Hi\n        },\n        number: {\n          source: Ki,\n          composite: Bi\n        }\n      },\n          i = function (t) {\n        return {\n          "line-pattern": {\n            source: Ti,\n            composite: Ti\n          },\n          "fill-pattern": {\n            source: Ti,\n            composite: Ti\n          },\n          "fill-extrusion-pattern": {\n            source: Ti,\n            composite: Ti\n          }\n        }[t];\n      }(t);\n\n      return i && i[r] || n[e][r];\n    }\n\n    Va.prototype.populatePaintArrays = function (t, e, r, n, i, a) {\n      for (var o in this.programConfigurations) {\n        this.programConfigurations[o].populatePaintArrays(t, e, n, i, a);\n      }\n\n      void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n    }, Va.prototype.updatePaintArrays = function (t, e, r, n) {\n      for (var i = 0, a = r; i < a.length; i += 1) {\n        var o = a[i];\n        this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, n) || this.needsUpload;\n      }\n    }, Va.prototype.get = function (t) {\n      return this.programConfigurations[t];\n    }, Va.prototype.upload = function (t) {\n      if (this.needsUpload) {\n        for (var e in this.programConfigurations) {\n          this.programConfigurations[e].upload(t);\n        }\n\n        this.needsUpload = !1;\n      }\n    }, Va.prototype.destroy = function () {\n      for (var t in this.programConfigurations) {\n        this.programConfigurations[t].destroy();\n      }\n    }, On("ConstantBinder", Ca), On("CrossFadedConstantBinder", Ea), On("SourceExpressionBinder", Pa), On("CrossFadedCompositeBinder", Ba), On("CompositeExpressionBinder", Ma), On("ProgramConfiguration", Ta, {\n      omit: ["_buffers"]\n    }), On("ProgramConfigurationSet", Va);\n    var La = Math.pow(2, 14) - 1,\n        Oa = -La - 1;\n\n    function Ra(t) {\n      for (var e = 8192 / t.extent, r = t.loadGeometry(), n = 0; n < r.length; n++) {\n        for (var i = r[n], a = 0; a < i.length; a++) {\n          var o = i[a],\n              s = Math.round(o.x * e),\n              u = Math.round(o.y * e);\n          o.x = p(s, Oa, La), o.y = p(u, Oa, La), (s < o.x || s > o.x + 1 || u < o.y || u > o.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");\n        }\n      }\n\n      return r;\n    }\n\n    function Ua(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Ra(t) : []\n      };\n    }\n\n    function ja(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n\n    var qa = function qa(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.segments = new sa(), this.programConfigurations = new Va(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    function Na(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        if (Wa(e, t[r])) return !0;\n      }\n\n      for (var n = 0; n < e.length; n++) {\n        if (Wa(t, e[n])) return !0;\n      }\n\n      return !!Xa(t, e);\n    }\n\n    function Ka(t, e, r) {\n      return !!Wa(t, e) || !!Ha(e, t, r);\n    }\n\n    function Ga(t, e) {\n      if (1 === t.length) return $a(e, t[0]);\n\n      for (var r = 0; r < e.length; r++) {\n        for (var n = e[r], i = 0; i < n.length; i++) {\n          if (Wa(t, n[i])) return !0;\n        }\n      }\n\n      for (var a = 0; a < t.length; a++) {\n        if ($a(e, t[a])) return !0;\n      }\n\n      for (var o = 0; o < e.length; o++) {\n        if (Xa(t, e[o])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Za(t, e, r) {\n      if (t.length > 1) {\n        if (Xa(t, e)) return !0;\n\n        for (var n = 0; n < e.length; n++) {\n          if (Ha(e[n], t, r)) return !0;\n        }\n      }\n\n      for (var i = 0; i < t.length; i++) {\n        if (Ha(t[i], e, r)) return !0;\n      }\n\n      return !1;\n    }\n\n    function Xa(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n\n      for (var r = 0; r < t.length - 1; r++) {\n        for (var n = t[r], i = t[r + 1], a = 0; a < e.length - 1; a++) {\n          if (Ja(n, i, e[a], e[a + 1])) return !0;\n        }\n      }\n\n      return !1;\n    }\n\n    function Ja(t, e, r, n) {\n      return S(t, r, n) !== S(e, r, n) && S(t, e, r) !== S(t, e, n);\n    }\n\n    function Ha(t, e, r) {\n      var n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n\n      for (var i = 1; i < e.length; i++) {\n        if (Ya(t, e[i - 1], e[i]) < n) return !0;\n      }\n\n      return !1;\n    }\n\n    function Ya(t, e, r) {\n      var n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      var i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n\n    function $a(t, e) {\n      for (var r, n, i, a = !1, o = 0; o < t.length; o++) {\n        for (var s = 0, u = (r = t[o]).length - 1; s < r.length; u = s++) {\n          (n = r[s]).y > e.y != (i = r[u]).y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (a = !a);\n        }\n      }\n\n      return a;\n    }\n\n    function Wa(t, e) {\n      for (var r = !1, n = 0, i = t.length - 1; n < t.length; i = n++) {\n        var a = t[n],\n            o = t[i];\n        a.y > e.y != o.y > e.y && e.x < (o.x - a.x) * (e.y - a.y) / (o.y - a.y) + a.x && (r = !r);\n      }\n\n      return r;\n    }\n\n    function Qa(t, e, r) {\n      var n = r[0],\n          i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      var a = S(t, e, r[0]);\n      return a !== S(t, e, r[1]) || a !== S(t, e, r[2]) || a !== S(t, e, r[3]);\n    }\n\n    function to(t, e, r) {\n      var n = e.paint.get(t).value;\n      return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n\n    function eo(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n\n    function ro(t, e, r, n, a) {\n      if (!e[0] && !e[1]) return t;\n\n      var o = i.convert(e)._mult(a);\n\n      "viewport" === r && o._rotate(-n);\n\n      for (var s = [], u = 0; u < t.length; u++) {\n        s.push(t[u].sub(o));\n      }\n\n      return s;\n    }\n\n    qa.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n          i = [],\n          a = null;\n      "circle" === n.type && (a = n.layout.get("circle-sort-key"));\n\n      for (var o = 0, s = t; o < s.length; o += 1) {\n        var u = s[o],\n            l = u.feature,\n            p = u.id,\n            c = u.index,\n            h = u.sourceLayerIndex,\n            f = this.layers[0]._featureFilter.needGeometry,\n            y = Ua(l, f);\n\n        if (this.layers[0]._featureFilter.filter(new si(this.zoom), y, r)) {\n          var d = a ? a.evaluate(y, {}, r) : void 0,\n              m = {\n            id: p,\n            properties: l.properties,\n            type: l.type,\n            sourceLayerIndex: h,\n            index: c,\n            geometry: f ? y.geometry : Ra(l),\n            patterns: {},\n            sortKey: d\n          };\n          i.push(m);\n        }\n      }\n\n      a && i.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var v = 0, g = i; v < g.length; v += 1) {\n        var x = g[v],\n            b = x.geometry,\n            w = x.index,\n            _ = x.sourceLayerIndex,\n            A = t[w].feature;\n        this.addFeature(x, b, w, r), e.featureIndex.insert(A, b, w, _, this.index);\n      }\n    }, qa.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, qa.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, qa.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, qa.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, oa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, qa.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, qa.prototype.addFeature = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) {\n        for (var o = 0, s = a[i]; o < s.length; o += 1) {\n          var u = s[o],\n              l = u.x,\n              p = u.y;\n\n          if (!(l < 0 || l >= 8192 || p < 0 || p >= 8192)) {\n            var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n                h = c.vertexLength;\n            ja(this.layoutVertexArray, l, p, -1, -1), ja(this.layoutVertexArray, l, p, 1, -1), ja(this.layoutVertexArray, l, p, 1, 1), ja(this.layoutVertexArray, l, p, -1, 1), this.indexArray.emplaceBack(h, h + 1, h + 2), this.indexArray.emplaceBack(h, h + 3, h + 2), c.vertexLength += 4, c.primitiveLength += 2;\n          }\n        }\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n);\n    }, On("CircleBucket", qa, {\n      omit: ["layers"]\n    });\n    var no = new wi({\n      "circle-sort-key": new vi(Et.layout_circle["circle-sort-key"])\n    }),\n        io = {\n      paint: new wi({\n        "circle-radius": new vi(Et.paint_circle["circle-radius"]),\n        "circle-color": new vi(Et.paint_circle["circle-color"]),\n        "circle-blur": new vi(Et.paint_circle["circle-blur"]),\n        "circle-opacity": new vi(Et.paint_circle["circle-opacity"]),\n        "circle-translate": new mi(Et.paint_circle["circle-translate"]),\n        "circle-translate-anchor": new mi(Et.paint_circle["circle-translate-anchor"]),\n        "circle-pitch-scale": new mi(Et.paint_circle["circle-pitch-scale"]),\n        "circle-pitch-alignment": new mi(Et.paint_circle["circle-pitch-alignment"]),\n        "circle-stroke-width": new vi(Et.paint_circle["circle-stroke-width"]),\n        "circle-stroke-color": new vi(Et.paint_circle["circle-stroke-color"]),\n        "circle-stroke-opacity": new vi(Et.paint_circle["circle-stroke-opacity"])\n      }),\n      layout: no\n    },\n        ao = "undefined" != typeof Float32Array ? Float32Array : Array;\n\n    function oo(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n\n    function so(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3],\n          s = e[4],\n          u = e[5],\n          l = e[6],\n          p = e[7],\n          c = e[8],\n          h = e[9],\n          f = e[10],\n          y = e[11],\n          d = e[12],\n          m = e[13],\n          v = e[14],\n          g = e[15],\n          x = r[0],\n          b = r[1],\n          w = r[2],\n          _ = r[3];\n      return t[0] = x * n + b * s + w * c + _ * d, t[1] = x * i + b * u + w * h + _ * m, t[2] = x * a + b * l + w * f + _ * v, t[3] = x * o + b * p + w * y + _ * g, t[4] = (x = r[4]) * n + (b = r[5]) * s + (w = r[6]) * c + (_ = r[7]) * d, t[5] = x * i + b * u + w * h + _ * m, t[6] = x * a + b * l + w * f + _ * v, t[7] = x * o + b * p + w * y + _ * g, t[8] = (x = r[8]) * n + (b = r[9]) * s + (w = r[10]) * c + (_ = r[11]) * d, t[9] = x * i + b * u + w * h + _ * m, t[10] = x * a + b * l + w * f + _ * v, t[11] = x * o + b * p + w * y + _ * g, t[12] = (x = r[12]) * n + (b = r[13]) * s + (w = r[14]) * c + (_ = r[15]) * d, t[13] = x * i + b * u + w * h + _ * m, t[14] = x * a + b * l + w * f + _ * v, t[15] = x * o + b * p + w * y + _ * g, t;\n    }\n\n    Math.hypot || (Math.hypot = function () {\n      for (var t = arguments, e = 0, r = arguments.length; r--;) {\n        e += t[r] * t[r];\n      }\n\n      return Math.sqrt(e);\n    });\n    var uo,\n        lo = so;\n\n    function po(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * o, t[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * o, t[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * o, t[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * o, t;\n    }\n\n    uo = new ao(3), ao != Float32Array && (uo[0] = 0, uo[1] = 0, uo[2] = 0), function () {\n      var t = new ao(4);\n      ao != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0);\n    }();\n    var co = (function () {\n      var t = new ao(2);\n      ao != Float32Array && (t[0] = 0, t[1] = 0);\n    }(), function (t) {\n      function e(e) {\n        t.call(this, e, io);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new qa(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t;\n        return to("circle-radius", this, e) + to("circle-stroke-width", this, e) + eo(this.paint.get("circle-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o, s) {\n        for (var u = ro(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, o), l = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r), p = "map" === this.paint.get("circle-pitch-alignment"), c = p ? u : function (t, e) {\n          return t.map(function (t) {\n            return ho(t, e);\n          });\n        }(u, s), h = p ? l * o : l, f = 0, y = n; f < y.length; f += 1) {\n          for (var d = 0, m = y[f]; d < m.length; d += 1) {\n            var v = m[d],\n                g = p ? v : ho(v, s),\n                x = h,\n                b = po([], [v.x, v.y, 0, 1], s);\n            if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x *= b[3] / a.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x *= a.cameraToCenterDistance / b[3]), Ka(c, g, x)) return !0;\n          }\n        }\n\n        return !1;\n      }, e;\n    }(_i));\n\n    function ho(t, e) {\n      var r = po([], [t.x, t.y, 0, 1], e);\n      return new i(r[0] / r[3], r[1] / r[3]);\n    }\n\n    var fo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(qa);\n\n    function yo(t, e, r, n) {\n      var i = e.width,\n          a = e.height;\n\n      if (n) {\n        if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);else if (n.length !== i * a * r) throw new RangeError("mismatched image size");\n      } else n = new Uint8Array(i * a * r);\n\n      return t.width = i, t.height = a, t.data = n, t;\n    }\n\n    function mo(t, e, r) {\n      var n = e.width,\n          i = e.height;\n\n      if (n !== t.width || i !== t.height) {\n        var a = yo({}, {\n          width: n,\n          height: i\n        }, r);\n        vo(t, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: 0,\n          y: 0\n        }, {\n          width: Math.min(t.width, n),\n          height: Math.min(t.height, i)\n        }, r), t.width = n, t.height = i, t.data = a.data;\n      }\n    }\n\n    function vo(t, e, r, n, i, a) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");\n\n      for (var o = t.data, s = e.data, u = 0; u < i.height; u++) {\n        for (var l = ((r.y + u) * t.width + r.x) * a, p = ((n.y + u) * e.width + n.x) * a, c = 0; c < i.width * a; c++) {\n          s[p + c] = o[l + c];\n        }\n      }\n\n      return e;\n    }\n\n    On("HeatmapBucket", fo, {\n      omit: ["layers"]\n    });\n\n    var go = function go(t, e) {\n      yo(this, t, 1, e);\n    };\n\n    go.prototype.resize = function (t) {\n      mo(this, t, 1);\n    }, go.prototype.clone = function () {\n      return new go({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, go.copy = function (t, e, r, n, i) {\n      vo(t, e, r, n, i, 1);\n    };\n\n    var xo = function xo(t, e) {\n      yo(this, t, 4, e);\n    };\n\n    xo.prototype.resize = function (t) {\n      mo(this, t, 4);\n    }, xo.prototype.replace = function (t, e) {\n      e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n    }, xo.prototype.clone = function () {\n      return new xo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, xo.copy = function (t, e, r, n, i) {\n      vo(t, e, r, n, i, 4);\n    }, On("AlphaImage", go), On("RGBAImage", xo);\n    var bo = {\n      paint: new wi({\n        "heatmap-radius": new vi(Et.paint_heatmap["heatmap-radius"]),\n        "heatmap-weight": new vi(Et.paint_heatmap["heatmap-weight"]),\n        "heatmap-intensity": new mi(Et.paint_heatmap["heatmap-intensity"]),\n        "heatmap-color": new bi(Et.paint_heatmap["heatmap-color"]),\n        "heatmap-opacity": new mi(Et.paint_heatmap["heatmap-opacity"])\n      })\n    };\n\n    function wo(t) {\n      var e = {},\n          r = t.resolution || 256,\n          n = t.clips ? t.clips.length : 1,\n          i = t.image || new xo({\n        width: r,\n        height: n\n      }),\n          a = function a(r, n, _a2) {\n        e[t.evaluationKey] = _a2;\n        var o = t.expression.evaluate(e);\n        i.data[r + n + 0] = Math.floor(255 * o.r / o.a), i.data[r + n + 1] = Math.floor(255 * o.g / o.a), i.data[r + n + 2] = Math.floor(255 * o.b / o.a), i.data[r + n + 3] = Math.floor(255 * o.a);\n      };\n\n      if (t.clips) for (var o = 0, s = 0; o < n; ++o, s += 4 * r) {\n        for (var u = 0, l = 0; u < r; u++, l += 4) {\n          var p = u / (r - 1),\n              c = t.clips[o];\n          a(s, l, c.start * (1 - p) + c.end * p);\n        }\n      } else for (var h = 0, f = 0; h < r; h++, f += 4) {\n        a(0, f, h / (r - 1));\n      }\n      return i;\n    }\n\n    var _o = function (t) {\n      function e(e) {\n        t.call(this, e, bo), this._updateColorRamp();\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new fo(t);\n      }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n        "heatmap-color" === t && this._updateColorRamp();\n      }, e.prototype._updateColorRamp = function () {\n        this.colorRamp = wo({\n          expression: this._transitionablePaint._values["heatmap-color"].value.expression,\n          evaluationKey: "heatmapDensity",\n          image: this.colorRamp\n        }), this.colorRampTexture = null;\n      }, e.prototype.resize = function () {\n        this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n      }, e.prototype.queryRadius = function () {\n        return 0;\n      }, e.prototype.queryIntersectsFeature = function () {\n        return !1;\n      }, e.prototype.hasOffscreenPass = function () {\n        return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;\n      }, e;\n    }(_i),\n        Ao = {\n      paint: new wi({\n        "hillshade-illumination-direction": new mi(Et.paint_hillshade["hillshade-illumination-direction"]),\n        "hillshade-illumination-anchor": new mi(Et.paint_hillshade["hillshade-illumination-anchor"]),\n        "hillshade-exaggeration": new mi(Et.paint_hillshade["hillshade-exaggeration"]),\n        "hillshade-shadow-color": new mi(Et.paint_hillshade["hillshade-shadow-color"]),\n        "hillshade-highlight-color": new mi(Et.paint_hillshade["hillshade-highlight-color"]),\n        "hillshade-accent-color": new mi(Et.paint_hillshade["hillshade-accent-color"])\n      })\n    },\n        So = function (t) {\n      function e(e) {\n        t.call(this, e, Ao);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.hasOffscreenPass = function () {\n        return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;\n      }, e;\n    }(_i),\n        ko = Ii([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }], 4).members,\n        Io = Co,\n        zo = Co;\n\n    function Co(t, e, r) {\n      r = r || 2;\n      var n,\n          i,\n          a,\n          o,\n          s,\n          u,\n          l,\n          p = e && e.length,\n          c = p ? e[0] * r : t.length,\n          h = Eo(t, 0, c, r, !0),\n          f = [];\n      if (!h || h.next === h.prev) return f;\n\n      if (p && (h = function (t, e, r, n) {\n        var i,\n            a,\n            o,\n            s = [];\n\n        for (i = 0, a = e.length; i < a; i++) {\n          (o = Eo(t, e[i] * n, i < a - 1 ? e[i + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0), s.push(Uo(o));\n        }\n\n        for (s.sort(Do), i = 0; i < s.length; i++) {\n          Lo(s[i], r), r = Po(r, r.next);\n        }\n\n        return r;\n      }(t, e, h, r)), t.length > 80 * r) {\n        n = a = t[0], i = o = t[1];\n\n        for (var y = r; y < c; y += r) {\n          (s = t[y]) < n && (n = s), (u = t[y + 1]) < i && (i = u), s > a && (a = s), u > o && (o = u);\n        }\n\n        l = 0 !== (l = Math.max(a - n, o - i)) ? 1 / l : 0;\n      }\n\n      return Mo(h, f, r, n, i, l), f;\n    }\n\n    function Eo(t, e, r, n, i) {\n      var a, o;\n      if (i === Qo(t, e, r, n) > 0) for (a = e; a < r; a += n) {\n        o = Yo(a, t[a], t[a + 1], o);\n      } else for (a = r - n; a >= e; a -= n) {\n        o = Yo(a, t[a], t[a + 1], o);\n      }\n      return o && Ko(o, o.next) && ($o(o), o = o.next), o;\n    }\n\n    function Po(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n          n = t;\n\n      do {\n        if (r = !1, n.steiner || !Ko(n, n.next) && 0 !== No(n.prev, n, n.next)) n = n.next;else {\n          if ($o(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n\n      return e;\n    }\n\n    function Mo(t, e, r, n, i, a, o) {\n      if (t) {\n        !o && a && function (t, e, r, n) {\n          var i = t;\n\n          do {\n            null === i.z && (i.z = Ro(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n                r,\n                n,\n                i,\n                a,\n                o,\n                s,\n                u,\n                l = 1;\n\n            do {\n              for (r = t, t = null, a = null, o = 0; r;) {\n                for (o++, n = r, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++) {\n                  ;\n                }\n\n                for (u = l; s > 0 || u > 0 && n;) {\n                  0 !== s && (0 === u || !n || r.z <= n.z) ? (i = r, r = r.nextZ, s--) : (i = n, n = n.nextZ, u--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;\n                }\n\n                r = n;\n              }\n\n              a.nextZ = null, l *= 2;\n            } while (o > 1);\n          }(i);\n        }(t, n, i, a);\n\n        for (var s, u, l = t; t.prev !== t.next;) {\n          if (s = t.prev, u = t.next, a ? To(t, n, i, a) : Bo(t)) e.push(s.i / r), e.push(t.i / r), e.push(u.i / r), $o(t), t = u.next, l = u.next;else if ((t = u) === l) {\n            o ? 1 === o ? Mo(t = Vo(Po(t), e, r), e, r, n, i, a, 2) : 2 === o && Fo(t, e, r, n, i, a) : Mo(Po(t), e, r, n, i, a, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    function Bo(t) {\n      var e = t.prev,\n          r = t,\n          n = t.next;\n      if (No(e, r, n) >= 0) return !1;\n\n      for (var i = t.next.next; i !== t.prev;) {\n        if (jo(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && No(i.prev, i, i.next) >= 0) return !1;\n        i = i.next;\n      }\n\n      return !0;\n    }\n\n    function To(t, e, r, n) {\n      var i = t.prev,\n          a = t,\n          o = t.next;\n      if (No(i, a, o) >= 0) return !1;\n\n      for (var s = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, l = Ro(i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, e, r, n), p = Ro(s, u, e, r, n), c = t.prevZ, h = t.nextZ; c && c.z >= l && h && h.z <= p;) {\n        if (c !== t.prev && c !== t.next && jo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && No(c.prev, c, c.next) >= 0) return !1;\n        if (c = c.prevZ, h !== t.prev && h !== t.next && jo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && No(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n\n      for (; c && c.z >= l;) {\n        if (c !== t.prev && c !== t.next && jo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && No(c.prev, c, c.next) >= 0) return !1;\n        c = c.prevZ;\n      }\n\n      for (; h && h.z <= p;) {\n        if (h !== t.prev && h !== t.next && jo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && No(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n\n      return !0;\n    }\n\n    function Vo(t, e, r) {\n      var n = t;\n\n      do {\n        var i = n.prev,\n            a = n.next.next;\n        !Ko(i, a) && Go(i, n, n.next, a) && Jo(i, a) && Jo(a, i) && (e.push(i.i / r), e.push(n.i / r), e.push(a.i / r), $o(n), $o(n.next), n = t = a), n = n.next;\n      } while (n !== t);\n\n      return Po(n);\n    }\n\n    function Fo(t, e, r, n, i, a) {\n      var o = t;\n\n      do {\n        for (var s = o.next.next; s !== o.prev;) {\n          if (o.i !== s.i && qo(o, s)) {\n            var u = Ho(o, s);\n            return o = Po(o, o.next), u = Po(u, u.next), Mo(o, e, r, n, i, a), void Mo(u, e, r, n, i, a);\n          }\n\n          s = s.next;\n        }\n\n        o = o.next;\n      } while (o !== t);\n    }\n\n    function Do(t, e) {\n      return t.x - e.x;\n    }\n\n    function Lo(t, e) {\n      if (e = function (t, e) {\n        var r,\n            n = e,\n            i = t.x,\n            a = t.y,\n            o = -1 / 0;\n\n        do {\n          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {\n            var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n            if (s <= i && s > o) {\n              if (o = s, s === i) {\n                if (a === n.y) return n;\n                if (a === n.next.y) return n.next;\n              }\n\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n\n          n = n.next;\n        } while (n !== e);\n\n        if (!r) return null;\n        if (i === o) return r;\n        var u,\n            l = r,\n            p = r.x,\n            c = r.y,\n            h = 1 / 0;\n        n = r;\n\n        do {\n          i >= n.x && n.x >= p && i !== n.x && jo(a < c ? i : o, a, p, c, a < c ? o : i, a, n.x, n.y) && (u = Math.abs(a - n.y) / (i - n.x), Jo(n, t) && (u < h || u === h && (n.x > r.x || n.x === r.x && Oo(r, n))) && (r = n, h = u)), n = n.next;\n        } while (n !== l);\n\n        return r;\n      }(t, e)) {\n        var r = Ho(e, t);\n        Po(e, e.next), Po(r, r.next);\n      }\n    }\n\n    function Oo(t, e) {\n      return No(t.prev, t, e.prev) < 0 && No(e.next, t, t.next) < 0;\n    }\n\n    function Ro(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n\n    function Uo(t) {\n      var e = t,\n          r = t;\n\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n\n      return r;\n    }\n\n    function jo(t, e, r, n, i, a, o, s) {\n      return (i - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (n - s) - (r - o) * (e - s) >= 0 && (r - o) * (a - s) - (i - o) * (n - s) >= 0;\n    }\n\n    function qo(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Go(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n\n        return !1;\n      }(t, e) && (Jo(t, e) && Jo(e, t) && function (t, e) {\n        var r = t,\n            n = !1,\n            i = (t.x + e.x) / 2,\n            a = (t.y + e.y) / 2;\n\n        do {\n          r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n\n        return n;\n      }(t, e) && (No(t.prev, t, e.prev) || No(t, e.prev, e)) || Ko(t, e) && No(t.prev, t, t.next) > 0 && No(e.prev, e, e.next) > 0);\n    }\n\n    function No(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n\n    function Ko(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n\n    function Go(t, e, r, n) {\n      var i = Xo(No(t, e, r)),\n          a = Xo(No(t, e, n)),\n          o = Xo(No(r, n, t)),\n          s = Xo(No(r, n, e));\n      return i !== a && o !== s || !(0 !== i || !Zo(t, r, e)) || !(0 !== a || !Zo(t, n, e)) || !(0 !== o || !Zo(r, t, n)) || !(0 !== s || !Zo(r, e, n));\n    }\n\n    function Zo(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n\n    function Xo(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n\n    function Jo(t, e) {\n      return No(t.prev, t, t.next) < 0 ? No(t, e, t.next) >= 0 && No(t, t.prev, e) >= 0 : No(t, e, t.prev) < 0 || No(t, t.next, e) < 0;\n    }\n\n    function Ho(t, e) {\n      var r = new Wo(t.i, t.x, t.y),\n          n = new Wo(e.i, e.x, e.y),\n          i = t.next,\n          a = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;\n    }\n\n    function Yo(t, e, r, n) {\n      var i = new Wo(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n\n    function $o(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n\n    function Wo(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n\n    function Qo(t, e, r, n) {\n      for (var i = 0, a = e, o = r - n; a < r; a += n) {\n        i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;\n      }\n\n      return i;\n    }\n\n    function ts(t, e, r, n, i) {\n      !function t(e, r, n, i, a) {\n        for (; i > n;) {\n          if (i - n > 600) {\n            var o = i - n + 1,\n                s = r - n + 1,\n                u = Math.log(o),\n                l = .5 * Math.exp(2 * u / 3),\n                p = .5 * Math.sqrt(u * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);\n            t(e, r, Math.max(n, Math.floor(r - s * l / o + p)), Math.min(i, Math.floor(r + (o - s) * l / o + p)), a);\n          }\n\n          var c = e[r],\n              h = n,\n              f = i;\n\n          for (es(e, n, r), a(e[i], c) > 0 && es(e, n, i); h < f;) {\n            for (es(e, h, f), h++, f--; a(e[h], c) < 0;) {\n              h++;\n            }\n\n            for (; a(e[f], c) > 0;) {\n              f--;\n            }\n          }\n\n          0 === a(e[n], c) ? es(e, n, f) : es(e, ++f, i), f <= r && (n = f + 1), r <= f && (i = f - 1);\n        }\n      }(t, e, r || 0, n || t.length - 1, i || rs);\n    }\n\n    function es(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    function rs(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function ns(t, e) {\n      var r = t.length;\n      if (r <= 1) return [t];\n\n      for (var n, i, a = [], o = 0; o < r; o++) {\n        var s = k(t[o]);\n        0 !== s && (t[o].area = Math.abs(s), void 0 === i && (i = s < 0), i === s < 0 ? (n && a.push(n), n = [t[o]]) : n.push(t[o]));\n      }\n\n      if (n && a.push(n), e > 1) for (var u = 0; u < a.length; u++) {\n        a[u].length <= e || (ts(a[u], e, 1, a[u].length - 1, is), a[u] = a[u].slice(0, e));\n      }\n      return a;\n    }\n\n    function is(t, e) {\n      return e.area - t.area;\n    }\n\n    function as(t, e, r) {\n      for (var n = r.patternDependencies, i = !1, a = 0, o = e; a < o.length; a += 1) {\n        var s = o[a].paint.get(t + "-pattern");\n        s.isConstant() || (i = !0);\n        var u = s.constantOr(null);\n        u && (i = !0, n[u.to] = !0, n[u.from] = !0);\n      }\n\n      return i;\n    }\n\n    function os(t, e, r, n, i) {\n      for (var a = i.patternDependencies, o = 0, s = e; o < s.length; o += 1) {\n        var u = s[o],\n            l = u.paint.get(t + "-pattern").value;\n\n        if ("constant" !== l.kind) {\n          var p = l.evaluate({\n            zoom: n - 1\n          }, r, {}, i.availableImages),\n              c = l.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages),\n              h = l.evaluate({\n            zoom: n + 1\n          }, r, {}, i.availableImages);\n          c = c && c.name ? c.name : c, h = h && h.name ? h.name : h, a[p = p && p.name ? p.name : p] = !0, a[c] = !0, a[h] = !0, r.patterns[u.id] = {\n            min: p,\n            mid: c,\n            max: h\n          };\n        }\n      }\n\n      return r;\n    }\n\n    Co.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n          a = Math.abs(Qo(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var o = 0, s = e.length; o < s; o++) {\n        a -= Math.abs(Qo(t, e[o] * r, o < s - 1 ? e[o + 1] * r : t.length, r));\n      }\n      var u = 0;\n\n      for (o = 0; o < n.length; o += 3) {\n        var l = n[o] * r,\n            p = n[o + 1] * r,\n            c = n[o + 2] * r;\n        u += Math.abs((t[l] - t[c]) * (t[p + 1] - t[l + 1]) - (t[l] - t[p]) * (t[c + 1] - t[l + 1]));\n      }\n\n      return 0 === a && 0 === u ? 0 : Math.abs((u - a) / a);\n    }, Co.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n        vertices: [],\n        holes: [],\n        dimensions: e\n      }, n = 0, i = 0; i < t.length; i++) {\n        for (var a = 0; a < t[i].length; a++) {\n          for (var o = 0; o < e; o++) {\n            r.vertices.push(t[i][a][o]);\n          }\n        }\n\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n\n      return r;\n    }, Io.default = zo;\n\n    var ss = function ss(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.indexArray2 = new Xi(), this.programConfigurations = new Va(t.layers, t.zoom), this.segments = new sa(), this.segments2 = new sa(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    ss.prototype.populate = function (t, e, r) {\n      this.hasPattern = as("fill", this.layers, e);\n\n      for (var n = this.layers[0].layout.get("fill-sort-key"), i = [], a = 0, o = t; a < o.length; a += 1) {\n        var s = o[a],\n            u = s.feature,\n            l = s.id,\n            p = s.index,\n            c = s.sourceLayerIndex,\n            h = this.layers[0]._featureFilter.needGeometry,\n            f = Ua(u, h);\n\n        if (this.layers[0]._featureFilter.filter(new si(this.zoom), f, r)) {\n          var y = n ? n.evaluate(f, {}, r, e.availableImages) : void 0,\n              d = {\n            id: l,\n            properties: u.properties,\n            type: u.type,\n            sourceLayerIndex: c,\n            index: p,\n            geometry: h ? f.geometry : Ra(u),\n            patterns: {},\n            sortKey: y\n          };\n          i.push(d);\n        }\n      }\n\n      n && i.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var m = 0, v = i; m < v.length; m += 1) {\n        var g = v[m],\n            x = g.geometry,\n            b = g.index,\n            w = g.sourceLayerIndex;\n\n        if (this.hasPattern) {\n          var _ = os("fill", this.layers, g, this.zoom, e);\n\n          this.patternFeatures.push(_);\n        } else this.addFeature(g, x, b, r, {});\n\n        e.featureIndex.insert(t[b].feature, x, b, w, this.index);\n      }\n    }, ss.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, ss.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, ss.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, ss.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, ss.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ko), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, ss.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n    }, ss.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = ns(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) {\n          u += p[l].length;\n        }\n\n        for (var c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray), h = c.vertexLength, f = [], y = [], d = 0, m = s; d < m.length; d += 1) {\n          var v = m[d];\n\n          if (0 !== v.length) {\n            v !== s[0] && y.push(f.length / 2);\n            var g = this.segments2.prepareSegment(v.length, this.layoutVertexArray, this.indexArray2),\n                x = g.vertexLength;\n            this.layoutVertexArray.emplaceBack(v[0].x, v[0].y), this.indexArray2.emplaceBack(x + v.length - 1, x), f.push(v[0].x), f.push(v[0].y);\n\n            for (var b = 1; b < v.length; b++) {\n              this.layoutVertexArray.emplaceBack(v[b].x, v[b].y), this.indexArray2.emplaceBack(x + b - 1, x + b), f.push(v[b].x), f.push(v[b].y);\n            }\n\n            g.vertexLength += v.length, g.primitiveLength += v.length;\n          }\n        }\n\n        for (var w = Io(f, y), _ = 0; _ < w.length; _ += 3) {\n          this.indexArray.emplaceBack(h + w[_], h + w[_ + 1], h + w[_ + 2]);\n        }\n\n        c.vertexLength += u, c.primitiveLength += w.length / 3;\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillBucket", ss, {\n      omit: ["layers", "patternFeatures"]\n    });\n\n    var us = new wi({\n      "fill-sort-key": new vi(Et.layout_fill["fill-sort-key"])\n    }),\n        ls = {\n      paint: new wi({\n        "fill-antialias": new mi(Et.paint_fill["fill-antialias"]),\n        "fill-opacity": new vi(Et.paint_fill["fill-opacity"]),\n        "fill-color": new vi(Et.paint_fill["fill-color"]),\n        "fill-outline-color": new vi(Et.paint_fill["fill-outline-color"]),\n        "fill-translate": new mi(Et.paint_fill["fill-translate"]),\n        "fill-translate-anchor": new mi(Et.paint_fill["fill-translate-anchor"]),\n        "fill-pattern": new gi(Et.paint_fill["fill-pattern"])\n      }),\n      layout: us\n    },\n        ps = function (t) {\n      function e(e) {\n        t.call(this, e, ls);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n        t.prototype.recalculate.call(this, e, r);\n        var n = this.paint._values["fill-outline-color"];\n        "constant" === n.value.kind && void 0 === n.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);\n      }, e.prototype.createBucket = function (t) {\n        return new ss(t);\n      }, e.prototype.queryRadius = function () {\n        return eo(this.paint.get("fill-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o) {\n        return Ga(ro(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, o), n);\n      }, e.prototype.isTileClipped = function () {\n        return !0;\n      }, e;\n    }(_i),\n        cs = Ii([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_normal_ed",\n      components: 4,\n      type: "Int16"\n    }], 4).members,\n        hs = fs;\n\n    function fs(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(ys, this, e);\n    }\n\n    function ys(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n              i = e._values[t.readVarint()];\n\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n\n    function ds(t) {\n      for (var e, r, n = 0, i = 0, a = t.length, o = a - 1; i < a; o = i++) {\n        n += ((r = t[o]).x - (e = t[i]).x) * (e.y + r.y);\n      }\n\n      return n;\n    }\n\n    fs.types = ["Unknown", "Point", "LineString", "Polygon"], fs.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e, r = t.readVarint() + t.pos, n = 1, a = 0, o = 0, s = 0, u = []; t.pos < r;) {\n        if (a <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, a = l >> 3;\n        }\n\n        if (a--, 1 === n || 2 === n) o += t.readSVarint(), s += t.readSVarint(), 1 === n && (e && u.push(e), e = []), e.push(new i(o, s));else {\n          if (7 !== n) throw new Error("unknown command " + n);\n          e && e.push(e[0].clone());\n        }\n      }\n\n      return e && u.push(e), u;\n    }, fs.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, a = 0, o = 1 / 0, s = -1 / 0, u = 1 / 0, l = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var p = t.readVarint();\n          r = 7 & p, n = p >> 3;\n        }\n\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < o && (o = i), i > s && (s = i), (a += t.readSVarint()) < u && (u = a), a > l && (l = a);else if (7 !== r) throw new Error("unknown command " + r);\n      }\n\n      return [o, u, s, l];\n    }, fs.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n          i,\n          a = this.extent * Math.pow(2, r),\n          o = this.extent * t,\n          s = this.extent * e,\n          u = this.loadGeometry(),\n          l = fs.types[this.type];\n\n      function p(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + o) / a - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + s) / a) * Math.PI / 180)) - 90];\n        }\n      }\n\n      switch (this.type) {\n        case 1:\n          var c = [];\n\n          for (n = 0; n < u.length; n++) {\n            c[n] = u[n][0];\n          }\n\n          p(u = c);\n          break;\n\n        case 2:\n          for (n = 0; n < u.length; n++) {\n            p(u[n]);\n          }\n\n          break;\n\n        case 3:\n          for (u = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n\n            for (var r, n, i = [], a = 0; a < e; a++) {\n              var o = ds(t[a]);\n              0 !== o && (void 0 === n && (n = o < 0), n === o < 0 ? (r && i.push(r), r = [t[a]]) : r.push(t[a]));\n            }\n\n            return r && i.push(r), i;\n          }(u), n = 0; n < u.length; n++) {\n            for (i = 0; i < u[n].length; i++) {\n              p(u[n][i]);\n            }\n          }\n\n      }\n\n      1 === u.length ? u = u[0] : l = "Multi" + l;\n      var h = {\n        type: "Feature",\n        geometry: {\n          type: l,\n          coordinates: u\n        },\n        properties: this.properties\n      };\n      return "id" in this && (h.id = this.id), h;\n    };\n    var ms = vs;\n\n    function vs(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(gs, this, e), this.length = this._features.length;\n    }\n\n    function gs(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n\n        return e;\n      }(r));\n    }\n\n    function xs(t, e, r) {\n      if (3 === t) {\n        var n = new ms(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n\n    vs.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");\n      this._pbf.pos = this._features[t];\n\n      var e = this._pbf.readVarint() + this._pbf.pos;\n\n      return new hs(this._pbf, e, this.extent, this._keys, this._values);\n    };\n\n    var bs = {\n      VectorTile: function VectorTile(t, e) {\n        this.layers = t.readFields(xs, {}, e);\n      },\n      VectorTileFeature: hs,\n      VectorTileLayer: ms\n    },\n        ws = bs.VectorTileFeature.types,\n        _s = Math.pow(2, 13);\n\n    function As(t, e, r, n, i, a, o, s) {\n      t.emplaceBack(e, r, 2 * Math.floor(n * _s) + o, i * _s * 2, a * _s * 2, Math.round(s));\n    }\n\n    var Ss = function Ss(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Pi(), this.indexArray = new ji(), this.programConfigurations = new Va(t.layers, t.zoom), this.segments = new sa(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    function ks(t, e) {\n      return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192);\n    }\n\n    Ss.prototype.populate = function (t, e, r) {\n      this.features = [], this.hasPattern = as("fill-extrusion", this.layers, e);\n\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n],\n            o = a.feature,\n            s = a.id,\n            u = a.index,\n            l = a.sourceLayerIndex,\n            p = this.layers[0]._featureFilter.needGeometry,\n            c = Ua(o, p);\n\n        if (this.layers[0]._featureFilter.filter(new si(this.zoom), c, r)) {\n          var h = {\n            id: s,\n            sourceLayerIndex: l,\n            index: u,\n            geometry: p ? c.geometry : Ra(o),\n            properties: o.properties,\n            type: o.type,\n            patterns: {}\n          };\n          this.hasPattern ? this.features.push(os("fill-extrusion", this.layers, h, this.zoom, e)) : this.addFeature(h, h.geometry, u, r, {}), e.featureIndex.insert(o, h.geometry, u, l, this.index, !0);\n        }\n      }\n    }, Ss.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.features; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, Ss.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Ss.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Ss.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Ss.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Ss.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Ss.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = ns(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) {\n          u += p[l].length;\n        }\n\n        for (var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h = 0, f = s; h < f.length; h += 1) {\n          var y = f[h];\n          if (0 !== y.length && !((B = y).every(function (t) {\n            return t.x < 0;\n          }) || B.every(function (t) {\n            return t.x > 8192;\n          }) || B.every(function (t) {\n            return t.y < 0;\n          }) || B.every(function (t) {\n            return t.y > 8192;\n          }))) for (var d = 0, m = 0; m < y.length; m++) {\n            var v = y[m];\n\n            if (m >= 1) {\n              var g = y[m - 1];\n\n              if (!ks(v, g)) {\n                c.vertexLength + 4 > sa.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n\n                var x = v.sub(g)._perp()._unit(),\n                    b = g.dist(v);\n\n                d + b > 32768 && (d = 0), As(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 0, d), As(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 1, d), As(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 0, d += b), As(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 1, d);\n                var w = c.vertexLength;\n                this.indexArray.emplaceBack(w, w + 2, w + 1), this.indexArray.emplaceBack(w + 1, w + 2, w + 3), c.vertexLength += 4, c.primitiveLength += 2;\n              }\n            }\n          }\n        }\n\n        if (c.vertexLength + u > sa.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray)), "Polygon" === ws[t.type]) {\n          for (var _ = [], A = [], S = c.vertexLength, k = 0, I = s; k < I.length; k += 1) {\n            var z = I[k];\n\n            if (0 !== z.length) {\n              z !== s[0] && A.push(_.length / 2);\n\n              for (var C = 0; C < z.length; C++) {\n                var E = z[C];\n                As(this.layoutVertexArray, E.x, E.y, 0, 0, 1, 1, 0), _.push(E.x), _.push(E.y);\n              }\n            }\n          }\n\n          for (var P = Io(_, A), M = 0; M < P.length; M += 3) {\n            this.indexArray.emplaceBack(S + P[M], S + P[M + 2], S + P[M + 1]);\n          }\n\n          c.primitiveLength += P.length / 3, c.vertexLength += u;\n        }\n      }\n\n      var B;\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillExtrusionBucket", Ss, {\n      omit: ["layers", "features"]\n    });\n\n    var Is = {\n      paint: new wi({\n        "fill-extrusion-opacity": new mi(Et["paint_fill-extrusion"]["fill-extrusion-opacity"]),\n        "fill-extrusion-color": new vi(Et["paint_fill-extrusion"]["fill-extrusion-color"]),\n        "fill-extrusion-translate": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate"]),\n        "fill-extrusion-translate-anchor": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),\n        "fill-extrusion-pattern": new gi(Et["paint_fill-extrusion"]["fill-extrusion-pattern"]),\n        "fill-extrusion-height": new vi(Et["paint_fill-extrusion"]["fill-extrusion-height"]),\n        "fill-extrusion-base": new vi(Et["paint_fill-extrusion"]["fill-extrusion-base"]),\n        "fill-extrusion-vertical-gradient": new mi(Et["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])\n      })\n    },\n        zs = function (t) {\n      function e(e) {\n        t.call(this, e, Is);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new Ss(t);\n      }, e.prototype.queryRadius = function () {\n        return eo(this.paint.get("fill-extrusion-translate"));\n      }, e.prototype.is3D = function () {\n        return !0;\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s, u) {\n        var l = ro(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, s),\n            p = this.paint.get("fill-extrusion-height").evaluate(e, r),\n            c = this.paint.get("fill-extrusion-base").evaluate(e, r),\n            h = function (t, e, r, n) {\n          for (var a = [], o = 0, s = t; o < s.length; o += 1) {\n            var u = s[o],\n                l = [u.x, u.y, 0, 1];\n            po(l, l, e), a.push(new i(l[0] / l[3], l[1] / l[3]));\n          }\n\n          return a;\n        }(l, u),\n            f = function (t, e, r, n) {\n          for (var a = [], o = [], s = n[8] * e, u = n[9] * e, l = n[10] * e, p = n[11] * e, c = n[8] * r, h = n[9] * r, f = n[10] * r, y = n[11] * r, d = 0, m = t; d < m.length; d += 1) {\n            for (var v = [], g = [], x = 0, b = m[d]; x < b.length; x += 1) {\n              var w = b[x],\n                  _ = w.x,\n                  A = w.y,\n                  S = n[0] * _ + n[4] * A + n[12],\n                  k = n[1] * _ + n[5] * A + n[13],\n                  I = n[2] * _ + n[6] * A + n[14],\n                  z = n[3] * _ + n[7] * A + n[15],\n                  C = I + l,\n                  E = z + p,\n                  P = S + c,\n                  M = k + h,\n                  B = I + f,\n                  T = z + y,\n                  V = new i((S + s) / E, (k + u) / E);\n              V.z = C / E, v.push(V);\n              var F = new i(P / T, M / T);\n              F.z = B / T, g.push(F);\n            }\n\n            a.push(v), o.push(g);\n          }\n\n          return [a, o];\n        }(n, c, p, u);\n\n        return function (t, e, r) {\n          var n = 1 / 0;\n          Ga(r, e) && (n = Es(r, e[0]));\n\n          for (var i = 0; i < e.length; i++) {\n            for (var a = e[i], o = t[i], s = 0; s < a.length - 1; s++) {\n              var u = a[s],\n                  l = [u, a[s + 1], o[s + 1], o[s], u];\n              Na(r, l) && (n = Math.min(n, Es(r, l)));\n            }\n          }\n\n          return n !== 1 / 0 && n;\n        }(f[0], f[1], h);\n      }, e;\n    }(_i);\n\n    function Cs(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n\n    function Es(t, e) {\n      if (1 === t.length) {\n        for (var r, n = 0, i = e[n++]; !r || i.equals(r);) {\n          if (!(r = e[n++])) return 1 / 0;\n        }\n\n        for (; n < e.length; n++) {\n          var a = e[n],\n              o = t[0],\n              s = r.sub(i),\n              u = a.sub(i),\n              l = o.sub(i),\n              p = Cs(s, s),\n              c = Cs(s, u),\n              h = Cs(u, u),\n              f = Cs(l, s),\n              y = Cs(l, u),\n              d = p * h - c * c,\n              m = (h * f - c * y) / d,\n              v = (p * y - c * f) / d,\n              g = i.z * (1 - m - v) + r.z * m + a.z * v;\n          if (isFinite(g)) return g;\n        }\n\n        return 1 / 0;\n      }\n\n      for (var x = 1 / 0, b = 0, w = e; b < w.length; b += 1) {\n        x = Math.min(x, w[b].z);\n      }\n\n      return x;\n    }\n\n    var Ps = Ii([{\n      name: "a_pos_normal",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_data",\n      components: 4,\n      type: "Uint8"\n    }], 4).members,\n        Ms = Ii([{\n      name: "a_uv_x",\n      components: 1,\n      type: "Float32"\n    }, {\n      name: "a_split_index",\n      components: 1,\n      type: "Float32"\n    }]).members,\n        Bs = bs.VectorTileFeature.types,\n        Ts = Math.cos(Math.PI / 180 * 37.5),\n        Vs = Math.pow(2, 14) / .5,\n        Fs = function Fs(t) {\n      var e = this;\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function (t) {\n        e.gradients[t.id] = {};\n      }), this.layoutVertexArray = new Mi(), this.layoutVertexArray2 = new Bi(), this.indexArray = new ji(), this.programConfigurations = new Va(t.layers, t.zoom), this.segments = new sa(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    Fs.prototype.populate = function (t, e, r) {\n      this.hasPattern = as("line", this.layers, e);\n\n      for (var n = this.layers[0].layout.get("line-sort-key"), i = [], a = 0, o = t; a < o.length; a += 1) {\n        var s = o[a],\n            u = s.feature,\n            l = s.id,\n            p = s.index,\n            c = s.sourceLayerIndex,\n            h = this.layers[0]._featureFilter.needGeometry,\n            f = Ua(u, h);\n\n        if (this.layers[0]._featureFilter.filter(new si(this.zoom), f, r)) {\n          var y = n ? n.evaluate(f, {}, r) : void 0,\n              d = {\n            id: l,\n            properties: u.properties,\n            type: u.type,\n            sourceLayerIndex: c,\n            index: p,\n            geometry: h ? f.geometry : Ra(u),\n            patterns: {},\n            sortKey: y\n          };\n          i.push(d);\n        }\n      }\n\n      n && i.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var m = 0, v = i; m < v.length; m += 1) {\n        var g = v[m],\n            x = g.geometry,\n            b = g.index,\n            w = g.sourceLayerIndex;\n\n        if (this.hasPattern) {\n          var _ = os("line", this.layers, g, this.zoom, e);\n\n          this.patternFeatures.push(_);\n        } else this.addFeature(g, x, b, r, {});\n\n        e.featureIndex.insert(t[b].feature, x, b, w, this.index);\n      }\n    }, Fs.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Fs.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, Fs.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Fs.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Fs.prototype.upload = function (t) {\n      this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ms)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ps), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Fs.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Fs.prototype.lineFeatureClips = function (t) {\n      if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {\n        start: +t.properties.mapbox_clip_start,\n        end: +t.properties.mapbox_clip_end\n      };\n    }, Fs.prototype.addFeature = function (t, e, r, n, i) {\n      var a = this.layers[0].layout,\n          o = a.get("line-join").evaluate(t, {}),\n          s = a.get("line-cap"),\n          u = a.get("line-miter-limit"),\n          l = a.get("line-round-limit");\n      this.lineClips = this.lineFeatureClips(t);\n\n      for (var p = 0, c = e; p < c.length; p += 1) {\n        this.addLine(c[p], t, o, s, u, l);\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, Fs.prototype.addLine = function (t, e, r, n, i, a) {\n      if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {\n        this.lineClipsArray.push(this.lineClips);\n\n        for (var o = 0; o < t.length - 1; o++) {\n          this.totalDistance += t[o].dist(t[o + 1]);\n        }\n\n        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n      }\n\n      for (var s = "Polygon" === Bs[e.type], u = t.length; u >= 2 && t[u - 1].equals(t[u - 2]);) {\n        u--;\n      }\n\n      for (var l = 0; l < u - 1 && t[l].equals(t[l + 1]);) {\n        l++;\n      }\n\n      if (!(u < (s ? 3 : 2))) {\n        "bevel" === r && (i = 1.05);\n        var p,\n            c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n            h = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray),\n            f = void 0,\n            y = void 0,\n            d = void 0,\n            m = void 0;\n        this.e1 = this.e2 = -1, s && (m = t[l].sub(p = t[u - 2])._unit()._perp());\n\n        for (var v = l; v < u; v++) {\n          if (!(y = v === u - 1 ? s ? t[l + 1] : void 0 : t[v + 1]) || !t[v].equals(y)) {\n            m && (d = m), p && (f = p), p = t[v], m = y ? y.sub(p)._unit()._perp() : d;\n            var g = (d = d || m).add(m);\n            0 === g.x && 0 === g.y || g._unit();\n\n            var x = d.x * m.x + d.y * m.y,\n                b = g.x * m.x + g.y * m.y,\n                w = 0 !== b ? 1 / b : 1 / 0,\n                _ = 2 * Math.sqrt(2 - 2 * b),\n                A = b < Ts && f && y,\n                S = d.x * m.y - d.y * m.x > 0;\n\n            if (A && v > l) {\n              var k = p.dist(f);\n\n              if (k > 2 * c) {\n                var I = p.sub(p.sub(f)._mult(c / k)._round());\n                this.updateDistance(f, I), this.addCurrentVertex(I, d, 0, 0, h), f = I;\n              }\n            }\n\n            var z = f && y,\n                C = z ? r : s ? "butt" : n;\n            if (z && "round" === C && (w < a ? C = "miter" : w <= 2 && (C = "fakeround")), "miter" === C && w > i && (C = "bevel"), "bevel" === C && (w > 2 && (C = "flipbevel"), w < i && (C = "miter")), f && this.updateDistance(f, p), "miter" === C) g._mult(w), this.addCurrentVertex(p, g, 0, 0, h);else if ("flipbevel" === C) {\n              if (w > 100) g = m.mult(-1);else {\n                var E = w * d.add(m).mag() / d.sub(m).mag();\n\n                g._perp()._mult(E * (S ? -1 : 1));\n              }\n              this.addCurrentVertex(p, g, 0, 0, h), this.addCurrentVertex(p, g.mult(-1), 0, 0, h);\n            } else if ("bevel" === C || "fakeround" === C) {\n              var P = -Math.sqrt(w * w - 1),\n                  M = S ? P : 0,\n                  B = S ? 0 : P;\n              if (f && this.addCurrentVertex(p, d, M, B, h), "fakeround" === C) for (var T = Math.round(180 * _ / Math.PI / 20), V = 1; V < T; V++) {\n                var F = V / T;\n\n                if (.5 !== F) {\n                  var D = F - .5;\n                  F += F * D * (F - 1) * ((1.0904 + x * (x * (3.55645 - 1.43519 * x) - 3.2452)) * D * D + (.848013 + x * (.215638 * x - 1.06021)));\n                }\n\n                var L = m.sub(d)._mult(F)._add(d)._unit()._mult(S ? -1 : 1);\n\n                this.addHalfVertex(p, L.x, L.y, !1, S, 0, h);\n              }\n              y && this.addCurrentVertex(p, m, -M, -B, h);\n            } else if ("butt" === C) this.addCurrentVertex(p, g, 0, 0, h);else if ("square" === C) {\n              var O = f ? 1 : -1;\n              this.addCurrentVertex(p, g, O, O, h);\n            } else "round" === C && (f && (this.addCurrentVertex(p, d, 0, 0, h), this.addCurrentVertex(p, d, 1, 1, h, !0)), y && (this.addCurrentVertex(p, m, -1, -1, h, !0), this.addCurrentVertex(p, m, 0, 0, h)));\n\n            if (A && v < u - 1) {\n              var R = p.dist(y);\n\n              if (R > 2 * c) {\n                var U = p.add(y.sub(p)._mult(c / R)._round());\n                this.updateDistance(p, U), this.addCurrentVertex(U, m, 0, 0, h), p = U;\n              }\n            }\n          }\n        }\n      }\n    }, Fs.prototype.addCurrentVertex = function (t, e, r, n, i, a) {\n      void 0 === a && (a = !1);\n      var o = e.y * n - e.x,\n          s = -e.y - e.x * n;\n      this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, a, !1, r, i), this.addHalfVertex(t, o, s, a, !0, -n, i), this.distance > Vs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, r, n, i, a));\n    }, Fs.prototype.addHalfVertex = function (t, e, r, n, i, a, o) {\n      var s = .5 * (this.lineClips ? this.scaledDistance * (Vs - 1) : this.scaledDistance);\n      this.layoutVertexArray.emplaceBack((t.x << 1) + (n ? 1 : 0), (t.y << 1) + (i ? 1 : 0), Math.round(63 * e) + 128, Math.round(63 * r) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & s) << 2, s >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);\n      var u = o.vertexLength++;\n      this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), i ? this.e2 = u : this.e1 = u;\n    }, Fs.prototype.updateScaledDistance = function () {\n      this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;\n    }, Fs.prototype.updateDistance = function (t, e) {\n      this.distance += t.dist(e), this.updateScaledDistance();\n    }, On("LineBucket", Fs, {\n      omit: ["layers", "patternFeatures"]\n    });\n    var Ds = new wi({\n      "line-cap": new mi(Et.layout_line["line-cap"]),\n      "line-join": new vi(Et.layout_line["line-join"]),\n      "line-miter-limit": new mi(Et.layout_line["line-miter-limit"]),\n      "line-round-limit": new mi(Et.layout_line["line-round-limit"]),\n      "line-sort-key": new vi(Et.layout_line["line-sort-key"])\n    }),\n        Ls = {\n      paint: new wi({\n        "line-opacity": new vi(Et.paint_line["line-opacity"]),\n        "line-color": new vi(Et.paint_line["line-color"]),\n        "line-translate": new mi(Et.paint_line["line-translate"]),\n        "line-translate-anchor": new mi(Et.paint_line["line-translate-anchor"]),\n        "line-width": new vi(Et.paint_line["line-width"]),\n        "line-gap-width": new vi(Et.paint_line["line-gap-width"]),\n        "line-offset": new vi(Et.paint_line["line-offset"]),\n        "line-blur": new vi(Et.paint_line["line-blur"]),\n        "line-dasharray": new xi(Et.paint_line["line-dasharray"]),\n        "line-pattern": new gi(Et.paint_line["line-pattern"]),\n        "line-gradient": new bi(Et.paint_line["line-gradient"])\n      }),\n      layout: Ds\n    },\n        Os = new (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (e, r) {\n        return r = new si(Math.floor(r.zoom), {\n          now: r.now,\n          fadeDuration: r.fadeDuration,\n          zoomHistory: r.zoomHistory,\n          transition: r.transition\n        }), t.prototype.possiblyEvaluate.call(this, e, r);\n      }, e.prototype.evaluate = function (e, r, n, i) {\n        return r = h({}, r, {\n          zoom: Math.floor(r.zoom)\n        }), t.prototype.evaluate.call(this, e, r, n, i);\n      }, e;\n    }(vi))(Ls.paint.properties["line-width"].specification);\n    Os.useIntegerZoom = !0;\n\n    var Rs = function (t) {\n      function e(e) {\n        t.call(this, e, Ls), this.gradientVersion = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n        "line-gradient" === t && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ne, this.gradientVersion = (this.gradientVersion + 1) % s);\n      }, e.prototype.gradientExpression = function () {\n        return this._transitionablePaint._values["line-gradient"].value.expression;\n      }, e.prototype.recalculate = function (e, r) {\n        t.prototype.recalculate.call(this, e, r), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);\n      }, e.prototype.createBucket = function (t) {\n        return new Fs(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t,\n            r = Us(to("line-width", this, e), to("line-gap-width", this, e)),\n            n = to("line-offset", this, e);\n        return r / 2 + Math.abs(n) + eo(this.paint.get("line-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s) {\n        var u = ro(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, s),\n            l = s / 2 * Us(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),\n            p = this.paint.get("line-offset").evaluate(e, r);\n        return p && (n = function (t, e) {\n          for (var r = [], n = new i(0, 0), a = 0; a < t.length; a++) {\n            for (var o = t[a], s = [], u = 0; u < o.length; u++) {\n              var l = o[u],\n                  p = o[u + 1],\n                  c = 0 === u ? n : l.sub(o[u - 1])._unit()._perp(),\n                  h = u === o.length - 1 ? n : p.sub(l)._unit()._perp(),\n                  f = c._add(h)._unit();\n\n              f._mult(1 / (f.x * h.x + f.y * h.y)), s.push(f._mult(e)._add(l));\n            }\n\n            r.push(s);\n          }\n\n          return r;\n        }(n, p * s)), function (t, e, r) {\n          for (var n = 0; n < e.length; n++) {\n            var i = e[n];\n            if (t.length >= 3) for (var a = 0; a < i.length; a++) {\n              if (Wa(t, i[a])) return !0;\n            }\n            if (Za(t, i, r)) return !0;\n          }\n\n          return !1;\n        }(u, n, l);\n      }, e.prototype.isTileClipped = function () {\n        return !0;\n      }, e;\n    }(_i);\n\n    function Us(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n\n    var js = Ii([{\n      name: "a_pos_offset",\n      components: 4,\n      type: "Int16"\n    }, {\n      name: "a_data",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pixeloffset",\n      components: 4,\n      type: "Int16"\n    }], 4),\n        qs = Ii([{\n      name: "a_projected_pos",\n      components: 3,\n      type: "Float32"\n    }], 4),\n        Ns = (Ii([{\n      name: "a_fade_opacity",\n      components: 1,\n      type: "Uint32"\n    }], 4), Ii([{\n      name: "a_placed",\n      components: 2,\n      type: "Uint8"\n    }, {\n      name: "a_shift",\n      components: 2,\n      type: "Float32"\n    }])),\n        Ks = (Ii([{\n      type: "Int16",\n      name: "anchorPointX"\n    }, {\n      type: "Int16",\n      name: "anchorPointY"\n    }, {\n      type: "Int16",\n      name: "x1"\n    }, {\n      type: "Int16",\n      name: "y1"\n    }, {\n      type: "Int16",\n      name: "x2"\n    }, {\n      type: "Int16",\n      name: "y2"\n    }, {\n      type: "Uint32",\n      name: "featureIndex"\n    }, {\n      type: "Uint16",\n      name: "sourceLayerIndex"\n    }, {\n      type: "Uint16",\n      name: "bucketIndex"\n    }]), Ii([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_anchor_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_extrude",\n      components: 2,\n      type: "Int16"\n    }], 4)),\n        Gs = Ii([{\n      name: "a_pos",\n      components: 2,\n      type: "Float32"\n    }, {\n      name: "a_radius",\n      components: 1,\n      type: "Float32"\n    }, {\n      name: "a_flags",\n      components: 2,\n      type: "Int16"\n    }], 4);\n\n    function Zs(t, e, r) {\n      return t.sections.forEach(function (t) {\n        t.text = function (t, e, r) {\n          var n = e.layout.get("text-transform").evaluate(r, {});\n          return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), oi.applyArabicShaping && (t = oi.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n\n    Ii([{\n      name: "triangle",\n      components: 3,\n      type: "Uint16"\n    }]), Ii([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Uint16",\n      name: "glyphStartIndex"\n    }, {\n      type: "Uint16",\n      name: "numGlyphs"\n    }, {\n      type: "Uint32",\n      name: "vertexStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineLength"\n    }, {\n      type: "Uint16",\n      name: "segment"\n    }, {\n      type: "Uint16",\n      name: "lowerSize"\n    }, {\n      type: "Uint16",\n      name: "upperSize"\n    }, {\n      type: "Float32",\n      name: "lineOffsetX"\n    }, {\n      type: "Float32",\n      name: "lineOffsetY"\n    }, {\n      type: "Uint8",\n      name: "writingMode"\n    }, {\n      type: "Uint8",\n      name: "placedOrientation"\n    }, {\n      type: "Uint8",\n      name: "hidden"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Int16",\n      name: "associatedIconIndex"\n    }]), Ii([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Int16",\n      name: "rightJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "centerJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "leftJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "placedIconSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedIconSymbolIndex"\n    }, {\n      type: "Uint16",\n      name: "key"\n    }, {\n      type: "Uint16",\n      name: "textBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "textBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "featureIndex"\n    }, {\n      type: "Uint16",\n      name: "numHorizontalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numIconVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalIconVertices"\n    }, {\n      type: "Uint16",\n      name: "useRuntimeCollisionCircles"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Float32",\n      name: "textBoxScale"\n    }, {\n      type: "Float32",\n      components: 2,\n      name: "textOffset"\n    }, {\n      type: "Float32",\n      name: "collisionCircleDiameter"\n    }]), Ii([{\n      type: "Float32",\n      name: "offsetX"\n    }]), Ii([{\n      type: "Int16",\n      name: "x"\n    }, {\n      type: "Int16",\n      name: "y"\n    }, {\n      type: "Int16",\n      name: "tileUnitDistanceFromAnchor"\n    }]);\n\n    var Xs = {\n      "!": "︕",\n      "#": "＃",\n      $: "＄",\n      "%": "％",\n      "&": "＆",\n      "(": "︵",\n      ")": "︶",\n      "*": "＊",\n      "+": "＋",\n      ",": "︐",\n      "-": "︲",\n      ".": "・",\n      "/": "／",\n      ":": "︓",\n      ";": "︔",\n      "<": "︿",\n      "=": "＝",\n      ">": "﹀",\n      "?": "︖",\n      "@": "＠",\n      "[": "﹇",\n      "\\\\": "＼",\n      "]": "﹈",\n      "^": "＾",\n      _: "︳",\n      "`": "｀",\n      "{": "︷",\n      "|": "―",\n      "}": "︸",\n      "~": "～",\n      "¢": "￠",\n      "£": "￡",\n      "¥": "￥",\n      "¦": "￤",\n      "¬": "￢",\n      "¯": "￣",\n      "–": "︲",\n      "—": "︱",\n      "‘": "﹃",\n      "’": "﹄",\n      "“": "﹁",\n      "”": "﹂",\n      "…": "︙",\n      "‧": "・",\n      "₩": "￦",\n      "、": "︑",\n      "。": "︒",\n      "〈": "︿",\n      "〉": "﹀",\n      "《": "︽",\n      "》": "︾",\n      "「": "﹁",\n      "」": "﹂",\n      "『": "﹃",\n      "』": "﹄",\n      "【": "︻",\n      "】": "︼",\n      "〔": "︹",\n      "〕": "︺",\n      "〖": "︗",\n      "〗": "︘",\n      "！": "︕",\n      "（": "︵",\n      "）": "︶",\n      "，": "︐",\n      "－": "︲",\n      "．": "・",\n      "：": "︓",\n      "；": "︔",\n      "＜": "︿",\n      "＞": "﹀",\n      "？": "︖",\n      "［": "﹇",\n      "］": "﹈",\n      "＿": "︳",\n      "｛": "︷",\n      "｜": "―",\n      "｝": "︸",\n      "｟": "︵",\n      "｠": "︶",\n      "｡": "︒",\n      "｢": "﹁",\n      "｣": "﹂"\n    },\n        Js = function Js(t, e, r, n, i) {\n      var a,\n          o,\n          s = 8 * i - n - 1,\n          u = (1 << s) - 1,\n          l = u >> 1,\n          p = -7,\n          c = r ? i - 1 : 0,\n          h = r ? -1 : 1,\n          f = t[e + c];\n\n      for (c += h, a = f & (1 << -p) - 1, f >>= -p, p += s; p > 0; a = 256 * a + t[e + c], c += h, p -= 8) {\n        ;\n      }\n\n      for (o = a & (1 << -p) - 1, a >>= -p, p += n; p > 0; o = 256 * o + t[e + c], c += h, p -= 8) {\n        ;\n      }\n\n      if (0 === a) a = 1 - l;else {\n        if (a === u) return o ? NaN : 1 / 0 * (f ? -1 : 1);\n        o += Math.pow(2, n), a -= l;\n      }\n      return (f ? -1 : 1) * o * Math.pow(2, a - n);\n    },\n        Hs = function Hs(t, e, r, n, i, a) {\n      var o,\n          s,\n          u,\n          l = 8 * a - i - 1,\n          p = (1 << l) - 1,\n          c = p >> 1,\n          h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : a - 1,\n          y = n ? 1 : -1,\n          d = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = p) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), (e += o + c >= 1 ? h / u : h * Math.pow(2, 1 - c)) * u >= 2 && (o++, u /= 2), o + c >= p ? (s = 0, o = p) : o + c >= 1 ? (s = (e * u - 1) * Math.pow(2, i), o += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + f] = 255 & s, f += y, s /= 256, i -= 8) {\n        ;\n      }\n\n      for (o = o << i | s, l += i; l > 0; t[r + f] = 255 & o, f += y, o /= 256, l -= 8) {\n        ;\n      }\n\n      t[r + f - y] |= 128 * d;\n    },\n        Ys = $s;\n\n    function $s(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n\n    $s.Varint = 0, $s.Fixed64 = 1, $s.Bytes = 2, $s.Fixed32 = 5;\n    var Ws = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");\n\n    function Qs(t) {\n      return t.type === $s.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n\n    function tu(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n\n    function eu(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n\n      for (var i = r.pos - 1; i >= t; i--) {\n        r.buf[i + n] = r.buf[i];\n      }\n    }\n\n    function ru(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeVarint(t[r]);\n      }\n    }\n\n    function nu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSVarint(t[r]);\n      }\n    }\n\n    function iu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFloat(t[r]);\n      }\n    }\n\n    function au(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeDouble(t[r]);\n      }\n    }\n\n    function ou(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeBoolean(t[r]);\n      }\n    }\n\n    function su(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFixed32(t[r]);\n      }\n    }\n\n    function uu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSFixed32(t[r]);\n      }\n    }\n\n    function lu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFixed64(t[r]);\n      }\n    }\n\n    function pu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSFixed64(t[r]);\n      }\n    }\n\n    function cu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n\n    function hu(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n\n    function fu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n\n    function yu(t, e, r) {\n      1 === t && r.readMessage(du, e);\n    }\n\n    function du(t, e, r) {\n      if (3 === t) {\n        var n = r.readMessage(mu, {}),\n            i = n.width,\n            a = n.height,\n            o = n.left,\n            s = n.top,\n            u = n.advance;\n        e.push({\n          id: n.id,\n          bitmap: new go({\n            width: i + 6,\n            height: a + 6\n          }, n.bitmap),\n          metrics: {\n            width: i,\n            height: a,\n            left: o,\n            top: s,\n            advance: u\n          }\n        });\n      }\n    }\n\n    function mu(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n\n    function vu(t) {\n      for (var e = 0, r = 0, n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        e += a.w * a.h, r = Math.max(r, a.w);\n      }\n\n      t.sort(function (t, e) {\n        return e.h - t.h;\n      });\n\n      for (var o = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }], s = 0, u = 0, l = 0, p = t; l < p.length; l += 1) {\n        for (var c = p[l], h = o.length - 1; h >= 0; h--) {\n          var f = o[h];\n\n          if (!(c.w > f.w || c.h > f.h)) {\n            if (c.x = f.x, c.y = f.y, u = Math.max(u, c.y + c.h), s = Math.max(s, c.x + c.w), c.w === f.w && c.h === f.h) {\n              var y = o.pop();\n              h < o.length && (o[h] = y);\n            } else c.h === f.h ? (f.x += c.w, f.w -= c.w) : c.w === f.w ? (f.y += c.h, f.h -= c.h) : (o.push({\n              x: f.x + c.w,\n              y: f.y,\n              w: f.w - c.w,\n              h: c.h\n            }), f.y += c.h, f.h -= c.h);\n\n            break;\n          }\n        }\n      }\n\n      return {\n        w: s,\n        h: u,\n        fill: e / (s * u) || 0\n      };\n    }\n\n    $s.prototype = {\n      destroy: function destroy() {\n        this.buf = null;\n      },\n      readFields: function readFields(t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n              i = n >> 3,\n              a = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === a && this.skip(n);\n        }\n\n        return e;\n      },\n      readMessage: function readMessage(t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function readFixed32() {\n        var t = cu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function readSFixed32() {\n        var t = fu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function readFixed64() {\n        var t = cu(this.buf, this.pos) + 4294967296 * cu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readSFixed64: function readSFixed64() {\n        var t = cu(this.buf, this.pos) + 4294967296 * fu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readFloat: function readFloat() {\n        var t = Js(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function readDouble() {\n        var t = Js(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function readVarint(t) {\n        var e,\n            r,\n            n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n              i,\n              a = r.buf;\n          if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return tu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return tu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return tu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return tu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return tu(t, n, e);\n          if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return tu(t, n, e);\n          throw new Error("Expected varint not more than 10 bytes");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function readVarint64() {\n        return this.readVarint(!0);\n      },\n      readSVarint: function readSVarint() {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function readBoolean() {\n        return Boolean(this.readVarint());\n      },\n      readString: function readString() {\n        var t = this.readVarint() + this.pos,\n            e = this.pos;\n        return this.pos = t, t - e >= 12 && Ws ? function (t, e, r) {\n          return Ws.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = "", i = e; i < r;) {\n            var a,\n                o,\n                s,\n                u = t[i],\n                l = null,\n                p = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;\n            if (i + p > r) break;\n            1 === p ? u < 128 && (l = u) : 2 === p ? 128 == (192 & (a = t[i + 1])) && (l = (31 & u) << 6 | 63 & a) <= 127 && (l = null) : 3 === p ? (o = t[i + 2], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && ((l = (15 & u) << 12 | (63 & a) << 6 | 63 & o) <= 2047 || l >= 55296 && l <= 57343) && (l = null)) : 4 === p && (o = t[i + 2], s = t[i + 3], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && 128 == (192 & s) && ((l = (15 & u) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) <= 65535 || l >= 1114112) && (l = null)), null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += p;\n          }\n\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function readBytes() {\n        var t = this.readVarint() + this.pos,\n            e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function readPackedVarint(t, e) {\n        if (this.type !== $s.Bytes) return t.push(this.readVarint(e));\n        var r = Qs(this);\n\n        for (t = t || []; this.pos < r;) {\n          t.push(this.readVarint(e));\n        }\n\n        return t;\n      },\n      readPackedSVarint: function readPackedSVarint(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readSVarint());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSVarint());\n        }\n\n        return t;\n      },\n      readPackedBoolean: function readPackedBoolean(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readBoolean());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readBoolean());\n        }\n\n        return t;\n      },\n      readPackedFloat: function readPackedFloat(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readFloat());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFloat());\n        }\n\n        return t;\n      },\n      readPackedDouble: function readPackedDouble(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readDouble());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readDouble());\n        }\n\n        return t;\n      },\n      readPackedFixed32: function readPackedFixed32(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readFixed32());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFixed32());\n        }\n\n        return t;\n      },\n      readPackedSFixed32: function readPackedSFixed32(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readSFixed32());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSFixed32());\n        }\n\n        return t;\n      },\n      readPackedFixed64: function readPackedFixed64(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readFixed64());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFixed64());\n        }\n\n        return t;\n      },\n      readPackedSFixed64: function readPackedSFixed64(t) {\n        if (this.type !== $s.Bytes) return t.push(this.readSFixed64());\n        var e = Qs(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSFixed64());\n        }\n\n        return t;\n      },\n      skip: function skip(t) {\n        var e = 7 & t;\n        if (e === $s.Varint) for (; this.buf[this.pos++] > 127;) {\n          ;\n        } else if (e === $s.Bytes) this.pos = this.readVarint() + this.pos;else if (e === $s.Fixed32) this.pos += 4;else {\n          if (e !== $s.Fixed64) throw new Error("Unimplemented type: " + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function writeTag(t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function realloc(t) {\n        for (var e = this.length || 16; e < this.pos + t;) {\n          e *= 2;\n        }\n\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function finish() {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function writeFixed32(t) {\n        this.realloc(4), hu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function writeSFixed32(t) {\n        this.realloc(4), hu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function writeFixed64(t) {\n        this.realloc(8), hu(this.buf, -1 & t, this.pos), hu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function writeSFixed64(t) {\n        this.realloc(8), hu(this.buf, -1 & t, this.pos), hu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function writeVarint(t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn\'t fit into 10 bytes");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function writeSVarint(t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function writeBoolean(t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function writeString(t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n\n        this.pos = function (t, e, r) {\n          for (var n, i, a = 0; a < e.length; a++) {\n            if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || a + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n\n          return r;\n        }(this.buf, t, this.pos);\n\n        var r = this.pos - e;\n        r >= 128 && eu(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function writeFloat(t) {\n        this.realloc(4), Hs(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function writeDouble(t) {\n        this.realloc(8), Hs(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function writeBytes(t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n\n        for (var r = 0; r < e; r++) {\n          this.buf[this.pos++] = t[r];\n        }\n      },\n      writeRawMessage: function writeRawMessage(t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && eu(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function writeMessage(t, e, r) {\n        this.writeTag(t, $s.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function writePackedVarint(t, e) {\n        e.length && this.writeMessage(t, ru, e);\n      },\n      writePackedSVarint: function writePackedSVarint(t, e) {\n        e.length && this.writeMessage(t, nu, e);\n      },\n      writePackedBoolean: function writePackedBoolean(t, e) {\n        e.length && this.writeMessage(t, ou, e);\n      },\n      writePackedFloat: function writePackedFloat(t, e) {\n        e.length && this.writeMessage(t, iu, e);\n      },\n      writePackedDouble: function writePackedDouble(t, e) {\n        e.length && this.writeMessage(t, au, e);\n      },\n      writePackedFixed32: function writePackedFixed32(t, e) {\n        e.length && this.writeMessage(t, su, e);\n      },\n      writePackedSFixed32: function writePackedSFixed32(t, e) {\n        e.length && this.writeMessage(t, uu, e);\n      },\n      writePackedFixed64: function writePackedFixed64(t, e) {\n        e.length && this.writeMessage(t, lu, e);\n      },\n      writePackedSFixed64: function writePackedSFixed64(t, e) {\n        e.length && this.writeMessage(t, pu, e);\n      },\n      writeBytesField: function writeBytesField(t, e) {\n        this.writeTag(t, $s.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function writeFixed32Field(t, e) {\n        this.writeTag(t, $s.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function writeSFixed32Field(t, e) {\n        this.writeTag(t, $s.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function writeFixed64Field(t, e) {\n        this.writeTag(t, $s.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function writeSFixed64Field(t, e) {\n        this.writeTag(t, $s.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function writeVarintField(t, e) {\n        this.writeTag(t, $s.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function writeSVarintField(t, e) {\n        this.writeTag(t, $s.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function writeStringField(t, e) {\n        this.writeTag(t, $s.Bytes), this.writeString(e);\n      },\n      writeFloatField: function writeFloatField(t, e) {\n        this.writeTag(t, $s.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function writeDoubleField(t, e) {\n        this.writeTag(t, $s.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function writeBooleanField(t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n\n    var gu = function gu(t, e) {\n      var r = e.pixelRatio,\n          n = e.version,\n          i = e.stretchX,\n          a = e.stretchY,\n          o = e.content;\n      this.paddedRect = t, this.pixelRatio = r, this.stretchX = i, this.stretchY = a, this.content = o, this.version = n;\n    },\n        xu = {\n      tl: {\n        configurable: !0\n      },\n      br: {\n        configurable: !0\n      },\n      tlbr: {\n        configurable: !0\n      },\n      displaySize: {\n        configurable: !0\n      }\n    };\n\n    xu.tl.get = function () {\n      return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n    }, xu.br.get = function () {\n      return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n    }, xu.tlbr.get = function () {\n      return this.tl.concat(this.br);\n    }, xu.displaySize.get = function () {\n      return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n    }, Object.defineProperties(gu.prototype, xu);\n\n    var bu = function bu(t, e) {\n      var r = {},\n          n = {};\n      this.haveRenderCallbacks = [];\n      var i = [];\n      this.addImages(t, r, i), this.addImages(e, n, i);\n      var a = vu(i),\n          o = new xo({\n        width: a.w || 1,\n        height: a.h || 1\n      });\n\n      for (var s in t) {\n        var u = t[s],\n            l = r[s].paddedRect;\n        xo.copy(u.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: l.x + 1,\n          y: l.y + 1\n        }, u.data);\n      }\n\n      for (var p in e) {\n        var c = e[p],\n            h = n[p].paddedRect,\n            f = h.x + 1,\n            y = h.y + 1,\n            d = c.data.width,\n            m = c.data.height;\n        xo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y\n        }, c.data), xo.copy(c.data, o, {\n          x: 0,\n          y: m - 1\n        }, {\n          x: f,\n          y: y - 1\n        }, {\n          width: d,\n          height: 1\n        }), xo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y + m\n        }, {\n          width: d,\n          height: 1\n        }), xo.copy(c.data, o, {\n          x: d - 1,\n          y: 0\n        }, {\n          x: f - 1,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        }), xo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f + d,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        });\n      }\n\n      this.image = o, this.iconPositions = r, this.patternPositions = n;\n    };\n\n    bu.prototype.addImages = function (t, e, r) {\n      for (var n in t) {\n        var i = t[n],\n            a = {\n          x: 0,\n          y: 0,\n          w: i.data.width + 2,\n          h: i.data.height + 2\n        };\n        r.push(a), e[n] = new gu(a, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n      }\n    }, bu.prototype.patchUpdatedImages = function (t, e) {\n      for (var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks), t.updatedImages) {\n        this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n      }\n    }, bu.prototype.patchUpdatedImage = function (t, e, r) {\n      if (t && e && t.version !== e.version) {\n        t.version = e.version;\n        var n = t.tl;\n        r.update(e.data, void 0, {\n          x: n[0],\n          y: n[1]\n        });\n      }\n    }, On("ImagePosition", gu), On("ImageAtlas", bu);\n\n    var wu = {\n      horizontal: 1,\n      vertical: 2,\n      horizontalOnly: 3\n    },\n        _u = function _u() {\n      this.scale = 1, this.fontStack = "", this.imageName = null;\n    };\n\n    _u.forText = function (t, e) {\n      var r = new _u();\n      return r.scale = t || 1, r.fontStack = e, r;\n    }, _u.forImage = function (t) {\n      var e = new _u();\n      return e.imageName = t, e;\n    };\n\n    var Au = function Au() {\n      this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n    };\n\n    function Su(t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d) {\n      var m,\n          v = Au.fromFeature(t, i);\n      c === wu.vertical && v.verticalizePunctuation();\n      var g = oi.processBidirectionalText,\n          x = oi.processStyledBidirectionalText;\n\n      if (g && 1 === v.sections.length) {\n        m = [];\n\n        for (var b = 0, w = g(v.toString(), Mu(v, l, a, e, n, f, y)); b < w.length; b += 1) {\n          var _ = w[b],\n              A = new Au();\n          A.text = _, A.sections = v.sections;\n\n          for (var S = 0; S < _.length; S++) {\n            A.sectionIndex.push(0);\n          }\n\n          m.push(A);\n        }\n      } else if (x) {\n        m = [];\n\n        for (var k = 0, I = x(v.text, v.sectionIndex, Mu(v, l, a, e, n, f, y)); k < I.length; k += 1) {\n          var z = I[k],\n              C = new Au();\n          C.text = z[0], C.sectionIndex = z[1], C.sections = v.sections, m.push(C);\n        }\n      } else m = function (t, e) {\n        for (var r = [], n = t.text, i = 0, a = 0, o = e; a < o.length; a += 1) {\n          var s = o[a];\n          r.push(t.substring(i, s)), i = s;\n        }\n\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(v, Mu(v, l, a, e, n, f, y));\n\n      var E = [],\n          P = {\n        positionedLines: E,\n        text: v.toString(),\n        top: p[1],\n        bottom: p[1],\n        left: p[0],\n        right: p[0],\n        writingMode: c,\n        iconsInText: !1,\n        verticalizable: !1\n      };\n      return function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        for (var h = 0, f = -17, y = 0, d = 0, m = "right" === s ? 1 : "left" === s ? 0 : .5, v = 0, g = 0, x = i; g < x.length; g += 1) {\n          var b = x[g];\n          b.trim();\n\n          var w = b.getMaxScale(),\n              _ = 24 * (w - 1),\n              A = {\n            positionedGlyphs: [],\n            lineOffset: 0\n          };\n\n          t.positionedLines[v] = A;\n          var S = A.positionedGlyphs,\n              k = 0;\n\n          if (b.length()) {\n            for (var I = 0; I < b.length(); I++) {\n              var z = b.getSection(I),\n                  C = b.getSectionIndex(I),\n                  E = b.getCharCode(I),\n                  P = 0,\n                  M = null,\n                  B = null,\n                  T = null,\n                  V = 24,\n                  F = !(u === wu.horizontal || !p && !Xn(E) || p && (ku[E] || (K = E, Gn.Arabic(K) || Gn["Arabic Supplement"](K) || Gn["Arabic Extended-A"](K) || Gn["Arabic Presentation Forms-A"](K) || Gn["Arabic Presentation Forms-B"](K))));\n\n              if (z.imageName) {\n                var D = n[z.imageName];\n                if (!D) continue;\n                T = z.imageName, t.iconsInText = t.iconsInText || !0, B = D.paddedRect;\n                var L = D.displaySize;\n                z.scale = 24 * z.scale / c, P = _ + (24 - L[1] * z.scale), V = (M = {\n                  width: L[0],\n                  height: L[1],\n                  left: 1,\n                  top: -3,\n                  advance: F ? L[1] : L[0]\n                }).advance;\n                var O = F ? L[0] * z.scale - 24 * w : L[1] * z.scale - 24 * w;\n                O > 0 && O > k && (k = O);\n              } else {\n                var R = r[z.fontStack],\n                    U = R && R[E];\n                if (U && U.rect) B = U.rect, M = U.metrics;else {\n                  var j = e[z.fontStack],\n                      q = j && j[E];\n                  if (!q) continue;\n                  M = q.metrics;\n                }\n                P = 24 * (w - z.scale);\n              }\n\n              F ? (t.verticalizable = !0, S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += V * z.scale + l) : (S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += M.advance * z.scale + l);\n            }\n\n            0 !== S.length && (y = Math.max(h - l, y), Tu(S, 0, S.length - 1, m, k)), h = 0;\n            var N = a * w + k;\n            A.lineOffset = Math.max(k, _), f += N, d = Math.max(N, d), ++v;\n          } else f += a, ++v;\n        }\n\n        var K,\n            G = f - -17,\n            Z = Bu(o),\n            X = Z.horizontalAlign,\n            J = Z.verticalAlign;\n        (function (t, e, r, n, i, a, o, s, u) {\n          var l,\n              p = (e - r) * i;\n          l = a !== o ? -s * n - -17 : (-n * u + .5) * o;\n\n          for (var c = 0, h = t; c < h.length; c += 1) {\n            for (var f = 0, y = h[c].positionedGlyphs; f < y.length; f += 1) {\n              var d = y[f];\n              d.x += p, d.y += l;\n            }\n          }\n        })(t.positionedLines, m, X, J, y, d, a, G, i.length), t.top += -J * G, t.bottom = t.top + G, t.left += -X * y, t.right = t.left + y;\n      }(P, e, r, n, m, o, s, u, c, l, h, d), !function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          if (0 !== r[e].positionedGlyphs.length) return !1;\n        }\n\n        return !0;\n      }(E) && P;\n    }\n\n    Au.fromFeature = function (t, e) {\n      for (var r = new Au(), n = 0; n < t.sections.length; n++) {\n        var i = t.sections[n];\n        i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n      }\n\n      return r;\n    }, Au.prototype.length = function () {\n      return this.text.length;\n    }, Au.prototype.getSection = function (t) {\n      return this.sections[this.sectionIndex[t]];\n    }, Au.prototype.getSectionIndex = function (t) {\n      return this.sectionIndex[t];\n    }, Au.prototype.getCharCode = function (t) {\n      return this.text.charCodeAt(t);\n    }, Au.prototype.verticalizePunctuation = function () {\n      this.text = function (t) {\n        for (var e = "", r = 0; r < t.length; r++) {\n          var n = t.charCodeAt(r + 1) || null,\n              i = t.charCodeAt(r - 1) || null;\n          e += n && Jn(n) && !Xs[t[r + 1]] || i && Jn(i) && !Xs[t[r - 1]] || !Xs[t[r]] ? t[r] : Xs[t[r]];\n        }\n\n        return e;\n      }(this.text);\n    }, Au.prototype.trim = function () {\n      for (var t = 0, e = 0; e < this.text.length && ku[this.text.charCodeAt(e)]; e++) {\n        t++;\n      }\n\n      for (var r = this.text.length, n = this.text.length - 1; n >= 0 && n >= t && ku[this.text.charCodeAt(n)]; n--) {\n        r--;\n      }\n\n      this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);\n    }, Au.prototype.substring = function (t, e) {\n      var r = new Au();\n      return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n    }, Au.prototype.toString = function () {\n      return this.text;\n    }, Au.prototype.getMaxScale = function () {\n      var t = this;\n      return this.sectionIndex.reduce(function (e, r) {\n        return Math.max(e, t.sections[r].scale);\n      }, 0);\n    }, Au.prototype.addTextSection = function (t, e) {\n      this.text += t.text, this.sections.push(_u.forText(t.scale, t.fontStack || e));\n\n      for (var r = this.sections.length - 1, n = 0; n < t.text.length; ++n) {\n        this.sectionIndex.push(r);\n      }\n    }, Au.prototype.addImageSection = function (t) {\n      var e = t.image ? t.image.name : "";\n\n      if (0 !== e.length) {\n        var r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(_u.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");\n      } else A("Can\'t add FormattedSection with an empty image.");\n    }, Au.prototype.getNextImageSectionCharCode = function () {\n      return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n    };\n    var ku = {\n      9: !0,\n      10: !0,\n      11: !0,\n      12: !0,\n      13: !0,\n      32: !0\n    },\n        Iu = {};\n\n    function zu(t, e, r, n, i, a) {\n      if (e.imageName) {\n        var o = n[e.imageName];\n        return o ? o.displaySize[0] * e.scale * 24 / a + i : 0;\n      }\n\n      var s = r[e.fontStack],\n          u = s && s[t];\n      return u ? u.metrics.advance * e.scale + i : 0;\n    }\n\n    function Cu(t, e, r, n) {\n      var i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n\n    function Eu(t, e, r) {\n      var n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n\n    function Pu(t, e, r, n, i, a) {\n      for (var o = null, s = Cu(e, r, i, a), u = 0, l = n; u < l.length; u += 1) {\n        var p = l[u],\n            c = Cu(e - p.x, r, i, a) + p.badness;\n        c <= s && (o = p, s = c);\n      }\n\n      return {\n        index: t,\n        x: e,\n        priorBreak: o,\n        badness: s\n      };\n    }\n\n    function Mu(t, e, r, n, i, a, o) {\n      if ("point" !== a) return [];\n      if (!t) return [];\n\n      for (var s, u = [], l = function (t, e, r, n, i, a) {\n        for (var o = 0, s = 0; s < t.length(); s++) {\n          var u = t.getSection(s);\n          o += zu(t.getCharCode(s), u, n, i, e, a);\n        }\n\n        return o / Math.max(1, Math.ceil(o / r));\n      }(t, e, r, n, i, o), p = t.text.indexOf("​") >= 0, c = 0, h = 0; h < t.length(); h++) {\n        var f = t.getSection(h),\n            y = t.getCharCode(h);\n\n        if (ku[y] || (c += zu(y, f, n, i, e, o)), h < t.length() - 1) {\n          var d = !((s = y) < 11904 || !(Gn["Bopomofo Extended"](s) || Gn.Bopomofo(s) || Gn["CJK Compatibility Forms"](s) || Gn["CJK Compatibility Ideographs"](s) || Gn["CJK Compatibility"](s) || Gn["CJK Radicals Supplement"](s) || Gn["CJK Strokes"](s) || Gn["CJK Symbols and Punctuation"](s) || Gn["CJK Unified Ideographs Extension A"](s) || Gn["CJK Unified Ideographs"](s) || Gn["Enclosed CJK Letters and Months"](s) || Gn["Halfwidth and Fullwidth Forms"](s) || Gn.Hiragana(s) || Gn["Ideographic Description Characters"](s) || Gn["Kangxi Radicals"](s) || Gn["Katakana Phonetic Extensions"](s) || Gn.Katakana(s) || Gn["Vertical Forms"](s) || Gn["Yi Radicals"](s) || Gn["Yi Syllables"](s)));\n          (Iu[y] || d || f.imageName) && u.push(Pu(h + 1, c, l, u, Eu(y, t.getCharCode(h + 1), d && p), !1));\n        }\n      }\n\n      return function t(e) {\n        return e ? t(e.priorBreak).concat(e.index) : [];\n      }(Pu(t.length(), c, l, u, 0, !0));\n    }\n\n    function Bu(t) {\n      var e = .5,\n          r = .5;\n\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          e = 1;\n          break;\n\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          e = 0;\n      }\n\n      switch (t) {\n        case "bottom":\n        case "bottom-right":\n        case "bottom-left":\n          r = 1;\n          break;\n\n        case "top":\n        case "top-right":\n        case "top-left":\n          r = 0;\n      }\n\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n\n    function Tu(t, e, r, n, i) {\n      if (n || i) for (var a = t[r], o = (t[r].x + a.metrics.advance * a.scale) * n, s = e; s <= r; s++) {\n        t[s].x -= o, t[s].y += i;\n      }\n    }\n\n    function Vu(t, e, r, n, i, a) {\n      var o,\n          s = t.image;\n\n      if (s.content) {\n        var u = s.content,\n            l = s.pixelRatio || 1;\n        o = [u[0] / l, u[1] / l, s.displaySize[0] - u[2] / l, s.displaySize[1] - u[3] / l];\n      }\n\n      var p,\n          c,\n          h,\n          f,\n          y = e.left * a,\n          d = e.right * a;\n      "width" === r || "both" === r ? (f = i[0] + y - n[3], c = i[0] + d + n[1]) : c = (f = i[0] + (y + d - s.displaySize[0]) / 2) + s.displaySize[0];\n      var m = e.top * a,\n          v = e.bottom * a;\n      return "height" === r || "both" === r ? (p = i[1] + m - n[0], h = i[1] + v + n[2]) : h = (p = i[1] + (m + v - s.displaySize[1]) / 2) + s.displaySize[1], {\n        image: s,\n        top: p,\n        right: c,\n        bottom: h,\n        left: f,\n        collisionPadding: o\n      };\n    }\n\n    Iu[10] = !0, Iu[32] = !0, Iu[38] = !0, Iu[40] = !0, Iu[41] = !0, Iu[43] = !0, Iu[45] = !0, Iu[47] = !0, Iu[173] = !0, Iu[183] = !0, Iu[8203] = !0, Iu[8208] = !0, Iu[8211] = !0, Iu[8231] = !0;\n\n    var Fu = function (t) {\n      function e(e, r, n, i) {\n        t.call(this, e, r), this.angle = n, void 0 !== i && (this.segment = i);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.clone = function () {\n        return new e(this.x, this.y, this.angle, this.segment);\n      }, e;\n    }(i);\n\n    function Du(t, e) {\n      var r = e.expression;\n      if ("constant" === r.kind) return {\n        kind: "constant",\n        layoutSize: r.evaluate(new si(t + 1))\n      };\n      if ("source" === r.kind) return {\n        kind: "source"\n      };\n\n      for (var n = r.zoomStops, i = r.interpolationType, a = 0; a < n.length && n[a] <= t;) {\n        a++;\n      }\n\n      for (var o = a = Math.max(0, a - 1); o < n.length && n[o] < t + 1;) {\n        o++;\n      }\n\n      o = Math.min(n.length - 1, o);\n      var s = n[a],\n          u = n[o];\n      return "composite" === r.kind ? {\n        kind: "composite",\n        minZoom: s,\n        maxZoom: u,\n        interpolationType: i\n      } : {\n        kind: "camera",\n        minZoom: s,\n        maxZoom: u,\n        minSize: r.evaluate(new si(s)),\n        maxSize: r.evaluate(new si(u)),\n        interpolationType: i\n      };\n    }\n\n    function Lu(t, e, r) {\n      var n = e.uSize,\n          i = r.lowerSize;\n      return "source" === t.kind ? i / 128 : "composite" === t.kind ? Ke(i / 128, r.upperSize / 128, e.uSizeT) : n;\n    }\n\n    function Ou(t, e) {\n      var r = 0,\n          n = 0;\n      if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {\n        var i = t.interpolationType,\n            a = i ? p(ar.interpolationFactor(i, e, t.minZoom, t.maxZoom), 0, 1) : 0;\n        "camera" === t.kind ? n = Ke(t.minSize, t.maxSize, a) : r = a;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n\n    On("Anchor", Fu);\n    var Ru = Object.freeze({\n      __proto__: null,\n      getSizeData: Du,\n      evaluateSizeForFeature: Lu,\n      evaluateSizeForZoom: Ou,\n      SIZE_PACK_FACTOR: 128\n    });\n\n    function Uu(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n\n      for (var a = e, o = e.segment + 1, s = 0; s > -r / 2;) {\n        if (--o < 0) return !1;\n        s -= t[o].dist(a), a = t[o];\n      }\n\n      s += t[o].dist(t[o + 1]), o++;\n\n      for (var u = [], l = 0; s < r / 2;) {\n        var p = t[o],\n            c = t[o + 1];\n        if (!c) return !1;\n        var h = t[o - 1].angleTo(p) - p.angleTo(c);\n\n        for (h = Math.abs((h + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u.push({\n          distance: s,\n          angleDelta: h\n        }), l += h; s - u[0].distance > n;) {\n          l -= u.shift().angleDelta;\n        }\n\n        if (l > i) return !1;\n        o++, s += p.dist(c);\n      }\n\n      return !0;\n    }\n\n    function ju(t) {\n      for (var e = 0, r = 0; r < t.length - 1; r++) {\n        e += t[r].dist(t[r + 1]);\n      }\n\n      return e;\n    }\n\n    function qu(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n\n    function Nu(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n\n    function Ku(t, e, r, n, i, a) {\n      for (var o = qu(r, i, a), s = Nu(r, n) * a, u = 0, l = ju(t) / 2, p = 0; p < t.length - 1; p++) {\n        var c = t[p],\n            h = t[p + 1],\n            f = c.dist(h);\n\n        if (u + f > l) {\n          var y = (l - u) / f,\n              d = Ke(c.x, h.x, y),\n              m = Ke(c.y, h.y, y),\n              v = new Fu(d, m, h.angleTo(c), p);\n          return v._round(), !o || Uu(t, v, s, o, e) ? v : void 0;\n        }\n\n        u += f;\n      }\n    }\n\n    function Gu(t, e, r, n, i, a, o, s, u) {\n      var l = qu(n, a, o),\n          p = Nu(n, i),\n          c = p * o,\n          h = 0 === t[0].x || t[0].x === u || 0 === t[0].y || t[0].y === u;\n      return e - c < e / 4 && (e = c + e / 4), function t(e, r, n, i, a, o, s, u, l) {\n        for (var p = o / 2, c = ju(e), h = 0, f = r - n, y = [], d = 0; d < e.length - 1; d++) {\n          for (var m = e[d], v = e[d + 1], g = m.dist(v), x = v.angleTo(m); f + n < h + g;) {\n            var b = ((f += n) - h) / g,\n                w = Ke(m.x, v.x, b),\n                _ = Ke(m.y, v.y, b);\n\n            if (w >= 0 && w < l && _ >= 0 && _ < l && f - p >= 0 && f + p <= c) {\n              var A = new Fu(w, _, x, d);\n              A._round(), i && !Uu(e, A, o, i, a) || y.push(A);\n            }\n          }\n\n          h += g;\n        }\n\n        return u || y.length || s || (y = t(e, h / 2, n, i, a, o, s, !0, l)), y;\n      }(t, h ? e / 2 * s % e : (p / 2 + 2 * a) * o * s % e, e, l, r, c, h, !1, u);\n    }\n\n    function Zu(t, e, r, n, a) {\n      for (var o = [], s = 0; s < t.length; s++) {\n        for (var u = t[s], l = void 0, p = 0; p < u.length - 1; p++) {\n          var c = u[p],\n              h = u[p + 1];\n          c.x < e && h.x < e || (c.x < e ? c = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x < e && (h = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y < r && h.y < r || (c.y < r ? c = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round() : h.y < r && (h = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round()), c.x >= n && h.x >= n || (c.x >= n ? c = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x >= n && (h = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y >= a && h.y >= a || (c.y >= a ? c = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round() : h.y >= a && (h = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round()), l && c.equals(l[l.length - 1]) || o.push(l = [c]), l.push(h)))));\n        }\n      }\n\n      return o;\n    }\n\n    function Xu(t, e, r, n) {\n      var a = [],\n          o = t.image,\n          s = o.pixelRatio,\n          u = o.paddedRect.w - 2,\n          l = o.paddedRect.h - 2,\n          p = t.right - t.left,\n          c = t.bottom - t.top,\n          h = o.stretchX || [[0, u]],\n          f = o.stretchY || [[0, l]],\n          y = function y(t, e) {\n        return t + e[1] - e[0];\n      },\n          d = h.reduce(y, 0),\n          m = f.reduce(y, 0),\n          v = u - d,\n          g = l - m,\n          x = 0,\n          b = d,\n          w = 0,\n          _ = m,\n          A = 0,\n          S = v,\n          k = 0,\n          I = g;\n\n      if (o.content && n) {\n        var z = o.content;\n        x = Ju(h, 0, z[0]), w = Ju(f, 0, z[1]), b = Ju(h, z[0], z[2]), _ = Ju(f, z[1], z[3]), A = z[0] - x, k = z[1] - w, S = z[2] - z[0] - b, I = z[3] - z[1] - _;\n      }\n\n      var C = function C(n, a, u, l) {\n        var h = Yu(n.stretch - x, b, p, t.left),\n            f = $u(n.fixed - A, S, n.stretch, d),\n            y = Yu(a.stretch - w, _, c, t.top),\n            v = $u(a.fixed - k, I, a.stretch, m),\n            g = Yu(u.stretch - x, b, p, t.left),\n            z = $u(u.fixed - A, S, u.stretch, d),\n            C = Yu(l.stretch - w, _, c, t.top),\n            E = $u(l.fixed - k, I, l.stretch, m),\n            P = new i(h, y),\n            M = new i(g, y),\n            B = new i(g, C),\n            T = new i(h, C),\n            V = new i(f / s, v / s),\n            F = new i(z / s, E / s),\n            D = e * Math.PI / 180;\n\n        if (D) {\n          var L = Math.sin(D),\n              O = Math.cos(D),\n              R = [O, -L, L, O];\n          P._matMult(R), M._matMult(R), T._matMult(R), B._matMult(R);\n        }\n\n        var U = n.stretch + n.fixed,\n            j = a.stretch + a.fixed;\n        return {\n          tl: P,\n          tr: M,\n          bl: T,\n          br: B,\n          tex: {\n            x: o.paddedRect.x + 1 + U,\n            y: o.paddedRect.y + 1 + j,\n            w: u.stretch + u.fixed - U,\n            h: l.stretch + l.fixed - j\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: V,\n          pixelOffsetBR: F,\n          minFontScaleX: S / s / p,\n          minFontScaleY: I / s / c,\n          isSDF: r\n        };\n      };\n\n      if (n && (o.stretchX || o.stretchY)) for (var E = Hu(h, v, d), P = Hu(f, g, m), M = 0; M < E.length - 1; M++) {\n        for (var B = E[M], T = E[M + 1], V = 0; V < P.length - 1; V++) {\n          a.push(C(B, P[V], T, P[V + 1]));\n        }\n      } else a.push(C({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n      return a;\n    }\n\n    function Ju(t, e, r) {\n      for (var n = 0, i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i];\n        n += Math.max(e, Math.min(r, o[1])) - Math.max(e, Math.min(r, o[0]));\n      }\n\n      return n;\n    }\n\n    function Hu(t, e, r) {\n      for (var n = [{\n        fixed: -1,\n        stretch: 0\n      }], i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i],\n            s = o[0],\n            u = o[1],\n            l = n[n.length - 1];\n        n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch\n        }), n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch + (u - s)\n        });\n      }\n\n      return n.push({\n        fixed: e + 1,\n        stretch: r\n      }), n;\n    }\n\n    function Yu(t, e, r, n) {\n      return t / e * r + n;\n    }\n\n    function $u(t, e, r, n) {\n      return t - e * r / n;\n    }\n\n    var Wu = function Wu(t, e, r, n, a, o, s, u, l, p) {\n      if (this.boxStartIndex = t.length, l) {\n        var c = o.top,\n            h = o.bottom,\n            f = o.collisionPadding;\n        f && (c -= f[1], h += f[3]);\n        var y = h - c;\n        y > 0 && (y = Math.max(10, y), this.circleDiameter = y);\n      } else {\n        var d = o.top * s - u,\n            m = o.bottom * s + u,\n            v = o.left * s - u,\n            g = o.right * s + u,\n            x = o.collisionPadding;\n\n        if (x && (v -= x[0] * s, d -= x[1] * s, g += x[2] * s, m += x[3] * s), p) {\n          var b = new i(v, d),\n              w = new i(g, d),\n              _ = new i(v, m),\n              A = new i(g, m),\n              S = p * Math.PI / 180;\n\n          b._rotate(S), w._rotate(S), _._rotate(S), A._rotate(S), v = Math.min(b.x, w.x, _.x, A.x), g = Math.max(b.x, w.x, _.x, A.x), d = Math.min(b.y, w.y, _.y, A.y), m = Math.max(b.y, w.y, _.y, A.y);\n        }\n\n        t.emplaceBack(e.x, e.y, v, d, g, m, r, n, a);\n      }\n\n      this.boxEndIndex = t.length;\n    },\n        Qu = function Qu(t, e) {\n      if (void 0 === t && (t = []), void 0 === e && (e = tl), this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (var r = (this.length >> 1) - 1; r >= 0; r--) {\n        this._down(r);\n      }\n    };\n\n    function tl(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function el(t, e, r) {\n      void 0 === e && (e = 1), void 0 === r && (r = !1);\n\n      for (var n = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, u = t[0], l = 0; l < u.length; l++) {\n        var p = u[l];\n        (!l || p.x < n) && (n = p.x), (!l || p.y < a) && (a = p.y), (!l || p.x > o) && (o = p.x), (!l || p.y > s) && (s = p.y);\n      }\n\n      var c = Math.min(o - n, s - a),\n          h = c / 2,\n          f = new Qu([], rl);\n      if (0 === c) return new i(n, a);\n\n      for (var y = n; y < o; y += c) {\n        for (var d = a; d < s; d += c) {\n          f.push(new nl(y + h, d + h, h, t));\n        }\n      }\n\n      for (var m = function (t) {\n        for (var e = 0, r = 0, n = 0, i = t[0], a = 0, o = i.length, s = o - 1; a < o; s = a++) {\n          var u = i[a],\n              l = i[s],\n              p = u.x * l.y - l.x * u.y;\n          r += (u.x + l.x) * p, n += (u.y + l.y) * p, e += 3 * p;\n        }\n\n        return new nl(r / e, n / e, 0, t);\n      }(t), v = f.length; f.length;) {\n        var g = f.pop();\n        (g.d > m.d || !m.d) && (m = g, r && console.log("found best %d after %d probes", Math.round(1e4 * g.d) / 1e4, v)), g.max - m.d <= e || (f.push(new nl(g.p.x - (h = g.h / 2), g.p.y - h, h, t)), f.push(new nl(g.p.x + h, g.p.y - h, h, t)), f.push(new nl(g.p.x - h, g.p.y + h, h, t)), f.push(new nl(g.p.x + h, g.p.y + h, h, t)), v += 4);\n      }\n\n      return r && (console.log("num probes: " + v), console.log("best distance: " + m.d)), m.p;\n    }\n\n    function rl(t, e) {\n      return e.max - t.max;\n    }\n\n    function nl(t, e, r, n) {\n      this.p = new i(t, e), this.h = r, this.d = function (t, e) {\n        for (var r = !1, n = 1 / 0, i = 0; i < e.length; i++) {\n          for (var a = e[i], o = 0, s = a.length, u = s - 1; o < s; u = o++) {\n            var l = a[o],\n                p = a[u];\n            l.y > t.y != p.y > t.y && t.x < (p.x - l.x) * (t.y - l.y) / (p.y - l.y) + l.x && (r = !r), n = Math.min(n, Ya(t, l, p));\n          }\n        }\n\n        return (r ? 1 : -1) * Math.sqrt(n);\n      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n    }\n\n    Qu.prototype.push = function (t) {\n      this.data.push(t), this.length++, this._up(this.length - 1);\n    }, Qu.prototype.pop = function () {\n      if (0 !== this.length) {\n        var t = this.data[0],\n            e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n    }, Qu.prototype.peek = function () {\n      return this.data[0];\n    }, Qu.prototype._up = function (t) {\n      for (var e = this.data, r = this.compare, n = e[t]; t > 0;) {\n        var i = t - 1 >> 1,\n            a = e[i];\n        if (r(n, a) >= 0) break;\n        e[t] = a, t = i;\n      }\n\n      e[t] = n;\n    }, Qu.prototype._down = function (t) {\n      for (var e = this.data, r = this.compare, n = this.length >> 1, i = e[t]; t < n;) {\n        var a = 1 + (t << 1),\n            o = e[a],\n            s = a + 1;\n        if (s < this.length && r(e[s], o) < 0 && (a = s, o = e[s]), r(o, i) >= 0) break;\n        e[t] = o, t = a;\n      }\n\n      e[t] = i;\n    };\n    var il = Number.POSITIVE_INFINITY;\n\n    function al(t, e) {\n      return e[1] !== il ? function (t, e, r) {\n        var n = 0,\n            i = 0;\n\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case "top-right":\n          case "top-left":\n          case "top":\n            i = r - 7;\n            break;\n\n          case "bottom-right":\n          case "bottom-left":\n          case "bottom":\n            i = 7 - r;\n        }\n\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n          case "right":\n            n = -e;\n            break;\n\n          case "top-left":\n          case "bottom-left":\n          case "left":\n            n = e;\n        }\n\n        return [n, i];\n      }(t, e[0], e[1]) : function (t, e) {\n        var r = 0,\n            n = 0;\n        e < 0 && (e = 0);\n        var i = e / Math.sqrt(2);\n\n        switch (t) {\n          case "top-right":\n          case "top-left":\n            n = i - 7;\n            break;\n\n          case "bottom-right":\n          case "bottom-left":\n            n = 7 - i;\n            break;\n\n          case "bottom":\n            n = 7 - e;\n            break;\n\n          case "top":\n            n = e - 7;\n        }\n\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n            r = -i;\n            break;\n\n          case "top-left":\n          case "bottom-left":\n            r = i;\n            break;\n\n          case "left":\n            r = e;\n            break;\n\n          case "right":\n            r = -e;\n        }\n\n        return [r, n];\n      }(t, e[0]);\n    }\n\n    function ol(t) {\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          return "right";\n\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          return "left";\n      }\n\n      return "center";\n    }\n\n    function sl(t, e, r, n, a, o, s, u, l, p, c, h, f, y, d) {\n      var m = function (t, e, r, n, a, o, s, u) {\n        for (var l = n.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180, p = [], c = 0, h = e.positionedLines; c < h.length; c += 1) {\n          for (var f = h[c], y = 0, d = f.positionedGlyphs; y < d.length; y += 1) {\n            var m = d[y];\n\n            if (m.rect) {\n              var v = m.rect || {},\n                  g = 4,\n                  x = !0,\n                  b = 1,\n                  w = 0,\n                  _ = (a || u) && m.vertical,\n                  A = m.metrics.advance * m.scale / 2;\n\n              if (u && e.verticalizable && (w = f.lineOffset / 2 - (m.imageName ? -(24 - m.metrics.width * m.scale) / 2 : 24 * (m.scale - 1))), m.imageName) {\n                var S = s[m.imageName];\n                x = S.sdf, g = 1 / (b = S.pixelRatio);\n              }\n\n              var k = a ? [m.x + A, m.y] : [0, 0],\n                  I = a ? [0, 0] : [m.x + A + r[0], m.y + r[1] - w],\n                  z = [0, 0];\n              _ && (z = I, I = [0, 0]);\n              var C = (m.metrics.left - g) * m.scale - A + I[0],\n                  E = (-m.metrics.top - g) * m.scale + I[1],\n                  P = C + v.w * m.scale / b,\n                  M = E + v.h * m.scale / b,\n                  B = new i(C, E),\n                  T = new i(P, E),\n                  V = new i(C, M),\n                  F = new i(P, M);\n\n              if (_) {\n                var D = new i(-A, A - -17),\n                    L = -Math.PI / 2,\n                    O = 12 - A,\n                    R = new i(22 - O, -(m.imageName ? O : 0)),\n                    U = new (Function.prototype.bind.apply(i, [null].concat(z)))();\n                B._rotateAround(L, D)._add(R)._add(U), T._rotateAround(L, D)._add(R)._add(U), V._rotateAround(L, D)._add(R)._add(U), F._rotateAround(L, D)._add(R)._add(U);\n              }\n\n              if (l) {\n                var j = Math.sin(l),\n                    q = Math.cos(l),\n                    N = [q, -j, j, q];\n                B._matMult(N), T._matMult(N), V._matMult(N), F._matMult(N);\n              }\n\n              var K = new i(0, 0),\n                  G = new i(0, 0);\n              p.push({\n                tl: B,\n                tr: T,\n                bl: V,\n                br: F,\n                tex: v,\n                writingMode: e.writingMode,\n                glyphOffset: k,\n                sectionIndex: m.sectionIndex,\n                isSDF: x,\n                pixelOffsetTL: K,\n                pixelOffsetBR: G,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n        }\n\n        return p;\n      }(0, r, u, a, o, s, n, t.allowVerticalPlacement),\n          v = t.textSizeData,\n          g = null;\n\n      "source" === v.kind ? (g = [128 * a.layout.get("text-size").evaluate(s, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\') : "composite" === v.kind && ((g = [128 * y.compositeTextSizes[0].evaluate(s, {}, d), 128 * y.compositeTextSizes[1].evaluate(s, {}, d)])[0] > 32640 || g[1] > 32640) && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\'), t.addSymbols(t.text, m, g, u, o, s, p, e, l.lineStartIndex, l.lineLength, f, d);\n\n      for (var x = 0, b = c; x < b.length; x += 1) {\n        h[b[x]] = t.text.placedSymbolArray.length - 1;\n      }\n\n      return 4 * m.length;\n    }\n\n    function ul(t) {\n      for (var e in t) {\n        return t[e];\n      }\n\n      return null;\n    }\n\n    function ll(t, e, r, n) {\n      var i = t.compareText;\n\n      if (e in i) {\n        for (var a = i[e], o = a.length - 1; o >= 0; o--) {\n          if (n.dist(a[o]) < r) return !0;\n        }\n      } else i[e] = [];\n\n      return i[e].push(n), !1;\n    }\n\n    var pl = bs.VectorTileFeature.types,\n        cl = [{\n      name: "a_fade_opacity",\n      components: 1,\n      type: "Uint8",\n      offset: 0\n    }];\n\n    function hl(t, e, r, n, i, a, o, s, u, l, p, c, h) {\n      var f = s ? Math.min(32640, Math.round(s[0])) : 0,\n          y = s ? Math.min(32640, Math.round(s[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), a, o, (f << 1) + (u ? 1 : 0), y, 16 * l, 16 * p, 256 * c, 256 * h);\n    }\n\n    function fl(t, e, r) {\n      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n    }\n\n    function yl(t) {\n      for (var e = 0, r = t.sections; e < r.length; e += 1) {\n        if ($n(r[e].text)) return !0;\n      }\n\n      return !1;\n    }\n\n    var dl = function dl(t) {\n      this.layoutVertexArray = new Vi(), this.indexArray = new ji(), this.programConfigurations = t, this.segments = new sa(), this.dynamicLayoutVertexArray = new Fi(), this.opacityVertexArray = new Di(), this.placedSymbolArray = new Qi();\n    };\n\n    dl.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n    }, dl.prototype.upload = function (t, e, r, n) {\n      this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, js.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, qs.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, cl, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n    }, dl.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n    }, On("SymbolBuffers", dl);\n\n    var ml = function ml(t, e, r) {\n      this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new sa(), this.collisionVertexArray = new Ui();\n    };\n\n    ml.prototype.upload = function (t) {\n      this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Ns.members, !0);\n    }, ml.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());\n    }, On("CollisionBuffers", ml);\n\n    var vl = function vl(t) {\n      this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = oo([]), this.placementViewportMatrix = oo([]);\n      var e = this.layers[0]._unevaluatedLayout._values;\n      this.textSizeData = Du(this.zoom, e["text-size"]), this.iconSizeData = Du(this.zoom, e["icon-size"]);\n      var r = this.layers[0].layout,\n          n = r.get("symbol-sort-key"),\n          i = r.get("symbol-z-order");\n      this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, "point" === r.get("symbol-placement") && (this.writingModes = r.get("text-writing-mode").map(function (t) {\n        return wu[t];\n      })), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      }), this.sourceID = t.sourceID;\n    };\n\n    vl.prototype.createArrays = function () {\n      this.text = new dl(new Va(this.layers, this.zoom, function (t) {\n        return /^text/.test(t);\n      })), this.icon = new dl(new Va(this.layers, this.zoom, function (t) {\n        return /^icon/.test(t);\n      })), this.glyphOffsetArray = new ra(), this.lineVertexArray = new na(), this.symbolInstances = new ea();\n    }, vl.prototype.calculateGlyphDependencies = function (t, e, r, n, i) {\n      for (var a = 0; a < t.length; a++) {\n        if (e[t.charCodeAt(a)] = !0, (r || n) && i) {\n          var o = Xs[t.charAt(a)];\n          o && (e[o.charCodeAt(0)] = !0);\n        }\n      }\n    }, vl.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n          i = n.layout,\n          a = i.get("text-font"),\n          o = i.get("text-field"),\n          s = i.get("icon-image"),\n          u = ("constant" !== o.value.kind || o.value.value instanceof ne && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0),\n          l = "constant" !== s.value.kind || !!s.value.value || Object.keys(s.parameters).length > 0,\n          p = i.get("symbol-sort-key");\n\n      if (this.features = [], u || l) {\n        for (var c = e.iconDependencies, h = e.glyphDependencies, f = e.availableImages, y = new si(this.zoom), d = 0, m = t; d < m.length; d += 1) {\n          var v = m[d],\n              g = v.feature,\n              x = v.id,\n              b = v.index,\n              w = v.sourceLayerIndex,\n              _ = n._featureFilter.needGeometry,\n              A = Ua(g, _);\n\n          if (n._featureFilter.filter(y, A, r)) {\n            _ || (A.geometry = Ra(g));\n            var S = void 0;\n\n            if (u) {\n              var k = n.getValueAndResolveTokens("text-field", A, r, f),\n                  I = ne.factory(k);\n              yl(I) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === ii() || this.hasRTLText && oi.isParsed()) && (S = Zs(I, n, A));\n            }\n\n            var z = void 0;\n\n            if (l) {\n              var C = n.getValueAndResolveTokens("icon-image", A, r, f);\n              z = C instanceof ie ? C : ie.fromString(C);\n            }\n\n            if (S || z) {\n              var E = this.sortFeaturesByKey ? p.evaluate(A, {}, r) : void 0;\n\n              if (this.features.push({\n                id: x,\n                text: S,\n                icon: z,\n                index: b,\n                sourceLayerIndex: w,\n                geometry: A.geometry,\n                properties: g.properties,\n                type: pl[g.type],\n                sortKey: E\n              }), z && (c[z.name] = !0), S) {\n                var P = a.evaluate(A, {}, r).join(","),\n                    M = "map" === i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement");\n                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(wu.vertical) >= 0;\n\n                for (var B = 0, T = S.sections; B < T.length; B += 1) {\n                  var V = T[B];\n                  if (V.image) c[V.image.name] = !0;else {\n                    var F = Zn(S.toString()),\n                        D = V.fontStack || P,\n                        L = h[D] = h[D] || {};\n                    this.calculateGlyphDependencies(V.text, L, M, this.allowVerticalPlacement, F);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        "line" === i.get("symbol-placement") && (this.features = function (t) {\n          var e = {},\n              r = {},\n              n = [],\n              i = 0;\n\n          function a(e) {\n            n.push(t[e]), i++;\n          }\n\n          function o(t, e, i) {\n            var a = r[t];\n            return delete r[t], r[e] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;\n          }\n\n          function s(t, r, i) {\n            var a = e[r];\n            return delete e[r], e[t] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;\n          }\n\n          function u(t, e, r) {\n            var n = r ? e[0][e[0].length - 1] : e[0][0];\n            return t + ":" + n.x + ":" + n.y;\n          }\n\n          for (var l = 0; l < t.length; l++) {\n            var p = t[l],\n                c = p.geometry,\n                h = p.text ? p.text.toString() : null;\n\n            if (h) {\n              var f = u(h, c),\n                  y = u(h, c, !0);\n\n              if (f in r && y in e && r[f] !== e[y]) {\n                var d = s(f, y, c),\n                    m = o(f, y, n[d].geometry);\n                delete e[f], delete r[y], r[u(h, n[m].geometry, !0)] = m, n[d].geometry = null;\n              } else f in r ? o(f, y, c) : y in e ? s(f, y, c) : (a(l), e[f] = i - 1, r[y] = i - 1);\n            } else a(l);\n          }\n\n          return n.filter(function (t) {\n            return t.geometry;\n          });\n        }(this.features)), this.sortFeaturesByKey && this.features.sort(function (t, e) {\n          return t.sortKey - e.sortKey;\n        });\n      }\n    }, vl.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r));\n    }, vl.prototype.isEmpty = function () {\n      return 0 === this.symbolInstances.length && !this.hasRTLText;\n    }, vl.prototype.uploadPending = function () {\n      return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n    }, vl.prototype.upload = function (t) {\n      !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n    }, vl.prototype.destroyDebugData = function () {\n      this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n    }, vl.prototype.destroy = function () {\n      this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n    }, vl.prototype.addToLineVertexArray = function (t, e) {\n      var r = this.lineVertexArray.length;\n\n      if (void 0 !== t.segment) {\n        for (var n = t.dist(e[t.segment + 1]), i = t.dist(e[t.segment]), a = {}, o = t.segment + 1; o < e.length; o++) {\n          a[o] = {\n            x: e[o].x,\n            y: e[o].y,\n            tileUnitDistanceFromAnchor: n\n          }, o < e.length - 1 && (n += e[o + 1].dist(e[o]));\n        }\n\n        for (var s = t.segment || 0; s >= 0; s--) {\n          a[s] = {\n            x: e[s].x,\n            y: e[s].y,\n            tileUnitDistanceFromAnchor: i\n          }, s > 0 && (i += e[s - 1].dist(e[s]));\n        }\n\n        for (var u = 0; u < e.length; u++) {\n          var l = a[u];\n          this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);\n        }\n      }\n\n      return {\n        lineStartIndex: r,\n        lineLength: this.lineVertexArray.length - r\n      };\n    }, vl.prototype.addSymbols = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n      for (var h = t.indexArray, f = t.layoutVertexArray, y = t.segments.prepareSegment(4 * e.length, f, h, this.canOverlap ? a.sortKey : void 0), d = this.glyphOffsetArray.length, m = y.vertexLength, v = this.allowVerticalPlacement && o === wu.vertical ? Math.PI / 2 : 0, g = a.text && a.text.sections, x = 0; x < e.length; x++) {\n        var b = e[x],\n            w = b.tl,\n            _ = b.tr,\n            A = b.bl,\n            S = b.br,\n            k = b.tex,\n            I = b.pixelOffsetTL,\n            z = b.pixelOffsetBR,\n            C = b.minFontScaleX,\n            E = b.minFontScaleY,\n            P = b.glyphOffset,\n            M = b.isSDF,\n            B = b.sectionIndex,\n            T = y.vertexLength,\n            V = P[1];\n        hl(f, s.x, s.y, w.x, V + w.y, k.x, k.y, r, M, I.x, I.y, C, E), hl(f, s.x, s.y, _.x, V + _.y, k.x + k.w, k.y, r, M, z.x, I.y, C, E), hl(f, s.x, s.y, A.x, V + A.y, k.x, k.y + k.h, r, M, I.x, z.y, C, E), hl(f, s.x, s.y, S.x, V + S.y, k.x + k.w, k.y + k.h, r, M, z.x, z.y, C, E), fl(t.dynamicLayoutVertexArray, s, v), h.emplaceBack(T, T + 1, T + 2), h.emplaceBack(T + 1, T + 2, T + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), x !== e.length - 1 && B === e[x + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, a, a.index, {}, c, g && g[B]);\n      }\n\n      t.placedSymbolArray.emplaceBack(s.x, s.y, d, this.glyphOffsetArray.length - d, m, u, l, s.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, !1, 0, p);\n    }, vl.prototype._addCollisionDebugVertex = function (t, e, r, n, i, a) {\n      return e.emplaceBack(0, 0), t.emplaceBack(r.x, r.y, n, i, Math.round(a.x), Math.round(a.y));\n    }, vl.prototype.addCollisionDebugVertices = function (t, e, r, n, a, o, s) {\n      var u = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray),\n          l = u.vertexLength,\n          p = a.layoutVertexArray,\n          c = a.collisionVertexArray,\n          h = s.anchorX,\n          f = s.anchorY;\n      this._addCollisionDebugVertex(p, c, o, h, f, new i(t, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, n)), this._addCollisionDebugVertex(p, c, o, h, f, new i(t, n)), u.vertexLength += 4;\n      var y = a.indexArray;\n      y.emplaceBack(l, l + 1), y.emplaceBack(l + 1, l + 2), y.emplaceBack(l + 2, l + 3), y.emplaceBack(l + 3, l), u.primitiveLength += 4;\n    }, vl.prototype.addDebugCollisionBoxes = function (t, e, r, n) {\n      for (var i = t; i < e; i++) {\n        var a = this.collisionBoxArray.get(i);\n        this.addCollisionDebugVertices(a.x1, a.y1, a.x2, a.y2, n ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, r);\n      }\n    }, vl.prototype.generateCollisionDebugBuffers = function () {\n      this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ml(Oi, Ks.members, Xi), this.iconCollisionBox = new ml(Oi, Ks.members, Xi);\n\n      for (var t = 0; t < this.symbolInstances.length; t++) {\n        var e = this.symbolInstances.get(t);\n        this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1);\n      }\n    }, vl.prototype._deserializeCollisionBoxesForSymbol = function (t, e, r, n, i, a, o, s, u) {\n      for (var l = {}, p = e; p < r; p++) {\n        var c = t.get(p);\n        l.textBox = {\n          x1: c.x1,\n          y1: c.y1,\n          x2: c.x2,\n          y2: c.y2,\n          anchorPointX: c.anchorPointX,\n          anchorPointY: c.anchorPointY\n        }, l.textFeatureIndex = c.featureIndex;\n        break;\n      }\n\n      for (var h = n; h < i; h++) {\n        var f = t.get(h);\n        l.verticalTextBox = {\n          x1: f.x1,\n          y1: f.y1,\n          x2: f.x2,\n          y2: f.y2,\n          anchorPointX: f.anchorPointX,\n          anchorPointY: f.anchorPointY\n        }, l.verticalTextFeatureIndex = f.featureIndex;\n        break;\n      }\n\n      for (var y = a; y < o; y++) {\n        var d = t.get(y);\n        l.iconBox = {\n          x1: d.x1,\n          y1: d.y1,\n          x2: d.x2,\n          y2: d.y2,\n          anchorPointX: d.anchorPointX,\n          anchorPointY: d.anchorPointY\n        }, l.iconFeatureIndex = d.featureIndex;\n        break;\n      }\n\n      for (var m = s; m < u; m++) {\n        var v = t.get(m);\n        l.verticalIconBox = {\n          x1: v.x1,\n          y1: v.y1,\n          x2: v.x2,\n          y2: v.y2,\n          anchorPointX: v.anchorPointX,\n          anchorPointY: v.anchorPointY\n        }, l.verticalIconFeatureIndex = v.featureIndex;\n        break;\n      }\n\n      return l;\n    }, vl.prototype.deserializeCollisionBoxes = function (t) {\n      this.collisionArrays = [];\n\n      for (var e = 0; e < this.symbolInstances.length; e++) {\n        var r = this.symbolInstances.get(e);\n        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n      }\n    }, vl.prototype.hasTextData = function () {\n      return this.text.segments.get().length > 0;\n    }, vl.prototype.hasIconData = function () {\n      return this.icon.segments.get().length > 0;\n    }, vl.prototype.hasDebugData = function () {\n      return this.textCollisionBox && this.iconCollisionBox;\n    }, vl.prototype.hasTextCollisionBoxData = function () {\n      return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n    }, vl.prototype.hasIconCollisionBoxData = function () {\n      return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n    }, vl.prototype.addIndicesForPlacedSymbol = function (t, e) {\n      for (var r = t.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs, i = r.vertexStartIndex; i < n; i += 4) {\n        t.indexArray.emplaceBack(i, i + 1, i + 2), t.indexArray.emplaceBack(i + 1, i + 2, i + 3);\n      }\n    }, vl.prototype.getSortedSymbolIndexes = function (t) {\n      if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n\n      for (var e = Math.sin(t), r = Math.cos(t), n = [], i = [], a = [], o = 0; o < this.symbolInstances.length; ++o) {\n        a.push(o);\n        var s = this.symbolInstances.get(o);\n        n.push(0 | Math.round(e * s.anchorX + r * s.anchorY)), i.push(s.featureIndex);\n      }\n\n      return a.sort(function (t, e) {\n        return n[t] - n[e] || i[e] - i[t];\n      }), a;\n    }, vl.prototype.addToSortKeyRanges = function (t, e) {\n      var r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n      r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n        sortKey: e,\n        symbolInstanceStart: t,\n        symbolInstanceEnd: t + 1\n      });\n    }, vl.prototype.sortFeatures = function (t) {\n      var e = this;\n\n      if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n\n        for (var r = 0, n = this.symbolInstanceIndexes; r < n.length; r += 1) {\n          var i = this.symbolInstances.get(n[r]);\n          this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach(function (t, r, n) {\n            t >= 0 && n.indexOf(t) === r && e.addIndicesForPlacedSymbol(e.text, t);\n          }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);\n        }\n\n        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n      }\n    }, On("SymbolBucket", vl, {\n      omit: ["layers", "collisionBoxArray", "features", "compareText"]\n    }), vl.MAX_GLYPHS = 65535, vl.addDynamicAttributes = fl;\n\n    var gl = new wi({\n      "symbol-placement": new mi(Et.layout_symbol["symbol-placement"]),\n      "symbol-spacing": new mi(Et.layout_symbol["symbol-spacing"]),\n      "symbol-avoid-edges": new mi(Et.layout_symbol["symbol-avoid-edges"]),\n      "symbol-sort-key": new vi(Et.layout_symbol["symbol-sort-key"]),\n      "symbol-z-order": new mi(Et.layout_symbol["symbol-z-order"]),\n      "icon-allow-overlap": new mi(Et.layout_symbol["icon-allow-overlap"]),\n      "icon-ignore-placement": new mi(Et.layout_symbol["icon-ignore-placement"]),\n      "icon-optional": new mi(Et.layout_symbol["icon-optional"]),\n      "icon-rotation-alignment": new mi(Et.layout_symbol["icon-rotation-alignment"]),\n      "icon-size": new vi(Et.layout_symbol["icon-size"]),\n      "icon-text-fit": new mi(Et.layout_symbol["icon-text-fit"]),\n      "icon-text-fit-padding": new mi(Et.layout_symbol["icon-text-fit-padding"]),\n      "icon-image": new vi(Et.layout_symbol["icon-image"]),\n      "icon-rotate": new vi(Et.layout_symbol["icon-rotate"]),\n      "icon-padding": new mi(Et.layout_symbol["icon-padding"]),\n      "icon-keep-upright": new mi(Et.layout_symbol["icon-keep-upright"]),\n      "icon-offset": new vi(Et.layout_symbol["icon-offset"]),\n      "icon-anchor": new vi(Et.layout_symbol["icon-anchor"]),\n      "icon-pitch-alignment": new mi(Et.layout_symbol["icon-pitch-alignment"]),\n      "text-pitch-alignment": new mi(Et.layout_symbol["text-pitch-alignment"]),\n      "text-rotation-alignment": new mi(Et.layout_symbol["text-rotation-alignment"]),\n      "text-field": new vi(Et.layout_symbol["text-field"]),\n      "text-font": new vi(Et.layout_symbol["text-font"]),\n      "text-size": new vi(Et.layout_symbol["text-size"]),\n      "text-max-width": new vi(Et.layout_symbol["text-max-width"]),\n      "text-line-height": new mi(Et.layout_symbol["text-line-height"]),\n      "text-letter-spacing": new vi(Et.layout_symbol["text-letter-spacing"]),\n      "text-justify": new vi(Et.layout_symbol["text-justify"]),\n      "text-radial-offset": new vi(Et.layout_symbol["text-radial-offset"]),\n      "text-variable-anchor": new mi(Et.layout_symbol["text-variable-anchor"]),\n      "text-anchor": new vi(Et.layout_symbol["text-anchor"]),\n      "text-max-angle": new mi(Et.layout_symbol["text-max-angle"]),\n      "text-writing-mode": new mi(Et.layout_symbol["text-writing-mode"]),\n      "text-rotate": new vi(Et.layout_symbol["text-rotate"]),\n      "text-padding": new mi(Et.layout_symbol["text-padding"]),\n      "text-keep-upright": new mi(Et.layout_symbol["text-keep-upright"]),\n      "text-transform": new vi(Et.layout_symbol["text-transform"]),\n      "text-offset": new vi(Et.layout_symbol["text-offset"]),\n      "text-allow-overlap": new mi(Et.layout_symbol["text-allow-overlap"]),\n      "text-ignore-placement": new mi(Et.layout_symbol["text-ignore-placement"]),\n      "text-optional": new mi(Et.layout_symbol["text-optional"])\n    }),\n        xl = {\n      paint: new wi({\n        "icon-opacity": new vi(Et.paint_symbol["icon-opacity"]),\n        "icon-color": new vi(Et.paint_symbol["icon-color"]),\n        "icon-halo-color": new vi(Et.paint_symbol["icon-halo-color"]),\n        "icon-halo-width": new vi(Et.paint_symbol["icon-halo-width"]),\n        "icon-halo-blur": new vi(Et.paint_symbol["icon-halo-blur"]),\n        "icon-translate": new mi(Et.paint_symbol["icon-translate"]),\n        "icon-translate-anchor": new mi(Et.paint_symbol["icon-translate-anchor"]),\n        "text-opacity": new vi(Et.paint_symbol["text-opacity"]),\n        "text-color": new vi(Et.paint_symbol["text-color"], {\n          runtimeType: jt,\n          getOverride: function getOverride(t) {\n            return t.textColor;\n          },\n          hasOverride: function hasOverride(t) {\n            return !!t.textColor;\n          }\n        }),\n        "text-halo-color": new vi(Et.paint_symbol["text-halo-color"]),\n        "text-halo-width": new vi(Et.paint_symbol["text-halo-width"]),\n        "text-halo-blur": new vi(Et.paint_symbol["text-halo-blur"]),\n        "text-translate": new mi(Et.paint_symbol["text-translate"]),\n        "text-translate-anchor": new mi(Et.paint_symbol["text-translate-anchor"])\n      }),\n      layout: gl\n    },\n        bl = function bl(t) {\n      this.type = t.property.overrides ? t.property.overrides.runtimeType : Lt, this.defaultValue = t;\n    };\n\n    bl.prototype.evaluate = function (t) {\n      if (t.formattedSection) {\n        var e = this.defaultValue.property.overrides;\n        if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n      }\n\n      return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n    }, bl.prototype.eachChild = function (t) {\n      this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n    }, bl.prototype.outputDefined = function () {\n      return !1;\n    }, bl.prototype.serialize = function () {\n      return null;\n    }, On("FormatSectionOverride", bl, {\n      omit: ["defaultValue"]\n    });\n\n    var wl = function (t) {\n      function e(e) {\n        t.call(this, e, xl);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n        if (t.prototype.recalculate.call(this, e, r), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {\n          var n = this.layout.get("text-writing-mode");\n\n          if (n) {\n            for (var i = [], a = 0, o = n; a < o.length; a += 1) {\n              var s = o[a];\n              i.indexOf(s) < 0 && i.push(s);\n            }\n\n            this.layout._values["text-writing-mode"] = i;\n          } else this.layout._values["text-writing-mode"] = ["horizontal"];\n        }\n\n        this._setPaintOverrides();\n      }, e.prototype.getValueAndResolveTokens = function (t, e, r, n) {\n        var i = this.layout.get(t).evaluate(e, {}, r, n),\n            a = this._unevaluatedLayout._values[t];\n        return a.isDataDriven() || Gr(a.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, function (e, r) {\n            return r in t ? String(t[r]) : "";\n          });\n        }(e.properties, i);\n      }, e.prototype.createBucket = function (t) {\n        return new vl(t);\n      }, e.prototype.queryRadius = function () {\n        return 0;\n      }, e.prototype.queryIntersectsFeature = function () {\n        return !1;\n      }, e.prototype._setPaintOverrides = function () {\n        for (var t = 0, r = xl.paint.overridableProperties; t < r.length; t += 1) {\n          var n = r[t];\n\n          if (e.hasPaintOverride(this.layout, n)) {\n            var i,\n                a = this.paint.get(n),\n                o = new bl(a),\n                s = new Kr(o, a.property.specification);\n            i = "constant" === a.value.kind || "source" === a.value.kind ? new Xr("source", s) : new Jr("composite", s, a.value.zoomStops, a.value._interpolationType), this.paint._values[n] = new yi(a.property, i, a.parameters);\n          }\n        }\n      }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, r, n) {\n        return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && e.hasPaintOverride(this.layout, t);\n      }, e.hasPaintOverride = function (t, e) {\n        var r = t.get("text-field"),\n            n = xl.paint.properties[e],\n            i = !1,\n            a = function a(t) {\n          for (var e = 0, r = t; e < r.length; e += 1) {\n            if (n.overrides && n.overrides.hasOverride(r[e])) return void (i = !0);\n          }\n        };\n\n        if ("constant" === r.value.kind && r.value.value instanceof ne) a(r.value.value.sections);else if ("source" === r.value.kind) {\n          var o = function o(t) {\n            i || (t instanceof le && se(t.value) === Gt ? a(t.value.sections) : t instanceof fe ? a(t.sections) : t.eachChild(o));\n          },\n              s = r.value;\n\n          s._styleExpression && o(s._styleExpression.expression);\n        }\n        return i;\n      }, e;\n    }(_i),\n        _l = {\n      paint: new wi({\n        "background-color": new mi(Et.paint_background["background-color"]),\n        "background-pattern": new xi(Et.paint_background["background-pattern"]),\n        "background-opacity": new mi(Et.paint_background["background-opacity"])\n      })\n    },\n        Al = function (t) {\n      function e(e) {\n        t.call(this, e, _l);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(_i),\n        Sl = {\n      paint: new wi({\n        "raster-opacity": new mi(Et.paint_raster["raster-opacity"]),\n        "raster-hue-rotate": new mi(Et.paint_raster["raster-hue-rotate"]),\n        "raster-brightness-min": new mi(Et.paint_raster["raster-brightness-min"]),\n        "raster-brightness-max": new mi(Et.paint_raster["raster-brightness-max"]),\n        "raster-saturation": new mi(Et.paint_raster["raster-saturation"]),\n        "raster-contrast": new mi(Et.paint_raster["raster-contrast"]),\n        "raster-resampling": new mi(Et.paint_raster["raster-resampling"]),\n        "raster-fade-duration": new mi(Et.paint_raster["raster-fade-duration"])\n      })\n    },\n        kl = function (t) {\n      function e(e) {\n        t.call(this, e, Sl);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(_i),\n        Il = function (t) {\n      function e(e) {\n        t.call(this, e, {}), this.implementation = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.is3D = function () {\n        return "3d" === this.implementation.renderingMode;\n      }, e.prototype.hasOffscreenPass = function () {\n        return void 0 !== this.implementation.prerender;\n      }, e.prototype.recalculate = function () {}, e.prototype.updateTransitions = function () {}, e.prototype.hasTransition = function () {}, e.prototype.serialize = function () {}, e.prototype.onAdd = function (t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }, e.prototype.onRemove = function (t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }, e;\n    }(_i),\n        zl = {\n      circle: co,\n      heatmap: _o,\n      hillshade: So,\n      fill: ps,\n      "fill-extrusion": zs,\n      line: Rs,\n      symbol: wl,\n      background: Al,\n      raster: kl\n    },\n        Cl = o.HTMLImageElement,\n        El = o.HTMLCanvasElement,\n        Pl = o.HTMLVideoElement,\n        Ml = o.ImageData,\n        Bl = o.ImageBitmap,\n        Tl = function Tl(t, e, r, n) {\n      this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n    };\n\n    Tl.prototype.update = function (t, e, r) {\n      var n = t.width,\n          i = t.height,\n          a = !(this.size && this.size[0] === n && this.size[1] === i || r),\n          o = this.context,\n          s = o.gl;\n      if (this.useMipmap = Boolean(e && e.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), a) this.size = [n, i], t instanceof Cl || t instanceof El || t instanceof Pl || t instanceof Ml || Bl && t instanceof Bl ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, t) : s.texImage2D(s.TEXTURE_2D, 0, this.format, n, i, 0, this.format, s.UNSIGNED_BYTE, t.data);else {\n        var u = r || {\n          x: 0,\n          y: 0\n        },\n            l = u.x,\n            p = u.y;\n        t instanceof Cl || t instanceof El || t instanceof Pl || t instanceof Ml || Bl && t instanceof Bl ? s.texSubImage2D(s.TEXTURE_2D, 0, l, p, s.RGBA, s.UNSIGNED_BYTE, t) : s.texSubImage2D(s.TEXTURE_2D, 0, l, p, n, i, s.RGBA, s.UNSIGNED_BYTE, t.data);\n      }\n      this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D);\n    }, Tl.prototype.bind = function (t, e, r) {\n      var n = this.context.gl;\n      n.bindTexture(n.TEXTURE_2D, this.texture), r !== n.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r = n.LINEAR), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, r || t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);\n    }, Tl.prototype.isSizePowerOfTwo = function () {\n      return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n    }, Tl.prototype.destroy = function () {\n      this.context.gl.deleteTexture(this.texture), this.texture = null;\n    };\n\n    var Vl = function Vl(t) {\n      var e = this;\n      this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function () {\n        e._triggered = !1, e._callback();\n      });\n    };\n\n    Vl.prototype.trigger = function () {\n      var t = this;\n      this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function () {\n        t._triggered = !1, t._callback();\n      }, 0));\n    }, Vl.prototype.remove = function () {\n      delete this._channel, this._callback = function () {};\n    };\n\n    var Fl = function Fl(t, e, r) {\n      this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v(["receive", "process"], this), this.invoker = new Vl(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = I() ? t : o;\n    };\n\n    function Dl(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n\n    Fl.prototype.send = function (t, e, r, n, i) {\n      var a = this;\n      void 0 === i && (i = !1);\n      var o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n      r && (this.callbacks[o] = r);\n      var s = E(this.globalScope) ? void 0 : [];\n      return this.target.postMessage({\n        id: o,\n        type: t,\n        hasCallback: !!r,\n        targetMapId: n,\n        mustQueue: i,\n        sourceMapId: this.mapId,\n        data: qn(e, s)\n      }, s), {\n        cancel: function cancel() {\n          r && delete a.callbacks[o], a.target.postMessage({\n            id: o,\n            type: "<cancel>",\n            targetMapId: n,\n            sourceMapId: a.mapId\n          });\n        }\n      };\n    }, Fl.prototype.receive = function (t) {\n      var e = t.data,\n          r = e.id;\n      if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {\n        delete this.tasks[r];\n        var n = this.cancelCallbacks[r];\n        delete this.cancelCallbacks[r], n && n();\n      } else I() || e.mustQueue ? (this.tasks[r] = e, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e);\n    }, Fl.prototype.process = function () {\n      if (this.taskQueue.length) {\n        var t = this.taskQueue.shift(),\n            e = this.tasks[t];\n        delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e);\n      }\n    }, Fl.prototype.processTask = function (t, e) {\n      var r = this;\n\n      if ("<response>" === e.type) {\n        var n = this.callbacks[t];\n        delete this.callbacks[t], n && (e.error ? n(Nn(e.error)) : n(null, Nn(e.data)));\n      } else {\n        var i = !1,\n            a = E(this.globalScope) ? void 0 : [],\n            o = e.hasCallback ? function (e, n) {\n          i = !0, delete r.cancelCallbacks[t], r.target.postMessage({\n            id: t,\n            type: "<response>",\n            sourceMapId: r.mapId,\n            error: e ? qn(e) : null,\n            data: qn(n, a)\n          }, a);\n        } : function (t) {\n          i = !0;\n        },\n            s = null,\n            u = Nn(e.data);\n        if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, u, o);else if (this.parent.getWorkerSource) {\n          var l = e.type.split(".");\n          s = this.parent.getWorkerSource(e.sourceMapId, l[0], u.source)[l[1]](u, o);\n        } else o(new Error("Could not find function " + e.type));\n        !i && s && s.cancel && (this.cancelCallbacks[t] = s.cancel);\n      }\n    }, Fl.prototype.remove = function () {\n      this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);\n    };\n\n    var Ll = function Ll(t, e) {\n      t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n    };\n\n    Ll.prototype.setNorthEast = function (t) {\n      return this._ne = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Ll.prototype.setSouthWest = function (t) {\n      return this._sw = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Ll.prototype.extend = function (t) {\n      var e,\n          r,\n          n = this._sw,\n          i = this._ne;\n      if (t instanceof Ol) e = t, r = t;else {\n        if (!(t instanceof Ll)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Ll.convert(t)) : this.extend(Ol.convert(t)) : this;\n        if (r = t._ne, !(e = t._sw) || !r) return this;\n      }\n      return n || i ? (n.lng = Math.min(e.lng, n.lng), n.lat = Math.min(e.lat, n.lat), i.lng = Math.max(r.lng, i.lng), i.lat = Math.max(r.lat, i.lat)) : (this._sw = new Ol(e.lng, e.lat), this._ne = new Ol(r.lng, r.lat)), this;\n    }, Ll.prototype.getCenter = function () {\n      return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }, Ll.prototype.getSouthWest = function () {\n      return this._sw;\n    }, Ll.prototype.getNorthEast = function () {\n      return this._ne;\n    }, Ll.prototype.getNorthWest = function () {\n      return new Ol(this.getWest(), this.getNorth());\n    }, Ll.prototype.getSouthEast = function () {\n      return new Ol(this.getEast(), this.getSouth());\n    }, Ll.prototype.getWest = function () {\n      return this._sw.lng;\n    }, Ll.prototype.getSouth = function () {\n      return this._sw.lat;\n    }, Ll.prototype.getEast = function () {\n      return this._ne.lng;\n    }, Ll.prototype.getNorth = function () {\n      return this._ne.lat;\n    }, Ll.prototype.toArray = function () {\n      return [this._sw.toArray(), this._ne.toArray()];\n    }, Ll.prototype.toString = function () {\n      return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";\n    }, Ll.prototype.isEmpty = function () {\n      return !(this._sw && this._ne);\n    }, Ll.prototype.contains = function (t) {\n      var e = Ol.convert(t),\n          r = e.lng,\n          n = e.lat,\n          i = this._sw.lng <= r && r <= this._ne.lng;\n      return this._sw.lng > this._ne.lng && (i = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= n && n <= this._ne.lat && i;\n    }, Ll.convert = function (t) {\n      return !t || t instanceof Ll ? t : new Ll(t);\n    };\n\n    var Ol = function Ol(t, e) {\n      if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")");\n      if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");\n    };\n\n    Ol.prototype.wrap = function () {\n      return new Ol(c(this.lng, -180, 180), this.lat);\n    }, Ol.prototype.toArray = function () {\n      return [this.lng, this.lat];\n    }, Ol.prototype.toString = function () {\n      return "LngLat(" + this.lng + ", " + this.lat + ")";\n    }, Ol.prototype.distanceTo = function (t) {\n      var e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n      return 6371008.8 * Math.acos(Math.min(i, 1));\n    }, Ol.prototype.toBounds = function (t) {\n      void 0 === t && (t = 0);\n      var e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n      return new Ll(new Ol(this.lng - r, this.lat - e), new Ol(this.lng + r, this.lat + e));\n    }, Ol.convert = function (t) {\n      if (t instanceof Ol) return t;\n      if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ol(Number(t[0]), Number(t[1]));\n      if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Ol(Number("lng" in t ? t.lng : t.lon), Number(t.lat));\n      throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");\n    };\n    var Rl = 2 * Math.PI * 6371008.8;\n\n    function Ul(t) {\n      return Rl * Math.cos(t * Math.PI / 180);\n    }\n\n    function jl(t) {\n      return (180 + t) / 360;\n    }\n\n    function ql(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n\n    function Nl(t, e) {\n      return t / Ul(e);\n    }\n\n    function Kl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n\n    var Gl = function Gl(t, e, r) {\n      void 0 === r && (r = 0), this.x = +t, this.y = +e, this.z = +r;\n    };\n\n    Gl.fromLngLat = function (t, e) {\n      void 0 === e && (e = 0);\n      var r = Ol.convert(t);\n      return new Gl(jl(r.lng), ql(r.lat), Nl(e, r.lat));\n    }, Gl.prototype.toLngLat = function () {\n      return new Ol(360 * this.x - 180, Kl(this.y));\n    }, Gl.prototype.toAltitude = function () {\n      return this.z * Ul(Kl(this.y));\n    }, Gl.prototype.meterInMercatorCoordinateUnits = function () {\n      return 1 / Rl * (t = Kl(this.y), 1 / Math.cos(t * Math.PI / 180));\n      var t;\n    };\n\n    var Zl = function Zl(t, e, r) {\n      this.z = t, this.x = e, this.y = r, this.key = Hl(0, t, t, e, r);\n    };\n\n    Zl.prototype.equals = function (t) {\n      return this.z === t.z && this.x === t.x && this.y === t.y;\n    }, Zl.prototype.url = function (t, e) {\n      var r,\n          n,\n          i,\n          a,\n          o,\n          s = (n = this.y, i = this.z, a = Dl(256 * (r = this.x), 256 * (n = Math.pow(2, i) - n - 1), i), o = Dl(256 * (r + 1), 256 * (n + 1), i), a[0] + "," + a[1] + "," + o[0] + "," + o[1]),\n          u = function (t, e, r) {\n        for (var n, i = "", a = t; a > 0; a--) {\n          i += (e & (n = 1 << a - 1) ? 1 : 0) + (r & n ? 2 : 0);\n        }\n\n        return i;\n      }(this.z, this.x, this.y);\n\n      return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", s);\n    }, Zl.prototype.getTilePoint = function (t) {\n      var e = Math.pow(2, this.z);\n      return new i(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y));\n    }, Zl.prototype.toString = function () {\n      return this.z + "/" + this.x + "/" + this.y;\n    };\n\n    var Xl = function Xl(t, e) {\n      this.wrap = t, this.canonical = e, this.key = Hl(t, e.z, e.z, e.x, e.y);\n    },\n        Jl = function Jl(t, e, r, n, i) {\n      this.overscaledZ = t, this.wrap = e, this.canonical = new Zl(r, +n, +i), this.key = Hl(e, t, r, n, i);\n    };\n\n    function Hl(t, e, r, n, i) {\n      (t *= 2) < 0 && (t = -1 * t - 1);\n      var a = 1 << r;\n      return (a * a * t + a * i + n).toString(36) + r.toString(36) + e.toString(36);\n    }\n\n    Jl.prototype.equals = function (t) {\n      return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n    }, Jl.prototype.scaledTo = function (t) {\n      var e = this.canonical.z - t;\n      return t > this.canonical.z ? new Jl(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Jl(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n    }, Jl.prototype.calculateScaledKey = function (t, e) {\n      var r = this.canonical.z - t;\n      return t > this.canonical.z ? Hl(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : Hl(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n    }, Jl.prototype.isChildOf = function (t) {\n      if (t.wrap !== this.wrap) return !1;\n      var e = this.canonical.z - t.canonical.z;\n      return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n    }, Jl.prototype.children = function (t) {\n      if (this.overscaledZ >= t) return [new Jl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n      var e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n      return [new Jl(e, this.wrap, e, r, n), new Jl(e, this.wrap, e, r + 1, n), new Jl(e, this.wrap, e, r, n + 1), new Jl(e, this.wrap, e, r + 1, n + 1)];\n    }, Jl.prototype.isLessThan = function (t) {\n      return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n    }, Jl.prototype.wrapped = function () {\n      return new Jl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Jl.prototype.unwrapTo = function (t) {\n      return new Jl(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Jl.prototype.overscaleFactor = function () {\n      return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }, Jl.prototype.toUnwrapped = function () {\n      return new Xl(this.wrap, this.canonical);\n    }, Jl.prototype.toString = function () {\n      return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;\n    }, Jl.prototype.getTilePoint = function (t) {\n      return this.canonical.getTilePoint(new Gl(t.x - this.wrap, t.y));\n    }, On("CanonicalTileID", Zl), On("OverscaledTileID", Jl, {\n      omit: ["posMatrix"]\n    });\n\n    var Yl = function Yl(t, e, r) {\n      if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");\n      if (r && "mapbox" !== r && "terrarium" !== r) return A(\'"\' + r + \'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".\');\n      this.stride = e.height;\n      var n = this.dim = e.height - 2;\n      this.data = new Uint32Array(e.data.buffer), this.encoding = r || "mapbox";\n\n      for (var i = 0; i < n; i++) {\n        this.data[this._idx(-1, i)] = this.data[this._idx(0, i)], this.data[this._idx(n, i)] = this.data[this._idx(n - 1, i)], this.data[this._idx(i, -1)] = this.data[this._idx(i, 0)], this.data[this._idx(i, n)] = this.data[this._idx(i, n - 1)];\n      }\n\n      this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n, -1)] = this.data[this._idx(n - 1, 0)], this.data[this._idx(-1, n)] = this.data[this._idx(0, n - 1)], this.data[this._idx(n, n)] = this.data[this._idx(n - 1, n - 1)];\n    };\n\n    Yl.prototype.get = function (t, e) {\n      var r = new Uint8Array(this.data.buffer),\n          n = 4 * this._idx(t, e);\n\n      return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[n], r[n + 1], r[n + 2]);\n    }, Yl.prototype.getUnpackVector = function () {\n      return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4];\n    }, Yl.prototype._idx = function (t, e) {\n      if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");\n      return (e + 1) * this.stride + (t + 1);\n    }, Yl.prototype._unpackMapbox = function (t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }, Yl.prototype._unpackTerrarium = function (t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }, Yl.prototype.getPixels = function () {\n      return new xo({\n        width: this.stride,\n        height: this.stride\n      }, new Uint8Array(this.data.buffer));\n    }, Yl.prototype.backfillBorder = function (t, e, r) {\n      if (this.dim !== t.dim) throw new Error("dem dimension mismatch");\n      var n = e * this.dim,\n          i = e * this.dim + this.dim,\n          a = r * this.dim,\n          o = r * this.dim + this.dim;\n\n      switch (e) {\n        case -1:\n          n = i - 1;\n          break;\n\n        case 1:\n          i = n + 1;\n      }\n\n      switch (r) {\n        case -1:\n          a = o - 1;\n          break;\n\n        case 1:\n          o = a + 1;\n      }\n\n      for (var s = -e * this.dim, u = -r * this.dim, l = a; l < o; l++) {\n        for (var p = n; p < i; p++) {\n          this.data[this._idx(p, l)] = t.data[this._idx(p + s, l + u)];\n        }\n      }\n    }, On("DEMData", Yl);\n\n    var $l = function $l(t) {\n      this._stringToNumber = {}, this._numberToString = [];\n\n      for (var e = 0; e < t.length; e++) {\n        var r = t[e];\n        this._stringToNumber[r] = e, this._numberToString[e] = r;\n      }\n    };\n\n    $l.prototype.encode = function (t) {\n      return this._stringToNumber[t];\n    }, $l.prototype.decode = function (t) {\n      return this._numberToString[t];\n    };\n\n    var Wl = function Wl(t, e, r, n, i) {\n      this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i;\n    },\n        Ql = {\n      geometry: {\n        configurable: !0\n      }\n    };\n\n    Ql.geometry.get = function () {\n      return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;\n    }, Ql.geometry.set = function (t) {\n      this._geometry = t;\n    }, Wl.prototype.toJSON = function () {\n      var t = {\n        geometry: this.geometry\n      };\n\n      for (var e in this) {\n        "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]);\n      }\n\n      return t;\n    }, Object.defineProperties(Wl.prototype, Ql);\n\n    var tp = function tp() {\n      this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n    };\n\n    tp.prototype.updateState = function (t, e, r) {\n      var n = String(e);\n      if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, h(this.stateChanges[t][n], r), null === this.deletedStates[t]) for (var i in this.deletedStates[t] = {}, this.state[t]) {\n        i !== n && (this.deletedStates[t][i] = null);\n      } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) for (var a in this.deletedStates[t][n] = {}, this.state[t][n]) {\n        r[a] || (this.deletedStates[t][n][a] = null);\n      } else for (var o in r) {\n        this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][o] && delete this.deletedStates[t][n][o];\n      }\n    }, tp.prototype.removeFeatureState = function (t, e, r) {\n      if (null !== this.deletedStates[t]) {\n        var n = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) {\n            this.deletedStates[t][n][r] = null;\n          } else this.deletedStates[t][n] = null;\n        } else this.deletedStates[t] = null;\n      }\n    }, tp.prototype.getState = function (t, e) {\n      var r = String(e),\n          n = h({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);\n      if (null === this.deletedStates[t]) return {};\n\n      if (this.deletedStates[t]) {\n        var i = this.deletedStates[t][e];\n        if (null === i) return {};\n\n        for (var a in i) {\n          delete n[a];\n        }\n      }\n\n      return n;\n    }, tp.prototype.initializeTileState = function (t, e) {\n      t.setFeatureState(this.state, e);\n    }, tp.prototype.coalesceChanges = function (t, e) {\n      var r = {};\n\n      for (var n in this.stateChanges) {\n        this.state[n] = this.state[n] || {};\n        var i = {};\n\n        for (var a in this.stateChanges[n]) {\n          this.state[n][a] || (this.state[n][a] = {}), h(this.state[n][a], this.stateChanges[n][a]), i[a] = this.state[n][a];\n        }\n\n        r[n] = i;\n      }\n\n      for (var o in this.deletedStates) {\n        this.state[o] = this.state[o] || {};\n        var s = {};\n        if (null === this.deletedStates[o]) for (var u in this.state[o]) {\n          s[u] = {}, this.state[o][u] = {};\n        } else for (var l in this.deletedStates[o]) {\n          if (null === this.deletedStates[o][l]) this.state[o][l] = {};else for (var p = 0, c = Object.keys(this.deletedStates[o][l]); p < c.length; p += 1) {\n            delete this.state[o][l][c[p]];\n          }\n          s[l] = this.state[o][l];\n        }\n        r[o] = r[o] || {}, h(r[o], s);\n      }\n\n      if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (var f in t) {\n        t[f].setFeatureState(r, e);\n      }\n    };\n\n    var ep = function ep(t, e) {\n      this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Tn(8192, 16, 0), this.grid3D = new Tn(8192, 16, 0), this.featureIndexArray = new aa(), this.promoteId = e;\n    };\n\n    function rp(t, e, r, n, i) {\n      return x(t, function (t, a) {\n        var o = e instanceof di ? e.get(a) : null;\n        return o && o.evaluate ? o.evaluate(r, n, i) : o;\n      });\n    }\n\n    function np(t) {\n      for (var e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0, o = t; a < o.length; a += 1) {\n        var s = o[a];\n        e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      }\n\n      return {\n        minX: e,\n        minY: r,\n        maxX: n,\n        maxY: i\n      };\n    }\n\n    function ip(t, e) {\n      return e - t;\n    }\n\n    ep.prototype.insert = function (t, e, r, n, i, a) {\n      var o = this.featureIndexArray.length;\n      this.featureIndexArray.emplaceBack(r, n, i);\n\n      for (var s = a ? this.grid3D : this.grid, u = 0; u < e.length; u++) {\n        for (var l = e[u], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = 0; c < l.length; c++) {\n          var h = l[c];\n          p[0] = Math.min(p[0], h.x), p[1] = Math.min(p[1], h.y), p[2] = Math.max(p[2], h.x), p[3] = Math.max(p[3], h.y);\n        }\n\n        p[0] < 8192 && p[1] < 8192 && p[2] >= 0 && p[3] >= 0 && s.insert(o, p[0], p[1], p[2], p[3]);\n      }\n    }, ep.prototype.loadVTLayers = function () {\n      return this.vtLayers || (this.vtLayers = new bs.VectorTile(new Ys(this.rawTileData)).layers, this.sourceLayerCoder = new $l(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;\n    }, ep.prototype.query = function (t, e, r, n) {\n      var a = this;\n      this.loadVTLayers();\n\n      for (var o = t.params || {}, s = 8192 / t.tileSize / t.scale, u = on(o.filter), l = t.queryGeometry, p = t.queryPadding * s, c = np(l), h = this.grid.query(c.minX - p, c.minY - p, c.maxX + p, c.maxY + p), f = np(t.cameraQueryGeometry), y = this.grid3D.query(f.minX - p, f.minY - p, f.maxX + p, f.maxY + p, function (e, r, n, a) {\n        return function (t, e, r, n, a) {\n          for (var o = 0, s = t; o < s.length; o += 1) {\n            var u = s[o];\n            if (e <= u.x && r <= u.y && n >= u.x && a >= u.y) return !0;\n          }\n\n          var l = [new i(e, r), new i(e, a), new i(n, a), new i(n, r)];\n          if (t.length > 2) for (var p = 0, c = l; p < c.length; p += 1) {\n            if (Wa(t, c[p])) return !0;\n          }\n\n          for (var h = 0; h < t.length - 1; h++) {\n            if (Qa(t[h], t[h + 1], l)) return !0;\n          }\n\n          return !1;\n        }(t.cameraQueryGeometry, e - p, r - p, n + p, a + p);\n      }), d = 0, m = y; d < m.length; d += 1) {\n        h.push(m[d]);\n      }\n\n      h.sort(ip);\n\n      for (var v, g = {}, x = function x(i) {\n        var p = h[i];\n\n        if (p !== v) {\n          v = p;\n          var c = a.featureIndexArray.get(p),\n              f = null;\n          a.loadMatchingFeature(g, c.bucketIndex, c.sourceLayerIndex, c.featureIndex, u, o.layers, o.availableImages, e, r, n, function (e, r, n) {\n            return f || (f = Ra(e)), r.queryIntersectsFeature(l, e, n, f, a.z, t.transform, s, t.pixelPosMatrix);\n          });\n        }\n      }, b = 0; b < h.length; b++) {\n        x(b);\n      }\n\n      return g;\n    }, ep.prototype.loadMatchingFeature = function (t, e, r, n, i, a, o, s, u, l, p) {\n      var c = this.bucketLayerIDs[e];\n\n      if (!a || function (t, e) {\n        for (var r = 0; r < t.length; r++) {\n          if (e.indexOf(t[r]) >= 0) return !0;\n        }\n\n        return !1;\n      }(a, c)) {\n        var f = this.sourceLayerCoder.decode(r),\n            y = this.vtLayers[f].feature(n);\n\n        if (i.needGeometry) {\n          var d = Ua(y, !0);\n          if (!i.filter(new si(this.tileID.overscaledZ), d, this.tileID.canonical)) return;\n        } else if (!i.filter(new si(this.tileID.overscaledZ), y)) return;\n\n        for (var m = this.getId(y, f), v = 0; v < c.length; v++) {\n          var g = c[v];\n\n          if (!(a && a.indexOf(g) < 0)) {\n            var x = s[g];\n\n            if (x) {\n              var b = {};\n              void 0 !== m && l && (b = l.getState(x.sourceLayer || "_geojsonTileLayer", m));\n              var w = h({}, u[g]);\n              w.paint = rp(w.paint, x.paint, y, b, o), w.layout = rp(w.layout, x.layout, y, b, o);\n\n              var _ = !p || p(y, x, b);\n\n              if (_) {\n                var A = new Wl(y, this.z, this.x, this.y, m);\n                A.layer = w;\n                var S = t[g];\n                void 0 === S && (S = t[g] = []), S.push({\n                  featureIndex: n,\n                  feature: A,\n                  intersectionZ: _\n                });\n              }\n            }\n          }\n        }\n      }\n    }, ep.prototype.lookupSymbolFeatures = function (t, e, r, n, i, a, o, s) {\n      var u = {};\n      this.loadVTLayers();\n\n      for (var l = on(i), p = 0, c = t; p < c.length; p += 1) {\n        this.loadMatchingFeature(u, r, n, c[p], l, a, o, s, e);\n      }\n\n      return u;\n    }, ep.prototype.hasLayer = function (t) {\n      for (var e = 0, r = this.bucketLayerIDs; e < r.length; e += 1) {\n        for (var n = 0, i = r[e]; n < i.length; n += 1) {\n          if (t === i[n]) return !0;\n        }\n      }\n\n      return !1;\n    }, ep.prototype.getId = function (t, e) {\n      var r = t.id;\n      return this.promoteId && "boolean" == typeof (r = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]]) && (r = Number(r)), r;\n    }, On("FeatureIndex", ep, {\n      omit: ["rawTileData", "sourceLayerCoder"]\n    });\n\n    var ap = function ap(t, e) {\n      this.tileID = t, this.uid = y(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";\n    };\n\n    ap.prototype.registerFadeDuration = function (t) {\n      var e = t + this.timeAdded;\n      e < O.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);\n    }, ap.prototype.wasRequested = function () {\n      return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;\n    }, ap.prototype.loadVectorData = function (t, e, r) {\n      if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {\n        for (var n in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {\n          var r = {};\n          if (!e) return r;\n\n          for (var n = function n() {\n            var t = a[i],\n                n = t.layerIds.map(function (t) {\n              return e.getLayer(t);\n            }).filter(Boolean);\n\n            if (0 !== n.length) {\n              t.layers = n, t.stateDependentLayerIds && (t.stateDependentLayers = t.stateDependentLayerIds.map(function (t) {\n                return n.filter(function (e) {\n                  return e.id === t;\n                })[0];\n              }));\n\n              for (var o = 0, s = n; o < s.length; o += 1) {\n                r[s[o].id] = t;\n              }\n            }\n          }, i = 0, a = t; i < a.length; i += 1) {\n            n();\n          }\n\n          return r;\n        }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) {\n          var i = this.buckets[n];\n\n          if (i instanceof vl) {\n            if (this.hasSymbolBuckets = !0, !r) break;\n            i.justReloaded = !0;\n          }\n        }\n\n        if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var a in this.buckets) {\n          var o = this.buckets[a];\n\n          if (o instanceof vl && o.hasRTLText) {\n            this.hasRTLText = !0, oi.isLoading() || oi.isLoaded() || "deferred" !== ii() || ai();\n            break;\n          }\n        }\n\n        for (var s in this.queryPadding = 0, this.buckets) {\n          var u = this.buckets[s];\n          this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(s).queryRadius(u));\n        }\n\n        t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);\n      } else this.collisionBoxArray = new $i();\n    }, ap.prototype.unloadVectorData = function () {\n      for (var t in this.buckets) {\n        this.buckets[t].destroy();\n      }\n\n      this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";\n    }, ap.prototype.getBucket = function (t) {\n      return this.buckets[t.id];\n    }, ap.prototype.upload = function (t) {\n      for (var e in this.buckets) {\n        var r = this.buckets[e];\n        r.uploadPending() && r.upload(t);\n      }\n\n      var n = t.gl;\n      this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Tl(t, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Tl(t, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null);\n    }, ap.prototype.prepare = function (t) {\n      this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n    }, ap.prototype.queryRenderedFeatures = function (t, e, r, n, i, a, o, s, u, l) {\n      return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n        queryGeometry: n,\n        cameraQueryGeometry: i,\n        scale: a,\n        tileSize: this.tileSize,\n        pixelPosMatrix: l,\n        transform: s,\n        params: o,\n        queryPadding: this.queryPadding * u\n      }, t, e, r) : {};\n    }, ap.prototype.querySourceFeatures = function (t, e) {\n      var r = this.latestFeatureIndex;\n\n      if (r && r.rawTileData) {\n        var n = r.loadVTLayers(),\n            i = e ? e.sourceLayer : "",\n            a = n._geojsonTileLayer || n[i];\n        if (a) for (var o = on(e && e.filter), s = this.tileID.canonical, u = s.z, l = s.x, p = s.y, c = {\n          z: u,\n          x: l,\n          y: p\n        }, h = 0; h < a.length; h++) {\n          var f = a.feature(h);\n\n          if (o.needGeometry) {\n            var y = Ua(f, !0);\n            if (!o.filter(new si(this.tileID.overscaledZ), y, this.tileID.canonical)) continue;\n          } else if (!o.filter(new si(this.tileID.overscaledZ), f)) continue;\n\n          var d = r.getId(f, i),\n              m = new Wl(f, u, l, p, d);\n          m.tile = c, t.push(m);\n        }\n      }\n    }, ap.prototype.hasData = function () {\n      return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;\n    }, ap.prototype.patternsLoaded = function () {\n      return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }, ap.prototype.setExpiryData = function (t) {\n      var e = this.expirationTime;\n\n      if (t.cacheControl) {\n        var r = z(t.cacheControl);\n        r["max-age"] && (this.expirationTime = Date.now() + 1e3 * r["max-age"]);\n      } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n\n      if (this.expirationTime) {\n        var n = Date.now(),\n            i = !1;\n        if (this.expirationTime > n) i = !1;else if (e) {\n          if (this.expirationTime < e) i = !0;else {\n            var a = this.expirationTime - e;\n            a ? this.expirationTime = n + Math.max(a, 3e4) : i = !0;\n          }\n        } else i = !0;\n        i ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;\n      }\n    }, ap.prototype.getExpiryTimeout = function () {\n      if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n    }, ap.prototype.setFeatureState = function (t, e) {\n      if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) {\n        var r = this.latestFeatureIndex.loadVTLayers();\n\n        for (var n in this.buckets) {\n          if (e.style.hasLayer(n)) {\n            var i = this.buckets[n],\n                a = i.layers[0].sourceLayer || "_geojsonTileLayer",\n                o = r[a],\n                s = t[a];\n\n            if (o && s && 0 !== Object.keys(s).length) {\n              i.update(s, o, this.imageAtlas && this.imageAtlas.patternPositions || {});\n              var u = e && e.style && e.style.getLayer(n);\n              u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(i)));\n            }\n          }\n        }\n      }\n    }, ap.prototype.holdingForFade = function () {\n      return void 0 !== this.symbolFadeHoldUntil;\n    }, ap.prototype.symbolFadeFinished = function () {\n      return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < O.now();\n    }, ap.prototype.clearFadeHold = function () {\n      this.symbolFadeHoldUntil = void 0;\n    }, ap.prototype.setHoldDuration = function (t) {\n      this.symbolFadeHoldUntil = O.now() + t;\n    }, ap.prototype.setDependencies = function (t, e) {\n      for (var r = {}, n = 0, i = e; n < i.length; n += 1) {\n        r[i[n]] = !0;\n      }\n\n      this.dependencies[t] = r;\n    }, ap.prototype.hasDependency = function (t, e) {\n      for (var r = 0, n = t; r < n.length; r += 1) {\n        var i = this.dependencies[n[r]];\n        if (i) for (var a = 0, o = e; a < o.length; a += 1) {\n          if (i[o[a]]) return !0;\n        }\n      }\n\n      return !1;\n    };\n\n    var op = o.performance,\n        sp = function sp(t) {\n      this._marks = {\n        start: [t.url, "start"].join("#"),\n        end: [t.url, "end"].join("#"),\n        measure: t.url.toString()\n      }, op.mark(this._marks.start);\n    };\n\n    sp.prototype.finish = function () {\n      op.mark(this._marks.end);\n      var t = op.getEntriesByName(this._marks.measure);\n      return 0 === t.length && (op.measure(this._marks.measure, this._marks.start, this._marks.end), t = op.getEntriesByName(this._marks.measure), op.clearMarks(this._marks.start), op.clearMarks(this._marks.end), op.clearMeasures(this._marks.measure)), t;\n    }, t.Actor = Fl, t.AlphaImage = go, t.CanonicalTileID = Zl, t.CollisionBoxArray = $i, t.Color = te, t.DEMData = Yl, t.DataConstantProperty = mi, t.DictionaryCoder = $l, t.EXTENT = 8192, t.ErrorEvent = zt, t.EvaluationParameters = si, t.Event = It, t.Evented = Ct, t.FeatureIndex = ep, t.FillBucket = ss, t.FillExtrusionBucket = Ss, t.ImageAtlas = bu, t.ImagePosition = gu, t.LineBucket = Fs, t.LngLat = Ol, t.LngLatBounds = Ll, t.MercatorCoordinate = Gl, t.ONE_EM = 24, t.OverscaledTileID = Jl, t.Point = i, t.Point$1 = i, t.Properties = wi, t.Protobuf = Ys, t.RGBAImage = xo, t.RequestManager = G, t.RequestPerformance = sp, t.ResourceType = yt, t.SegmentVector = sa, t.SourceFeatureState = tp, t.StructArrayLayout1ui2 = Ji, t.StructArrayLayout2f1f2i16 = Ri, t.StructArrayLayout2i4 = Ci, t.StructArrayLayout3ui6 = ji, t.StructArrayLayout4i8 = Ei, t.SymbolBucket = vl, t.Texture = Tl, t.Tile = ap, t.Transitionable = pi, t.Uniform1f = ba, t.Uniform1i = xa, t.Uniform2f = wa, t.Uniform3f = _a, t.Uniform4f = Aa, t.UniformColor = Sa, t.UniformMatrix4f = Ia, t.UnwrappedTileID = Xl, t.ValidationError = Pt, t.WritingMode = wu, t.ZoomHistory = Kn, t.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }, t.addDynamicAttributes = fl, t.asyncAll = function (t, e, r) {\n      if (!t.length) return r(null, []);\n      var n = t.length,\n          i = new Array(t.length),\n          a = null;\n      t.forEach(function (t, o) {\n        e(t, function (t, e) {\n          t && (a = t), i[o] = e, 0 == --n && r(a, i);\n        });\n      });\n    }, t.bezier = u, t.bindAll = v, t.browser = O, t.cacheEntryPossiblyAdded = function (t) {\n      ++ht > ut && (t.getActor().send("enforceCacheSizeLimit", st), ht = 0);\n    }, t.clamp = p, t.clearTileCache = function (t) {\n      var e = o.caches.delete("mapbox-tiles");\n      t && e.catch(t).then(function () {\n        return t();\n      });\n    }, t.clipLine = Zu, t.clone = function (t) {\n      var e = new ao(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = w, t.clone$2 = function (t) {\n      var e = new ao(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }, t.collisionCircleLayout = Gs, t.config = R, t.create = function () {\n      var t = new ao(16);\n      return ao != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.create$1 = function () {\n      var t = new ao(9);\n      return ao != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }, t.create$2 = function () {\n      var t = new ao(4);\n      return ao != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n    }, t.createCommonjsModule = e, t.createExpression = Zr, t.createLayout = Ii, t.createStyleLayer = function (t) {\n      return "custom" === t.type ? new Il(t) : new zl[t.type](t);\n    }, t.cross = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = r[0],\n          s = r[1],\n          u = r[2];\n      return t[0] = i * u - a * s, t[1] = a * o - n * u, t[2] = n * s - i * o, t;\n    }, t.deepEqual = function t(e, r) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(r) || e.length !== r.length) return !1;\n\n        for (var n = 0; n < e.length; n++) {\n          if (!t(e[n], r[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      if ("object" == typeof e && null !== e && null !== r) {\n        if ("object" != typeof r) return !1;\n        if (Object.keys(e).length !== Object.keys(r).length) return !1;\n\n        for (var i in e) {\n          if (!t(e[i], r[i])) return !1;\n        }\n\n        return !0;\n      }\n\n      return e === r;\n    }, t.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }, t.dot$1 = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n    }, t.ease = l, t.emitValidationErrors = Bn, t.endsWith = g, t.enforceCacheSizeLimit = function (t) {\n      lt(), tt && tt.then(function (e) {\n        e.keys().then(function (r) {\n          for (var n = 0; n < r.length - t; n++) {\n            e.delete(r[n]);\n          }\n        });\n      });\n    }, t.evaluateSizeForFeature = Lu, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = al, t.evented = ni, t.extend = h, t.featureFilter = on, t.filterObject = b, t.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n          n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.getAnchorAlignment = Bu, t.getAnchorJustification = ol, t.getArrayBuffer = bt, t.getImage = At, t.getJSON = function (t, e) {\n      return xt(h(t, {\n        type: "json"\n      }), e);\n    }, t.getRTLTextPluginStatus = ii, t.getReferrer = mt, t.getVideo = function (t, e) {\n      var r,\n          n,\n          i = o.document.createElement("video");\n      i.muted = !0, i.onloadstart = function () {\n        e(null, i);\n      };\n\n      for (var a = 0; a < t.length; a++) {\n        var s = o.document.createElement("source");\n        r = t[a], n = void 0, (n = o.document.createElement("a")).href = r, (n.protocol !== o.document.location.protocol || n.host !== o.document.location.host) && (i.crossOrigin = "Anonymous"), s.src = t[a], i.appendChild(s);\n      }\n\n      return {\n        cancel: function cancel() {}\n      };\n    }, t.identity = oo, t.invert = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = e[3],\n          o = e[4],\n          s = e[5],\n          u = e[6],\n          l = e[7],\n          p = e[8],\n          c = e[9],\n          h = e[10],\n          f = e[11],\n          y = e[12],\n          d = e[13],\n          m = e[14],\n          v = e[15],\n          g = r * s - n * o,\n          x = r * u - i * o,\n          b = r * l - a * o,\n          w = n * u - i * s,\n          _ = n * l - a * s,\n          A = i * l - a * u,\n          S = p * d - c * y,\n          k = p * m - h * y,\n          I = p * v - f * y,\n          z = c * m - h * d,\n          C = c * v - f * d,\n          E = h * v - f * m,\n          P = g * E - x * C + b * z + w * I - _ * k + A * S;\n\n      return P ? (t[0] = (s * E - u * C + l * z) * (P = 1 / P), t[1] = (i * C - n * E - a * z) * P, t[2] = (d * A - m * _ + v * w) * P, t[3] = (h * _ - c * A - f * w) * P, t[4] = (u * I - o * E - l * k) * P, t[5] = (r * E - i * I + a * k) * P, t[6] = (m * b - y * A - v * x) * P, t[7] = (p * A - h * b + f * x) * P, t[8] = (o * C - s * I + l * S) * P, t[9] = (n * I - r * C - a * S) * P, t[10] = (y * _ - d * b + v * g) * P, t[11] = (c * b - p * _ - f * g) * P, t[12] = (s * k - o * z - u * S) * P, t[13] = (r * z - n * k + i * S) * P, t[14] = (d * x - y * w - m * g) * P, t[15] = (p * w - c * x + h * g) * P, t) : null;\n    }, t.isChar = Gn, t.isMapboxURL = Z, t.keysDifference = function (t, e) {\n      var r = [];\n\n      for (var n in t) {\n        n in e || r.push(n);\n      }\n\n      return r;\n    }, t.makeRequest = xt, t.mapObject = x, t.mercatorXfromLng = jl, t.mercatorYfromLat = ql, t.mercatorZfromAltitude = Nl, t.mul = lo, t.multiply = so, t.mvt = bs, t.nextPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }, t.normalize = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = r * r + n * n + i * i;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;\n    }, t.number = Ke, t.offscreenCanvasSupported = ft, t.ortho = function (t, e, r, n, i, a, o) {\n      var s = 1 / (e - r),\n          u = 1 / (n - i),\n          l = 1 / (a - o);\n      return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + r) * s, t[13] = (i + n) * u, t[14] = (o + a) * l, t[15] = 1, t;\n    }, t.parseGlyphPBF = function (t) {\n      return new Ys(t).readFields(yu, []);\n    }, t.pbf = Ys, t.performSymbolLayout = function (t, e, r, n, i, a, o) {\n      t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      var s = t.layers[0].layout,\n          u = t.layers[0]._unevaluatedLayout._values,\n          l = {};\n\n      if ("composite" === t.textSizeData.kind) {\n        var p = t.textSizeData,\n            c = p.maxZoom;\n        l.compositeTextSizes = [u["text-size"].possiblyEvaluate(new si(p.minZoom), o), u["text-size"].possiblyEvaluate(new si(c), o)];\n      }\n\n      if ("composite" === t.iconSizeData.kind) {\n        var h = t.iconSizeData,\n            f = h.maxZoom;\n        l.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new si(h.minZoom), o), u["icon-size"].possiblyEvaluate(new si(f), o)];\n      }\n\n      l.layoutTextSize = u["text-size"].possiblyEvaluate(new si(t.zoom + 1), o), l.layoutIconSize = u["icon-size"].possiblyEvaluate(new si(t.zoom + 1), o), l.textMaxSize = u["text-size"].possiblyEvaluate(new si(18));\n\n      for (var y = 24 * s.get("text-line-height"), d = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"), m = s.get("text-keep-upright"), v = s.get("text-size"), g = function g() {\n        var a = b[x],\n            u = s.get("text-font").evaluate(a, {}, o).join(","),\n            p = v.evaluate(a, {}, o),\n            c = l.layoutTextSize.evaluate(a, {}, o),\n            h = l.layoutIconSize.evaluate(a, {}, o),\n            f = {\n          horizontal: {},\n          vertical: void 0\n        },\n            g = a.text,\n            w = [0, 0];\n\n        if (g) {\n          var _ = g.toString(),\n              S = 24 * s.get("text-letter-spacing").evaluate(a, {}, o),\n              k = function (t) {\n            for (var e = 0, r = t; e < r.length; e += 1) {\n              if (n = r[e].charCodeAt(0), Gn.Arabic(n) || Gn["Arabic Supplement"](n) || Gn["Arabic Extended-A"](n) || Gn["Arabic Presentation Forms-A"](n) || Gn["Arabic Presentation Forms-B"](n)) return !1;\n            }\n\n            var n;\n            return !0;\n          }(_) ? S : 0,\n              I = s.get("text-anchor").evaluate(a, {}, o),\n              z = s.get("text-variable-anchor");\n\n          if (!z) {\n            var C = s.get("text-radial-offset").evaluate(a, {}, o);\n            w = C ? al(I, [24 * C, il]) : s.get("text-offset").evaluate(a, {}, o).map(function (t) {\n              return 24 * t;\n            });\n          }\n\n          var E = d ? "center" : s.get("text-justify").evaluate(a, {}, o),\n              P = s.get("symbol-placement"),\n              M = "point" === P ? 24 * s.get("text-max-width").evaluate(a, {}, o) : 0,\n              B = function B() {\n            t.allowVerticalPlacement && Zn(_) && (f.vertical = Su(g, e, r, i, u, M, y, I, "left", k, w, wu.vertical, !0, P, c, p));\n          };\n\n          if (!d && z) {\n            for (var T = "auto" === E ? z.map(function (t) {\n              return ol(t);\n            }) : [E], V = !1, F = 0; F < T.length; F++) {\n              var D = T[F];\n              if (!f.horizontal[D]) if (V) f.horizontal[D] = f.horizontal[0];else {\n                var L = Su(g, e, r, i, u, M, y, "center", D, k, w, wu.horizontal, !1, P, c, p);\n                L && (f.horizontal[D] = L, V = 1 === L.positionedLines.length);\n              }\n            }\n\n            B();\n          } else {\n            "auto" === E && (E = ol(I));\n            var O = Su(g, e, r, i, u, M, y, I, E, k, w, wu.horizontal, !1, P, c, p);\n            O && (f.horizontal[E] = O), B(), Zn(_) && d && m && (f.vertical = Su(g, e, r, i, u, M, y, I, E, k, w, wu.vertical, !1, P, c, p));\n          }\n        }\n\n        var R = void 0,\n            U = !1;\n\n        if (a.icon && a.icon.name) {\n          var j = n[a.icon.name];\n          j && (R = function (t, e, r) {\n            var n = Bu(r),\n                i = e[0] - t.displaySize[0] * n.horizontalAlign,\n                a = e[1] - t.displaySize[1] * n.verticalAlign;\n            return {\n              image: t,\n              top: a,\n              bottom: a + t.displaySize[1],\n              left: i,\n              right: i + t.displaySize[0]\n            };\n          }(i[a.icon.name], s.get("icon-offset").evaluate(a, {}, o), s.get("icon-anchor").evaluate(a, {}, o)), U = j.sdf, void 0 === t.sdfIcons ? t.sdfIcons = j.sdf : t.sdfIcons !== j.sdf && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j.pixelRatio !== t.pixelRatio || 0 !== s.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n\n        var q = ul(f.horizontal) || f.vertical;\n        t.iconsInText = !!q && q.iconsInText, (q || R) && function (t, e, r, n, i, a, o, s, u, l, p) {\n          var c = a.textMaxSize.evaluate(e, {});\n          void 0 === c && (c = o);\n\n          var h,\n              f = t.layers[0].layout,\n              y = f.get("icon-offset").evaluate(e, {}, p),\n              d = ul(r.horizontal),\n              m = o / 24,\n              v = t.tilePixelRatio * m,\n              g = t.tilePixelRatio * c / 24,\n              x = t.tilePixelRatio * s,\n              b = t.tilePixelRatio * f.get("symbol-spacing"),\n              w = f.get("text-padding") * t.tilePixelRatio,\n              _ = f.get("icon-padding") * t.tilePixelRatio,\n              S = f.get("text-max-angle") / 180 * Math.PI,\n              k = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              I = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              z = f.get("symbol-placement"),\n              C = b / 2,\n              E = f.get("icon-text-fit");\n\n          n && "none" !== E && (t.allowVerticalPlacement && r.vertical && (h = Vu(n, r.vertical, E, f.get("icon-text-fit-padding"), y, m)), d && (n = Vu(n, d, E, f.get("icon-text-fit-padding"), y, m)));\n\n          var P = function P(s, c) {\n            c.x < 0 || c.x >= 8192 || c.y < 0 || c.y >= 8192 || function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, S, k) {\n              var I,\n                  z,\n                  C,\n                  E,\n                  P,\n                  M = t.addToLineVertexArray(e, r),\n                  B = 0,\n                  T = 0,\n                  V = 0,\n                  F = 0,\n                  D = -1,\n                  L = -1,\n                  O = {},\n                  R = ha(""),\n                  U = 0,\n                  j = 0;\n\n              if (void 0 === s._unevaluatedLayout.getValue("text-radial-offset") ? (U = (I = s.layout.get("text-offset").evaluate(b, {}, S).map(function (t) {\n                return 24 * t;\n              }))[0], j = I[1]) : (U = 24 * s.layout.get("text-radial-offset").evaluate(b, {}, S), j = il), t.allowVerticalPlacement && n.vertical) {\n                var q = s.layout.get("text-rotate").evaluate(b, {}, S) + 90;\n                E = new Wu(u, e, l, p, c, n.vertical, h, f, y, q), o && (P = new Wu(u, e, l, p, c, o, m, v, y, q));\n              }\n\n              if (i) {\n                var N = s.layout.get("icon-rotate").evaluate(b, {}),\n                    K = "none" !== s.layout.get("icon-text-fit"),\n                    G = Xu(i, N, _, K),\n                    Z = o ? Xu(o, N, _, K) : void 0;\n                C = new Wu(u, e, l, p, c, i, m, v, !1, N), B = 4 * G.length;\n                var X = t.iconSizeData,\n                    J = null;\n                "source" === X.kind ? (J = [128 * s.layout.get("icon-size").evaluate(b, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\') : "composite" === X.kind && ((J = [128 * w.compositeIconSizes[0].evaluate(b, {}, S), 128 * w.compositeIconSizes[1].evaluate(b, {}, S)])[0] > 32640 || J[1] > 32640) && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\'), t.addSymbols(t.icon, G, J, x, g, b, !1, e, M.lineStartIndex, M.lineLength, -1, S), D = t.icon.placedSymbolArray.length - 1, Z && (T = 4 * Z.length, t.addSymbols(t.icon, Z, J, x, g, b, wu.vertical, e, M.lineStartIndex, M.lineLength, -1, S), L = t.icon.placedSymbolArray.length - 1);\n              }\n\n              for (var H in n.horizontal) {\n                var Y = n.horizontal[H];\n\n                if (!z) {\n                  R = ha(Y.text);\n                  var $ = s.layout.get("text-rotate").evaluate(b, {}, S);\n                  z = new Wu(u, e, l, p, c, Y, h, f, y, $);\n                }\n\n                var W = 1 === Y.positionedLines.length;\n                if (V += sl(t, e, Y, a, s, y, b, d, M, n.vertical ? wu.horizontal : wu.horizontalOnly, W ? Object.keys(n.horizontal) : [H], O, D, w, S), W) break;\n              }\n\n              n.vertical && (F += sl(t, e, n.vertical, a, s, y, b, d, M, wu.vertical, ["vertical"], O, L, w, S));\n\n              var Q = z ? z.boxStartIndex : t.collisionBoxArray.length,\n                  tt = z ? z.boxEndIndex : t.collisionBoxArray.length,\n                  et = E ? E.boxStartIndex : t.collisionBoxArray.length,\n                  rt = E ? E.boxEndIndex : t.collisionBoxArray.length,\n                  nt = C ? C.boxStartIndex : t.collisionBoxArray.length,\n                  it = C ? C.boxEndIndex : t.collisionBoxArray.length,\n                  at = P ? P.boxStartIndex : t.collisionBoxArray.length,\n                  ot = P ? P.boxEndIndex : t.collisionBoxArray.length,\n                  st = -1,\n                  ut = function ut(t, e) {\n                return t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;\n              };\n\n              st = ut(z, st), st = ut(E, st), st = ut(C, st);\n              var lt = (st = ut(P, st)) > -1 ? 1 : 0;\n              lt && (st *= k / 24), t.glyphOffsetArray.length >= vl.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, O.right >= 0 ? O.right : -1, O.center >= 0 ? O.center : -1, O.left >= 0 ? O.left : -1, O.vertical || -1, D, L, R, Q, tt, et, rt, nt, it, at, ot, l, V, F, B, T, lt, 0, h, U, j, st);\n            }(t, c, s, r, n, i, h, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, v, w, k, u, x, _, I, y, e, a, l, p, o);\n          };\n\n          if ("line" === z) for (var M = 0, B = Zu(e.geometry, 0, 0, 8192, 8192); M < B.length; M += 1) {\n            for (var T = B[M], V = 0, F = Gu(T, b, S, r.vertical || d, n, 24, g, t.overscaling, 8192); V < F.length; V += 1) {\n              var D = F[V];\n              d && ll(t, d.text, C, D) || P(T, D);\n            }\n          } else if ("line-center" === z) for (var L = 0, O = e.geometry; L < O.length; L += 1) {\n            var R = O[L];\n\n            if (R.length > 1) {\n              var U = Ku(R, S, r.vertical || d, n, 24, g);\n              U && P(R, U);\n            }\n          } else if ("Polygon" === e.type) for (var j = 0, q = ns(e.geometry, 0); j < q.length; j += 1) {\n            var N = q[j],\n                K = el(N, 16);\n            P(N[0], new Fu(K.x, K.y, 0));\n          } else if ("LineString" === e.type) for (var G = 0, Z = e.geometry; G < Z.length; G += 1) {\n            var X = Z[G];\n            P(X, new Fu(X[0].x, X[0].y, 0));\n          } else if ("Point" === e.type) for (var J = 0, H = e.geometry; J < H.length; J += 1) {\n            for (var Y = 0, $ = H[J]; Y < $.length; Y += 1) {\n              var W = $[Y];\n              P([W], new Fu(W.x, W.y, 0));\n            }\n          }\n        }(t, a, f, R, n, l, c, h, w, U, o);\n      }, x = 0, b = t.features; x < b.length; x += 1) {\n        g();\n      }\n\n      a && t.generateCollisionDebugBuffers();\n    }, t.perspective = function (t, e, r, n, i) {\n      var a,\n          o = 1 / Math.tan(e / 2);\n      return t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (a = 1 / (n - i)), t[14] = 2 * i * n * a) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      for (var r = {}, n = 0; n < e.length; n++) {\n        var i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n\n      return r;\n    }, t.plugin = oi, t.polygonIntersectsPolygon = Na, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = vu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: Qn,\n        pluginURL: ti\n      }), ni.on("pluginStateChange", t), t;\n    }, t.renderColorRamp = wo, t.rotate = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3],\n          s = Math.sin(r),\n          u = Math.cos(r);\n      return t[0] = n * u + a * s, t[1] = i * u + o * s, t[2] = n * -s + a * u, t[3] = i * -s + o * u, t;\n    }, t.rotateX = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          a = e[4],\n          o = e[5],\n          s = e[6],\n          u = e[7],\n          l = e[8],\n          p = e[9],\n          c = e[10],\n          h = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + l * n, t[5] = o * i + p * n, t[6] = s * i + c * n, t[7] = u * i + h * n, t[8] = l * i - a * n, t[9] = p * i - o * n, t[10] = c * i - s * n, t[11] = h * i - u * n, t;\n    }, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          a = e[0],\n          o = e[1],\n          s = e[2],\n          u = e[3],\n          l = e[4],\n          p = e[5],\n          c = e[6],\n          h = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + l * n, t[1] = o * i + p * n, t[2] = s * i + c * n, t[3] = u * i + h * n, t[4] = l * i - a * n, t[5] = p * i - o * n, t[6] = c * i - s * n, t[7] = h * i - u * n, t;\n    }, t.scale = function (t, e, r) {\n      var n = r[0],\n          i = r[1],\n          a = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, t.scale$1 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, t.scale$2 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }, t.setCacheLimits = function (t, e) {\n      st = t, ut = e;\n    }, t.setRTLTextPlugin = function (t, e, r) {\n      if (void 0 === r && (r = !1), "deferred" === Qn || "loading" === Qn || "loaded" === Qn) throw new Error("setRTLTextPlugin cannot be called multiple times.");\n      ti = O.resolveURL(t), Qn = "deferred", Wn = e, ri(), r || ai();\n    }, t.sphericalToCartesian = function (t) {\n      var e = t[0],\n          r = t[1],\n          n = t[2];\n      return r += 90, r *= Math.PI / 180, n *= Math.PI / 180, {\n        x: e * Math.cos(r) * Math.sin(n),\n        y: e * Math.sin(r) * Math.sin(n),\n        z: e * Math.cos(n)\n      };\n    }, t.sqrLen = function (t) {\n      var e = t[0],\n          r = t[1];\n      return e * e + r * r;\n    }, t.styleSpec = Et, t.sub = function (t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }, t.symbolSize = Ru, t.transformMat3 = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2];\n      return t[0] = n * r[0] + i * r[3] + a * r[6], t[1] = n * r[1] + i * r[4] + a * r[7], t[2] = n * r[2] + i * r[5] + a * r[8], t;\n    }, t.transformMat4 = po, t.translate = function (t, e, r) {\n      var n,\n          i,\n          a,\n          o,\n          s,\n          u,\n          l,\n          p,\n          c,\n          h,\n          f,\n          y,\n          d = r[0],\n          m = r[1],\n          v = r[2];\n      return e === t ? (t[12] = e[0] * d + e[4] * m + e[8] * v + e[12], t[13] = e[1] * d + e[5] * m + e[9] * v + e[13], t[14] = e[2] * d + e[6] * m + e[10] * v + e[14], t[15] = e[3] * d + e[7] * m + e[11] * v + e[15]) : (i = e[1], a = e[2], o = e[3], s = e[4], u = e[5], l = e[6], p = e[7], c = e[8], h = e[9], f = e[10], y = e[11], t[0] = n = e[0], t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = u, t[6] = l, t[7] = p, t[8] = c, t[9] = h, t[10] = f, t[11] = y, t[12] = n * d + s * m + c * v + e[12], t[13] = i * d + u * m + h * v + e[13], t[14] = a * d + l * m + f * v + e[14], t[15] = o * d + p * m + y * v + e[15]), t;\n    }, t.triggerPluginCompletionEvent = ei, t.uniqueId = y, t.validateCustomStyleLayer = function (t) {\n      var e = [],\n          r = t.id;\n      return void 0 === r && e.push({\n        message: "layers." + r + \': missing required property "id"\'\n      }), void 0 === t.render && e.push({\n        message: "layers." + r + \': missing required method "render"\'\n      }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({\n        message: "layers." + r + \': property "renderingMode" must be either "2d" or "3d"\'\n      }), e;\n    }, t.validateLight = En, t.validateStyle = Cn, t.values = function (t) {\n      var e = [];\n\n      for (var r in t) {\n        e.push(t[r]);\n      }\n\n      return e;\n    }, t.vectorTile = bs, t.version = "1.13.1", t.warnOnce = A, t.webpSupported = U, t.window = o, t.wrap = c;\n  });\n  define(["./shared"], function (e) {\n    "use strict";\n\n    function t(e) {\n      var r = typeof e;\n      if ("number" === r || "boolean" === r || "string" === r || null == e) return JSON.stringify(e);\n\n      if (Array.isArray(e)) {\n        for (var i = "[", o = 0, n = e; o < n.length; o += 1) {\n          i += t(n[o]) + ",";\n        }\n\n        return i + "]";\n      }\n\n      for (var s = Object.keys(e).sort(), a = "{", l = 0; l < s.length; l++) {\n        a += JSON.stringify(s[l]) + ":" + t(e[s[l]]) + ",";\n      }\n\n      return a + "}";\n    }\n\n    function r(r) {\n      for (var i = "", o = 0, n = e.refProperties; o < n.length; o += 1) {\n        i += "/" + t(r[n[o]]);\n      }\n\n      return i;\n    }\n\n    var i = function i(e) {\n      this.keyCache = {}, e && this.replace(e);\n    };\n\n    i.prototype.replace = function (e) {\n      this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n    }, i.prototype.update = function (t, i) {\n      for (var o = this, n = 0, s = t; n < s.length; n += 1) {\n        var a = s[n];\n        this._layerConfigs[a.id] = a;\n        var l = this._layers[a.id] = e.createStyleLayer(a);\n        l._featureFilter = e.featureFilter(l.filter), this.keyCache[a.id] && delete this.keyCache[a.id];\n      }\n\n      for (var u = 0, h = i; u < h.length; u += 1) {\n        var c = h[u];\n        delete this.keyCache[c], delete this._layerConfigs[c], delete this._layers[c];\n      }\n\n      this.familiesBySource = {};\n\n      for (var p = 0, f = function (e, t) {\n        for (var i = {}, o = 0; o < e.length; o++) {\n          var n = t && t[e[o].id] || r(e[o]);\n          t && (t[e[o].id] = n);\n          var s = i[n];\n          s || (s = i[n] = []), s.push(e[o]);\n        }\n\n        var a = [];\n\n        for (var l in i) {\n          a.push(i[l]);\n        }\n\n        return a;\n      }(e.values(this._layerConfigs), this.keyCache); p < f.length; p += 1) {\n        var d = f[p].map(function (e) {\n          return o._layers[e.id];\n        }),\n            g = d[0];\n\n        if ("none" !== g.visibility) {\n          var v = g.source || "",\n              m = this.familiesBySource[v];\n          m || (m = this.familiesBySource[v] = {});\n          var y = g.sourceLayer || "_geojsonTileLayer",\n              x = m[y];\n          x || (x = m[y] = []), x.push(d);\n        }\n      }\n    };\n\n    var o = function o(t) {\n      var r = {},\n          i = [];\n\n      for (var o in t) {\n        var n = t[o],\n            s = r[o] = {};\n\n        for (var a in n) {\n          var l = n[+a];\n\n          if (l && 0 !== l.bitmap.width && 0 !== l.bitmap.height) {\n            var u = {\n              x: 0,\n              y: 0,\n              w: l.bitmap.width + 2,\n              h: l.bitmap.height + 2\n            };\n            i.push(u), s[a] = {\n              rect: u,\n              metrics: l.metrics\n            };\n          }\n        }\n      }\n\n      var h = e.potpack(i),\n          c = new e.AlphaImage({\n        width: h.w || 1,\n        height: h.h || 1\n      });\n\n      for (var p in t) {\n        var f = t[p];\n\n        for (var d in f) {\n          var g = f[+d];\n\n          if (g && 0 !== g.bitmap.width && 0 !== g.bitmap.height) {\n            var v = r[p][d].rect;\n            e.AlphaImage.copy(g.bitmap, c, {\n              x: 0,\n              y: 0\n            }, {\n              x: v.x + 1,\n              y: v.y + 1\n            }, g.bitmap);\n          }\n        }\n      }\n\n      this.image = c, this.positions = r;\n    };\n\n    e.register("GlyphAtlas", o);\n\n    var n = function n(t) {\n      this.tileID = new e.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId;\n    };\n\n    function s(t, r, i) {\n      for (var o = new e.EvaluationParameters(r), n = 0, s = t; n < s.length; n += 1) {\n        s[n].recalculate(o, i);\n      }\n    }\n\n    function a(t, r) {\n      var i = e.getArrayBuffer(t.request, function (t, i, o, n) {\n        t ? r(t) : i && r(null, {\n          vectorTile: new e.vectorTile.VectorTile(new e.pbf(i)),\n          rawData: i,\n          cacheControl: o,\n          expires: n\n        });\n      });\n      return function () {\n        i.cancel(), r();\n      };\n    }\n\n    n.prototype.parse = function (t, r, i, n, a) {\n      var l = this;\n      this.status = "parsing", this.data = t, this.collisionBoxArray = new e.CollisionBoxArray();\n      var u = new e.DictionaryCoder(Object.keys(t.layers).sort()),\n          h = new e.FeatureIndex(this.tileID, this.promoteId);\n      h.bucketLayerIDs = [];\n      var c,\n          p,\n          f,\n          d,\n          g = {},\n          v = {\n        featureIndex: h,\n        iconDependencies: {},\n        patternDependencies: {},\n        glyphDependencies: {},\n        availableImages: i\n      },\n          m = r.familiesBySource[this.source];\n\n      for (var y in m) {\n        var x = t.layers[y];\n\n        if (x) {\n          1 === x.version && e.warnOnce(\'Vector tile source "\' + this.source + \'" layer "\' + y + \'" does not use vector tile spec v2 and therefore may have some rendering errors.\');\n\n          for (var w = u.encode(y), S = [], I = 0; I < x.length; I++) {\n            var M = x.feature(I),\n                b = h.getId(M, y);\n            S.push({\n              feature: M,\n              id: b,\n              index: I,\n              sourceLayerIndex: w\n            });\n          }\n\n          for (var _ = 0, k = m[y]; _ < k.length; _ += 1) {\n            var P = k[_],\n                T = P[0];\n            T.minzoom && this.zoom < Math.floor(T.minzoom) || T.maxzoom && this.zoom >= T.maxzoom || "none" !== T.visibility && (s(P, this.zoom, i), (g[T.id] = T.createBucket({\n              index: h.bucketLayerIDs.length,\n              layers: P,\n              zoom: this.zoom,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: w,\n              sourceID: this.source\n            })).populate(S, v, this.tileID.canonical), h.bucketLayerIDs.push(P.map(function (e) {\n              return e.id;\n            })));\n          }\n        }\n      }\n\n      var C = e.mapObject(v.glyphDependencies, function (e) {\n        return Object.keys(e).map(Number);\n      });\n      Object.keys(C).length ? n.send("getGlyphs", {\n        uid: this.uid,\n        stacks: C\n      }, function (e, t) {\n        c || (c = e, p = t, z.call(l));\n      }) : p = {};\n      var D = Object.keys(v.iconDependencies);\n      D.length ? n.send("getImages", {\n        icons: D,\n        source: this.source,\n        tileID: this.tileID,\n        type: "icons"\n      }, function (e, t) {\n        c || (c = e, f = t, z.call(l));\n      }) : f = {};\n      var L = Object.keys(v.patternDependencies);\n\n      function z() {\n        if (c) return a(c);\n\n        if (p && f && d) {\n          var t = new o(p),\n              r = new e.ImageAtlas(f, d);\n\n          for (var n in g) {\n            var l = g[n];\n            l instanceof e.SymbolBucket ? (s(l.layers, this.zoom, i), e.performSymbolLayout(l, p, t.positions, f, r.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l.hasPattern && (l instanceof e.LineBucket || l instanceof e.FillBucket || l instanceof e.FillExtrusionBucket) && (s(l.layers, this.zoom, i), l.addFeatures(v, this.tileID.canonical, r.patternPositions));\n          }\n\n          this.status = "done", a(null, {\n            buckets: e.values(g).filter(function (e) {\n              return !e.isEmpty();\n            }),\n            featureIndex: h,\n            collisionBoxArray: this.collisionBoxArray,\n            glyphAtlasImage: t.image,\n            imageAtlas: r,\n            glyphMap: this.returnDependencies ? p : null,\n            iconMap: this.returnDependencies ? f : null,\n            glyphPositions: this.returnDependencies ? t.positions : null\n          });\n        }\n      }\n\n      L.length ? n.send("getImages", {\n        icons: L,\n        source: this.source,\n        tileID: this.tileID,\n        type: "patterns"\n      }, function (e, t) {\n        c || (c = e, d = t, z.call(l));\n      }) : d = {}, z.call(this);\n    };\n\n    var l = function l(e, t, r, i) {\n      this.actor = e, this.layerIndex = t, this.availableImages = r, this.loadVectorData = i || a, this.loading = {}, this.loaded = {};\n    };\n\n    l.prototype.loadTile = function (t, r) {\n      var i = this,\n          o = t.uid;\n      this.loading || (this.loading = {});\n      var s = !!(t && t.request && t.request.collectResourceTiming) && new e.RequestPerformance(t.request),\n          a = this.loading[o] = new n(t);\n      a.abort = this.loadVectorData(t, function (t, n) {\n        if (delete i.loading[o], t || !n) return a.status = "done", i.loaded[o] = a, r(t);\n        var l = n.rawData,\n            u = {};\n        n.expires && (u.expires = n.expires), n.cacheControl && (u.cacheControl = n.cacheControl);\n        var h = {};\n\n        if (s) {\n          var c = s.finish();\n          c && (h.resourceTiming = JSON.parse(JSON.stringify(c)));\n        }\n\n        a.vectorTile = n.vectorTile, a.parse(n.vectorTile, i.layerIndex, i.availableImages, i.actor, function (t, i) {\n          if (t || !i) return r(t);\n          r(null, e.extend({\n            rawTileData: l.slice(0)\n          }, i, u, h));\n        }), i.loaded = i.loaded || {}, i.loaded[o] = a;\n      });\n    }, l.prototype.reloadTile = function (e, t) {\n      var r = this,\n          i = this.loaded,\n          o = e.uid,\n          n = this;\n\n      if (i && i[o]) {\n        var s = i[o];\n        s.showCollisionBoxes = e.showCollisionBoxes;\n\n        var a = function a(e, i) {\n          var o = s.reloadCallback;\n          o && (delete s.reloadCallback, s.parse(s.vectorTile, n.layerIndex, r.availableImages, n.actor, o)), t(e, i);\n        };\n\n        "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n      }\n    }, l.prototype.abortTile = function (e, t) {\n      var r = this.loading,\n          i = e.uid;\n      r && r[i] && r[i].abort && (r[i].abort(), delete r[i]), t();\n    }, l.prototype.removeTile = function (e, t) {\n      var r = this.loaded,\n          i = e.uid;\n      r && r[i] && delete r[i], t();\n    };\n\n    var u = e.window.ImageBitmap,\n        h = function h() {\n      this.loaded = {};\n    };\n\n    function c(e, t) {\n      if (0 !== e.length) {\n        p(e[0], t);\n\n        for (var r = 1; r < e.length; r++) {\n          p(e[r], !t);\n        }\n      }\n    }\n\n    function p(e, t) {\n      for (var r = 0, i = 0, o = e.length, n = o - 1; i < o; n = i++) {\n        r += (e[i][0] - e[n][0]) * (e[n][1] + e[i][1]);\n      }\n\n      r >= 0 != !!t && e.reverse();\n    }\n\n    h.prototype.loadTile = function (t, r) {\n      var i = t.uid,\n          o = t.encoding,\n          n = t.rawImageData,\n          s = u && n instanceof u ? this.getImageData(n) : n,\n          a = new e.DEMData(i, s, o);\n      this.loaded = this.loaded || {}, this.loaded[i] = a, r(null, a);\n    }, h.prototype.getImageData = function (t) {\n      this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);\n      var r = this.offscreenCanvasContext.getImageData(-1, -1, t.width + 2, t.height + 2);\n      return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({\n        width: r.width,\n        height: r.height\n      }, r.data);\n    }, h.prototype.removeTile = function (e) {\n      var t = this.loaded,\n          r = e.uid;\n      t && t[r] && delete t[r];\n    };\n\n    var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON,\n        d = function d(t) {\n      this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n    };\n\n    d.prototype.loadGeometry = function () {\n      if (1 === this._feature.type) {\n        for (var t = [], r = 0, i = this._feature.geometry; r < i.length; r += 1) {\n          var o = i[r];\n          t.push([new e.Point$1(o[0], o[1])]);\n        }\n\n        return t;\n      }\n\n      for (var n = [], s = 0, a = this._feature.geometry; s < a.length; s += 1) {\n        for (var l = [], u = 0, h = a[s]; u < h.length; u += 1) {\n          var c = h[u];\n          l.push(new e.Point$1(c[0], c[1]));\n        }\n\n        n.push(l);\n      }\n\n      return n;\n    }, d.prototype.toGeoJSON = function (e, t, r) {\n      return f.call(this, e, t, r);\n    };\n\n    var g = function g(t) {\n      this.layers = {\n        _geojsonTileLayer: this\n      }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n    };\n\n    g.prototype.feature = function (e) {\n      return new d(this._features[e]);\n    };\n\n    var v = e.vectorTile.VectorTileFeature,\n        m = y;\n\n    function y(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n\n    function x(e, t) {\n      this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n\n    y.prototype.feature = function (e) {\n      return new x(this.features[e], this.options.extent);\n    }, x.prototype.loadGeometry = function () {\n      var t = this.rawGeometry;\n      this.geometry = [];\n\n      for (var r = 0; r < t.length; r++) {\n        for (var i = t[r], o = [], n = 0; n < i.length; n++) {\n          o.push(new e.Point$1(i[n][0], i[n][1]));\n        }\n\n        this.geometry.push(o);\n      }\n\n      return this.geometry;\n    }, x.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n\n      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, i = 1 / 0, o = -1 / 0, n = 0; n < e.length; n++) {\n        for (var s = e[n], a = 0; a < s.length; a++) {\n          var l = s[a];\n          t = Math.min(t, l.x), r = Math.max(r, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);\n        }\n      }\n\n      return [t, i, r, o];\n    }, x.prototype.toGeoJSON = v.prototype.toGeoJSON;\n    var w = I,\n        S = m;\n\n    function I(t) {\n      var r = new e.pbf();\n      return function (e, t) {\n        for (var r in e.layers) {\n          t.writeMessage(3, M, e.layers[r]);\n        }\n      }(t, r), r.finish();\n    }\n\n    function M(e, t) {\n      var r;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);\n      var i = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n\n      for (r = 0; r < e.length; r++) {\n        i.feature = e.feature(r), t.writeMessage(2, b, i);\n      }\n\n      var o = i.keys;\n\n      for (r = 0; r < o.length; r++) {\n        t.writeStringField(3, o[r]);\n      }\n\n      var n = i.values;\n\n      for (r = 0; r < n.length; r++) {\n        t.writeMessage(4, C, n[r]);\n      }\n    }\n\n    function b(e, t) {\n      var r = e.feature;\n      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, _, e), t.writeVarintField(3, r.type), t.writeMessage(4, T, r);\n    }\n\n    function _(e, t) {\n      var r = e.feature,\n          i = e.keys,\n          o = e.values,\n          n = e.keycache,\n          s = e.valuecache;\n\n      for (var a in r.properties) {\n        var l = n[a];\n        void 0 === l && (i.push(a), n[a] = l = i.length - 1), t.writeVarint(l);\n        var u = r.properties[a],\n            h = typeof u;\n        "string" !== h && "boolean" !== h && "number" !== h && (u = JSON.stringify(u));\n        var c = h + ":" + u,\n            p = s[c];\n        void 0 === p && (o.push(u), s[c] = p = o.length - 1), t.writeVarint(p);\n      }\n    }\n\n    function k(e, t) {\n      return (t << 3) + (7 & e);\n    }\n\n    function P(e) {\n      return e << 1 ^ e >> 31;\n    }\n\n    function T(e, t) {\n      for (var r = e.loadGeometry(), i = e.type, o = 0, n = 0, s = r.length, a = 0; a < s; a++) {\n        var l = r[a],\n            u = 1;\n        1 === i && (u = l.length), t.writeVarint(k(1, u));\n\n        for (var h = 3 === i ? l.length - 1 : l.length, c = 0; c < h; c++) {\n          1 === c && 1 !== i && t.writeVarint(k(2, h - 1));\n          var p = l[c].x - o,\n              f = l[c].y - n;\n          t.writeVarint(P(p)), t.writeVarint(P(f)), o += p, n += f;\n        }\n\n        3 === i && t.writeVarint(k(7, 1));\n      }\n    }\n\n    function C(e, t) {\n      var r = typeof e;\n      "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n\n    function D(e, t, r, i) {\n      L(e, r, i), L(t, 2 * r, 2 * i), L(t, 2 * r + 1, 2 * i + 1);\n    }\n\n    function L(e, t, r) {\n      var i = e[t];\n      e[t] = e[r], e[r] = i;\n    }\n\n    function z(e, t, r, i) {\n      var o = e - r,\n          n = t - i;\n      return o * o + n * n;\n    }\n\n    w.fromVectorTileJs = I, w.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var r = {};\n\n      for (var i in e) {\n        r[i] = new m(e[i].features, t), r[i].name = i, r[i].version = t.version, r[i].extent = t.extent;\n      }\n\n      return I({\n        layers: r\n      });\n    }, w.GeoJSONWrapper = S;\n\n    var O = function O(e) {\n      return e[0];\n    },\n        E = function E(e) {\n      return e[1];\n    },\n        F = function F(e, t, r, i, o) {\n      void 0 === t && (t = O), void 0 === r && (r = E), void 0 === i && (i = 64), void 0 === o && (o = Float64Array), this.nodeSize = i, this.points = e;\n\n      for (var n = e.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new n(e.length), a = this.coords = new o(2 * e.length), l = 0; l < e.length; l++) {\n        s[l] = l, a[2 * l] = t(e[l]), a[2 * l + 1] = r(e[l]);\n      }\n\n      !function e(t, r, i, o, n, s) {\n        if (!(n - o <= i)) {\n          var a = o + n >> 1;\n          !function e(t, r, i, o, n, s) {\n            for (; n > o;) {\n              if (n - o > 600) {\n                var a = n - o + 1,\n                    l = i - o + 1,\n                    u = Math.log(a),\n                    h = .5 * Math.exp(2 * u / 3),\n                    c = .5 * Math.sqrt(u * h * (a - h) / a) * (l - a / 2 < 0 ? -1 : 1);\n                e(t, r, i, Math.max(o, Math.floor(i - l * h / a + c)), Math.min(n, Math.floor(i + (a - l) * h / a + c)), s);\n              }\n\n              var p = r[2 * i + s],\n                  f = o,\n                  d = n;\n\n              for (D(t, r, o, i), r[2 * n + s] > p && D(t, r, o, n); f < d;) {\n                for (D(t, r, f, d), f++, d--; r[2 * f + s] < p;) {\n                  f++;\n                }\n\n                for (; r[2 * d + s] > p;) {\n                  d--;\n                }\n              }\n\n              r[2 * o + s] === p ? D(t, r, o, d) : D(t, r, ++d, n), d <= i && (o = d + 1), i <= d && (n = d - 1);\n            }\n          }(t, r, a, o, n, s % 2), e(t, r, i, o, a - 1, s + 1), e(t, r, i, a + 1, n, s + 1);\n        }\n      }(s, a, i, 0, s.length - 1, 0);\n    };\n\n    F.prototype.range = function (e, t, r, i) {\n      return function (e, t, r, i, o, n, s) {\n        for (var a, l, u = [0, e.length - 1, 0], h = []; u.length;) {\n          var c = u.pop(),\n              p = u.pop(),\n              f = u.pop();\n          if (p - f <= s) for (var d = f; d <= p; d++) {\n            l = t[2 * d + 1], (a = t[2 * d]) >= r && a <= o && l >= i && l <= n && h.push(e[d]);\n          } else {\n            var g = Math.floor((f + p) / 2);\n            l = t[2 * g + 1], (a = t[2 * g]) >= r && a <= o && l >= i && l <= n && h.push(e[g]);\n            var v = (c + 1) % 2;\n            (0 === c ? r <= a : i <= l) && (u.push(f), u.push(g - 1), u.push(v)), (0 === c ? o >= a : n >= l) && (u.push(g + 1), u.push(p), u.push(v));\n          }\n        }\n\n        return h;\n      }(this.ids, this.coords, e, t, r, i, this.nodeSize);\n    }, F.prototype.within = function (e, t, r) {\n      return function (e, t, r, i, o, n) {\n        for (var s = [0, e.length - 1, 0], a = [], l = o * o; s.length;) {\n          var u = s.pop(),\n              h = s.pop(),\n              c = s.pop();\n          if (h - c <= n) for (var p = c; p <= h; p++) {\n            z(t[2 * p], t[2 * p + 1], r, i) <= l && a.push(e[p]);\n          } else {\n            var f = Math.floor((c + h) / 2),\n                d = t[2 * f],\n                g = t[2 * f + 1];\n            z(d, g, r, i) <= l && a.push(e[f]);\n            var v = (u + 1) % 2;\n            (0 === u ? r - o <= d : i - o <= g) && (s.push(c), s.push(f - 1), s.push(v)), (0 === u ? r + o >= d : i + o >= g) && (s.push(f + 1), s.push(h), s.push(v));\n          }\n        }\n\n        return a;\n      }(this.ids, this.coords, e, t, r, this.nodeSize);\n    };\n\n    var N = {\n      minZoom: 0,\n      maxZoom: 16,\n      minPoints: 2,\n      radius: 40,\n      extent: 512,\n      nodeSize: 64,\n      log: !1,\n      generateId: !1,\n      reduce: null,\n      map: function map(e) {\n        return e;\n      }\n    },\n        J = function J(e) {\n      this.options = V(Object.create(N), e), this.trees = new Array(this.options.maxZoom + 1);\n    };\n\n    function Z(e, t, r, i, o) {\n      return {\n        x: e,\n        y: t,\n        zoom: 1 / 0,\n        id: r,\n        parentId: -1,\n        numPoints: i,\n        properties: o\n      };\n    }\n\n    function A(e, t) {\n      var r = e.geometry.coordinates,\n          i = r[1];\n      return {\n        x: Y(r[0]),\n        y: j(i),\n        zoom: 1 / 0,\n        index: t,\n        parentId: -1\n      };\n    }\n\n    function B(e) {\n      return {\n        type: "Feature",\n        id: e.id,\n        properties: G(e),\n        geometry: {\n          type: "Point",\n          coordinates: [(i = e.x, 360 * (i - .5)), (t = e.y, r = (180 - 360 * t) * Math.PI / 180, 360 * Math.atan(Math.exp(r)) / Math.PI - 90)]\n        }\n      };\n      var t, r, i;\n    }\n\n    function G(e) {\n      var t = e.numPoints,\n          r = t >= 1e4 ? Math.round(t / 1e3) + "k" : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;\n      return V(V({}, e.properties), {\n        cluster: !0,\n        cluster_id: e.id,\n        point_count: t,\n        point_count_abbreviated: r\n      });\n    }\n\n    function Y(e) {\n      return e / 360 + .5;\n    }\n\n    function j(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function V(e, t) {\n      for (var r in t) {\n        e[r] = t[r];\n      }\n\n      return e;\n    }\n\n    function X(e) {\n      return e.x;\n    }\n\n    function W(e) {\n      return e.y;\n    }\n\n    function R(e, t, r, i, o, n) {\n      var s = o - r,\n          a = n - i;\n\n      if (0 !== s || 0 !== a) {\n        var l = ((e - r) * s + (t - i) * a) / (s * s + a * a);\n        l > 1 ? (r = o, i = n) : l > 0 && (r += s * l, i += a * l);\n      }\n\n      return (s = e - r) * s + (a = t - i) * a;\n    }\n\n    function q(e, t, r, i) {\n      var o = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: r,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n            r = e.type;\n        if ("Point" === r || "MultiPoint" === r || "LineString" === r) U(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var i = 0; i < t.length; i++) {\n          U(e, t[i]);\n        } else if ("MultiPolygon" === r) for (i = 0; i < t.length; i++) {\n          for (var o = 0; o < t[i].length; o++) {\n            U(e, t[i][o]);\n          }\n        }\n      }(o), o;\n    }\n\n    function U(e, t) {\n      for (var r = 0; r < t.length; r += 3) {\n        e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);\n      }\n    }\n\n    function $(e, t, r, i) {\n      if (t.geometry) {\n        var o = t.geometry.coordinates,\n            n = t.geometry.type,\n            s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n            a = [],\n            l = t.id;\n        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = i || 0), "Point" === n) H(o, a);else if ("MultiPoint" === n) for (var u = 0; u < o.length; u++) {\n          H(o[u], a);\n        } else if ("LineString" === n) K(o, a, s, !1);else if ("MultiLineString" === n) {\n          if (r.lineMetrics) {\n            for (u = 0; u < o.length; u++) {\n              K(o[u], a = [], s, !1), e.push(q(l, "LineString", a, t.properties));\n            }\n\n            return;\n          }\n\n          Q(o, a, s, !1);\n        } else if ("Polygon" === n) Q(o, a, s, !0);else {\n          if ("MultiPolygon" !== n) {\n            if ("GeometryCollection" === n) {\n              for (u = 0; u < t.geometry.geometries.length; u++) {\n                $(e, {\n                  id: l,\n                  geometry: t.geometry.geometries[u],\n                  properties: t.properties\n                }, r, i);\n              }\n\n              return;\n            }\n\n            throw new Error("Input data is not a valid GeoJSON object.");\n          }\n\n          for (u = 0; u < o.length; u++) {\n            var h = [];\n            Q(o[u], h, s, !0), a.push(h);\n          }\n        }\n        e.push(q(l, n, a, t.properties));\n      }\n    }\n\n    function H(e, t) {\n      t.push(ee(e[0])), t.push(te(e[1])), t.push(0);\n    }\n\n    function K(e, t, r, i) {\n      for (var o, n, s = 0, a = 0; a < e.length; a++) {\n        var l = ee(e[a][0]),\n            u = te(e[a][1]);\n        t.push(l), t.push(u), t.push(0), a > 0 && (s += i ? (o * u - l * n) / 2 : Math.sqrt(Math.pow(l - o, 2) + Math.pow(u - n, 2))), o = l, n = u;\n      }\n\n      var h = t.length - 3;\n      t[2] = 1, function e(t, r, i, o) {\n        for (var n, s = o, a = i - r >> 1, l = i - r, u = t[r], h = t[r + 1], c = t[i], p = t[i + 1], f = r + 3; f < i; f += 3) {\n          var d = R(t[f], t[f + 1], u, h, c, p);\n          if (d > s) n = f, s = d;else if (d === s) {\n            var g = Math.abs(f - a);\n            g < l && (n = f, l = g);\n          }\n        }\n\n        s > o && (n - r > 3 && e(t, r, n, o), t[n + 2] = s, i - n > 3 && e(t, n, i, o));\n      }(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n\n    function Q(e, t, r, i) {\n      for (var o = 0; o < e.length; o++) {\n        var n = [];\n        K(e[o], n, r, i), t.push(n);\n      }\n    }\n\n    function ee(e) {\n      return e / 360 + .5;\n    }\n\n    function te(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function re(e, t, r, i, o, n, s, a) {\n      if (i /= t, n >= (r /= t) && s < i) return e;\n      if (s < r || n >= i) return null;\n\n      for (var l = [], u = 0; u < e.length; u++) {\n        var h = e[u],\n            c = h.geometry,\n            p = h.type,\n            f = 0 === o ? h.minX : h.minY,\n            d = 0 === o ? h.maxX : h.maxY;\n        if (f >= r && d < i) l.push(h);else if (!(d < r || f >= i)) {\n          var g = [];\n          if ("Point" === p || "MultiPoint" === p) ie(c, g, r, i, o);else if ("LineString" === p) oe(c, g, r, i, o, !1, a.lineMetrics);else if ("MultiLineString" === p) se(c, g, r, i, o, !1);else if ("Polygon" === p) se(c, g, r, i, o, !0);else if ("MultiPolygon" === p) for (var v = 0; v < c.length; v++) {\n            var m = [];\n            se(c[v], m, r, i, o, !0), m.length && g.push(m);\n          }\n\n          if (g.length) {\n            if (a.lineMetrics && "LineString" === p) {\n              for (v = 0; v < g.length; v++) {\n                l.push(q(h.id, p, g[v], h.tags));\n              }\n\n              continue;\n            }\n\n            "LineString" !== p && "MultiLineString" !== p || (1 === g.length ? (p = "LineString", g = g[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === g.length ? "Point" : "MultiPoint"), l.push(q(h.id, p, g, h.tags));\n          }\n        }\n      }\n\n      return l.length ? l : null;\n    }\n\n    function ie(e, t, r, i, o) {\n      for (var n = 0; n < e.length; n += 3) {\n        var s = e[n + o];\n        s >= r && s <= i && (t.push(e[n]), t.push(e[n + 1]), t.push(e[n + 2]));\n      }\n    }\n\n    function oe(e, t, r, i, o, n, s) {\n      for (var a, l, u = ne(e), h = 0 === o ? le : ue, c = e.start, p = 0; p < e.length - 3; p += 3) {\n        var f = e[p],\n            d = e[p + 1],\n            g = e[p + 2],\n            v = e[p + 3],\n            m = e[p + 4],\n            y = 0 === o ? f : d,\n            x = 0 === o ? v : m,\n            w = !1;\n        s && (a = Math.sqrt(Math.pow(f - v, 2) + Math.pow(d - m, 2))), y < r ? x > r && (l = h(u, f, d, v, m, r), s && (u.start = c + a * l)) : y > i ? x < i && (l = h(u, f, d, v, m, i), s && (u.start = c + a * l)) : ae(u, f, d, g), x < r && y >= r && (l = h(u, f, d, v, m, r), w = !0), x > i && y <= i && (l = h(u, f, d, v, m, i), w = !0), !n && w && (s && (u.end = c + a * l), t.push(u), u = ne(e)), s && (c += a);\n      }\n\n      var S = e.length - 3;\n      f = e[S], d = e[S + 1], g = e[S + 2], (y = 0 === o ? f : d) >= r && y <= i && ae(u, f, d, g), S = u.length - 3, n && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ae(u, u[0], u[1], u[2]), u.length && t.push(u);\n    }\n\n    function ne(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n\n    function se(e, t, r, i, o, n) {\n      for (var s = 0; s < e.length; s++) {\n        oe(e[s], t, r, i, o, n, !1);\n      }\n    }\n\n    function ae(e, t, r, i) {\n      e.push(t), e.push(r), e.push(i);\n    }\n\n    function le(e, t, r, i, o, n) {\n      var s = (n - t) / (i - t);\n      return e.push(n), e.push(r + (o - r) * s), e.push(1), s;\n    }\n\n    function ue(e, t, r, i, o, n) {\n      var s = (n - r) / (o - r);\n      return e.push(t + (i - t) * s), e.push(n), e.push(1), s;\n    }\n\n    function he(e, t) {\n      for (var r = [], i = 0; i < e.length; i++) {\n        var o,\n            n = e[i],\n            s = n.type;\n        if ("Point" === s || "MultiPoint" === s || "LineString" === s) o = ce(n.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {\n          o = [];\n\n          for (var a = 0; a < n.geometry.length; a++) {\n            o.push(ce(n.geometry[a], t));\n          }\n        } else if ("MultiPolygon" === s) for (o = [], a = 0; a < n.geometry.length; a++) {\n          for (var l = [], u = 0; u < n.geometry[a].length; u++) {\n            l.push(ce(n.geometry[a][u], t));\n          }\n\n          o.push(l);\n        }\n        r.push(q(n.id, s, o, n.tags));\n      }\n\n      return r;\n    }\n\n    function ce(e, t) {\n      var r = [];\n      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);\n\n      for (var i = 0; i < e.length; i += 3) {\n        r.push(e[i] + t, e[i + 1], e[i + 2]);\n      }\n\n      return r;\n    }\n\n    function pe(e, t) {\n      if (e.transformed) return e;\n      var r,\n          i,\n          o,\n          n = 1 << e.z,\n          s = e.x,\n          a = e.y;\n\n      for (r = 0; r < e.features.length; r++) {\n        var l = e.features[r],\n            u = l.geometry,\n            h = l.type;\n        if (l.geometry = [], 1 === h) for (i = 0; i < u.length; i += 2) {\n          l.geometry.push(fe(u[i], u[i + 1], t, n, s, a));\n        } else for (i = 0; i < u.length; i++) {\n          var c = [];\n\n          for (o = 0; o < u[i].length; o += 2) {\n            c.push(fe(u[i][o], u[i][o + 1], t, n, s, a));\n          }\n\n          l.geometry.push(c);\n        }\n      }\n\n      return e.transformed = !0, e;\n    }\n\n    function fe(e, t, r, i, o, n) {\n      return [Math.round(r * (e * i - o)), Math.round(r * (t * i - n))];\n    }\n\n    function de(e, t, r, i, o) {\n      for (var n = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent), s = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: r,\n        y: i,\n        z: t,\n        transformed: !1,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n      }, a = 0; a < e.length; a++) {\n        s.numFeatures++, ge(s, e[a], n, o);\n        var l = e[a].minX,\n            u = e[a].minY,\n            h = e[a].maxX,\n            c = e[a].maxY;\n        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);\n      }\n\n      return s;\n    }\n\n    function ge(e, t, r, i) {\n      var o = t.geometry,\n          n = t.type,\n          s = [];\n      if ("Point" === n || "MultiPoint" === n) for (var a = 0; a < o.length; a += 3) {\n        s.push(o[a]), s.push(o[a + 1]), e.numPoints++, e.numSimplified++;\n      } else if ("LineString" === n) ve(s, o, e, r, !1, !1);else if ("MultiLineString" === n || "Polygon" === n) for (a = 0; a < o.length; a++) {\n        ve(s, o[a], e, r, "Polygon" === n, 0 === a);\n      } else if ("MultiPolygon" === n) for (var l = 0; l < o.length; l++) {\n        var u = o[l];\n\n        for (a = 0; a < u.length; a++) {\n          ve(s, u[a], e, r, !0, 0 === a);\n        }\n      }\n\n      if (s.length) {\n        var h = t.tags || null;\n\n        if ("LineString" === n && i.lineMetrics) {\n          for (var c in h = {}, t.tags) {\n            h[c] = t.tags[c];\n          }\n\n          h.mapbox_clip_start = o.start / o.size, h.mapbox_clip_end = o.end / o.size;\n        }\n\n        var p = {\n          geometry: s,\n          type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,\n          tags: h\n        };\n        null !== t.id && (p.id = t.id), e.features.push(p);\n      }\n    }\n\n    function ve(e, t, r, i, o, n) {\n      var s = i * i;\n      if (i > 0 && t.size < (o ? s : i)) r.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) {\n          (0 === i || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;\n        }\n\n        o && function (e, t) {\n          for (var r = 0, i = 0, o = e.length, n = o - 2; i < o; n = i, i += 2) {\n            r += (e[i] - e[n]) * (e[i + 1] + e[n + 1]);\n          }\n\n          if (r > 0 === t) for (i = 0, o = e.length; i < o / 2; i += 2) {\n            var s = e[i],\n                a = e[i + 1];\n            e[i] = e[o - 2 - i], e[i + 1] = e[o - 1 - i], e[o - 2 - i] = s, e[o - 1 - i] = a;\n          }\n        }(a, n), e.push(a);\n      }\n    }\n\n    function me(e, t) {\n      var r = (t = this.options = function (e, t) {\n        for (var r in t) {\n          e[r] = t[r];\n        }\n\n        return e;\n      }(Object.create(this.options), t)).debug;\n\n      if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");\n      if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");\n\n      var i = function (e, t) {\n        var r = [];\n        if ("FeatureCollection" === e.type) for (var i = 0; i < e.features.length; i++) {\n          $(r, e.features[i], t, i);\n        } else $(r, "Feature" === e.type ? e : {\n          geometry: e\n        }, t);\n        return r;\n      }(e, t);\n\n      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i = function (e, t) {\n        var r = t.buffer / t.extent,\n            i = e,\n            o = re(e, 1, -1 - r, r, 0, -1, 2, t),\n            n = re(e, 1, 1 - r, 2 + r, 0, -1, 2, t);\n        return (o || n) && (i = re(e, 1, -r, 1 + r, 0, -1, 2, t) || [], o && (i = he(o, 1).concat(i)), n && (i = i.concat(he(n, -1)))), i;\n      }(i, t)).length && this.splitTile(i, 0, 0, 0), r && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));\n    }\n\n    function ye(e, t, r) {\n      return 32 * ((1 << e) * r + t) + e;\n    }\n\n    function xe(e, t) {\n      var r = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n\n      var i = this._geoJSONIndex.getTile(r.z, r.x, r.y);\n\n      if (!i) return t(null, null);\n      var o = new g(i.features),\n          n = w(o);\n      0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t(null, {\n        vectorTile: o,\n        rawData: n.buffer\n      });\n    }\n\n    J.prototype.load = function (e) {\n      var t = this.options,\n          r = t.log,\n          i = t.minZoom,\n          o = t.maxZoom,\n          n = t.nodeSize;\n      r && console.time("total time");\n      var s = "prepare " + e.length + " points";\n      r && console.time(s), this.points = e;\n\n      for (var a = [], l = 0; l < e.length; l++) {\n        e[l].geometry && a.push(A(e[l], l));\n      }\n\n      this.trees[o + 1] = new F(a, X, W, n, Float32Array), r && console.timeEnd(s);\n\n      for (var u = o; u >= i; u--) {\n        var h = +Date.now();\n        a = this._cluster(a, u), this.trees[u] = new F(a, X, W, n, Float32Array), r && console.log("z%d: %d clusters in %dms", u, a.length, +Date.now() - h);\n      }\n\n      return r && console.timeEnd("total time"), this;\n    }, J.prototype.getClusters = function (e, t) {\n      var r = ((e[0] + 180) % 360 + 360) % 360 - 180,\n          i = Math.max(-90, Math.min(90, e[1])),\n          o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180,\n          n = Math.max(-90, Math.min(90, e[3]));\n      if (e[2] - e[0] >= 360) r = -180, o = 180;else if (r > o) {\n        var s = this.getClusters([r, i, 180, n], t),\n            a = this.getClusters([-180, i, o, n], t);\n        return s.concat(a);\n      }\n\n      for (var l = this.trees[this._limitZoom(t)], u = [], h = 0, c = l.range(Y(r), j(n), Y(o), j(i)); h < c.length; h += 1) {\n        var p = l.points[c[h]];\n        u.push(p.numPoints ? B(p) : this.points[p.index]);\n      }\n\n      return u;\n    }, J.prototype.getChildren = function (e) {\n      var t = this._getOriginId(e),\n          r = this._getOriginZoom(e),\n          i = "No cluster with the specified id.",\n          o = this.trees[r];\n\n      if (!o) throw new Error(i);\n      var n = o.points[t];\n      if (!n) throw new Error(i);\n\n      for (var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = [], l = 0, u = o.within(n.x, n.y, s); l < u.length; l += 1) {\n        var h = o.points[u[l]];\n        h.parentId === e && a.push(h.numPoints ? B(h) : this.points[h.index]);\n      }\n\n      if (0 === a.length) throw new Error(i);\n      return a;\n    }, J.prototype.getLeaves = function (e, t, r) {\n      var i = [];\n      return this._appendLeaves(i, e, t = t || 10, r = r || 0, 0), i;\n    }, J.prototype.getTile = function (e, t, r) {\n      var i = this.trees[this._limitZoom(e)],\n          o = Math.pow(2, e),\n          n = this.options,\n          s = n.radius / n.extent,\n          a = (r - s) / o,\n          l = (r + 1 + s) / o,\n          u = {\n        features: []\n      };\n\n      return this._addTileFeatures(i.range((t - s) / o, a, (t + 1 + s) / o, l), i.points, t, r, o, u), 0 === t && this._addTileFeatures(i.range(1 - s / o, a, 1, l), i.points, o, r, o, u), t === o - 1 && this._addTileFeatures(i.range(0, a, s / o, l), i.points, -1, r, o, u), u.features.length ? u : null;\n    }, J.prototype.getClusterExpansionZoom = function (e) {\n      for (var t = this._getOriginZoom(e) - 1; t <= this.options.maxZoom;) {\n        var r = this.getChildren(e);\n        if (t++, 1 !== r.length) break;\n        e = r[0].properties.cluster_id;\n      }\n\n      return t;\n    }, J.prototype._appendLeaves = function (e, t, r, i, o) {\n      for (var n = 0, s = this.getChildren(t); n < s.length; n += 1) {\n        var a = s[n],\n            l = a.properties;\n        if (l && l.cluster ? o + l.point_count <= i ? o += l.point_count : o = this._appendLeaves(e, l.cluster_id, r, i, o) : o < i ? o++ : e.push(a), e.length === r) break;\n      }\n\n      return o;\n    }, J.prototype._addTileFeatures = function (e, t, r, i, o, n) {\n      for (var s = 0, a = e; s < a.length; s += 1) {\n        var l = t[a[s]],\n            u = l.numPoints,\n            h = {\n          type: 1,\n          geometry: [[Math.round(this.options.extent * (l.x * o - r)), Math.round(this.options.extent * (l.y * o - i))]],\n          tags: u ? G(l) : this.points[l.index].properties\n        },\n            c = void 0;\n        u ? c = l.id : this.options.generateId ? c = l.index : this.points[l.index].id && (c = this.points[l.index].id), void 0 !== c && (h.id = c), n.features.push(h);\n      }\n    }, J.prototype._limitZoom = function (e) {\n      return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));\n    }, J.prototype._cluster = function (e, t) {\n      for (var r = [], i = this.options, o = i.reduce, n = i.minPoints, s = i.radius / (i.extent * Math.pow(2, t)), a = 0; a < e.length; a++) {\n        var l = e[a];\n\n        if (!(l.zoom <= t)) {\n          l.zoom = t;\n\n          for (var u = this.trees[t + 1], h = u.within(l.x, l.y, s), c = l.numPoints || 1, p = c, f = 0, d = h; f < d.length; f += 1) {\n            var g = u.points[d[f]];\n            g.zoom > t && (p += g.numPoints || 1);\n          }\n\n          if (p >= n) {\n            for (var v = l.x * c, m = l.y * c, y = o && c > 1 ? this._map(l, !0) : null, x = (a << 5) + (t + 1) + this.points.length, w = 0, S = h; w < S.length; w += 1) {\n              var I = u.points[S[w]];\n\n              if (!(I.zoom <= t)) {\n                I.zoom = t;\n                var M = I.numPoints || 1;\n                v += I.x * M, m += I.y * M, I.parentId = x, o && (y || (y = this._map(l, !0)), o(y, this._map(I)));\n              }\n            }\n\n            l.parentId = x, r.push(Z(v / p, m / p, x, p, y));\n          } else if (r.push(l), p > 1) for (var b = 0, _ = h; b < _.length; b += 1) {\n            var k = u.points[_[b]];\n            k.zoom <= t || (k.zoom = t, r.push(k));\n          }\n        }\n      }\n\n      return r;\n    }, J.prototype._getOriginId = function (e) {\n      return e - this.points.length >> 5;\n    }, J.prototype._getOriginZoom = function (e) {\n      return (e - this.points.length) % 32;\n    }, J.prototype._map = function (e, t) {\n      if (e.numPoints) return t ? V({}, e.properties) : e.properties;\n      var r = this.points[e.index].properties,\n          i = this.options.map(r);\n      return t && i === r ? V({}, i) : i;\n    }, me.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, me.prototype.splitTile = function (e, t, r, i, o, n, s) {\n      for (var a = [e, t, r, i], l = this.options, u = l.debug; a.length;) {\n        i = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();\n        var h = 1 << t,\n            c = ye(t, r, i),\n            p = this.tiles[c];\n\n        if (!p && (u > 1 && console.time("creation"), p = this.tiles[c] = de(e, t, r, i, l), this.tileCoords.push({\n          z: t,\n          x: r,\n          y: i\n        }), u)) {\n          u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation"));\n          var f = "z" + t;\n          this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n        }\n\n        if (p.source = e, o) {\n          if (t === l.maxZoom || t === o) continue;\n          var d = 1 << o - t;\n          if (r !== Math.floor(n / d) || i !== Math.floor(s / d)) continue;\n        } else if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n\n        if (p.source = null, 0 !== e.length) {\n          u > 1 && console.time("clipping");\n          var g,\n              v,\n              m,\n              y,\n              x,\n              w,\n              S = .5 * l.buffer / l.extent,\n              I = .5 - S,\n              M = .5 + S,\n              b = 1 + S;\n          g = v = m = y = null, x = re(e, h, r - S, r + M, 0, p.minX, p.maxX, l), w = re(e, h, r + I, r + b, 0, p.minX, p.maxX, l), e = null, x && (g = re(x, h, i - S, i + M, 1, p.minY, p.maxY, l), v = re(x, h, i + I, i + b, 1, p.minY, p.maxY, l), x = null), w && (m = re(w, h, i - S, i + M, 1, p.minY, p.maxY, l), y = re(w, h, i + I, i + b, 1, p.minY, p.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(g || [], t + 1, 2 * r, 2 * i), a.push(v || [], t + 1, 2 * r, 2 * i + 1), a.push(m || [], t + 1, 2 * r + 1, 2 * i), a.push(y || [], t + 1, 2 * r + 1, 2 * i + 1);\n        }\n      }\n    }, me.prototype.getTile = function (e, t, r) {\n      var i = this.options,\n          o = i.extent,\n          n = i.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n          a = ye(e, t = (t % s + s) % s, r);\n      if (this.tiles[a]) return pe(this.tiles[a], o);\n      n > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);\n\n      for (var l, u = e, h = t, c = r; !l && u > 0;) {\n        u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[ye(u, h, c)];\n      }\n\n      return l && l.source ? (n > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), n > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? pe(this.tiles[a], o) : null) : null;\n    };\n\n    var we = function (t) {\n      function r(e, r, i, o) {\n        t.call(this, e, r, i, xe), o && (this.loadGeoJSON = o);\n      }\n\n      return t && (r.__proto__ = t), (r.prototype = Object.create(t && t.prototype)).constructor = r, r.prototype.loadData = function (e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), this._pendingCallback = t, this._pendingLoadDataParams = e, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());\n      }, r.prototype._loadData = function () {\n        var t = this;\n\n        if (this._pendingCallback && this._pendingLoadDataParams) {\n          var r = this._pendingCallback,\n              i = this._pendingLoadDataParams;\n          delete this._pendingCallback, delete this._pendingLoadDataParams;\n          var o = !!(i && i.request && i.request.collectResourceTiming) && new e.RequestPerformance(i.request);\n          this.loadGeoJSON(i, function (n, s) {\n            if (n || !s) return r(n);\n            if ("object" != typeof s) return r(new Error("Input data given to \'" + i.source + "\' is not a valid GeoJSON object."));\n            !function e(t, r) {\n              var i,\n                  o = t && t.type;\n              if ("FeatureCollection" === o) for (i = 0; i < t.features.length; i++) {\n                e(t.features[i], r);\n              } else if ("GeometryCollection" === o) for (i = 0; i < t.geometries.length; i++) {\n                e(t.geometries[i], r);\n              } else if ("Feature" === o) e(t.geometry, r);else if ("Polygon" === o) c(t.coordinates, r);else if ("MultiPolygon" === o) for (i = 0; i < t.coordinates.length; i++) {\n                c(t.coordinates[i], r);\n              }\n              return t;\n            }(s, !0);\n\n            try {\n              if (i.filter) {\n                var a = e.createExpression(i.filter, {\n                  type: "boolean",\n                  "property-type": "data-driven",\n                  overridable: !1,\n                  transition: !1\n                });\n                if ("error" === a.result) throw new Error(a.value.map(function (e) {\n                  return e.key + ": " + e.message;\n                }).join(", "));\n                var l = s.features.filter(function (e) {\n                  return a.value.evaluate({\n                    zoom: 0\n                  }, e);\n                });\n                s = {\n                  type: "FeatureCollection",\n                  features: l\n                };\n              }\n\n              t._geoJSONIndex = i.cluster ? new J(function (t) {\n                var r = t.superclusterOptions,\n                    i = t.clusterProperties;\n                if (!i || !r) return r;\n\n                for (var o = {}, n = {}, s = {\n                  accumulated: null,\n                  zoom: 0\n                }, a = {\n                  properties: null\n                }, l = Object.keys(i), u = 0, h = l; u < h.length; u += 1) {\n                  var c = h[u],\n                      p = i[c],\n                      f = p[0],\n                      d = e.createExpression(p[1]),\n                      g = e.createExpression("string" == typeof f ? [f, ["accumulated"], ["get", c]] : f);\n                  o[c] = d.value, n[c] = g.value;\n                }\n\n                return r.map = function (e) {\n                  a.properties = e;\n\n                  for (var t = {}, r = 0, i = l; r < i.length; r += 1) {\n                    var n = i[r];\n                    t[n] = o[n].evaluate(s, a);\n                  }\n\n                  return t;\n                }, r.reduce = function (e, t) {\n                  a.properties = t;\n\n                  for (var r = 0, i = l; r < i.length; r += 1) {\n                    var o = i[r];\n                    s.accumulated = e[o], e[o] = n[o].evaluate(s, a);\n                  }\n                }, r;\n              }(i)).load(s.features) : function (e, t) {\n                return new me(e, t);\n              }(s, i.geojsonVtOptions);\n            } catch (n) {\n              return r(n);\n            }\n\n            t.loaded = {};\n            var u = {};\n\n            if (o) {\n              var h = o.finish();\n              h && (u.resourceTiming = {}, u.resourceTiming[i.source] = JSON.parse(JSON.stringify(h)));\n            }\n\n            r(null, u);\n          });\n        }\n      }, r.prototype.coalesce = function () {\n        "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());\n      }, r.prototype.reloadTile = function (e, r) {\n        var i = this.loaded;\n        return i && i[e.uid] ? t.prototype.reloadTile.call(this, e, r) : this.loadTile(e, r);\n      }, r.prototype.loadGeoJSON = function (t, r) {\n        if (t.request) e.getJSON(t.request, r);else {\n          if ("string" != typeof t.data) return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n\n          try {\n            return r(null, JSON.parse(t.data));\n          } catch (e) {\n            return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n          }\n        }\n      }, r.prototype.removeSource = function (e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), t();\n      }, r.prototype.getClusterExpansionZoom = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }, r.prototype.getClusterChildren = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }, r.prototype.getClusterLeaves = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }, r;\n    }(l),\n        Se = function Se(t) {\n      var r = this;\n      this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {\n        vector: l,\n        geojson: we\n      }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (e, t) {\n        if (r.workerSourceTypes[e]) throw new Error(\'Worker source with name "\' + e + \'" already registered.\');\n        r.workerSourceTypes[e] = t;\n      }, this.self.registerRTLTextPlugin = function (t) {\n        if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");\n        e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n      };\n    };\n\n    return Se.prototype.setReferrer = function (e, t) {\n      this.referrer = t;\n    }, Se.prototype.setImages = function (e, t, r) {\n      for (var i in this.availableImages[e] = t, this.workerSources[e]) {\n        var o = this.workerSources[e][i];\n\n        for (var n in o) {\n          o[n].availableImages = t;\n        }\n      }\n\n      r();\n    }, Se.prototype.setLayers = function (e, t, r) {\n      this.getLayerIndex(e).replace(t), r();\n    }, Se.prototype.updateLayers = function (e, t, r) {\n      this.getLayerIndex(e).update(t.layers, t.removedIds), r();\n    }, Se.prototype.loadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).loadTile(t, r);\n    }, Se.prototype.loadDEMTile = function (e, t, r) {\n      this.getDEMWorkerSource(e, t.source).loadTile(t, r);\n    }, Se.prototype.reloadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).reloadTile(t, r);\n    }, Se.prototype.abortTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).abortTile(t, r);\n    }, Se.prototype.removeTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).removeTile(t, r);\n    }, Se.prototype.removeDEMTile = function (e, t) {\n      this.getDEMWorkerSource(e, t.source).removeTile(t);\n    }, Se.prototype.removeSource = function (e, t, r) {\n      if (this.workerSources[e] && this.workerSources[e][t.type] && this.workerSources[e][t.type][t.source]) {\n        var i = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, r) : r();\n      }\n    }, Se.prototype.loadWorkerSource = function (e, t, r) {\n      try {\n        this.self.importScripts(t.url), r();\n      } catch (e) {\n        r(e.toString());\n      }\n    }, Se.prototype.syncRTLPluginState = function (t, r, i) {\n      try {\n        e.plugin.setState(r);\n        var o = e.plugin.getPluginURL();\n\n        if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o) {\n          this.self.importScripts(o);\n          var n = e.plugin.isParsed();\n          i(n ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o), n);\n        }\n      } catch (e) {\n        i(e.toString());\n      }\n    }, Se.prototype.getAvailableImages = function (e) {\n      var t = this.availableImages[e];\n      return t || (t = []), t;\n    }, Se.prototype.getLayerIndex = function (e) {\n      var t = this.layerIndexes[e];\n      return t || (t = this.layerIndexes[e] = new i()), t;\n    }, Se.prototype.getWorkerSource = function (e, t, r) {\n      var i = this;\n      return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({\n        send: function send(t, r, o) {\n          i.actor.send(t, r, o, e);\n        }\n      }, this.getLayerIndex(e), this.getAvailableImages(e))), this.workerSources[e][t][r];\n    }, Se.prototype.getDEMWorkerSource = function (e, t) {\n      return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new h()), this.demWorkerSources[e][t];\n    }, Se.prototype.enforceCacheSizeLimit = function (t, r) {\n      e.enforceCacheSizeLimit(r);\n    }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;\n  });\n  define(["./shared"], function (t) {\n    "use strict";\n\n    var e = t.createCommonjsModule(function (t) {\n      function e(t) {\n        return !i(t);\n      }\n\n      function i(t) {\n        return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {\n          if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;\n          var t,\n              e,\n              i = new Blob([""], {\n            type: "text/javascript"\n          }),\n              o = URL.createObjectURL(i);\n\n          try {\n            e = new Worker(o), t = !0;\n          } catch (e) {\n            t = !1;\n          }\n\n          return e && e.terminate(), URL.revokeObjectURL(o), t;\n        }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {\n          var t = document.createElement("canvas");\n          t.width = t.height = 1;\n          var e = t.getContext("2d");\n          if (!e) return !1;\n          var i = e.getImageData(0, 0, 1, 1);\n          return i && i.width === t.width;\n        }() ? (void 0 === o[i = t && t.failIfMajorPerformanceCaveat] && (o[i] = function (t) {\n          var i = function (t) {\n            var i = document.createElement("canvas"),\n                o = Object.create(e.webGLContextAttributes);\n            return o.failIfMajorPerformanceCaveat = t, i.probablySupportsContext ? i.probablySupportsContext("webgl", o) || i.probablySupportsContext("experimental-webgl", o) : i.supportsContext ? i.supportsContext("webgl", o) || i.supportsContext("experimental-webgl", o) : i.getContext("webgl", o) || i.getContext("experimental-webgl", o);\n          }(t);\n\n          if (!i) return !1;\n          var o = i.createShader(i.VERTEX_SHADER);\n          return !(!o || i.isContextLost()) && (i.shaderSource(o, "void main() {}"), i.compileShader(o), !0 === i.getShaderParameter(o, i.COMPILE_STATUS));\n        }(i)), o[i] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";\n        var i;\n      }\n\n      t.exports ? t.exports = e : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e, window.mapboxgl.notSupportedReason = i);\n      var o = {};\n      e.webGLContextAttributes = {\n        antialias: !1,\n        alpha: !0,\n        stencil: !0,\n        depth: !0\n      };\n    }),\n        i = {\n      create: function create(e, i, o) {\n        var r = t.window.document.createElement(e);\n        return void 0 !== i && (r.className = i), o && o.appendChild(r), r;\n      },\n      createNS: function createNS(e, i) {\n        return t.window.document.createElementNS(e, i);\n      }\n    },\n        o = t.window.document && t.window.document.documentElement.style;\n\n    function r(t) {\n      if (!o) return t[0];\n\n      for (var e = 0; e < t.length; e++) {\n        if (t[e] in o) return t[e];\n      }\n\n      return t[0];\n    }\n\n    var a,\n        n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);\n    i.disableDrag = function () {\n      o && n && (a = o[n], o[n] = "none");\n    }, i.enableDrag = function () {\n      o && n && (o[n] = a);\n    };\n    var s = r(["transform", "WebkitTransform"]);\n\n    i.setTransform = function (t, e) {\n      t.style[s] = e;\n    };\n\n    var l = !1;\n\n    try {\n      var c = Object.defineProperty({}, "passive", {\n        get: function get() {\n          l = !0;\n        }\n      });\n      t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);\n    } catch (t) {\n      l = !1;\n    }\n\n    i.addEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.addEventListener(e, i, "passive" in o && l ? o : o.capture);\n    }, i.removeEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.removeEventListener(e, i, "passive" in o && l ? o : o.capture);\n    };\n\n    var u = function u(e) {\n      e.preventDefault(), e.stopPropagation(), t.window.removeEventListener("click", u, !0);\n    };\n\n    function h(t) {\n      var e = t.userImage;\n      return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0);\n    }\n\n    i.suppressClick = function () {\n      t.window.addEventListener("click", u, !0), t.window.setTimeout(function () {\n        t.window.removeEventListener("click", u, !0);\n      }, 0);\n    }, i.mousePos = function (e, i) {\n      var o = e.getBoundingClientRect();\n      return new t.Point(i.clientX - o.left - e.clientLeft, i.clientY - o.top - e.clientTop);\n    }, i.touchPos = function (e, i) {\n      for (var o = e.getBoundingClientRect(), r = [], a = 0; a < i.length; a++) {\n        r.push(new t.Point(i[a].clientX - o.left - e.clientLeft, i[a].clientY - o.top - e.clientTop));\n      }\n\n      return r;\n    }, i.mouseButton = function (e) {\n      return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button;\n    }, i.remove = function (t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    };\n\n    var p = function (e) {\n      function i() {\n        e.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({\n          width: 1,\n          height: 1\n        }), this.dirty = !0;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.isLoaded = function () {\n        return this.loaded;\n      }, i.prototype.setLoaded = function (t) {\n        if (this.loaded !== t && (this.loaded = t, t)) {\n          for (var e = 0, i = this.requestors; e < i.length; e += 1) {\n            var o = i[e];\n\n            this._notify(o.ids, o.callback);\n          }\n\n          this.requestors = [];\n        }\n      }, i.prototype.getImage = function (t) {\n        return this.images[t];\n      }, i.prototype.addImage = function (t, e) {\n        this._validate(t, e) && (this.images[t] = e);\n      }, i.prototype._validate = function (e, i) {\n        var o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchX" value\'))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchY" value\'))), o = !1), this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "content" value\'))), o = !1), o;\n      }, i.prototype._validateStretch = function (t, e) {\n        if (!t) return !0;\n\n        for (var i = 0, o = 0, r = t; o < r.length; o += 1) {\n          var a = r[o];\n          if (a[0] < i || a[1] < a[0] || e < a[1]) return !1;\n          i = a[1];\n        }\n\n        return !0;\n      }, i.prototype._validateContent = function (t, e) {\n        return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]));\n      }, i.prototype.updateImage = function (t, e) {\n        e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0;\n      }, i.prototype.removeImage = function (t) {\n        var e = this.images[t];\n        delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove();\n      }, i.prototype.listImages = function () {\n        return Object.keys(this.images);\n      }, i.prototype.getImages = function (t, e) {\n        var i = !0;\n        if (!this.isLoaded()) for (var o = 0, r = t; o < r.length; o += 1) {\n          this.images[r[o]] || (i = !1);\n        }\n        this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({\n          ids: t,\n          callback: e\n        });\n      }, i.prototype._notify = function (e, i) {\n        for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n          var n = a[r];\n          this.images[n] || this.fire(new t.Event("styleimagemissing", {\n            id: n\n          }));\n          var s = this.images[n];\n          s ? o[n] = {\n            data: s.data.clone(),\n            pixelRatio: s.pixelRatio,\n            sdf: s.sdf,\n            version: s.version,\n            stretchX: s.stretchX,\n            stretchY: s.stretchY,\n            content: s.content,\n            hasRenderCallback: Boolean(s.userImage && s.userImage.render)\n          } : t.warnOnce(\'Image "\' + n + \'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.\');\n        }\n\n        i(null, o);\n      }, i.prototype.getPixelSize = function () {\n        var t = this.atlasImage;\n        return {\n          width: t.width,\n          height: t.height\n        };\n      }, i.prototype.getPattern = function (e) {\n        var i = this.patterns[e],\n            o = this.getImage(e);\n        if (!o) return null;\n        if (i && i.position.version === o.version) return i.position;\n        if (i) i.position.version = o.version;else {\n          var r = {\n            w: o.data.width + 2,\n            h: o.data.height + 2,\n            x: 0,\n            y: 0\n          },\n              a = new t.ImagePosition(r, o);\n          this.patterns[e] = {\n            bin: r,\n            position: a\n          };\n        }\n        return this._updatePatternAtlas(), this.patterns[e].position;\n      }, i.prototype.bind = function (e) {\n        var i = e.gl;\n        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.Texture(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n      }, i.prototype._updatePatternAtlas = function () {\n        var e = [];\n\n        for (var i in this.patterns) {\n          e.push(this.patterns[i].bin);\n        }\n\n        var o = t.potpack(e),\n            r = o.w,\n            a = o.h,\n            n = this.atlasImage;\n\n        for (var s in n.resize({\n          width: r || 1,\n          height: a || 1\n        }), this.patterns) {\n          var l = this.patterns[s].bin,\n              c = l.x + 1,\n              u = l.y + 1,\n              h = this.images[s].data,\n              p = h.width,\n              d = h.height;\n          t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c,\n            y: u\n          }, {\n            width: p,\n            height: d\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: d - 1\n          }, {\n            x: c,\n            y: u - 1\n          }, {\n            width: p,\n            height: 1\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c,\n            y: u + d\n          }, {\n            width: p,\n            height: 1\n          }), t.RGBAImage.copy(h, n, {\n            x: p - 1,\n            y: 0\n          }, {\n            x: c - 1,\n            y: u\n          }, {\n            width: 1,\n            height: d\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c + p,\n            y: u\n          }, {\n            width: 1,\n            height: d\n          });\n        }\n\n        this.dirty = !0;\n      }, i.prototype.beginFrame = function () {\n        this.callbackDispatchedThisFrame = {};\n      }, i.prototype.dispatchRenderCallbacks = function (t) {\n        for (var e = 0, i = t; e < i.length; e += 1) {\n          var o = i[e];\n\n          if (!this.callbackDispatchedThisFrame[o]) {\n            this.callbackDispatchedThisFrame[o] = !0;\n            var r = this.images[o];\n            h(r) && this.updateImage(o, r);\n          }\n        }\n      }, i;\n    }(t.Evented),\n        d = m,\n        _ = m,\n        f = 1e20;\n\n    function m(t, e, i, o, r, a) {\n      this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = o || .25, this.fontFamily = r || "sans-serif", this.fontWeight = a || "normal", this.radius = i || 8;\n      var n = this.size = this.fontSize + 2 * this.buffer;\n      this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.d = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Int16Array(n), this.middle = Math.round(n / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));\n    }\n\n    function g(t, e, i, o, r, a, n) {\n      for (var s = 0; s < e; s++) {\n        for (var l = 0; l < i; l++) {\n          o[l] = t[l * e + s];\n        }\n\n        for (v(o, r, a, n, i), l = 0; l < i; l++) {\n          t[l * e + s] = r[l];\n        }\n      }\n\n      for (l = 0; l < i; l++) {\n        for (s = 0; s < e; s++) {\n          o[s] = t[l * e + s];\n        }\n\n        for (v(o, r, a, n, e), s = 0; s < e; s++) {\n          t[l * e + s] = Math.sqrt(r[s]);\n        }\n      }\n    }\n\n    function v(t, e, i, o, r) {\n      i[0] = 0, o[0] = -f, o[1] = +f;\n\n      for (var a = 1, n = 0; a < r; a++) {\n        for (var s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]); s <= o[n];) {\n          n--, s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]);\n        }\n\n        i[++n] = a, o[n] = s, o[n + 1] = +f;\n      }\n\n      for (a = 0, n = 0; a < r; a++) {\n        for (; o[n + 1] < a;) {\n          n++;\n        }\n\n        e[a] = (a - i[n]) * (a - i[n]) + t[i[n]];\n      }\n    }\n\n    m.prototype.draw = function (t) {\n      this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle);\n\n      for (var e = this.ctx.getImageData(0, 0, this.size, this.size), i = new Uint8ClampedArray(this.size * this.size), o = 0; o < this.size * this.size; o++) {\n        var r = e.data[4 * o + 3] / 255;\n        this.gridOuter[o] = 1 === r ? 0 : 0 === r ? f : Math.pow(Math.max(0, .5 - r), 2), this.gridInner[o] = 1 === r ? f : 0 === r ? 0 : Math.pow(Math.max(0, r - .5), 2);\n      }\n\n      for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o = 0; o < this.size * this.size; o++) {\n        i[o] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o] - this.gridInner[o]) / this.radius + this.cutoff))));\n      }\n\n      return i;\n    }, d.default = _;\n\n    var y = function y(t, e) {\n      this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {};\n    };\n\n    y.prototype.setURL = function (t) {\n      this.url = t;\n    }, y.prototype.getGlyphs = function (e, i) {\n      var o = this,\n          r = [];\n\n      for (var a in e) {\n        for (var n = 0, s = e[a]; n < s.length; n += 1) {\n          r.push({\n            stack: a,\n            id: s[n]\n          });\n        }\n      }\n\n      t.asyncAll(r, function (t, e) {\n        var i = t.stack,\n            r = t.id,\n            a = o.entries[i];\n        a || (a = o.entries[i] = {\n          glyphs: {},\n          requests: {},\n          ranges: {}\n        });\n        var n = a.glyphs[r];\n\n        if (void 0 === n) {\n          if (n = o._tinySDF(a, i, r)) return a.glyphs[r] = n, void e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });\n          var s = Math.floor(r / 256);\n          if (256 * s > 65535) e(new Error("glyphs > 65535 not supported"));else if (a.ranges[s]) e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });else {\n            var l = a.requests[s];\n            l || (l = a.requests[s] = [], y.loadGlyphRange(i, s, o.url, o.requestManager, function (t, e) {\n              if (e) {\n                for (var i in e) {\n                  o._doesCharSupportLocalGlyph(+i) || (a.glyphs[+i] = e[+i]);\n                }\n\n                a.ranges[s] = !0;\n              }\n\n              for (var r = 0, n = l; r < n.length; r += 1) {\n                (0, n[r])(t, e);\n              }\n\n              delete a.requests[s];\n            })), l.push(function (t, o) {\n              t ? e(t) : o && e(null, {\n                stack: i,\n                id: r,\n                glyph: o[r] || null\n              });\n            });\n          }\n        } else e(null, {\n          stack: i,\n          id: r,\n          glyph: n\n        });\n      }, function (t, e) {\n        if (t) i(t);else if (e) {\n          for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n            var n = a[r],\n                s = n.stack,\n                l = n.id,\n                c = n.glyph;\n            (o[s] || (o[s] = {}))[l] = c && {\n              id: c.id,\n              bitmap: c.bitmap.clone(),\n              metrics: c.metrics\n            };\n          }\n\n          i(null, o);\n        }\n      });\n    }, y.prototype._doesCharSupportLocalGlyph = function (e) {\n      return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e) || t.isChar["Hangul Syllables"](e) || t.isChar.Hiragana(e) || t.isChar.Katakana(e));\n    }, y.prototype._tinySDF = function (e, i, o) {\n      var r = this.localIdeographFontFamily;\n\n      if (r && this._doesCharSupportLocalGlyph(o)) {\n        var a = e.tinySDF;\n\n        if (!a) {\n          var n = "400";\n          /bold/i.test(i) ? n = "900" : /medium/i.test(i) ? n = "500" : /light/i.test(i) && (n = "200"), a = e.tinySDF = new y.TinySDF(24, 3, 8, .25, r, n);\n        }\n\n        return {\n          id: o,\n          bitmap: new t.AlphaImage({\n            width: 30,\n            height: 30\n          }, a.draw(String.fromCharCode(o))),\n          metrics: {\n            width: 24,\n            height: 24,\n            left: 0,\n            top: -8,\n            advance: 24\n          }\n        };\n      }\n    }, y.loadGlyphRange = function (e, i, o, r, a) {\n      var n = 256 * i,\n          s = n + 255,\n          l = r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}", e).replace("{range}", n + "-" + s), t.ResourceType.Glyphs);\n      t.getArrayBuffer(l, function (e, i) {\n        if (e) a(e);else if (i) {\n          for (var o = {}, r = 0, n = t.parseGlyphPBF(i); r < n.length; r += 1) {\n            var s = n[r];\n            o[s.id] = s;\n          }\n\n          a(null, o);\n        }\n      });\n    }, y.TinySDF = d;\n\n    var x = function x() {\n      this.specification = t.styleSpec.light.position;\n    };\n\n    x.prototype.possiblyEvaluate = function (e, i) {\n      return t.sphericalToCartesian(e.expression.evaluate(i));\n    }, x.prototype.interpolate = function (e, i, o) {\n      return {\n        x: t.number(e.x, i.x, o),\n        y: t.number(e.y, i.y, o),\n        z: t.number(e.z, i.z, o)\n      };\n    };\n\n    var b = new t.Properties({\n      anchor: new t.DataConstantProperty(t.styleSpec.light.anchor),\n      position: new x(),\n      color: new t.DataConstantProperty(t.styleSpec.light.color),\n      intensity: new t.DataConstantProperty(t.styleSpec.light.intensity)\n    }),\n        w = function (e) {\n      function i(i) {\n        e.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i), this._transitioning = this._transitionable.untransitioned();\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getLight = function () {\n        return this._transitionable.serialize();\n      }, i.prototype.setLight = function (e, i) {\n        if (void 0 === i && (i = {}), !this._validate(t.validateLight, e, i)) for (var o in e) {\n          var r = e[o];\n          t.endsWith(o, "-transition") ? this._transitionable.setTransition(o.slice(0, -"-transition".length), r) : this._transitionable.setValue(o, r);\n        }\n      }, i.prototype.updateTransitions = function (t) {\n        this._transitioning = this._transitionable.transitioned(t, this._transitioning);\n      }, i.prototype.hasTransition = function () {\n        return this._transitioning.hasTransition();\n      }, i.prototype.recalculate = function (t) {\n        this.properties = this._transitioning.possiblyEvaluate(t);\n      }, i.prototype._validate = function (e, i, o) {\n        return (!o || !1 !== o.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: t.styleSpec\n        })));\n      }, i;\n    }(t.Evented),\n        T = function T(t, e) {\n      this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};\n    };\n\n    T.prototype.getDash = function (t, e) {\n      var i = t.join(",") + String(e);\n      return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)), this.dashEntry[i];\n    }, T.prototype.getDashRanges = function (t, e, i) {\n      var o = [],\n          r = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,\n          a = t[0] * i,\n          n = !0;\n      o.push({\n        left: r,\n        right: a,\n        isDash: n,\n        zeroLength: 0 === t[0]\n      });\n\n      for (var s = t[0], l = 1; l < t.length; l++) {\n        var c = t[l];\n        o.push({\n          left: r = s * i,\n          right: a = (s += c) * i,\n          isDash: n = !n,\n          zeroLength: 0 === c\n        });\n      }\n\n      return o;\n    }, T.prototype.addRoundDash = function (t, e, i) {\n      for (var o = e / 2, r = -i; r <= i; r++) {\n        for (var a = this.width * (this.nextRow + i + r), n = 0, s = t[n], l = 0; l < this.width; l++) {\n          l / s.right > 1 && (s = t[++n]);\n          var c = Math.abs(l - s.left),\n              u = Math.abs(l - s.right),\n              h = Math.min(c, u),\n              p = void 0,\n              d = r / i * (o + 1);\n\n          if (s.isDash) {\n            var _ = o - Math.abs(d);\n\n            p = Math.sqrt(h * h + _ * _);\n          } else p = o - Math.sqrt(h * h + d * d);\n\n          this.data[a + l] = Math.max(0, Math.min(255, p + 128));\n        }\n      }\n    }, T.prototype.addRegularDash = function (t) {\n      for (var e = t.length - 1; e >= 0; --e) {\n        var i = t[e],\n            o = t[e + 1];\n        i.zeroLength ? t.splice(e, 1) : o && o.isDash === i.isDash && (o.left = i.left, t.splice(e, 1));\n      }\n\n      var r = t[0],\n          a = t[t.length - 1];\n      r.isDash === a.isDash && (r.left = a.left - this.width, a.right = r.right + this.width);\n\n      for (var n = this.width * this.nextRow, s = 0, l = t[s], c = 0; c < this.width; c++) {\n        c / l.right > 1 && (l = t[++s]);\n        var u = Math.abs(c - l.left),\n            h = Math.abs(c - l.right),\n            p = Math.min(u, h);\n        this.data[n + c] = Math.max(0, Math.min(255, (l.isDash ? p : -p) + 128));\n      }\n    }, T.prototype.addDash = function (e, i) {\n      var o = i ? 7 : 0,\n          r = 2 * o + 1;\n      if (this.nextRow + r > this.height) return t.warnOnce("LineAtlas out of space"), null;\n\n      for (var a = 0, n = 0; n < e.length; n++) {\n        a += e[n];\n      }\n\n      if (0 !== a) {\n        var s = this.width / a,\n            l = this.getDashRanges(e, this.width, s);\n        i ? this.addRoundDash(l, s, o) : this.addRegularDash(l);\n      }\n\n      var c = {\n        y: (this.nextRow + o + .5) / this.height,\n        height: 2 * o / this.height,\n        width: a\n      };\n      return this.nextRow += r, this.dirty = !0, c;\n    }, T.prototype.bind = function (t) {\n      var e = t.gl;\n      this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data));\n    };\n\n    var E = function e(i, o) {\n      this.workerPool = i, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();\n\n      for (var r = this.workerPool.acquire(this.id), a = 0; a < r.length; a++) {\n        var n = new e.Actor(r[a], o, this.id);\n        n.name = "Worker " + a, this.actors.push(n);\n      }\n    };\n\n    function I(e, i, o) {\n      var r = function r(_r2, a) {\n        if (_r2) return o(_r2);\n\n        if (a) {\n          var n = t.pick(t.extend(a, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);\n          a.vector_layers && (n.vectorLayers = a.vector_layers, n.vectorLayerIds = n.vectorLayers.map(function (t) {\n            return t.id;\n          })), n.tiles = i.canonicalizeTileset(n, e.url), o(null, n);\n        }\n      };\n\n      return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url), t.ResourceType.Source), r) : t.browser.frame(function () {\n        return r(null, e);\n      });\n    }\n\n    E.prototype.broadcast = function (e, i, o) {\n      t.asyncAll(this.actors, function (t, o) {\n        t.send(e, i, o);\n      }, o = o || function () {});\n    }, E.prototype.getActor = function () {\n      return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n    }, E.prototype.remove = function () {\n      this.actors.forEach(function (t) {\n        t.remove();\n      }), this.actors = [], this.workerPool.release(this.id);\n    }, E.Actor = t.Actor;\n\n    var P = function P(e, i, o) {\n      this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = o || 24;\n    };\n\n    P.prototype.validateBounds = function (t) {\n      return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];\n    }, P.prototype.contains = function (e) {\n      var i = Math.pow(2, e.z),\n          o = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i),\n          r = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i),\n          a = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i),\n          n = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);\n      return e.x >= o && e.x < a && e.y >= r && e.y < n;\n    };\n\n    var S = function (e) {\n      function i(i, o, r, a) {\n        if (e.call(this), this.id = i, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(o, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({\n          type: "vector"\n        }, o), this._collectResourceTiming = o.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");\n        this.setEventedParent(a);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n          e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles, e.map._requestManager._customAccessToken), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken, e.map._requestManager._customAccessToken), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "metadata"\n          })), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "content"\n          })));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.hasTile = function (t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setSourceProperty = function (t) {\n        this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();\n      }, i.prototype.setTiles = function (t) {\n        var e = this;\n        return this.setSourceProperty(function () {\n          e._options.tiles = t;\n        }), this;\n      }, i.prototype.setUrl = function (t) {\n        var e = this;\n        return this.setSourceProperty(function () {\n          e.url = t, e._options.url = t;\n        }), this;\n      }, i.prototype.onRemove = function () {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options);\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)),\n            r = {\n          request: this.map._requestManager.transformRequest(o, t.ResourceType.Tile),\n          uid: e.uid,\n          tileID: e.tileID,\n          zoom: e.tileID.overscaledZ,\n          tileSize: this.tileSize * e.tileID.overscaleFactor(),\n          type: this.type,\n          source: this.id,\n          pixelRatio: t.browser.devicePixelRatio,\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        };\n\n        function a(o, r) {\n          return delete e.request, e.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null)));\n        }\n\n        r.request.collectResourceTiming = this._collectResourceTiming, e.actor && "expired" !== e.state ? "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", r, a.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send("loadTile", r, a.bind(this)));\n      }, i.prototype.abortTile = function (t) {\n        t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }, i.prototype.unloadTile = function (t) {\n        t.unloadVectorData(), t.actor && t.actor.send("removeTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        C = function (e) {\n      function i(i, o, r, a) {\n        e.call(this), this.id = i, this.dispatcher = r, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({\n          type: "raster"\n        }, o), t.extend(this, t.pick(o, ["url", "scheme", "tileSize"]));\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n          e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "metadata"\n          })), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "content"\n          })));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.onRemove = function () {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options);\n      }, i.prototype.hasTile = function (t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this,\n            r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n\n        e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function (r, a) {\n          if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (r) e.state = "errored", i(r);else if (a) {\n            o.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n            var n = o.map.painter.context,\n                s = n.gl;\n            e.texture = o.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, {\n              useMipmap: !0\n            }) : (e.texture = new t.Texture(n, a, s.RGBA, {\n              useMipmap: !0\n            }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), e.state = "loaded", t.cacheEntryPossiblyAdded(o.dispatcher), i(null);\n          }\n        });\n      }, i.prototype.abortTile = function (t, e) {\n        t.request && (t.request.cancel(), delete t.request), e();\n      }, i.prototype.unloadTile = function (t, e) {\n        t.texture && this.map.painter.saveTileTexture(t.texture), e();\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        z = function (e) {\n      function i(i, o, r, a) {\n        e.call(this, i, o, r, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({\n          type: "raster-dem"\n        }, o), this.encoding = o.encoding || "mapbox";\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.serialize = function () {\n        return {\n          type: "raster-dem",\n          url: this.url,\n          tileSize: this.tileSize,\n          tiles: this.tiles,\n          bounds: this.bounds,\n          encoding: this.encoding\n        };\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n\n        function r(t, o) {\n          t && (e.state = "errored", i(t)), o && (e.dem = o, e.needsHillshadePrepare = !0, e.state = "loaded", i(null));\n        }\n\n        e.request = t.getImage(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), function (o, a) {\n          if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (o) e.state = "errored", i(o);else if (a) {\n            this.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n            var n = t.window.ImageBitmap && a instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a : t.browser.getImageData(a, 1),\n                s = {\n              uid: e.uid,\n              coord: e.tileID,\n              source: this.id,\n              rawImageData: n,\n              encoding: this.encoding\n            };\n            e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send("loadDEMTile", s, r.bind(this)));\n          }\n        }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID);\n      }, i.prototype._getNeighboringTiles = function (e) {\n        var i = e.canonical,\n            o = Math.pow(2, i.z),\n            r = (i.x - 1 + o) % o,\n            a = 0 === i.x ? e.wrap - 1 : e.wrap,\n            n = (i.x + 1 + o) % o,\n            s = i.x + 1 === o ? e.wrap + 1 : e.wrap,\n            l = {};\n        return l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y).key] = {\n          backfilled: !1\n        }, i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y - 1).key] = {\n          backfilled: !1\n        }), i.y + 1 < o && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y + 1).key] = {\n          backfilled: !1\n        }), l;\n      }, i.prototype.unloadTile = function (t) {\n        t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && t.actor.send("removeDEMTile", {\n          uid: t.uid,\n          source: this.id\n        });\n      }, i;\n    }(C),\n        D = function (e) {\n      function i(i, o, r, a) {\n        e.call(this), this.id = i, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = r.getActor(), this.setEventedParent(a), this._data = o.data, this._options = t.extend({}, o), this._collectResourceTiming = o.collectResourceTiming, this._resourceTiming = [], void 0 !== o.maxzoom && (this.maxzoom = o.maxzoom), o.type && (this.type = o.type), o.attribution && (this.attribution = o.attribution), this.promoteId = o.promoteId;\n        var n = t.EXTENT / this.tileSize;\n        this.workerOptions = t.extend({\n          source: this.id,\n          cluster: o.cluster || !1,\n          geojsonVtOptions: {\n            buffer: (void 0 !== o.buffer ? o.buffer : 128) * n,\n            tolerance: (void 0 !== o.tolerance ? o.tolerance : .375) * n,\n            extent: t.EXTENT,\n            maxZoom: this.maxzoom,\n            lineMetrics: o.lineMetrics || !1,\n            generateId: o.generateId || !1\n          },\n          superclusterOptions: {\n            maxZoom: void 0 !== o.clusterMaxZoom ? Math.min(o.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,\n            minPoints: Math.max(2, o.clusterMinPoints || 2),\n            extent: t.EXTENT,\n            radius: (o.clusterRadius || 50) * n,\n            log: !1,\n            generateId: o.generateId || !1\n          },\n          clusterProperties: o.clusterProperties,\n          filter: o.filter\n        }, o.workerOptions);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._updateWorkerData(function (i) {\n          if (i) e.fire(new t.ErrorEvent(i));else {\n            var o = {\n              dataType: "source",\n              sourceDataType: "metadata"\n            };\n            e._collectResourceTiming && e._resourceTiming && e._resourceTiming.length > 0 && (o.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new t.Event("data", o));\n          }\n        });\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setData = function (e) {\n        var i = this;\n        return this._data = e, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._updateWorkerData(function (e) {\n          if (e) i.fire(new t.ErrorEvent(e));else {\n            var o = {\n              dataType: "source",\n              sourceDataType: "content"\n            };\n            i._collectResourceTiming && i._resourceTiming && i._resourceTiming.length > 0 && (o.resourceTiming = i._resourceTiming, i._resourceTiming = []), i.fire(new t.Event("data", o));\n          }\n        }), this;\n      }, i.prototype.getClusterExpansionZoom = function (t, e) {\n        return this.actor.send("geojson.getClusterExpansionZoom", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }, i.prototype.getClusterChildren = function (t, e) {\n        return this.actor.send("geojson.getClusterChildren", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }, i.prototype.getClusterLeaves = function (t, e, i, o) {\n        return this.actor.send("geojson.getClusterLeaves", {\n          source: this.id,\n          clusterId: t,\n          limit: e,\n          offset: i\n        }, o), this;\n      }, i.prototype._updateWorkerData = function (e) {\n        var i = this;\n        this._loaded = !1;\n        var o = t.extend({}, this.workerOptions),\n            r = this._data;\n        "string" == typeof r ? (o.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r), t.ResourceType.Source), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(r), this.actor.send(this.type + ".loadData", o, function (t, r) {\n          i._removed || r && r.abandoned || (i._loaded = !0, r && r.resourceTiming && r.resourceTiming[i.id] && (i._resourceTiming = r.resourceTiming[i.id].slice(0)), i.actor.send(i.type + ".coalesce", {\n            source: o.source\n          }, null), e(t));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this,\n            r = e.actor ? "reloadTile" : "loadTile";\n        e.actor = this.actor, e.request = this.actor.send(r, {\n          type: this.type,\n          uid: e.uid,\n          tileID: e.tileID,\n          zoom: e.tileID.overscaledZ,\n          maxZoom: this.maxzoom,\n          tileSize: this.tileSize,\n          source: this.id,\n          pixelRatio: t.browser.devicePixelRatio,\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        }, function (t, a) {\n          return delete e.request, e.unloadVectorData(), e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(a, o.map.painter, "reloadTile" === r), i(null));\n        });\n      }, i.prototype.abortTile = function (t) {\n        t.request && (t.request.cancel(), delete t.request), t.aborted = !0;\n      }, i.prototype.unloadTile = function (t) {\n        t.unloadVectorData(), this.actor.send("removeTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        });\n      }, i.prototype.onRemove = function () {\n        this._removed = !0, this.actor.send("removeSource", {\n          type: this.type,\n          source: this.id\n        });\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options, {\n          type: this.type,\n          data: this._data\n        });\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        A = t.createLayout([{\n      name: "a_pos",\n      type: "Int16",\n      components: 2\n    }, {\n      name: "a_texture_pos",\n      type: "Int16",\n      components: 2\n    }]),\n        M = function (e) {\n      function i(t, i, o, r) {\n        e.call(this), this.id = t, this.dispatcher = o, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(r), this.options = i;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function (e, i) {\n        var o = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function (r, a) {\n          o._loaded = !0, r ? o.fire(new t.ErrorEvent(r)) : a && (o.image = a, e && (o.coordinates = e), i && i(), o._finishLoading());\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.updateImage = function (t) {\n        var e = this;\n        return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, function () {\n          e.texture = null;\n        }), this) : this;\n      }, i.prototype._finishLoading = function () {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", {\n          dataType: "source",\n          sourceDataType: "metadata"\n        })));\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setCoordinates = function (e) {\n        var i = this;\n        this.coordinates = e;\n        var o = e.map(t.MercatorCoordinate.fromLngLat);\n        this.tileID = function (e) {\n          for (var i = 1 / 0, o = 1 / 0, r = -1 / 0, a = -1 / 0, n = 0, s = e; n < s.length; n += 1) {\n            var l = s[n];\n            i = Math.min(i, l.x), o = Math.min(o, l.y), r = Math.max(r, l.x), a = Math.max(a, l.y);\n          }\n\n          var c = Math.max(r - i, a - o),\n              u = Math.max(0, Math.floor(-Math.log(c) / Math.LN2)),\n              h = Math.pow(2, u);\n          return new t.CanonicalTileID(u, Math.floor((i + r) / 2 * h), Math.floor((o + a) / 2 * h));\n        }(o), this.minzoom = this.maxzoom = this.tileID.z;\n        var r = o.map(function (t) {\n          return i.tileID.getTilePoint(t)._round();\n        });\n        return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r[0].x, r[0].y, 0, 0), this._boundsArray.emplaceBack(r[1].x, r[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r[3].x, r[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r[2].x, r[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", {\n          dataType: "source",\n          sourceDataType: "content"\n        })), this;\n      }, i.prototype.prepare = function () {\n        if (0 !== Object.keys(this.tiles).length && this.image) {\n          var e = this.map.painter.context,\n              i = e.gl;\n\n          for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n            var r = this.tiles[o];\n            "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n          }\n        }\n      }, i.prototype.loadTile = function (t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = "errored", e(null));\n      }, i.prototype.serialize = function () {\n        return {\n          type: "image",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        L = function (e) {\n      function i(t, i, o, r) {\n        e.call(this, t, i, o, r), this.roundZoom = !0, this.type = "video", this.options = i;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1;\n        var i = this.options;\n        this.urls = [];\n\n        for (var o = 0, r = i.urls; o < r.length; o += 1) {\n          this.urls.push(this.map._requestManager.transformRequest(r[o], t.ResourceType.Source).url);\n        }\n\n        t.getVideo(this.urls, function (i, o) {\n          e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (e.video = o, e.video.loop = !0, e.video.addEventListener("playing", function () {\n            e.map.triggerRepaint();\n          }), e.map && e.video.play(), e._finishLoading());\n        });\n      }, i.prototype.pause = function () {\n        this.video && this.video.pause();\n      }, i.prototype.play = function () {\n        this.video && this.video.play();\n      }, i.prototype.seek = function (e) {\n        if (this.video) {\n          var i = this.video.seekable;\n          e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i.start(0) + " and " + i.end(0) + "-second mark."))) : this.video.currentTime = e;\n        }\n      }, i.prototype.getVideo = function () {\n        return this.video;\n      }, i.prototype.onAdd = function (t) {\n        this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n      }, i.prototype.prepare = function () {\n        if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {\n          var e = this.map.painter.context,\n              i = e.gl;\n\n          for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n            var r = this.tiles[o];\n            "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n          }\n        }\n      }, i.prototype.serialize = function () {\n        return {\n          type: "video",\n          urls: this.urls,\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return this.video && !this.video.paused;\n      }, i;\n    }(M),\n        R = function (e) {\n      function i(i, o, r, a) {\n        e.call(this, i, o, r, a), o.coordinates ? Array.isArray(o.coordinates) && 4 === o.coordinates.length && !o.coordinates.some(function (t) {\n          return !Array.isArray(t) || 2 !== t.length || t.some(function (t) {\n            return "number" != typeof t;\n          });\n        }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"coordinates" property must be an array of 4 longitude/latitude array pairs\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "coordinates"\'))), o.animate && "boolean" != typeof o.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'optional "animate" property must be a boolean value\'))), o.canvas ? "string" == typeof o.canvas || o.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "canvas"\'))), this.options = o, this.animate = void 0 === o.animate || o.animate;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {\n          this._playing = !0, this.map.triggerRepaint();\n        }, this.pause = function () {\n          this._playing && (this.prepare(), this._playing = !1);\n        }, this._finishLoading());\n      }, i.prototype.getCanvas = function () {\n        return this.canvas;\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load(), this.canvas && this.animate && this.play();\n      }, i.prototype.onRemove = function () {\n        this.pause();\n      }, i.prototype.prepare = function () {\n        var e = !1;\n\n        if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {\n          var i = this.map.painter.context,\n              o = i.gl;\n\n          for (var r in this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, {\n            premultiply: !0\n          }) : this.texture = new t.Texture(i, this.canvas, o.RGBA, {\n            premultiply: !0\n          }), this.tiles) {\n            var a = this.tiles[r];\n            "loaded" !== a.state && (a.state = "loaded", a.texture = this.texture);\n          }\n        }\n      }, i.prototype.serialize = function () {\n        return {\n          type: "canvas",\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return this._playing;\n      }, i.prototype._hasInvalidDimensions = function () {\n        for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) {\n          var i = e[t];\n          if (isNaN(i) || i <= 0) return !0;\n        }\n\n        return !1;\n      }, i;\n    }(M),\n        k = {\n      vector: S,\n      raster: C,\n      "raster-dem": z,\n      geojson: D,\n      video: L,\n      image: M,\n      canvas: R\n    };\n\n    function B(e, i) {\n      var o = t.identity([]);\n      return t.translate(o, o, [1, 1, 0]), t.scale(o, o, [.5 * e.width, .5 * e.height, 1]), t.multiply(o, o, e.calculatePosMatrix(i.toUnwrapped()));\n    }\n\n    function O(t, e, i, o, r, a) {\n      var n = function (t, e, i) {\n        if (t) for (var o = 0, r = t; o < r.length; o += 1) {\n          var a = e[r[o]];\n          if (a && a.source === i && "fill-extrusion" === a.type) return !0;\n        } else for (var n in e) {\n          var s = e[n];\n          if (s.source === i && "fill-extrusion" === s.type) return !0;\n        }\n        return !1;\n      }(r && r.layers, e, t.id),\n          s = a.maxPitchScaleFactor(),\n          l = t.tilesIn(o, s, n);\n\n      l.sort(F);\n\n      for (var c = [], u = 0, h = l; u < h.length; u += 1) {\n        var p = h[u];\n        c.push({\n          wrappedTileID: p.tileID.wrapped().key,\n          queryResults: p.tile.queryRenderedFeatures(e, i, t._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, r, a, s, B(t.transform, p.tileID))\n        });\n      }\n\n      var d = function (t) {\n        for (var e = {}, i = {}, o = 0, r = t; o < r.length; o += 1) {\n          var a = r[o],\n              n = a.queryResults,\n              s = a.wrappedTileID,\n              l = i[s] = i[s] || {};\n\n          for (var c in n) {\n            for (var u = n[c], h = l[c] = l[c] || {}, p = e[c] = e[c] || [], d = 0, _ = u; d < _.length; d += 1) {\n              var f = _[d];\n              h[f.featureIndex] || (h[f.featureIndex] = !0, p.push(f));\n            }\n          }\n        }\n\n        return e;\n      }(c);\n\n      for (var _ in d) {\n        d[_].forEach(function (e) {\n          var i = e.feature,\n              o = t.getFeatureState(i.layer["source-layer"], i.id);\n          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o;\n        });\n      }\n\n      return d;\n    }\n\n    function F(t, e) {\n      var i = t.tileID,\n          o = e.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n\n    var U = function U(t, e) {\n      this.max = t, this.onRemove = e, this.reset();\n    };\n\n    U.prototype.reset = function () {\n      for (var t in this.data) {\n        for (var e = 0, i = this.data[t]; e < i.length; e += 1) {\n          var o = i[e];\n          o.timeout && clearTimeout(o.timeout), this.onRemove(o.value);\n        }\n      }\n\n      return this.data = {}, this.order = [], this;\n    }, U.prototype.add = function (t, e, i) {\n      var o = this,\n          r = t.wrapped().key;\n      void 0 === this.data[r] && (this.data[r] = []);\n      var a = {\n        value: e,\n        timeout: void 0\n      };\n\n      if (void 0 !== i && (a.timeout = setTimeout(function () {\n        o.remove(t, a);\n      }, i)), this.data[r].push(a), this.order.push(r), this.order.length > this.max) {\n        var n = this._getAndRemoveByKey(this.order[0]);\n\n        n && this.onRemove(n);\n      }\n\n      return this;\n    }, U.prototype.has = function (t) {\n      return t.wrapped().key in this.data;\n    }, U.prototype.getAndRemove = function (t) {\n      return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n    }, U.prototype._getAndRemoveByKey = function (t) {\n      var e = this.data[t].shift();\n      return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n    }, U.prototype.getByKey = function (t) {\n      var e = this.data[t];\n      return e ? e[0].value : null;\n    }, U.prototype.get = function (t) {\n      return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n    }, U.prototype.remove = function (t, e) {\n      if (!this.has(t)) return this;\n      var i = t.wrapped().key,\n          o = void 0 === e ? 0 : this.data[i].indexOf(e),\n          r = this.data[i][o];\n      return this.data[i].splice(o, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(r.value), this.order.splice(this.order.indexOf(i), 1), this;\n    }, U.prototype.setMaxSize = function (t) {\n      for (this.max = t; this.order.length > this.max;) {\n        var e = this._getAndRemoveByKey(this.order[0]);\n\n        e && this.onRemove(e);\n      }\n\n      return this;\n    }, U.prototype.filter = function (t) {\n      var e = [];\n\n      for (var i in this.data) {\n        for (var o = 0, r = this.data[i]; o < r.length; o += 1) {\n          var a = r[o];\n          t(a.value) || e.push(a);\n        }\n      }\n\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n];\n        this.remove(l.value.tileID, l);\n      }\n    };\n\n    var N = function N(t, e, i) {\n      this.context = t;\n      var o = t.gl;\n      this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n    };\n\n    N.prototype.bind = function () {\n      this.context.bindElementBuffer.set(this.buffer);\n    }, N.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, N.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n\n    var Z = {\n      Int8: "BYTE",\n      Uint8: "UNSIGNED_BYTE",\n      Int16: "SHORT",\n      Uint16: "UNSIGNED_SHORT",\n      Int32: "INT",\n      Uint32: "UNSIGNED_INT",\n      Float32: "FLOAT"\n    },\n        q = function q(t, e, i, o) {\n      this.length = e.length, this.attributes = i, this.itemSize = e.bytesPerElement, this.dynamicDraw = o, this.context = t;\n      var r = t.gl;\n      this.buffer = r.createBuffer(), t.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n    };\n\n    q.prototype.bind = function () {\n      this.context.bindVertexBuffer.set(this.buffer);\n    }, q.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, q.prototype.enableAttributes = function (t, e) {\n      for (var i = 0; i < this.attributes.length; i++) {\n        var o = e.attributes[this.attributes[i].name];\n        void 0 !== o && t.enableVertexAttribArray(o);\n      }\n    }, q.prototype.setVertexAttribPointers = function (t, e, i) {\n      for (var o = 0; o < this.attributes.length; o++) {\n        var r = this.attributes[o],\n            a = e.attributes[r.name];\n        void 0 !== a && t.vertexAttribPointer(a, r.components, t[Z[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n      }\n    }, q.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n\n    var j = function j(t) {\n      this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n    };\n\n    j.prototype.get = function () {\n      return this.current;\n    }, j.prototype.set = function (t) {}, j.prototype.getDefault = function () {\n      return this.default;\n    }, j.prototype.setDefault = function () {\n      this.set(this.default);\n    };\n\n    var V = function (e) {\n      function i() {\n        e.apply(this, arguments);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n        return t.Color.transparent;\n      }, i.prototype.set = function (t) {\n        var e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }, i;\n    }(j),\n        G = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 1;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        W = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        X = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return [!0, !0, !0, !0];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        H = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        K = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 255;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        Y = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        J = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [t.KEEP, t.KEEP, t.KEEP];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        Q = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        $ = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return [0, 1];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        tt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        et = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.LESS;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        it = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        ot = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [t.ONE, t.ZERO];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        rt = function (e) {\n      function i() {\n        e.apply(this, arguments);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n        return t.Color.transparent;\n      }, i.prototype.set = function (t) {\n        var e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }, i;\n    }(j),\n        at = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.FUNC_ADD;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        nt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        st = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.BACK;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        lt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.CCW;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ct = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ut = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.TEXTURE0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ht = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        pt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        dt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        _t = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        ft = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        mt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        var e = this.gl;\n        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n      }, e;\n    }(j),\n        gt = function (t) {\n      function e(e) {\n        t.call(this, e), this.vao = e.extVertexArrayObject;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        vt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 4;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        yt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        xt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        bt = function (t) {\n      function e(e, i) {\n        t.call(this, e), this.context = e, this.parent = i;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e;\n    }(j),\n        wt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.setDirty = function () {\n        this.dirty = !0;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          this.context.bindFramebuffer.set(this.parent);\n          var e = this.gl;\n          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(bt),\n        Tt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          this.context.bindFramebuffer.set(this.parent);\n          var e = this.gl;\n          e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(bt),\n        Et = function Et(t, e, i, o) {\n      this.context = t, this.width = e, this.height = i;\n      var r = this.framebuffer = t.gl.createFramebuffer();\n      this.colorAttachment = new wt(t, r), o && (this.depthAttachment = new Tt(t, r));\n    };\n\n    Et.prototype.destroy = function () {\n      var t = this.context.gl,\n          e = this.colorAttachment.get();\n\n      if (e && t.deleteTexture(e), this.depthAttachment) {\n        var i = this.depthAttachment.get();\n        i && t.deleteRenderbuffer(i);\n      }\n\n      t.deleteFramebuffer(this.framebuffer);\n    };\n\n    var It = function It(t, e, i) {\n      this.func = t, this.mask = e, this.range = i;\n    };\n\n    It.ReadOnly = !1, It.ReadWrite = !0, It.disabled = new It(519, It.ReadOnly, [0, 1]);\n\n    var Pt = function Pt(t, e, i, o, r, a) {\n      this.test = t, this.ref = e, this.mask = i, this.fail = o, this.depthFail = r, this.pass = a;\n    };\n\n    Pt.disabled = new Pt({\n      func: 519,\n      mask: 0\n    }, 0, 0, 7680, 7680, 7680);\n\n    var St = function St(t, e, i) {\n      this.blendFunction = t, this.blendColor = e, this.mask = i;\n    };\n\n    St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [!1, !1, !1, !1]), St.unblended = new St(St.Replace, t.Color.transparent, [!0, !0, !0, !0]), St.alphaBlended = new St([1, 771], t.Color.transparent, [!0, !0, !0, !0]);\n\n    var Ct = function Ct(t, e, i) {\n      this.enable = t, this.mode = e, this.frontFace = i;\n    };\n\n    Ct.disabled = new Ct(!1, 1029, 2305), Ct.backCCW = new Ct(!0, 1029, 2305);\n\n    var zt = function zt(t) {\n      this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);\n    };\n\n    zt.prototype.setDefault = function () {\n      this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n    }, zt.prototype.setDirty = function () {\n      this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n    }, zt.prototype.createIndexBuffer = function (t, e) {\n      return new N(this, t, e);\n    }, zt.prototype.createVertexBuffer = function (t, e, i) {\n      return new q(this, t, e, i);\n    }, zt.prototype.createRenderbuffer = function (t, e, i) {\n      var o = this.gl,\n          r = o.createRenderbuffer();\n      return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, t, e, i), this.bindRenderbuffer.set(null), r;\n    }, zt.prototype.createFramebuffer = function (t, e, i) {\n      return new Et(this, t, e, i);\n    }, zt.prototype.clear = function (t) {\n      var e = t.color,\n          i = t.depth,\n          o = this.gl,\n          r = 0;\n      e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== i && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), o.clear(r);\n    }, zt.prototype.setCullFace = function (t) {\n      !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));\n    }, zt.prototype.setDepthMode = function (t) {\n      t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);\n    }, zt.prototype.setStencilMode = function (t) {\n      t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({\n        func: t.test.func,\n        ref: t.ref,\n        mask: t.test.mask\n      })) : this.stencilTest.set(!1);\n    }, zt.prototype.setColorMode = function (e) {\n      t.deepEqual(e.blendFunction, St.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);\n    }, zt.prototype.unbindVAO = function () {\n      this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n    };\n\n    var Dt = function (e) {\n      function i(i, o, r) {\n        var a = this;\n        e.call(this), this.id = i, this.dispatcher = r, this.on("data", function (t) {\n          "source" === t.dataType && "metadata" === t.sourceDataType && (a._sourceLoaded = !0), a._sourceLoaded && !a._paused && "source" === t.dataType && "content" === t.sourceDataType && (a.reload(), a.transform && a.update(a.transform));\n        }), this.on("error", function () {\n          a._sourceErrored = !0;\n        }), this._source = function (e, i, o, r) {\n          var a = new k[i.type](e, i, o, r);\n          if (a.id !== e) throw new Error("Expected Source id to be " + e + " instead of " + a.id);\n          return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a), a;\n        }(i, o, r, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.onAdd = function (t) {\n        this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t);\n      }, i.prototype.onRemove = function (t) {\n        this._source && this._source.onRemove && this._source.onRemove(t);\n      }, i.prototype.loaded = function () {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n\n        for (var t in this._tiles) {\n          var e = this._tiles[t];\n          if ("loaded" !== e.state && "errored" !== e.state) return !1;\n        }\n\n        return !0;\n      }, i.prototype.getSource = function () {\n        return this._source;\n      }, i.prototype.pause = function () {\n        this._paused = !0;\n      }, i.prototype.resume = function () {\n        if (this._paused) {\n          var t = this._shouldReloadOnResume;\n          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n        }\n      }, i.prototype._loadTile = function (t, e) {\n        return this._source.loadTile(t, e);\n      }, i.prototype._unloadTile = function (t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, function () {});\n      }, i.prototype._abortTile = function (t) {\n        if (this._source.abortTile) return this._source.abortTile(t, function () {});\n      }, i.prototype.serialize = function () {\n        return this._source.serialize();\n      }, i.prototype.prepare = function (t) {\n        for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {\n          var i = this._tiles[e];\n          i.upload(t), i.prepare(this.map.style.imageManager);\n        }\n      }, i.prototype.getIds = function () {\n        return t.values(this._tiles).map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.getRenderableIds = function (e) {\n        var i = this,\n            o = [];\n\n        for (var r in this._tiles) {\n          this._isIdRenderable(r, e) && o.push(this._tiles[r]);\n        }\n\n        return e ? o.sort(function (e, o) {\n          var r = e.tileID,\n              a = o.tileID,\n              n = new t.Point(r.canonical.x, r.canonical.y)._rotate(i.transform.angle),\n              s = new t.Point(a.canonical.x, a.canonical.y)._rotate(i.transform.angle);\n\n          return r.overscaledZ - a.overscaledZ || s.y - n.y || s.x - n.x;\n        }).map(function (t) {\n          return t.tileID.key;\n        }) : o.map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.hasRenderableParent = function (t) {\n        var e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }, i.prototype._isIdRenderable = function (t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }, i.prototype.reload = function () {\n        if (this._paused) this._shouldReloadOnResume = !0;else for (var t in this._cache.reset(), this._tiles) {\n          "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading");\n        }\n      }, i.prototype._reloadTile = function (t, e) {\n        var i = this._tiles[t];\n        i && ("loading" !== i.state && (i.state = e), this._loadTile(i, this._tileLoaded.bind(this, i, t, e)));\n      }, i.prototype._tileLoaded = function (e, i, o, r) {\n        if (r) return e.state = "errored", void (404 !== r.status ? this._source.fire(new t.ErrorEvent(r, {\n          tile: e\n        })) : this.update(this.transform));\n        e.timeAdded = t.browser.now(), "expired" === o && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", {\n          dataType: "source",\n          tile: e,\n          coord: e.tileID\n        }));\n      }, i.prototype._backfillDEM = function (t) {\n        for (var e = this.getRenderableIds(), i = 0; i < e.length; i++) {\n          var o = e[i];\n\n          if (t.neighboringTiles && t.neighboringTiles[o]) {\n            var r = this.getTileByID(o);\n            a(t, r), a(r, t);\n          }\n        }\n\n        function a(t, e) {\n          t.needsHillshadePrepare = !0;\n          var i = e.tileID.canonical.x - t.tileID.canonical.x,\n              o = e.tileID.canonical.y - t.tileID.canonical.y,\n              r = Math.pow(2, t.tileID.canonical.z),\n              a = e.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, o), t.neighboringTiles && t.neighboringTiles[a] && (t.neighboringTiles[a].backfilled = !0)));\n        }\n      }, i.prototype.getTile = function (t) {\n        return this.getTileByID(t.key);\n      }, i.prototype.getTileByID = function (t) {\n        return this._tiles[t];\n      }, i.prototype._retainLoadedChildren = function (t, e, i, o) {\n        for (var r in this._tiles) {\n          var a = this._tiles[r];\n\n          if (!(o[r] || !a.hasData() || a.tileID.overscaledZ <= e || a.tileID.overscaledZ > i)) {\n            for (var n = a.tileID; a && a.tileID.overscaledZ > e + 1;) {\n              var s = a.tileID.scaledTo(a.tileID.overscaledZ - 1);\n              (a = this._tiles[s.key]) && a.hasData() && (n = s);\n            }\n\n            for (var l = n; l.overscaledZ > e;) {\n              if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) {\n                o[n.key] = n;\n                break;\n              }\n            }\n          }\n        }\n      }, i.prototype.findLoadedParent = function (t, e) {\n        if (t.key in this._loadedParentTiles) {\n          var i = this._loadedParentTiles[t.key];\n          return i && i.tileID.overscaledZ >= e ? i : null;\n        }\n\n        for (var o = t.overscaledZ - 1; o >= e; o--) {\n          var r = t.scaledTo(o),\n              a = this._getLoadedTile(r);\n\n          if (a) return a;\n        }\n      }, i.prototype._getLoadedTile = function (t) {\n        var e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key);\n      }, i.prototype.updateCacheSize = function (t) {\n        var e = Math.ceil(t.width / this._source.tileSize) + 1,\n            i = Math.ceil(t.height / this._source.tileSize) + 1,\n            o = Math.floor(e * i * 5),\n            r = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;\n\n        this._cache.setMaxSize(r);\n      }, i.prototype.handleWrapJump = function (t) {\n        var e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n\n        if (this._prevLng = t, e) {\n          var i = {};\n\n          for (var o in this._tiles) {\n            var r = this._tiles[o];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e), i[r.tileID.key] = r;\n          }\n\n          for (var a in this._tiles = i, this._timers) {\n            clearTimeout(this._timers[a]), delete this._timers[a];\n          }\n\n          for (var n in this._tiles) {\n            this._setTileReloadTimer(n, this._tiles[n]);\n          }\n        }\n      }, i.prototype.update = function (e) {\n        var o = this;\n\n        if (this.transform = e, this._sourceLoaded && !this._paused) {\n          var r;\n          this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(function (e) {\n            return new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y);\n          }) : (r = e.coveringTiles({\n            tileSize: this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom,\n            reparseOverscaled: this._source.reparseOverscaled\n          }), this._source.hasTile && (r = r.filter(function (t) {\n            return o._source.hasTile(t);\n          }))) : r = [];\n\n          var a = e.coveringZoomLevel(this._source),\n              n = Math.max(a - i.maxOverzooming, this._source.minzoom),\n              s = Math.max(a + i.maxUnderzooming, this._source.minzoom),\n              l = this._updateRetainedTiles(r, a);\n\n          if (Mt(this._source.type)) {\n            for (var c = {}, u = {}, h = 0, p = Object.keys(l); h < p.length; h += 1) {\n              var d = p[h],\n                  _ = l[d],\n                  f = this._tiles[d];\n\n              if (f && !(f.fadeEndTime && f.fadeEndTime <= t.browser.now())) {\n                var m = this.findLoadedParent(_, n);\n                m && (this._addTile(m.tileID), c[m.tileID.key] = m.tileID), u[d] = _;\n              }\n            }\n\n            for (var g in this._retainLoadedChildren(u, a, s, l), c) {\n              l[g] || (this._coveredTiles[g] = !0, l[g] = c[g]);\n            }\n          }\n\n          for (var v in l) {\n            this._tiles[v].clearFadeHold();\n          }\n\n          for (var y = 0, x = t.keysDifference(this._tiles, l); y < x.length; y += 1) {\n            var b = x[y],\n                w = this._tiles[b];\n            w.hasSymbolBuckets && !w.holdingForFade() ? w.setHoldDuration(this.map._fadeDuration) : w.hasSymbolBuckets && !w.symbolFadeFinished() || this._removeTile(b);\n          }\n\n          this._updateLoadedParentTileCache();\n        }\n      }, i.prototype.releaseSymbolFadeTiles = function () {\n        for (var t in this._tiles) {\n          this._tiles[t].holdingForFade() && this._removeTile(t);\n        }\n      }, i.prototype._updateRetainedTiles = function (t, e) {\n        for (var o = {}, r = {}, a = Math.max(e - i.maxOverzooming, this._source.minzoom), n = Math.max(e + i.maxUnderzooming, this._source.minzoom), s = {}, l = 0, c = t; l < c.length; l += 1) {\n          var u = c[l],\n              h = this._addTile(u);\n\n          o[u.key] = u, h.hasData() || e < this._source.maxzoom && (s[u.key] = u);\n        }\n\n        this._retainLoadedChildren(s, e, n, o);\n\n        for (var p = 0, d = t; p < d.length; p += 1) {\n          var _ = d[p],\n              f = this._tiles[_.key];\n\n          if (!f.hasData()) {\n            if (e + 1 > this._source.maxzoom) {\n              var m = _.children(this._source.maxzoom)[0],\n                  g = this.getTile(m);\n\n              if (g && g.hasData()) {\n                o[m.key] = m;\n                continue;\n              }\n            } else {\n              var v = _.children(this._source.maxzoom);\n\n              if (o[v[0].key] && o[v[1].key] && o[v[2].key] && o[v[3].key]) continue;\n            }\n\n            for (var y = f.wasRequested(), x = _.overscaledZ - 1; x >= a; --x) {\n              var b = _.scaledTo(x);\n\n              if (r[b.key]) break;\n              if (r[b.key] = !0, !(f = this.getTile(b)) && y && (f = this._addTile(b)), f && (o[b.key] = b, y = f.wasRequested(), f.hasData())) break;\n            }\n          }\n        }\n\n        return o;\n      }, i.prototype._updateLoadedParentTileCache = function () {\n        for (var t in this._loadedParentTiles = {}, this._tiles) {\n          for (var e = [], i = void 0, o = this._tiles[t].tileID; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n\n            e.push(o.key);\n            var r = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(r)) break;\n            o = r;\n          }\n\n          for (var a = 0, n = e; a < n.length; a += 1) {\n            this._loadedParentTiles[n[a]] = i;\n          }\n        }\n      }, i.prototype._addTile = function (e) {\n        var i = this._tiles[e.key];\n        if (i) return i;\n        (i = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));\n        var o = Boolean(i);\n        return o || (i = new t.Tile(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state))), i ? (i.uses++, this._tiles[e.key] = i, o || this._source.fire(new t.Event("dataloading", {\n          tile: i,\n          coord: i.tileID,\n          dataType: "source"\n        })), i) : null;\n      }, i.prototype._setTileReloadTimer = function (t, e) {\n        var i = this;\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        var o = e.getExpiryTimeout();\n        o && (this._timers[t] = setTimeout(function () {\n          i._reloadTile(t, "expired"), delete i._timers[t];\n        }, o));\n      }, i.prototype._removeTile = function (t) {\n        var e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }, i.prototype.clearTiles = function () {\n        for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) {\n          this._removeTile(t);\n        }\n\n        this._cache.reset();\n      }, i.prototype.tilesIn = function (e, i, o) {\n        var r = this,\n            a = [],\n            n = this.transform;\n        if (!n) return a;\n\n        for (var s = o ? n.getCameraQueryGeometry(e) : e, l = e.map(function (t) {\n          return n.pointCoordinate(t);\n        }), c = s.map(function (t) {\n          return n.pointCoordinate(t);\n        }), u = this.getIds(), h = 1 / 0, p = 1 / 0, d = -1 / 0, _ = -1 / 0, f = 0, m = c; f < m.length; f += 1) {\n          var g = m[f];\n          h = Math.min(h, g.x), p = Math.min(p, g.y), d = Math.max(d, g.x), _ = Math.max(_, g.y);\n        }\n\n        for (var v = function v(e) {\n          var o = r._tiles[u[e]];\n\n          if (!o.holdingForFade()) {\n            var s = o.tileID,\n                f = Math.pow(2, n.zoom - o.tileID.overscaledZ),\n                m = i * o.queryPadding * t.EXTENT / o.tileSize / f,\n                g = [s.getTilePoint(new t.MercatorCoordinate(h, p)), s.getTilePoint(new t.MercatorCoordinate(d, _))];\n\n            if (g[0].x - m < t.EXTENT && g[0].y - m < t.EXTENT && g[1].x + m >= 0 && g[1].y + m >= 0) {\n              var v = l.map(function (t) {\n                return s.getTilePoint(t);\n              }),\n                  y = c.map(function (t) {\n                return s.getTilePoint(t);\n              });\n              a.push({\n                tile: o,\n                tileID: s,\n                queryGeometry: v,\n                cameraQueryGeometry: y,\n                scale: f\n              });\n            }\n          }\n        }, y = 0; y < u.length; y++) {\n          v(y);\n        }\n\n        return a;\n      }, i.prototype.getVisibleCoordinates = function (t) {\n        for (var e = this, i = this.getRenderableIds(t).map(function (t) {\n          return e._tiles[t].tileID;\n        }), o = 0, r = i; o < r.length; o += 1) {\n          var a = r[o];\n          a.posMatrix = this.transform.calculatePosMatrix(a.toUnwrapped());\n        }\n\n        return i;\n      }, i.prototype.hasTransition = function () {\n        if (this._source.hasTransition()) return !0;\n        if (Mt(this._source.type)) for (var e in this._tiles) {\n          var i = this._tiles[e];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t.browser.now()) return !0;\n        }\n        return !1;\n      }, i.prototype.setFeatureState = function (t, e, i) {\n        this._state.updateState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.removeFeatureState = function (t, e, i) {\n        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.getFeatureState = function (t, e) {\n        return this._state.getState(t = t || "_geojsonTileLayer", e);\n      }, i.prototype.setDependencies = function (t, e, i) {\n        var o = this._tiles[t];\n        o && o.setDependencies(e, i);\n      }, i.prototype.reloadTilesForDependencies = function (t, e) {\n        for (var i in this._tiles) {\n          this._tiles[i].hasDependency(t, e) && this._reloadTile(i, "reloading");\n        }\n\n        this._cache.filter(function (i) {\n          return !i.hasDependency(t, e);\n        });\n      }, i;\n    }(t.Evented);\n\n    function At(t, e) {\n      var i = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n          o = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || o - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n\n    function Mt(t) {\n      return "raster" === t || "image" === t || "video" === t;\n    }\n\n    function Lt() {\n      return new t.window.Worker(Kr.workerUrl);\n    }\n\n    Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;\n\n    var Rt = "mapboxgl_preloaded_worker_pool",\n        kt = function kt() {\n      this.active = {};\n    };\n\n    kt.prototype.acquire = function (t) {\n      if (!this.workers) for (this.workers = []; this.workers.length < kt.workerCount;) {\n        this.workers.push(new Lt());\n      }\n      return this.active[t] = !0, this.workers.slice();\n    }, kt.prototype.release = function (t) {\n      delete this.active[t], 0 === this.numActive() && (this.workers.forEach(function (t) {\n        t.terminate();\n      }), this.workers = null);\n    }, kt.prototype.isPreloaded = function () {\n      return !!this.active[Rt];\n    }, kt.prototype.numActive = function () {\n      return Object.keys(this.active).length;\n    };\n    var Bt,\n        Ot = Math.floor(t.browser.hardwareConcurrency / 2);\n\n    function Ft() {\n      return Bt || (Bt = new kt()), Bt;\n    }\n\n    function Ut(e, i) {\n      var o = {};\n\n      for (var r in e) {\n        "ref" !== r && (o[r] = e[r]);\n      }\n\n      return t.refProperties.forEach(function (t) {\n        t in i && (o[t] = i[t]);\n      }), o;\n    }\n\n    function Nt(t) {\n      t = t.slice();\n\n      for (var e = Object.create(null), i = 0; i < t.length; i++) {\n        e[t[i].id] = t[i];\n      }\n\n      for (var o = 0; o < t.length; o++) {\n        "ref" in t[o] && (t[o] = Ut(t[o], e[t[o].ref]));\n      }\n\n      return t;\n    }\n\n    kt.workerCount = Math.max(Math.min(Ot, 6), 1);\n    var Zt = {\n      setStyle: "setStyle",\n      addLayer: "addLayer",\n      removeLayer: "removeLayer",\n      setPaintProperty: "setPaintProperty",\n      setLayoutProperty: "setLayoutProperty",\n      setFilter: "setFilter",\n      addSource: "addSource",\n      removeSource: "removeSource",\n      setGeoJSONSourceData: "setGeoJSONSourceData",\n      setLayerZoomRange: "setLayerZoomRange",\n      setLayerProperty: "setLayerProperty",\n      setCenter: "setCenter",\n      setZoom: "setZoom",\n      setBearing: "setBearing",\n      setPitch: "setPitch",\n      setSprite: "setSprite",\n      setGlyphs: "setGlyphs",\n      setTransition: "setTransition",\n      setLight: "setLight"\n    };\n\n    function qt(t, e, i) {\n      i.push({\n        command: Zt.addSource,\n        args: [t, e[t]]\n      });\n    }\n\n    function jt(t, e, i) {\n      e.push({\n        command: Zt.removeSource,\n        args: [t]\n      }), i[t] = !0;\n    }\n\n    function Vt(t, e, i, o) {\n      jt(t, i, o), qt(t, e, i);\n    }\n\n    function Gt(e, i, o) {\n      var r;\n\n      for (r in e[o]) {\n        if (e[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      }\n\n      for (r in i[o]) {\n        if (i[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      }\n\n      return !0;\n    }\n\n    function Wt(e, i, o, r, a, n) {\n      var s;\n\n      for (s in i = i || {}, e = e || {}) {\n        e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n          command: n,\n          args: [r, s, i[s], a]\n        }));\n      }\n\n      for (s in i) {\n        i.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n          command: n,\n          args: [r, s, i[s], a]\n        }));\n      }\n    }\n\n    function Xt(t) {\n      return t.id;\n    }\n\n    function Ht(t, e) {\n      return t[e.id] = e, t;\n    }\n\n    var Kt = function Kt(t, e) {\n      this.reset(t, e);\n    };\n\n    Kt.prototype.reset = function (t, e) {\n      this.points = t || [], this._distances = [0];\n\n      for (var i = 1; i < this.points.length; i++) {\n        this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);\n      }\n\n      this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n    }, Kt.prototype.lerp = function (e) {\n      if (1 === this.points.length) return this.points[0];\n      e = t.clamp(e, 0, 1);\n\n      for (var i = 1, o = this._distances[i], r = e * this.paddedLength + this.padding; o < r && i < this._distances.length;) {\n        o = this._distances[++i];\n      }\n\n      var a = i - 1,\n          n = this._distances[a],\n          s = o - n,\n          l = s > 0 ? (r - n) / s : 0;\n      return this.points[a].mult(1 - l).add(this.points[i].mult(l));\n    };\n\n    var Yt = function Yt(t, e, i) {\n      var o = this.boxCells = [],\n          r = this.circleCells = [];\n      this.xCellCount = Math.ceil(t / i), this.yCellCount = Math.ceil(e / i);\n\n      for (var a = 0; a < this.xCellCount * this.yCellCount; a++) {\n        o.push([]), r.push([]);\n      }\n\n      this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0;\n    };\n\n    function Jt(e, i, o, r, a) {\n      var n = t.create();\n      return i ? (t.scale(n, n, [1 / a, 1 / a, 1]), o || t.rotateZ(n, n, r.angle)) : t.multiply(n, r.labelPlaneMatrix, e), n;\n    }\n\n    function Qt(e, i, o, r, a) {\n      if (i) {\n        var n = t.clone(e);\n        return t.scale(n, n, [a, a, 1]), o || t.rotateZ(n, n, -r.angle), n;\n      }\n\n      return r.glCoordMatrix;\n    }\n\n    function $t(e, i) {\n      var o = [e.x, e.y, 0, 1];\n      ue(o, o, i);\n      var r = o[3];\n      return {\n        point: new t.Point(o[0] / r, o[1] / r),\n        signedDistanceFromCamera: r\n      };\n    }\n\n    function te(t, e) {\n      return .5 + t / e * .5;\n    }\n\n    function ee(t, e) {\n      var i = t[0] / t[3],\n          o = t[1] / t[3];\n      return i >= -e[0] && i <= e[0] && o >= -e[1] && o <= e[1];\n    }\n\n    function ie(e, i, o, r, a, n, s, l) {\n      var c = r ? e.textSizeData : e.iconSizeData,\n          u = t.evaluateSizeForZoom(c, o.transform.zoom),\n          h = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n          p = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;\n      p.clear();\n\n      for (var d = e.lineVertexArray, _ = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray, f = o.transform.width / o.transform.height, m = !1, g = 0; g < _.length; g++) {\n        var v = _.get(g);\n\n        if (v.hidden || v.writingMode === t.WritingMode.vertical && !m) ce(v.numGlyphs, p);else {\n          m = !1;\n          var y = [v.anchorX, v.anchorY, 0, 1];\n\n          if (t.transformMat4(y, y, i), ee(y, h)) {\n            var x = te(o.transform.cameraToCenterDistance, y[3]),\n                b = t.evaluateSizeForFeature(c, u, v),\n                w = s ? b / x : b * x,\n                T = new t.Point(v.anchorX, v.anchorY),\n                E = $t(T, a).point,\n                I = {},\n                P = ae(v, w, !1, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f);\n            m = P.useVertical, (P.notEnoughRoom || m || P.needsFlipping && ae(v, w, !0, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f).notEnoughRoom) && ce(v.numGlyphs, p);\n          } else ce(v.numGlyphs, p);\n        }\n      }\n\n      r ? e.text.dynamicLayoutVertexBuffer.updateData(p) : e.icon.dynamicLayoutVertexBuffer.updateData(p);\n    }\n\n    function oe(t, e, i, o, r, a, n, s, l, c, u) {\n      var h = s.glyphStartIndex + s.numGlyphs,\n          p = s.lineStartIndex,\n          d = s.lineStartIndex + s.lineLength,\n          _ = e.getoffsetX(s.glyphStartIndex),\n          f = e.getoffsetX(h - 1),\n          m = se(t * _, i, o, r, a, n, s.segment, p, d, l, c, u);\n\n      if (!m) return null;\n      var g = se(t * f, i, o, r, a, n, s.segment, p, d, l, c, u);\n      return g ? {\n        first: m,\n        last: g\n      } : null;\n    }\n\n    function re(e, i, o, r) {\n      return e === t.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * r ? {\n        useVertical: !0\n      } : (e === t.WritingMode.vertical ? i.y < o.y : i.x > o.x) ? {\n        needsFlipping: !0\n      } : null;\n    }\n\n    function ae(e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n          m = i / 24,\n          g = e.lineOffsetX * m,\n          v = e.lineOffsetY * m;\n\n      if (e.numGlyphs > 1) {\n        var y = e.glyphStartIndex + e.numGlyphs,\n            x = e.lineStartIndex,\n            b = e.lineStartIndex + e.lineLength,\n            w = oe(m, l, g, v, o, h, p, e, c, n, d);\n        if (!w) return {\n          notEnoughRoom: !0\n        };\n        var T = $t(w.first.point, s).point,\n            E = $t(w.last.point, s).point;\n\n        if (r && !o) {\n          var I = re(e.writingMode, T, E, _);\n          if (I) return I;\n        }\n\n        f = [w.first];\n\n        for (var P = e.glyphStartIndex + 1; P < y - 1; P++) {\n          f.push(se(m * l.getoffsetX(P), g, v, o, h, p, e.segment, x, b, c, n, d));\n        }\n\n        f.push(w.last);\n      } else {\n        if (r && !o) {\n          var S = $t(p, a).point,\n              C = e.lineStartIndex + e.segment + 1,\n              z = new t.Point(c.getx(C), c.gety(C)),\n              D = $t(z, a),\n              A = D.signedDistanceFromCamera > 0 ? D.point : ne(p, z, S, 1, a),\n              M = re(e.writingMode, S, A, _);\n          if (M) return M;\n        }\n\n        var L = se(m * l.getoffsetX(e.glyphStartIndex), g, v, o, h, p, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, n, d);\n        if (!L) return {\n          notEnoughRoom: !0\n        };\n        f = [L];\n      }\n\n      for (var R = 0, k = f; R < k.length; R += 1) {\n        var B = k[R];\n        t.addDynamicAttributes(u, B.point, B.angle);\n      }\n\n      return {};\n    }\n\n    function ne(t, e, i, o, r) {\n      var a = $t(t.add(t.sub(e)._unit()), r).point,\n          n = i.sub(a);\n      return i.add(n._mult(o / n.mag()));\n    }\n\n    function se(e, i, o, r, a, n, s, l, c, u, h, p) {\n      var d = r ? e - i : e + i,\n          _ = d > 0 ? 1 : -1,\n          f = 0;\n\n      r && (_ *= -1, f = Math.PI), _ < 0 && (f += Math.PI);\n\n      for (var m = _ > 0 ? l + s : l + s + 1, g = a, v = a, y = 0, x = 0, b = Math.abs(d), w = []; y + x <= b;) {\n        if ((m += _) < l || m >= c) return null;\n\n        if (v = g, w.push(g), void 0 === (g = p[m])) {\n          var T = new t.Point(u.getx(m), u.gety(m)),\n              E = $t(T, h);\n          if (E.signedDistanceFromCamera > 0) g = p[m] = E.point;else {\n            var I = m - _;\n            g = ne(0 === y ? n : new t.Point(u.getx(I), u.gety(I)), T, v, b - y + 1, h);\n          }\n        }\n\n        y += x, x = v.dist(g);\n      }\n\n      var P = (b - y) / x,\n          S = g.sub(v),\n          C = S.mult(P)._add(v);\n\n      C._add(S._unit()._perp()._mult(o * _));\n\n      var z = f + Math.atan2(g.y - v.y, g.x - v.x);\n      return w.push(C), {\n        point: C,\n        angle: z,\n        path: w\n      };\n    }\n\n    Yt.prototype.keysLength = function () {\n      return this.boxKeys.length + this.circleKeys.length;\n    }, Yt.prototype.insert = function (t, e, i, o, r) {\n      this._forEachCell(e, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n    }, Yt.prototype.insertCircle = function (t, e, i, o) {\n      this._forEachCell(e - o, i - o, e + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(i), this.circles.push(o);\n    }, Yt.prototype._insertBoxCell = function (t, e, i, o, r, a) {\n      this.boxCells[r].push(a);\n    }, Yt.prototype._insertCircleCell = function (t, e, i, o, r, a) {\n      this.circleCells[r].push(a);\n    }, Yt.prototype._query = function (t, e, i, o, r, a) {\n      if (i < 0 || t > this.width || o < 0 || e > this.height) return !r && [];\n      var n = [];\n\n      if (t <= 0 && e <= 0 && this.width <= i && this.height <= o) {\n        if (r) return !0;\n\n        for (var s = 0; s < this.boxKeys.length; s++) {\n          n.push({\n            key: this.boxKeys[s],\n            x1: this.bboxes[4 * s],\n            y1: this.bboxes[4 * s + 1],\n            x2: this.bboxes[4 * s + 2],\n            y2: this.bboxes[4 * s + 3]\n          });\n        }\n\n        for (var l = 0; l < this.circleKeys.length; l++) {\n          var c = this.circles[3 * l],\n              u = this.circles[3 * l + 1],\n              h = this.circles[3 * l + 2];\n          n.push({\n            key: this.circleKeys[l],\n            x1: c - h,\n            y1: u - h,\n            x2: c + h,\n            y2: u + h\n          });\n        }\n\n        return a ? n.filter(a) : n;\n      }\n\n      return this._forEachCell(t, e, i, o, this._queryCell, n, {\n        hitTest: r,\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, a), r ? n.length > 0 : n;\n    }, Yt.prototype._queryCircle = function (t, e, i, o, r) {\n      var a = t - i,\n          n = t + i,\n          s = e - i,\n          l = e + i;\n      if (n < 0 || a > this.width || l < 0 || s > this.height) return !o && [];\n      var c = [];\n      return this._forEachCell(a, s, n, l, this._queryCellCircle, c, {\n        hitTest: o,\n        circle: {\n          x: t,\n          y: e,\n          radius: i\n        },\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, r), o ? c.length > 0 : c;\n    }, Yt.prototype.query = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !1, r);\n    }, Yt.prototype.hitTest = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !0, r);\n    }, Yt.prototype.hitTestCircle = function (t, e, i, o) {\n      return this._queryCircle(t, e, i, !0, o);\n    }, Yt.prototype._queryCell = function (t, e, i, o, r, a, n, s) {\n      var l = n.seenUids,\n          c = this.boxCells[r];\n      if (null !== c) for (var u = this.bboxes, h = 0, p = c; h < p.length; h += 1) {\n        var d = p[h];\n\n        if (!l.box[d]) {\n          l.box[d] = !0;\n\n          var _ = 4 * d;\n\n          if (t <= u[_ + 2] && e <= u[_ + 3] && i >= u[_ + 0] && o >= u[_ + 1] && (!s || s(this.boxKeys[d]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            a.push({\n              key: this.boxKeys[d],\n              x1: u[_],\n              y1: u[_ + 1],\n              x2: u[_ + 2],\n              y2: u[_ + 3]\n            });\n          }\n        }\n      }\n      var f = this.circleCells[r];\n      if (null !== f) for (var m = this.circles, g = 0, v = f; g < v.length; g += 1) {\n        var y = v[g];\n\n        if (!l.circle[y]) {\n          l.circle[y] = !0;\n          var x = 3 * y;\n\n          if (this._circleAndRectCollide(m[x], m[x + 1], m[x + 2], t, e, i, o) && (!s || s(this.circleKeys[y]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            var b = m[x],\n                w = m[x + 1],\n                T = m[x + 2];\n            a.push({\n              key: this.circleKeys[y],\n              x1: b - T,\n              y1: w - T,\n              x2: b + T,\n              y2: w + T\n            });\n          }\n        }\n      }\n    }, Yt.prototype._queryCellCircle = function (t, e, i, o, r, a, n, s) {\n      var l = n.circle,\n          c = n.seenUids,\n          u = this.boxCells[r];\n      if (null !== u) for (var h = this.bboxes, p = 0, d = u; p < d.length; p += 1) {\n        var _ = d[p];\n\n        if (!c.box[_]) {\n          c.box[_] = !0;\n          var f = 4 * _;\n          if (this._circleAndRectCollide(l.x, l.y, l.radius, h[f + 0], h[f + 1], h[f + 2], h[f + 3]) && (!s || s(this.boxKeys[_]))) return a.push(!0), !0;\n        }\n      }\n      var m = this.circleCells[r];\n      if (null !== m) for (var g = this.circles, v = 0, y = m; v < y.length; v += 1) {\n        var x = y[v];\n\n        if (!c.circle[x]) {\n          c.circle[x] = !0;\n          var b = 3 * x;\n          if (this._circlesCollide(g[b], g[b + 1], g[b + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[x]))) return a.push(!0), !0;\n        }\n      }\n    }, Yt.prototype._forEachCell = function (t, e, i, o, r, a, n, s) {\n      for (var l = this._convertToXCellCoord(t), c = this._convertToYCellCoord(e), u = this._convertToXCellCoord(i), h = this._convertToYCellCoord(o), p = l; p <= u; p++) {\n        for (var d = c; d <= h; d++) {\n          if (r.call(this, t, e, i, o, this.xCellCount * d + p, a, n, s)) return;\n        }\n      }\n    }, Yt.prototype._convertToXCellCoord = function (t) {\n      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));\n    }, Yt.prototype._convertToYCellCoord = function (t) {\n      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));\n    }, Yt.prototype._circlesCollide = function (t, e, i, o, r, a) {\n      var n = o - t,\n          s = r - e,\n          l = i + a;\n      return l * l > n * n + s * s;\n    }, Yt.prototype._circleAndRectCollide = function (t, e, i, o, r, a, n) {\n      var s = (a - o) / 2,\n          l = Math.abs(t - (o + s));\n      if (l > s + i) return !1;\n      var c = (n - r) / 2,\n          u = Math.abs(e - (r + c));\n      if (u > c + i) return !1;\n      if (l <= s || u <= c) return !0;\n      var h = l - s,\n          p = u - c;\n      return h * h + p * p <= i * i;\n    };\n    var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);\n\n    function ce(t, e) {\n      for (var i = 0; i < t; i++) {\n        var o = e.length;\n        e.resize(o + 4), e.float32.set(le, 3 * o);\n      }\n    }\n\n    function ue(t, e, i) {\n      var o = e[0],\n          r = e[1];\n      return t[0] = i[0] * o + i[4] * r + i[12], t[1] = i[1] * o + i[5] * r + i[13], t[3] = i[3] * o + i[7] * r + i[15], t;\n    }\n\n    var he = function he(t, e, i) {\n      void 0 === e && (e = new Yt(t.width + 200, t.height + 200, 25)), void 0 === i && (i = new Yt(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = i, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200;\n    };\n\n    function pe(e, i, o) {\n      return i * (t.EXTENT / (e.tileSize * Math.pow(2, o - e.tileID.overscaledZ)));\n    }\n\n    he.prototype.placeCollisionBox = function (t, e, i, o, r) {\n      var a = this.projectAndGetPerspectiveRatio(o, t.anchorPointX, t.anchorPointY),\n          n = i * a.perspectiveRatio,\n          s = t.x1 * n + a.point.x,\n          l = t.y1 * n + a.point.y,\n          c = t.x2 * n + a.point.x,\n          u = t.y2 * n + a.point.y;\n      return !this.isInsideGrid(s, l, c, u) || !e && this.grid.hitTest(s, l, c, u, r) ? {\n        box: [],\n        offscreen: !1\n      } : {\n        box: [s, l, c, u],\n        offscreen: this.isOffscreen(s, l, c, u)\n      };\n    }, he.prototype.placeCollisionCircles = function (e, i, o, r, a, n, s, l, c, u, h, p, d) {\n      var _ = [],\n          f = new t.Point(i.anchorX, i.anchorY),\n          m = $t(f, n),\n          g = te(this.transform.cameraToCenterDistance, m.signedDistanceFromCamera),\n          v = (u ? a / g : a * g) / t.ONE_EM,\n          y = $t(f, s).point,\n          x = oe(v, r, i.lineOffsetX * v, i.lineOffsetY * v, !1, y, f, i, o, s, {}),\n          b = !1,\n          w = !1,\n          T = !0;\n\n      if (x) {\n        for (var E = .5 * p * g + d, I = new t.Point(-100, -100), P = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S = new Kt(), C = x.first, z = x.last, D = [], A = C.path.length - 1; A >= 1; A--) {\n          D.push(C.path[A]);\n        }\n\n        for (var M = 1; M < z.path.length; M++) {\n          D.push(z.path[M]);\n        }\n\n        var L = 2.5 * E;\n\n        if (l) {\n          var R = D.map(function (t) {\n            return $t(t, l);\n          });\n          D = R.some(function (t) {\n            return t.signedDistanceFromCamera <= 0;\n          }) ? [] : R.map(function (t) {\n            return t.point;\n          });\n        }\n\n        var k = [];\n\n        if (D.length > 0) {\n          for (var B = D[0].clone(), O = D[0].clone(), F = 1; F < D.length; F++) {\n            B.x = Math.min(B.x, D[F].x), B.y = Math.min(B.y, D[F].y), O.x = Math.max(O.x, D[F].x), O.y = Math.max(O.y, D[F].y);\n          }\n\n          k = B.x >= I.x && O.x <= P.x && B.y >= I.y && O.y <= P.y ? [D] : O.x < I.x || B.x > P.x || O.y < I.y || B.y > P.y ? [] : t.clipLine([D], I.x, I.y, P.x, P.y);\n        }\n\n        for (var U = 0, N = k; U < N.length; U += 1) {\n          var Z;\n          S.reset(N[U], .25 * E), Z = S.length <= .5 * E ? 1 : Math.ceil(S.paddedLength / L) + 1;\n\n          for (var q = 0; q < Z; q++) {\n            var j = q / Math.max(Z - 1, 1),\n                V = S.lerp(j),\n                G = V.x + 100,\n                W = V.y + 100;\n\n            _.push(G, W, E, 0);\n\n            var X = G - E,\n                H = W - E,\n                K = G + E,\n                Y = W + E;\n            if (T = T && this.isOffscreen(X, H, K, Y), w = w || this.isInsideGrid(X, H, K, Y), !e && this.grid.hitTestCircle(G, W, E, h) && (b = !0, !c)) return {\n              circles: [],\n              offscreen: !1,\n              collisionDetected: b\n            };\n          }\n        }\n      }\n\n      return {\n        circles: !c && b || !w ? [] : _,\n        offscreen: T,\n        collisionDetected: b\n      };\n    }, he.prototype.queryRenderedSymbols = function (e) {\n      if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n\n      for (var i = [], o = 1 / 0, r = 1 / 0, a = -1 / 0, n = -1 / 0, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s],\n            u = new t.Point(c.x + 100, c.y + 100);\n        o = Math.min(o, u.x), r = Math.min(r, u.y), a = Math.max(a, u.x), n = Math.max(n, u.y), i.push(u);\n      }\n\n      for (var h = {}, p = {}, d = 0, _ = this.grid.query(o, r, a, n).concat(this.ignoredGrid.query(o, r, a, n)); d < _.length; d += 1) {\n        var f = _[d],\n            m = f.key;\n\n        if (void 0 === h[m.bucketInstanceId] && (h[m.bucketInstanceId] = {}), !h[m.bucketInstanceId][m.featureIndex]) {\n          var g = [new t.Point(f.x1, f.y1), new t.Point(f.x2, f.y1), new t.Point(f.x2, f.y2), new t.Point(f.x1, f.y2)];\n          t.polygonIntersectsPolygon(i, g) && (h[m.bucketInstanceId][m.featureIndex] = !0, void 0 === p[m.bucketInstanceId] && (p[m.bucketInstanceId] = []), p[m.bucketInstanceId].push(m.featureIndex));\n        }\n      }\n\n      return p;\n    }, he.prototype.insertCollisionBox = function (t, e, i, o, r) {\n      (e ? this.ignoredGrid : this.grid).insert({\n        bucketInstanceId: i,\n        featureIndex: o,\n        collisionGroupID: r\n      }, t[0], t[1], t[2], t[3]);\n    }, he.prototype.insertCollisionCircles = function (t, e, i, o, r) {\n      for (var a = e ? this.ignoredGrid : this.grid, n = {\n        bucketInstanceId: i,\n        featureIndex: o,\n        collisionGroupID: r\n      }, s = 0; s < t.length; s += 4) {\n        a.insertCircle(n, t[s], t[s + 1], t[s + 2]);\n      }\n    }, he.prototype.projectAndGetPerspectiveRatio = function (e, i, o) {\n      var r = [i, o, 0, 1];\n      return ue(r, r, e), {\n        point: new t.Point((r[0] / r[3] + 1) / 2 * this.transform.width + 100, (-r[1] / r[3] + 1) / 2 * this.transform.height + 100),\n        perspectiveRatio: .5 + this.transform.cameraToCenterDistance / r[3] * .5\n      };\n    }, he.prototype.isOffscreen = function (t, e, i, o) {\n      return i < 100 || t >= this.screenRightBoundary || o < 100 || e > this.screenBottomBoundary;\n    }, he.prototype.isInsideGrid = function (t, e, i, o) {\n      return i >= 0 && t < this.gridRightBoundary && o >= 0 && e < this.gridBottomBoundary;\n    }, he.prototype.getViewportMatrix = function () {\n      var e = t.identity([]);\n      return t.translate(e, e, [-100, -100, 0]), e;\n    };\n\n    var de = function de(t, e, i, o) {\n      this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : o && i ? 1 : 0, this.placed = i;\n    };\n\n    de.prototype.isHidden = function () {\n      return 0 === this.opacity && !this.placed;\n    };\n\n    var _e = function _e(t, e, i, o, r) {\n      this.text = new de(t ? t.text : null, e, i, r), this.icon = new de(t ? t.icon : null, e, o, r);\n    };\n\n    _e.prototype.isHidden = function () {\n      return this.text.isHidden() && this.icon.isHidden();\n    };\n\n    var fe = function fe(t, e, i) {\n      this.text = t, this.icon = e, this.skipFade = i;\n    },\n        me = function me() {\n      this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];\n    },\n        ge = function ge(t, e, i, o, r) {\n      this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n    },\n        ve = function ve(t) {\n      this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};\n    };\n\n    function ye(e, i, o, r, a) {\n      var n = t.getAnchorAlignment(e),\n          s = -(n.horizontalAlign - .5) * i,\n          l = -(n.verticalAlign - .5) * o,\n          c = t.evaluateVariableOffset(e, r);\n      return new t.Point(s + c[0] * a, l + c[1] * a);\n    }\n\n    function xe(e, i, o, r, a, n) {\n      var s = e.x1,\n          l = e.x2,\n          c = e.y1,\n          u = e.y2,\n          h = e.anchorPointX,\n          p = e.anchorPointY,\n          d = new t.Point(i, o);\n      return r && d._rotate(a ? n : -n), {\n        x1: s + d.x,\n        y1: c + d.y,\n        x2: l + d.x,\n        y2: u + d.y,\n        anchorPointX: h,\n        anchorPointY: p\n      };\n    }\n\n    ve.prototype.get = function (t) {\n      if (this.crossSourceCollisions) return {\n        ID: 0,\n        predicate: null\n      };\n\n      if (!this.collisionGroups[t]) {\n        var e = ++this.maxGroupID;\n        this.collisionGroups[t] = {\n          ID: e,\n          predicate: function predicate(t) {\n            return t.collisionGroupID === e;\n          }\n        };\n      }\n\n      return this.collisionGroups[t];\n    };\n\n    var be = function be(t, e, i, o) {\n      this.transform = t.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new ve(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n    };\n\n    function we(t, e, i, o, r) {\n      t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n\n    be.prototype.getBucketParts = function (e, i, o, r) {\n      var a = o.getBucket(i),\n          n = o.latestFeatureIndex;\n\n      if (a && n && i.id === a.layerIds[0]) {\n        var s = o.collisionBoxArray,\n            l = a.layers[0].layout,\n            c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n            u = o.tileSize / t.EXTENT,\n            h = this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),\n            p = "map" === l.get("text-pitch-alignment"),\n            d = "map" === l.get("text-rotation-alignment"),\n            _ = pe(o, 1, this.transform.zoom),\n            f = Jt(h, p, d, this.transform, _),\n            m = null;\n\n        if (p) {\n          var g = Qt(h, p, d, this.transform, _);\n          m = t.multiply([], this.transform.labelPlaneMatrix, g);\n        }\n\n        this.retainedQueryData[a.bucketInstanceId] = new ge(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, o.tileID);\n        var v = {\n          bucket: a,\n          layout: l,\n          posMatrix: h,\n          textLabelPlaneMatrix: f,\n          labelToScreenMatrix: m,\n          scale: c,\n          textPixelRatio: u,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: s,\n          partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a.textSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(a.sourceID)\n        };\n        if (r) for (var y = 0, x = a.sortKeyRanges; y < x.length; y += 1) {\n          var b = x[y];\n          e.push({\n            sortKey: b.sortKey,\n            symbolInstanceStart: b.symbolInstanceStart,\n            symbolInstanceEnd: b.symbolInstanceEnd,\n            parameters: v\n          });\n        } else e.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: a.symbolInstances.length,\n          parameters: v\n        });\n      }\n    }, be.prototype.attemptAnchorPlacement = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n          m = [h.textOffset0, h.textOffset1],\n          g = ye(t, i, o, m, r),\n          v = this.collisionIndex.placeCollisionBox(xe(e, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate);\n      if (!_ || 0 !== this.collisionIndex.placeCollisionBox(xe(_, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate).box.length) return v.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (f = this.prevPlacement.variableOffsets[h.crossTileID].anchor), this.variableOffsets[h.crossTileID] = {\n        textOffset: m,\n        width: i,\n        height: o,\n        anchor: t,\n        textBoxScale: r,\n        prevAnchor: f\n      }, this.markUsedJustification(p, t, h, d), p.allowVerticalPlacement && (this.markUsedOrientation(p, d, h), this.placedOrientations[h.crossTileID] = d), {\n        shift: g,\n        placedGlyphBoxes: v\n      }) : void 0;\n    }, be.prototype.placeLayerBucketPart = function (e, i, o) {\n      var r = this,\n          a = e.parameters,\n          n = a.bucket,\n          s = a.layout,\n          l = a.posMatrix,\n          c = a.textLabelPlaneMatrix,\n          u = a.labelToScreenMatrix,\n          h = a.textPixelRatio,\n          p = a.holdingForFade,\n          d = a.collisionBoxArray,\n          _ = a.partiallyEvaluatedTextSize,\n          f = a.collisionGroup,\n          m = s.get("text-optional"),\n          g = s.get("icon-optional"),\n          v = s.get("text-allow-overlap"),\n          y = s.get("icon-allow-overlap"),\n          x = "map" === s.get("text-rotation-alignment"),\n          b = "map" === s.get("text-pitch-alignment"),\n          w = "none" !== s.get("icon-text-fit"),\n          T = "viewport-y" === s.get("symbol-z-order"),\n          E = v && (y || !n.hasIconData() || g),\n          I = y && (v || !n.hasTextData() || m);\n      !n.collisionArrays && d && n.deserializeCollisionBoxes(d);\n\n      var P = function P(e, a) {\n        if (!i[e.crossTileID]) if (p) r.placements[e.crossTileID] = new fe(!1, !1, !1);else {\n          var d,\n              T = !1,\n              P = !1,\n              S = !0,\n              C = null,\n              z = {\n            box: null,\n            offscreen: null\n          },\n              D = {\n            box: null,\n            offscreen: null\n          },\n              A = null,\n              M = null,\n              L = 0,\n              R = 0,\n              k = 0;\n          a.textFeatureIndex ? L = a.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), a.verticalTextFeatureIndex && (R = a.verticalTextFeatureIndex);\n          var B = a.textBox;\n\n          if (B) {\n            var O = function O(i) {\n              var o = t.WritingMode.horizontal;\n\n              if (n.allowVerticalPlacement && !i && r.prevPlacement) {\n                var a = r.prevPlacement.placedOrientations[e.crossTileID];\n                a && (r.placedOrientations[e.crossTileID] = a, r.markUsedOrientation(n, o = a, e));\n              }\n\n              return o;\n            },\n                F = function F(i, o) {\n              if (n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && a.verticalTextBox) for (var r = 0, s = n.writingModes; r < s.length && (s[r] === t.WritingMode.vertical ? (z = o(), D = z) : z = i(), !(z && z.box && z.box.length)); r += 1) {\n                ;\n              } else z = i();\n            };\n\n            if (s.get("text-variable-anchor")) {\n              var U = s.get("text-variable-anchor");\n\n              if (r.prevPlacement && r.prevPlacement.variableOffsets[e.crossTileID]) {\n                var N = r.prevPlacement.variableOffsets[e.crossTileID];\n                U.indexOf(N.anchor) > 0 && (U = U.filter(function (t) {\n                  return t !== N.anchor;\n                })).unshift(N.anchor);\n              }\n\n              var Z = function Z(t, i, o) {\n                for (var a = t.x2 - t.x1, s = t.y2 - t.y1, c = e.textBoxScale, u = w && !y ? i : null, p = {\n                  box: [],\n                  offscreen: !1\n                }, d = v ? 2 * U.length : U.length, _ = 0; _ < d; ++_) {\n                  var m = r.attemptAnchorPlacement(U[_ % U.length], t, a, s, c, x, b, h, l, f, _ >= U.length, e, n, o, u);\n\n                  if (m && (p = m.placedGlyphBoxes) && p.box && p.box.length) {\n                    T = !0, C = m.shift;\n                    break;\n                  }\n                }\n\n                return p;\n              };\n\n              F(function () {\n                return Z(B, a.iconBox, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && !(z && z.box && z.box.length) && e.numVerticalGlyphVertices > 0 && i ? Z(i, a.verticalIconBox, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), z && (T = z.box, S = z.offscreen);\n              var q = O(z && z.box);\n\n              if (!T && r.prevPlacement) {\n                var j = r.prevPlacement.variableOffsets[e.crossTileID];\n                j && (r.variableOffsets[e.crossTileID] = j, r.markUsedJustification(n, j.anchor, e, q));\n              }\n            } else {\n              var V = function V(t, i) {\n                var o = r.collisionIndex.placeCollisionBox(t, v, h, l, f.predicate);\n                return o && o.box && o.box.length && (r.markUsedOrientation(n, i, e), r.placedOrientations[e.crossTileID] = i), o;\n              };\n\n              F(function () {\n                return V(B, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? V(i, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), O(z && z.box && z.box.length);\n            }\n          }\n\n          if (T = (d = z) && d.box && d.box.length > 0, S = d && d.offscreen, e.useRuntimeCollisionCircles) {\n            var G = n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),\n                W = t.evaluateSizeForFeature(n.textSizeData, _, G),\n                X = s.get("text-padding");\n            A = r.collisionIndex.placeCollisionCircles(v, G, n.lineVertexArray, n.glyphOffsetArray, W, l, c, u, o, b, f.predicate, e.collisionCircleDiameter, X), T = v || A.circles.length > 0 && !A.collisionDetected, S = S && A.offscreen;\n          }\n\n          if (a.iconFeatureIndex && (k = a.iconFeatureIndex), a.iconBox) {\n            var H = function H(t) {\n              var e = w && C ? xe(t, C.x, C.y, x, b, r.transform.angle) : t;\n              return r.collisionIndex.placeCollisionBox(e, y, h, l, f.predicate);\n            };\n\n            P = D && D.box && D.box.length && a.verticalIconBox ? (M = H(a.verticalIconBox)).box.length > 0 : (M = H(a.iconBox)).box.length > 0, S = S && M.offscreen;\n          }\n\n          var K = m || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices,\n              Y = g || 0 === e.numIconVertices;\n\n          if (K || Y ? Y ? K || (P = P && T) : T = P && T : P = T = P && T, T && d && d.box && r.collisionIndex.insertCollisionBox(d.box, s.get("text-ignore-placement"), n.bucketInstanceId, D && D.box && R ? R : L, f.ID), P && M && r.collisionIndex.insertCollisionBox(M.box, s.get("icon-ignore-placement"), n.bucketInstanceId, k, f.ID), A && (T && r.collisionIndex.insertCollisionCircles(A.circles, s.get("text-ignore-placement"), n.bucketInstanceId, L, f.ID), o)) {\n            var J = n.bucketInstanceId,\n                Q = r.collisionCircleArrays[J];\n            void 0 === Q && (Q = r.collisionCircleArrays[J] = new me());\n\n            for (var $ = 0; $ < A.circles.length; $ += 4) {\n              Q.circles.push(A.circles[$ + 0]), Q.circles.push(A.circles[$ + 1]), Q.circles.push(A.circles[$ + 2]), Q.circles.push(A.collisionDetected ? 1 : 0);\n            }\n          }\n\n          r.placements[e.crossTileID] = new fe(T || E, P || I, S || n.justReloaded), i[e.crossTileID] = !0;\n        }\n      };\n\n      if (T) for (var S = n.getSortedSymbolIndexes(this.transform.angle), C = S.length - 1; C >= 0; --C) {\n        var z = S[C];\n        P(n.symbolInstances.get(z), n.collisionArrays[z]);\n      } else for (var D = e.symbolInstanceStart; D < e.symbolInstanceEnd; D++) {\n        P(n.symbolInstances.get(D), n.collisionArrays[D]);\n      }\n\n      if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n        var A = this.collisionCircleArrays[n.bucketInstanceId];\n        t.invert(A.invProjMatrix, l), A.viewportMatrix = this.collisionIndex.getViewportMatrix();\n      }\n\n      n.justReloaded = !1;\n    }, be.prototype.markUsedJustification = function (e, i, o, r) {\n      var a;\n      a = r === t.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {\n        left: o.leftJustifiedTextSymbolIndex,\n        center: o.centerJustifiedTextSymbolIndex,\n        right: o.rightJustifiedTextSymbolIndex\n      }[t.getAnchorJustification(i)];\n\n      for (var n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex]; n < s.length; n += 1) {\n        var l = s[n];\n        l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = a >= 0 && l !== a ? 0 : o.crossTileID);\n      }\n    }, be.prototype.markUsedOrientation = function (e, i, o) {\n      for (var r = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0, a = i === t.WritingMode.vertical ? i : 0, n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex]; n < s.length; n += 1) {\n        e.text.placedSymbolArray.get(s[n]).placedOrientation = r;\n      }\n\n      o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = a);\n    }, be.prototype.commit = function (t) {\n      this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;\n      var e = this.prevPlacement,\n          i = !1;\n      this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;\n      var o = e ? e.symbolFadeChange(t) : 1,\n          r = e ? e.opacities : {},\n          a = e ? e.variableOffsets : {},\n          n = e ? e.placedOrientations : {};\n\n      for (var s in this.placements) {\n        var l = this.placements[s],\n            c = r[s];\n        c ? (this.opacities[s] = new _e(c, o, l.text, l.icon), i = i || l.text !== c.text.placed || l.icon !== c.icon.placed) : (this.opacities[s] = new _e(null, o, l.text, l.icon, l.skipFade), i = i || l.text || l.icon);\n      }\n\n      for (var u in r) {\n        var h = r[u];\n\n        if (!this.opacities[u]) {\n          var p = new _e(h, o, !1, !1);\n          p.isHidden() || (this.opacities[u] = p, i = i || h.text.placed || h.icon.placed);\n        }\n      }\n\n      for (var d in a) {\n        this.variableOffsets[d] || !this.opacities[d] || this.opacities[d].isHidden() || (this.variableOffsets[d] = a[d]);\n      }\n\n      for (var _ in n) {\n        this.placedOrientations[_] || !this.opacities[_] || this.opacities[_].isHidden() || (this.placedOrientations[_] = n[_]);\n      }\n\n      i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);\n    }, be.prototype.updateLayerOpacities = function (t, e) {\n      for (var i = {}, o = 0, r = e; o < r.length; o += 1) {\n        var a = r[o],\n            n = a.getBucket(t);\n        n && a.latestFeatureIndex && t.id === n.layerIds[0] && this.updateBucketOpacities(n, i, a.collisionBoxArray);\n      }\n    }, be.prototype.updateBucketOpacities = function (e, i, o) {\n      var r = this;\n      e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();\n      var a = e.layers[0].layout,\n          n = new _e(null, 0, !1, !1, !0),\n          s = a.get("text-allow-overlap"),\n          l = a.get("icon-allow-overlap"),\n          c = a.get("text-variable-anchor"),\n          u = "map" === a.get("text-rotation-alignment"),\n          h = "map" === a.get("text-pitch-alignment"),\n          p = "none" !== a.get("icon-text-fit"),\n          d = new _e(null, 0, s && (l || !e.hasIconData() || a.get("icon-optional")), l && (s || !e.hasTextData() || a.get("text-optional")), !0);\n      !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);\n\n      for (var _ = function _(t, e, i) {\n        for (var o = 0; o < e / 4; o++) {\n          t.opacityVertexArray.emplaceBack(i);\n        }\n      }, f = function f(o) {\n        var a = e.symbolInstances.get(o),\n            s = a.numHorizontalGlyphVertices,\n            l = a.numVerticalGlyphVertices,\n            f = a.crossTileID,\n            m = r.opacities[f];\n        i[f] ? m = n : m || (r.opacities[f] = m = d), i[f] = !0;\n        var g = a.numIconVertices > 0,\n            v = r.placedOrientations[a.crossTileID],\n            y = v === t.WritingMode.vertical,\n            x = v === t.WritingMode.horizontal || v === t.WritingMode.horizontalOnly;\n\n        if (s > 0 || l > 0) {\n          var b = De(m.text);\n          _(e.text, s, y ? Ae : b), _(e.text, l, x ? Ae : b);\n          var w = m.text.isHidden();\n          [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(function (t) {\n            t >= 0 && (e.text.placedSymbolArray.get(t).hidden = w || y ? 1 : 0);\n          }), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = w || x ? 1 : 0);\n          var T = r.variableOffsets[a.crossTileID];\n          T && r.markUsedJustification(e, T.anchor, a, v);\n          var E = r.placedOrientations[a.crossTileID];\n          E && (r.markUsedJustification(e, "left", a, E), r.markUsedOrientation(e, E, a));\n        }\n\n        if (g) {\n          var I = De(m.icon),\n              P = !(p && a.verticalPlacedIconSymbolIndex && y);\n          a.placedIconSymbolIndex >= 0 && (_(e.icon, a.numIconVertices, P ? I : Ae), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = m.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (_(e.icon, a.numVerticalIconVertices, P ? Ae : I), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = m.icon.isHidden());\n        }\n\n        if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {\n          var S = e.collisionArrays[o];\n\n          if (S) {\n            var C = new t.Point(0, 0);\n\n            if (S.textBox || S.verticalTextBox) {\n              var z = !0;\n\n              if (c) {\n                var D = r.variableOffsets[f];\n                D ? (C = ye(D.anchor, D.width, D.height, D.textOffset, D.textBoxScale), u && C._rotate(h ? r.transform.angle : -r.transform.angle)) : z = !1;\n              }\n\n              S.textBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || y, C.x, C.y), S.verticalTextBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || x, C.x, C.y);\n            }\n\n            var A = Boolean(!x && S.verticalIconBox);\n            S.iconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, A, p ? C.x : 0, p ? C.y : 0), S.verticalIconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, !A, p ? C.x : 0, p ? C.y : 0);\n          }\n        }\n      }, m = 0; m < e.symbolInstances.length; m++) {\n        f(m);\n      }\n\n      if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) {\n        var g = this.collisionCircleArrays[e.bucketInstanceId];\n        e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId];\n      }\n    }, be.prototype.symbolFadeChange = function (t) {\n      return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n    }, be.prototype.zoomAdjustment = function (t) {\n      return Math.max(0, (this.transform.zoom - t) / 1.5);\n    }, be.prototype.hasTransitions = function (t) {\n      return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;\n    }, be.prototype.stillRecent = function (t, e) {\n      var i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;\n      return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * i > t;\n    }, be.prototype.setStale = function () {\n      this.stale = !0;\n    };\n    var Te = Math.pow(2, 25),\n        Ee = Math.pow(2, 24),\n        Ie = Math.pow(2, 17),\n        Pe = Math.pow(2, 16),\n        Se = Math.pow(2, 9),\n        Ce = Math.pow(2, 8),\n        ze = Math.pow(2, 1);\n\n    function De(t) {\n      if (0 === t.opacity && !t.placed) return 0;\n      if (1 === t.opacity && t.placed) return 4294967295;\n      var e = t.placed ? 1 : 0,\n          i = Math.floor(127 * t.opacity);\n      return i * Te + e * Ee + i * Ie + e * Pe + i * Se + e * Ce + i * ze + e;\n    }\n\n    var Ae = 0,\n        Me = function Me(t) {\n      this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];\n    };\n\n    Me.prototype.continuePlacement = function (t, e, i, o, r) {\n      for (var a = this._bucketParts; this._currentTileIndex < t.length;) {\n        if (e.getBucketParts(a, o, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n      }\n\n      for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      })); this._currentPartIndex < a.length;) {\n        if (e.placeLayerBucketPart(a[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, r()) return !0;\n      }\n\n      return !1;\n    };\n\n    var Le = function Le(t, e, i, o, r, a, n) {\n      this.placement = new be(t, r, a, n), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n    };\n\n    Le.prototype.isDone = function () {\n      return this._done;\n    }, Le.prototype.continuePlacement = function (e, i, o) {\n      for (var r = this, a = t.browser.now(), n = function n() {\n        var e = t.browser.now() - a;\n        return !r._forceFullPlacement && e > 2;\n      }; this._currentPlacementIndex >= 0;) {\n        var s = i[e[this._currentPlacementIndex]],\n            l = this.placement.collisionIndex.transform.zoom;\n\n        if ("symbol" === s.type && (!s.minzoom || s.minzoom <= l) && (!s.maxzoom || s.maxzoom > l)) {\n          if (this._inProgressLayer || (this._inProgressLayer = new Me(s)), this._inProgressLayer.continuePlacement(o[s.source], this.placement, this._showCollisionBoxes, s, n)) return;\n          delete this._inProgressLayer;\n        }\n\n        this._currentPlacementIndex--;\n      }\n\n      this._done = !0;\n    }, Le.prototype.commit = function (t) {\n      return this.placement.commit(t), this.placement;\n    };\n\n    var Re = 512 / t.EXTENT / 2,\n        ke = function ke(t, e, i) {\n      this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;\n\n      for (var o = 0; o < e.length; o++) {\n        var r = e.get(o),\n            a = r.key;\n        this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({\n          crossTileID: r.crossTileID,\n          coord: this.getScaledCoordinates(r, t)\n        });\n      }\n    };\n\n    ke.prototype.getScaledCoordinates = function (e, i) {\n      var o = Re / Math.pow(2, i.canonical.z - this.tileID.canonical.z);\n      return {\n        x: Math.floor((i.canonical.x * t.EXTENT + e.anchorX) * o),\n        y: Math.floor((i.canonical.y * t.EXTENT + e.anchorY) * o)\n      };\n    }, ke.prototype.findMatches = function (t, e, i) {\n      for (var o = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), r = 0; r < t.length; r++) {\n        var a = t.get(r);\n\n        if (!a.crossTileID) {\n          var n = this.indexedSymbolInstances[a.key];\n          if (n) for (var s = this.getScaledCoordinates(a, e), l = 0, c = n; l < c.length; l += 1) {\n            var u = c[l];\n\n            if (Math.abs(u.coord.x - s.x) <= o && Math.abs(u.coord.y - s.y) <= o && !i[u.crossTileID]) {\n              i[u.crossTileID] = !0, a.crossTileID = u.crossTileID;\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    var Be = function Be() {\n      this.maxCrossTileID = 0;\n    };\n\n    Be.prototype.generate = function () {\n      return ++this.maxCrossTileID;\n    };\n\n    var Oe = function Oe() {\n      this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n    };\n\n    Oe.prototype.handleWrapJump = function (t) {\n      var e = Math.round((t - this.lng) / 360);\n      if (0 !== e) for (var i in this.indexes) {\n        var o = this.indexes[i],\n            r = {};\n\n        for (var a in o) {\n          var n = o[a];\n          n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), r[n.tileID.key] = n;\n        }\n\n        this.indexes[i] = r;\n      }\n      this.lng = t;\n    }, Oe.prototype.addBucket = function (t, e, i) {\n      if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {\n        if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1;\n        this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);\n      }\n\n      for (var o = 0; o < e.symbolInstances.length; o++) {\n        e.symbolInstances.get(o).crossTileID = 0;\n      }\n\n      this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});\n      var r = this.usedCrossTileIDs[t.overscaledZ];\n\n      for (var a in this.indexes) {\n        var n = this.indexes[a];\n        if (Number(a) > t.overscaledZ) for (var s in n) {\n          var l = n[s];\n          l.tileID.isChildOf(t) && l.findMatches(e.symbolInstances, t, r);\n        } else {\n          var c = n[t.scaledTo(Number(a)).key];\n          c && c.findMatches(e.symbolInstances, t, r);\n        }\n      }\n\n      for (var u = 0; u < e.symbolInstances.length; u++) {\n        var h = e.symbolInstances.get(u);\n        h.crossTileID || (h.crossTileID = i.generate(), r[h.crossTileID] = !0);\n      }\n\n      return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new ke(t, e.symbolInstances, e.bucketInstanceId), !0;\n    }, Oe.prototype.removeBucketCrossTileIDs = function (t, e) {\n      for (var i in e.indexedSymbolInstances) {\n        for (var o = 0, r = e.indexedSymbolInstances[i]; o < r.length; o += 1) {\n          delete this.usedCrossTileIDs[t][r[o].crossTileID];\n        }\n      }\n    }, Oe.prototype.removeStaleBuckets = function (t) {\n      var e = !1;\n\n      for (var i in this.indexes) {\n        var o = this.indexes[i];\n\n        for (var r in o) {\n          t[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], e = !0);\n        }\n      }\n\n      return e;\n    };\n\n    var Fe = function Fe() {\n      this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n    };\n\n    Fe.prototype.addLayer = function (t, e, i) {\n      var o = this.layerIndexes[t.id];\n      void 0 === o && (o = this.layerIndexes[t.id] = new Oe());\n      var r = !1,\n          a = {};\n      o.handleWrapJump(i);\n\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n],\n            c = l.getBucket(t);\n        c && t.id === c.layerIds[0] && (c.bucketInstanceId || (c.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(l.tileID, c, this.crossTileIDs) && (r = !0), a[c.bucketInstanceId] = !0);\n      }\n\n      return o.removeStaleBuckets(a) && (r = !0), r;\n    }, Fe.prototype.pruneUnusedLayers = function (t) {\n      var e = {};\n\n      for (var i in t.forEach(function (t) {\n        e[t] = !0;\n      }), this.layerIndexes) {\n        e[i] || delete this.layerIndexes[i];\n      }\n    };\n\n    var Ue = function Ue(e, i) {\n      return t.emitValidationErrors(e, i && i.filter(function (t) {\n        return "source.canvas" !== t.identifier;\n      }));\n    },\n        Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]),\n        Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]),\n        qe = function () {\n      var e = {},\n          i = t.styleSpec.$version;\n\n      for (var o in t.styleSpec.$root) {\n        var r,\n            a = t.styleSpec.$root[o];\n        if (a.required) null != (r = "version" === o ? i : "array" === a.type ? [] : {}) && (e[o] = r);\n      }\n\n      return e;\n    }(),\n        je = function (e) {\n      function i(o, r) {\n        var a = this;\n        void 0 === r && (r = {}), e.call(this), this.map = o, this.dispatcher = new E(Ft(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o._requestManager, r.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());\n        var n = this;\n        this._rtlTextPluginCallback = i.registerForPluginStateChange(function (e) {\n          n.dispatcher.broadcast("syncRTLPluginState", {\n            pluginStatus: e.pluginStatus,\n            pluginURL: e.pluginURL\n          }, function (e, i) {\n            if (t.triggerPluginCompletionEvent(e), i && i.every(function (t) {\n              return t;\n            })) for (var o in n.sourceCaches) {\n              n.sourceCaches[o].reload();\n            }\n          });\n        }), this.on("data", function (t) {\n          if ("source" === t.dataType && "metadata" === t.sourceDataType) {\n            var e = a.sourceCaches[t.sourceId];\n\n            if (e) {\n              var i = e.getSource();\n              if (i && i.vectorLayerIds) for (var o in a._layers) {\n                var r = a._layers[o];\n                r.source === i.id && a._validateLayer(r);\n              }\n            }\n          }\n        });\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.loadURL = function (e, i) {\n        var o = this;\n        void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        }));\n        var r = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e);\n        e = this.map._requestManager.normalizeStyleURL(e, i.accessToken);\n\n        var a = this.map._requestManager.transformRequest(e, t.ResourceType.Style);\n\n        this._request = t.getJSON(a, function (e, i) {\n          o._request = null, e ? o.fire(new t.ErrorEvent(e)) : i && o._load(i, r);\n        });\n      }, i.prototype.loadJSON = function (e, i) {\n        var o = this;\n        void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        })), this._request = t.browser.frame(function () {\n          o._request = null, o._load(e, !1 !== i.validate);\n        });\n      }, i.prototype.loadEmpty = function () {\n        this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        })), this._load(qe, !1);\n      }, i.prototype._load = function (e, i) {\n        if (!i || !Ue(this, t.validateStyle(e))) {\n          for (var o in this._loaded = !0, this.stylesheet = e, e.sources) {\n            this.addSource(o, e.sources[o], {\n              validate: !1\n            });\n          }\n\n          e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs);\n          var r = Nt(this.stylesheet.layers);\n          this._order = r.map(function (t) {\n            return t.id;\n          }), this._layers = {}, this._serializedLayers = {};\n\n          for (var a = 0, n = r; a < n.length; a += 1) {\n            var s = n[a];\n            (s = t.createStyleLayer(s)).setEventedParent(this, {\n              layer: {\n                id: s.id\n              }\n            }), this._layers[s.id] = s, this._serializedLayers[s.id] = s.serialize();\n          }\n\n          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", {\n            dataType: "style"\n          })), this.fire(new t.Event("style.load"));\n        }\n      }, i.prototype._loadSprite = function (e) {\n        var i = this;\n\n        this._spriteRequest = function (e, i, o) {\n          var r,\n              a,\n              n,\n              s = t.browser.devicePixelRatio > 1 ? "@2x" : "",\n              l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, s, ".json"), t.ResourceType.SpriteJSON), function (t, e) {\n            l = null, n || (n = t, r = e, u());\n          }),\n              c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, s, ".png"), t.ResourceType.SpriteImage), function (t, e) {\n            c = null, n || (n = t, a = e, u());\n          });\n\n          function u() {\n            if (n) o(n);else if (r && a) {\n              var e = t.browser.getImageData(a),\n                  i = {};\n\n              for (var s in r) {\n                var l = r[s],\n                    c = l.width,\n                    u = l.height,\n                    h = l.x,\n                    p = l.y,\n                    d = l.sdf,\n                    _ = l.pixelRatio,\n                    f = l.stretchX,\n                    m = l.stretchY,\n                    g = l.content,\n                    v = new t.RGBAImage({\n                  width: c,\n                  height: u\n                });\n                t.RGBAImage.copy(e, v, {\n                  x: h,\n                  y: p\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: c,\n                  height: u\n                }), i[s] = {\n                  data: v,\n                  pixelRatio: _,\n                  sdf: d,\n                  stretchX: f,\n                  stretchY: m,\n                  content: g\n                };\n              }\n\n              o(null, i);\n            }\n          }\n\n          return {\n            cancel: function cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(e, this.map._requestManager, function (e, o) {\n          if (i._spriteRequest = null, e) i.fire(new t.ErrorEvent(e));else if (o) for (var r in o) {\n            i.imageManager.addImage(r, o[r]);\n          }\n          i.imageManager.setLoaded(!0), i._availableImages = i.imageManager.listImages(), i.dispatcher.broadcast("setImages", i._availableImages), i.fire(new t.Event("data", {\n            dataType: "style"\n          }));\n        });\n      }, i.prototype._validateLayer = function (e) {\n        var i = this.sourceCaches[e.source];\n\n        if (i) {\n          var o = e.sourceLayer;\n\n          if (o) {\n            var r = i.getSource();\n            ("geojson" === r.type || r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(o)) && this.fire(new t.ErrorEvent(new Error(\'Source layer "\' + o + \'" does not exist on source "\' + r.id + \'" as specified by style layer "\' + e.id + \'"\')));\n          }\n        }\n      }, i.prototype.loaded = function () {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._updatedSources).length) return !1;\n\n        for (var t in this.sourceCaches) {\n          if (!this.sourceCaches[t].loaded()) return !1;\n        }\n\n        return !!this.imageManager.isLoaded();\n      }, i.prototype._serializeLayers = function (t) {\n        for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n          var r = this._layers[o[i]];\n          "custom" !== r.type && e.push(r.serialize());\n        }\n\n        return e;\n      }, i.prototype.hasTransitions = function () {\n        if (this.light && this.light.hasTransition()) return !0;\n\n        for (var t in this.sourceCaches) {\n          if (this.sourceCaches[t].hasTransition()) return !0;\n        }\n\n        for (var e in this._layers) {\n          if (this._layers[e].hasTransition()) return !0;\n        }\n\n        return !1;\n      }, i.prototype._checkLoaded = function () {\n        if (!this._loaded) throw new Error("Style is not done loading");\n      }, i.prototype.update = function (e) {\n        if (this._loaded) {\n          var i = this._changed;\n\n          if (this._changed) {\n            var o = Object.keys(this._updatedLayers),\n                r = Object.keys(this._removedLayers);\n\n            for (var a in (o.length || r.length) && this._updateWorkerLayers(o, r), this._updatedSources) {\n              var n = this._updatedSources[a];\n              "reload" === n ? this._reloadSource(a) : "clear" === n && this._clearSource(a);\n            }\n\n            for (var s in this._updateTilesForChangedImages(), this._updatedPaintProps) {\n              this._layers[s].updateTransitions(e);\n            }\n\n            this.light.updateTransitions(e), this._resetUpdates();\n          }\n\n          var l = {};\n\n          for (var c in this.sourceCaches) {\n            var u = this.sourceCaches[c];\n            l[c] = u.used, u.used = !1;\n          }\n\n          for (var h = 0, p = this._order; h < p.length; h += 1) {\n            var d = this._layers[p[h]];\n            d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0);\n          }\n\n          for (var _ in l) {\n            var f = this.sourceCaches[_];\n            l[_] !== f.used && f.fire(new t.Event("data", {\n              sourceDataType: "visibility",\n              dataType: "source",\n              sourceId: _\n            }));\n          }\n\n          this.light.recalculate(e), this.z = e.zoom, i && this.fire(new t.Event("data", {\n            dataType: "style"\n          }));\n        }\n      }, i.prototype._updateTilesForChangedImages = function () {\n        var t = Object.keys(this._changedImages);\n\n        if (t.length) {\n          for (var e in this.sourceCaches) {\n            this.sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);\n          }\n\n          this._changedImages = {};\n        }\n      }, i.prototype._updateWorkerLayers = function (t, e) {\n        this.dispatcher.broadcast("updateLayers", {\n          layers: this._serializeLayers(t),\n          removedIds: e\n        });\n      }, i.prototype._resetUpdates = function () {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n      }, i.prototype.setState = function (e) {\n        var i = this;\n        if (this._checkLoaded(), Ue(this, t.validateStyle(e))) return !1;\n        (e = t.clone$1(e)).layers = Nt(e.layers);\n\n        var o = function (e, i) {\n          if (!e) return [{\n            command: Zt.setStyle,\n            args: [i]\n          }];\n          var o = [];\n\n          try {\n            if (!t.deepEqual(e.version, i.version)) return [{\n              command: Zt.setStyle,\n              args: [i]\n            }];\n            t.deepEqual(e.center, i.center) || o.push({\n              command: Zt.setCenter,\n              args: [i.center]\n            }), t.deepEqual(e.zoom, i.zoom) || o.push({\n              command: Zt.setZoom,\n              args: [i.zoom]\n            }), t.deepEqual(e.bearing, i.bearing) || o.push({\n              command: Zt.setBearing,\n              args: [i.bearing]\n            }), t.deepEqual(e.pitch, i.pitch) || o.push({\n              command: Zt.setPitch,\n              args: [i.pitch]\n            }), t.deepEqual(e.sprite, i.sprite) || o.push({\n              command: Zt.setSprite,\n              args: [i.sprite]\n            }), t.deepEqual(e.glyphs, i.glyphs) || o.push({\n              command: Zt.setGlyphs,\n              args: [i.glyphs]\n            }), t.deepEqual(e.transition, i.transition) || o.push({\n              command: Zt.setTransition,\n              args: [i.transition]\n            }), t.deepEqual(e.light, i.light) || o.push({\n              command: Zt.setLight,\n              args: [i.light]\n            });\n            var r = {},\n                a = [];\n            !function (e, i, o, r) {\n              var a;\n\n              for (a in i = i || {}, e = e || {}) {\n                e.hasOwnProperty(a) && (i.hasOwnProperty(a) || jt(a, o, r));\n              }\n\n              for (a in i) {\n                i.hasOwnProperty(a) && (e.hasOwnProperty(a) ? t.deepEqual(e[a], i[a]) || ("geojson" === e[a].type && "geojson" === i[a].type && Gt(e, i, a) ? o.push({\n                  command: Zt.setGeoJSONSourceData,\n                  args: [a, i[a].data]\n                }) : Vt(a, i, o, r)) : qt(a, i, o));\n              }\n            }(e.sources, i.sources, a, r);\n            var n = [];\n            e.layers && e.layers.forEach(function (t) {\n              r[t.source] ? o.push({\n                command: Zt.removeLayer,\n                args: [t.id]\n              }) : n.push(t);\n            }), o = o.concat(a), function (e, i, o) {\n              i = i || [];\n\n              var r,\n                  a,\n                  n,\n                  s,\n                  l,\n                  c,\n                  u,\n                  h = (e = e || []).map(Xt),\n                  p = i.map(Xt),\n                  d = e.reduce(Ht, {}),\n                  _ = i.reduce(Ht, {}),\n                  f = h.slice(),\n                  m = Object.create(null);\n\n              for (r = 0, a = 0; r < h.length; r++) {\n                _.hasOwnProperty(n = h[r]) ? a++ : (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.indexOf(n, a), 1));\n              }\n\n              for (r = 0, a = 0; r < p.length; r++) {\n                f[f.length - 1 - r] !== (n = p[p.length - 1 - r]) && (d.hasOwnProperty(n) ? (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.lastIndexOf(n, f.length - a), 1)) : a++, o.push({\n                  command: Zt.addLayer,\n                  args: [_[n], c = f[f.length - r]]\n                }), f.splice(f.length - r, 0, n), m[n] = !0);\n              }\n\n              for (r = 0; r < p.length; r++) {\n                if (s = d[n = p[r]], l = _[n], !m[n] && !t.deepEqual(s, l)) if (t.deepEqual(s.source, l.source) && t.deepEqual(s["source-layer"], l["source-layer"]) && t.deepEqual(s.type, l.type)) {\n                  for (u in Wt(s.layout, l.layout, o, n, null, Zt.setLayoutProperty), Wt(s.paint, l.paint, o, n, null, Zt.setPaintProperty), t.deepEqual(s.filter, l.filter) || o.push({\n                    command: Zt.setFilter,\n                    args: [n, l.filter]\n                  }), t.deepEqual(s.minzoom, l.minzoom) && t.deepEqual(s.maxzoom, l.maxzoom) || o.push({\n                    command: Zt.setLayerZoomRange,\n                    args: [n, l.minzoom, l.maxzoom]\n                  }), s) {\n                    s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                      command: Zt.setLayerProperty,\n                      args: [n, u, l[u]]\n                    }));\n                  }\n\n                  for (u in l) {\n                    l.hasOwnProperty(u) && !s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                      command: Zt.setLayerProperty,\n                      args: [n, u, l[u]]\n                    }));\n                  }\n                } else o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), c = f[f.lastIndexOf(n) + 1], o.push({\n                  command: Zt.addLayer,\n                  args: [l, c]\n                });\n              }\n            }(n, i.layers, o);\n          } catch (t) {\n            console.warn("Unable to compute style diff:", t), o = [{\n              command: Zt.setStyle,\n              args: [i]\n            }];\n          }\n\n          return o;\n        }(this.serialize(), e).filter(function (t) {\n          return !(t.command in Ze);\n        });\n\n        if (0 === o.length) return !1;\n        var r = o.filter(function (t) {\n          return !(t.command in Ne);\n        });\n        if (r.length > 0) throw new Error("Unimplemented: " + r.map(function (t) {\n          return t.command;\n        }).join(", ") + ".");\n        return o.forEach(function (t) {\n          "setTransition" !== t.command && i[t.command].apply(i, t.args);\n        }), this.stylesheet = e, !0;\n      }, i.prototype.addImage = function (e, i) {\n        if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));\n        this.imageManager.addImage(e, i), this._afterImageUpdated(e);\n      }, i.prototype.updateImage = function (t, e) {\n        this.imageManager.updateImage(t, e);\n      }, i.prototype.getImage = function (t) {\n        return this.imageManager.getImage(t);\n      }, i.prototype.removeImage = function (e) {\n        if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));\n        this.imageManager.removeImage(e), this._afterImageUpdated(e);\n      }, i.prototype._afterImageUpdated = function (e) {\n        this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", {\n          dataType: "style"\n        }));\n      }, i.prototype.listImages = function () {\n        return this._checkLoaded(), this.imageManager.listImages();\n      }, i.prototype.addSource = function (e, i, o) {\n        var r = this;\n        if (void 0 === o && (o = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error("There is already a source with this ID");\n        if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i).join(", ") + ".");\n\n        if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e, i, null, o))) {\n          this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n          var a = this.sourceCaches[e] = new Dt(e, i, this.dispatcher);\n          a.style = this, a.setEventedParent(this, function () {\n            return {\n              isSourceLoaded: r.loaded(),\n              source: a.serialize(),\n              sourceId: e\n            };\n          }), a.onAdd(this.map), this._changed = !0;\n        }\n      }, i.prototype.removeSource = function (e) {\n        if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID");\n\n        for (var i in this._layers) {\n          if (this._layers[i].source === e) return this.fire(new t.ErrorEvent(new Error(\'Source "\' + e + \'" cannot be removed while layer "\' + i + \'" is using it.\')));\n        }\n\n        var o = this.sourceCaches[e];\n        delete this.sourceCaches[e], delete this._updatedSources[e], o.fire(new t.Event("data", {\n          sourceDataType: "metadata",\n          dataType: "source",\n          sourceId: e\n        })), o.setEventedParent(null), o.clearTiles(), o.onRemove && o.onRemove(this.map), this._changed = !0;\n      }, i.prototype.setGeoJSONSourceData = function (t, e) {\n        this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0;\n      }, i.prototype.getSource = function (t) {\n        return this.sourceCaches[t] && this.sourceCaches[t].getSource();\n      }, i.prototype.addLayer = function (e, i, o) {\n        void 0 === o && (o = {}), this._checkLoaded();\n        var r = e.id;\n        if (this.getLayer(r)) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + r + \'" already exists on this map\')));else {\n          var a;\n\n          if ("custom" === e.type) {\n            if (Ue(this, t.validateCustomStyleLayer(e))) return;\n            a = t.createStyleLayer(e);\n          } else {\n            if ("object" == typeof e.source && (this.addSource(r, e.source), e = t.clone$1(e), e = t.extend(e, {\n              source: r\n            })), this._validate(t.validateStyle.layer, "layers." + r, e, {\n              arrayIndex: -1\n            }, o)) return;\n            a = t.createStyleLayer(e), this._validateLayer(a), a.setEventedParent(this, {\n              layer: {\n                id: r\n              }\n            }), this._serializedLayers[a.id] = a.serialize();\n          }\n\n          var n = i ? this._order.indexOf(i) : this._order.length;\n          if (i && -1 === n) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\')));else {\n            if (this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = a, this._removedLayers[r] && a.source && "custom" !== a.type) {\n              var s = this._removedLayers[r];\n              delete this._removedLayers[r], s.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());\n            }\n\n            this._updateLayer(a), a.onAdd && a.onAdd(this.map);\n          }\n        }\n      }, i.prototype.moveLayer = function (e, i) {\n        if (this._checkLoaded(), this._changed = !0, this._layers[e]) {\n          if (e !== i) {\n            var o = this._order.indexOf(e);\n\n            this._order.splice(o, 1);\n\n            var r = i ? this._order.indexOf(i) : this._order.length;\n            i && -1 === r ? this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\'))) : (this._order.splice(r, 0, e), this._layerOrderChanged = !0);\n          }\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be moved.")));\n      }, i.prototype.removeLayer = function (e) {\n        this._checkLoaded();\n\n        var i = this._layers[e];\n\n        if (i) {\n          i.setEventedParent(null);\n\n          var o = this._order.indexOf(e);\n\n          this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be removed.")));\n      }, i.prototype.getLayer = function (t) {\n        return this._layers[t];\n      }, i.prototype.hasLayer = function (t) {\n        return t in this._layers;\n      }, i.prototype.setLayerZoomRange = function (e, i, o) {\n        this._checkLoaded();\n\n        var r = this.getLayer(e);\n        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot have zoom extent.")));\n      }, i.prototype.setFilter = function (e, i, o) {\n        void 0 === o && (o = {}), this._checkLoaded();\n        var r = this.getLayer(e);\n\n        if (r) {\n          if (!t.deepEqual(r.filter, i)) return null == i ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(t.validateStyle.filter, "layers." + r.id + ".filter", i, null, o) || (r.filter = t.clone$1(i), this._updateLayer(r)));\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be filtered.")));\n      }, i.prototype.getFilter = function (e) {\n        return t.clone$1(this.getLayer(e).filter);\n      }, i.prototype.setLayoutProperty = function (e, i, o, r) {\n        void 0 === r && (r = {}), this._checkLoaded();\n        var a = this.getLayer(e);\n        a ? t.deepEqual(a.getLayoutProperty(i), o) || (a.setLayoutProperty(i, o, r), this._updateLayer(a)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n      }, i.prototype.getLayoutProperty = function (e, i) {\n        var o = this.getLayer(e);\n        if (o) return o.getLayoutProperty(i);\n        this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style.")));\n      }, i.prototype.setPaintProperty = function (e, i, o, r) {\n        void 0 === r && (r = {}), this._checkLoaded();\n        var a = this.getLayer(e);\n        a ? t.deepEqual(a.getPaintProperty(i), o) || (a.setPaintProperty(i, o, r) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n      }, i.prototype.getPaintProperty = function (t, e) {\n        return this.getLayer(t).getPaintProperty(e);\n      }, i.prototype.setFeatureState = function (e, i) {\n        this._checkLoaded();\n\n        var o = e.source,\n            r = e.sourceLayer,\n            a = this.sourceCaches[o];\n\n        if (void 0 !== a) {\n          var n = a.getSource().type;\n          "geojson" === n && r ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n || r ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a.setFeatureState(r, e.id, i)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n      }, i.prototype.removeFeatureState = function (e, i) {\n        this._checkLoaded();\n\n        var o = e.source,\n            r = this.sourceCaches[o];\n\n        if (void 0 !== r) {\n          var a = r.getSource().type,\n              n = "vector" === a ? e.sourceLayer : void 0;\n          "vector" !== a || n ? i && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r.removeFeatureState(n, e.id, i) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n      }, i.prototype.getFeatureState = function (e) {\n        this._checkLoaded();\n\n        var i = e.source,\n            o = e.sourceLayer,\n            r = this.sourceCaches[i];\n\n        if (void 0 !== r) {\n          if ("vector" !== r.getSource().type || o) return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r.getFeatureState(o, e.id);\n          this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + i + "\' does not exist in the map\'s style.")));\n      }, i.prototype.getTransition = function () {\n        return t.extend({\n          duration: 300,\n          delay: 0\n        }, this.stylesheet && this.stylesheet.transition);\n      }, i.prototype.serialize = function () {\n        return t.filterObject({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          light: this.stylesheet.light,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          sources: t.mapObject(this.sourceCaches, function (t) {\n            return t.serialize();\n          }),\n          layers: this._serializeLayers(this._order)\n        }, function (t) {\n          return void 0 !== t;\n        });\n      }, i.prototype._updateLayer = function (t) {\n        this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && "raster" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0;\n      }, i.prototype._flattenAndSortRenderedFeatures = function (t) {\n        for (var e = this, i = function i(t) {\n          return "fill-extrusion" === e._layers[t].type;\n        }, o = {}, r = [], a = this._order.length - 1; a >= 0; a--) {\n          var n = this._order[a];\n\n          if (i(n)) {\n            o[n] = a;\n\n            for (var s = 0, l = t; s < l.length; s += 1) {\n              var c = l[s][n];\n              if (c) for (var u = 0, h = c; u < h.length; u += 1) {\n                r.push(h[u]);\n              }\n            }\n          }\n        }\n\n        r.sort(function (t, e) {\n          return e.intersectionZ - t.intersectionZ;\n        });\n\n        for (var p = [], d = this._order.length - 1; d >= 0; d--) {\n          var _ = this._order[d];\n          if (i(_)) for (var f = r.length - 1; f >= 0; f--) {\n            var m = r[f].feature;\n            if (o[m.layer.id] < d) break;\n            p.push(m), r.pop();\n          } else for (var g = 0, v = t; g < v.length; g += 1) {\n            var y = v[g][_];\n            if (y) for (var x = 0, b = y; x < b.length; x += 1) {\n              p.push(b[x].feature);\n            }\n          }\n        }\n\n        return p;\n      }, i.prototype.queryRenderedFeatures = function (e, i, o) {\n        i && i.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i.filter, null, i);\n        var r = {};\n\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];\n\n          for (var a = 0, n = i.layers; a < n.length; a += 1) {\n            var s = n[a],\n                l = this._layers[s];\n            if (!l) return this.fire(new t.ErrorEvent(new Error("The layer \'" + s + "\' does not exist in the map\'s style and cannot be queried for features."))), [];\n            r[l.source] = !0;\n          }\n        }\n\n        var c = [];\n\n        for (var u in i.availableImages = this._availableImages, this.sourceCaches) {\n          i.layers && !r[u] || c.push(O(this.sourceCaches[u], this._layers, this._serializedLayers, e, i, o));\n        }\n\n        return this.placement && c.push(function (t, e, i, o, r, a, n) {\n          for (var s = {}, l = a.queryRenderedSymbols(o), c = [], u = 0, h = Object.keys(l).map(Number); u < h.length; u += 1) {\n            c.push(n[h[u]]);\n          }\n\n          c.sort(F);\n\n          for (var p = function p() {\n            var i = _[d],\n                o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, t);\n\n            for (var a in o) {\n              var n = s[a] = s[a] || [],\n                  c = o[a];\n              c.sort(function (t, e) {\n                var o = i.featureSortOrder;\n\n                if (o) {\n                  var r = o.indexOf(t.featureIndex);\n                  return o.indexOf(e.featureIndex) - r;\n                }\n\n                return e.featureIndex - t.featureIndex;\n              });\n\n              for (var u = 0, h = c; u < h.length; u += 1) {\n                n.push(h[u]);\n              }\n            }\n          }, d = 0, _ = c; d < _.length; d += 1) {\n            p();\n          }\n\n          var f = function f(e) {\n            s[e].forEach(function (o) {\n              var r = o.feature,\n                  a = i[t[e].source].getFeatureState(r.layer["source-layer"], r.id);\n              r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = a;\n            });\n          };\n\n          for (var m in s) {\n            f(m);\n          }\n\n          return s;\n        }(this._layers, this._serializedLayers, this.sourceCaches, e, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c);\n      }, i.prototype.querySourceFeatures = function (e, i) {\n        i && i.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i.filter, null, i);\n        var o = this.sourceCaches[e];\n        return o ? function (t, e) {\n          for (var i = t.getRenderableIds().map(function (e) {\n            return t.getTileByID(e);\n          }), o = [], r = {}, a = 0; a < i.length; a++) {\n            var n = i[a],\n                s = n.tileID.canonical.key;\n            r[s] || (r[s] = !0, n.querySourceFeatures(o, e));\n          }\n\n          return o;\n        }(o, i) : [];\n      }, i.prototype.addSourceType = function (t, e, o) {\n        return i.getSourceType(t) ? o(new Error(\'A source type called "\' + t + \'" already exists.\')) : (i.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {\n          name: t,\n          url: e.workerSourceURL\n        }, o) : o(null, null));\n      }, i.prototype.getLight = function () {\n        return this.light.getLight();\n      }, i.prototype.setLight = function (e, i) {\n        void 0 === i && (i = {}), this._checkLoaded();\n        var o = this.light.getLight(),\n            r = !1;\n\n        for (var a in e) {\n          if (!t.deepEqual(e[a], o[a])) {\n            r = !0;\n            break;\n          }\n        }\n\n        if (r) {\n          var n = {\n            now: t.browser.now(),\n            transition: t.extend({\n              duration: 300,\n              delay: 0\n            }, this.stylesheet.transition)\n          };\n          this.light.setLight(e, i), this.light.updateTransitions(n);\n        }\n      }, i.prototype._validate = function (e, i, o, r, a) {\n        return void 0 === a && (a = {}), (!a || !1 !== a.validate) && Ue(this, e.call(t.validateStyle, t.extend({\n          key: i,\n          style: this.serialize(),\n          value: o,\n          styleSpec: t.styleSpec\n        }, r)));\n      }, i.prototype._remove = function () {\n        for (var e in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) {\n          this._layers[e].setEventedParent(null);\n        }\n\n        for (var i in this.sourceCaches) {\n          this.sourceCaches[i].clearTiles(), this.sourceCaches[i].setEventedParent(null);\n        }\n\n        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n      }, i.prototype._clearSource = function (t) {\n        this.sourceCaches[t].clearTiles();\n      }, i.prototype._reloadSource = function (t) {\n        this.sourceCaches[t].resume(), this.sourceCaches[t].reload();\n      }, i.prototype._updateSources = function (t) {\n        for (var e in this.sourceCaches) {\n          this.sourceCaches[e].update(t);\n        }\n      }, i.prototype._generateCollisionBoxes = function () {\n        for (var t in this.sourceCaches) {\n          this._reloadSource(t);\n        }\n      }, i.prototype._updatePlacement = function (e, i, o, r, a) {\n        void 0 === a && (a = !1);\n\n        for (var n = !1, s = !1, l = {}, c = 0, u = this._order; c < u.length; c += 1) {\n          var h = this._layers[u[c]];\n\n          if ("symbol" === h.type) {\n            if (!l[h.source]) {\n              var p = this.sourceCaches[h.source];\n              l[h.source] = p.getRenderableIds(!0).map(function (t) {\n                return p.getTileByID(t);\n              }).sort(function (t, e) {\n                return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1);\n              });\n            }\n\n            var d = this.crossTileSymbolIndex.addLayer(h, l[h.source], e.center.lng);\n            n = n || d;\n          }\n        }\n\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || 0 === o) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e.zoom)) && (this.pauseablePlacement = new Le(e, this._order, a, i, o, r, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s = !0), n && this.pauseablePlacement.placement.setStale()), s || n) for (var _ = 0, f = this._order; _ < f.length; _ += 1) {\n          var m = this._layers[f[_]];\n          "symbol" === m.type && this.placement.updateLayerOpacities(m, l[m.source]);\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());\n      }, i.prototype._releaseSymbolFadeTiles = function () {\n        for (var t in this.sourceCaches) {\n          this.sourceCaches[t].releaseSymbolFadeTiles();\n        }\n      }, i.prototype.getImages = function (t, e, i) {\n        this.imageManager.getImages(e.icons, i), this._updateTilesForChangedImages();\n        var o = this.sourceCaches[e.source];\n        o && o.setDependencies(e.tileID.key, e.type, e.icons);\n      }, i.prototype.getGlyphs = function (t, e, i) {\n        this.glyphManager.getGlyphs(e.stacks, i);\n      }, i.prototype.getResource = function (e, i, o) {\n        return t.makeRequest(i, o);\n      }, i;\n    }(t.Evented);\n\n    je.getSourceType = function (t) {\n      return k[t];\n    }, je.setSourceType = function (t, e) {\n      k[t] = e;\n    }, je.registerForPluginStateChange = t.registerForPluginStateChange;\n\n    var Ve = t.createLayout([{\n      name: "a_pos",\n      type: "Int16",\n      components: 2\n    }]),\n        Ge = gi("#ifdef GL_ES\\nprecision mediump float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif", "#ifdef GL_ES\\nprecision highp float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),\n        We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),\n        He = gi("varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),\n        Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),\n        Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),\n        Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),\n        $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),\n        ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"),\n        ei = gi("#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_FragColor=color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        ii = gi("varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n        oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n        ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),\n        ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),\n        ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\\n? a_pos\\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),\n        si = gi("#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),\n        li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\\n#define PI 3.141592653589793\\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),\n        ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n        ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n        hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),\n        pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),\n        di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),\n        _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),\n        fi = gi("#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),\n        mi = gi("#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");\n\n    function gi(t, e) {\n      var i = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n          o = e.match(/attribute ([\\w]+) ([\\w]+)/g),\n          r = t.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n          a = e.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n          n = a ? a.concat(r) : r,\n          s = {};\n      return {\n        fragmentSource: t = t.replace(i, function (t, e, i, o, r) {\n          return s[r] = !0, "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "\\n#ifdef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        vertexSource: e = e.replace(i, function (t, e, i, o, r) {\n          var a = "float" === o ? "vec2" : "vec4",\n              n = r.match(/color/) ? "color" : a;\n          return s[r] ? "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        staticAttributes: o,\n        staticUniforms: n\n      };\n    }\n\n    var vi = Object.freeze({\n      __proto__: null,\n      prelude: Ge,\n      background: We,\n      backgroundPattern: Xe,\n      circle: He,\n      clippingMask: Ke,\n      heatmap: Ye,\n      heatmapTexture: Je,\n      collisionBox: Qe,\n      collisionCircle: $e,\n      debug: ti,\n      fill: ei,\n      fillOutline: ii,\n      fillOutlinePattern: oi,\n      fillPattern: ri,\n      fillExtrusion: ai,\n      fillExtrusionPattern: ni,\n      hillshadePrepare: si,\n      hillshade: li,\n      line: ci,\n      lineGradient: ui,\n      linePattern: hi,\n      lineSDF: pi,\n      raster: di,\n      symbolIcon: _i,\n      symbolSDF: fi,\n      symbolTextAndIcon: mi\n    }),\n        yi = function yi() {\n      this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;\n    };\n\n    function xi(t) {\n      for (var e = [], i = 0; i < t.length; i++) {\n        if (null !== t[i]) {\n          var o = t[i].split(" ");\n          e.push(o.pop());\n        }\n      }\n\n      return e;\n    }\n\n    yi.prototype.bind = function (t, e, i, o, r, a, n, s) {\n      this.context = t;\n\n      for (var l = this.boundPaintVertexBuffers.length !== o.length, c = 0; !l && c < o.length; c++) {\n        this.boundPaintVertexBuffers[c] !== o[c] && (l = !0);\n      }\n\n      t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === r && this.boundVertexOffset === a && this.boundDynamicVertexBuffer === n && this.boundDynamicVertexBuffer2 === s ? (t.bindVertexArrayOES.set(this.vao), n && n.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(e, i, o, r, a, n, s);\n    }, yi.prototype.freshBind = function (t, e, i, o, r, a, n) {\n      var s,\n          l = t.numAttributes,\n          c = this.context,\n          u = c.gl;\n      if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = n;else {\n        s = c.currentNumAttributes || 0;\n\n        for (var h = l; h < s; h++) {\n          u.disableVertexAttribArray(h);\n        }\n      }\n      e.enableAttributes(u, t);\n\n      for (var p = 0, d = i; p < d.length; p += 1) {\n        d[p].enableAttributes(u, t);\n      }\n\n      a && a.enableAttributes(u, t), n && n.enableAttributes(u, t), e.bind(), e.setVertexAttribPointers(u, t, r);\n\n      for (var _ = 0, f = i; _ < f.length; _ += 1) {\n        var m = f[_];\n        m.bind(), m.setVertexAttribPointers(u, t, r);\n      }\n\n      a && (a.bind(), a.setVertexAttribPointers(u, t, r)), o && o.bind(), n && (n.bind(), n.setVertexAttribPointers(u, t, r)), c.currentNumAttributes = l;\n    }, yi.prototype.destroy = function () {\n      this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n    };\n\n    var bi = function bi(t, e, i, o, r, a) {\n      var n = t.gl;\n      this.program = n.createProgram();\n\n      for (var s = xi(i.staticAttributes), l = o ? o.getBinderAttributes() : [], c = s.concat(l), u = i.staticUniforms ? xi(i.staticUniforms) : [], h = o ? o.getBinderUniforms() : [], p = [], d = 0, _ = u.concat(h); d < _.length; d += 1) {\n        var f = _[d];\n        p.indexOf(f) < 0 && p.push(f);\n      }\n\n      var m = o ? o.defines() : [];\n      a && m.push("#define OVERDRAW_INSPECTOR;");\n      var g = m.concat(Ge.fragmentSource, i.fragmentSource).join("\\n"),\n          v = m.concat(Ge.vertexSource, i.vertexSource).join("\\n"),\n          y = n.createShader(n.FRAGMENT_SHADER);\n      if (n.isContextLost()) this.failedToCreate = !0;else {\n        n.shaderSource(y, g), n.compileShader(y), n.attachShader(this.program, y);\n        var x = n.createShader(n.VERTEX_SHADER);\n        if (n.isContextLost()) this.failedToCreate = !0;else {\n          n.shaderSource(x, v), n.compileShader(x), n.attachShader(this.program, x), this.attributes = {};\n          var b = {};\n          this.numAttributes = c.length;\n\n          for (var w = 0; w < this.numAttributes; w++) {\n            c[w] && (n.bindAttribLocation(this.program, w, c[w]), this.attributes[c[w]] = w);\n          }\n\n          n.linkProgram(this.program), n.deleteShader(x), n.deleteShader(y);\n\n          for (var T = 0; T < p.length; T++) {\n            var E = p[T];\n\n            if (E && !b[E]) {\n              var I = n.getUniformLocation(this.program, E);\n              I && (b[E] = I);\n            }\n          }\n\n          this.fixedUniforms = r(t, b), this.binderUniforms = o ? o.getUniforms(t, b) : [];\n        }\n      }\n    };\n\n    function wi(t, e, i) {\n      var o = 1 / pe(i, 1, e.transform.tileZoom),\n          r = Math.pow(2, i.tileID.overscaledZ),\n          a = i.tileSize * Math.pow(2, e.transform.tileZoom) / r,\n          n = a * (i.tileID.canonical.x + i.tileID.wrap * r),\n          s = a * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture.size,\n        u_scale: [o, t.fromScale, t.toScale],\n        u_fade: t.t,\n        u_pixel_coord_upper: [n >> 16, s >> 16],\n        u_pixel_coord_lower: [65535 & n, 65535 & s]\n      };\n    }\n\n    bi.prototype.draw = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _, f) {\n      var m,\n          g = t.gl;\n\n      if (!this.failedToCreate) {\n        for (var v in t.program.set(this.program), t.setDepthMode(i), t.setStencilMode(o), t.setColorMode(r), t.setCullFace(a), this.fixedUniforms) {\n          this.fixedUniforms[v].set(n[v]);\n        }\n\n        d && d.setUniforms(t, this.binderUniforms, h, {\n          zoom: p\n        });\n\n        for (var y = (m = {}, m[g.LINES] = 2, m[g.TRIANGLES] = 3, m[g.LINE_STRIP] = 1, m)[e], x = 0, b = u.get(); x < b.length; x += 1) {\n          var w = b[x],\n              T = w.vaos || (w.vaos = {});\n          (T[s] || (T[s] = new yi())).bind(t, this, l, d ? d.getPaintVertexBuffers() : [], c, w.vertexOffset, _, f), g.drawElements(e, w.primitiveLength * y, g.UNSIGNED_SHORT, w.primitiveOffset * y * 2);\n        }\n      }\n    };\n\n    var Ti = function Ti(e, i, o, r) {\n      var a = i.style.light,\n          n = a.properties.get("position"),\n          s = [n.x, n.y, n.z],\n          l = t.create$1();\n      "viewport" === a.properties.get("anchor") && t.fromRotation(l, -i.transform.angle), t.transformMat3(s, s, l);\n      var c = a.properties.get("color");\n      return {\n        u_matrix: e,\n        u_lightpos: s,\n        u_lightintensity: a.properties.get("intensity"),\n        u_lightcolor: [c.r, c.g, c.b],\n        u_vertical_gradient: +o,\n        u_opacity: r\n      };\n    },\n        Ei = function Ei(e, i, o, r, a, n, s) {\n      return t.extend(Ti(e, i, o, r), wi(n, i, s), {\n        u_height_factor: -Math.pow(2, a.overscaledZ) / s.tileSize / 8\n      });\n    },\n        Ii = function Ii(t) {\n      return {\n        u_matrix: t\n      };\n    },\n        Pi = function Pi(e, i, o, r) {\n      return t.extend(Ii(e), wi(o, i, r));\n    },\n        Si = function Si(t, e) {\n      return {\n        u_matrix: t,\n        u_world: e\n      };\n    },\n        Ci = function Ci(e, i, o, r, a) {\n      return t.extend(Pi(e, i, o, r), {\n        u_world: a\n      });\n    },\n        zi = function zi(e, i, o, r) {\n      var a,\n          n,\n          s = e.transform;\n\n      if ("map" === r.paint.get("circle-pitch-alignment")) {\n        var l = pe(o, 1, s.zoom);\n        a = !0, n = [l, l];\n      } else a = !1, n = s.pixelsToGLUnits;\n\n      return {\n        u_camera_to_center_distance: s.cameraToCenterDistance,\n        u_scale_with_map: +("map" === r.paint.get("circle-pitch-scale")),\n        u_matrix: e.translatePosMatrix(i.posMatrix, o, r.paint.get("circle-translate"), r.paint.get("circle-translate-anchor")),\n        u_pitch_with_map: +a,\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_extrude_scale: n\n      };\n    },\n        Di = function Di(t, e, i) {\n      var o = pe(i, 1, e.zoom),\n          r = Math.pow(2, e.zoom - i.tileID.overscaledZ),\n          a = i.tileID.overscaleFactor();\n      return {\n        u_matrix: t,\n        u_camera_to_center_distance: e.cameraToCenterDistance,\n        u_pixels_to_tile_units: o,\n        u_extrude_scale: [e.pixelsToGLUnits[0] / (o * r), e.pixelsToGLUnits[1] / (o * r)],\n        u_overscale_factor: a\n      };\n    },\n        Ai = function Ai(t, e, i) {\n      return {\n        u_matrix: t,\n        u_inv_matrix: e,\n        u_camera_to_center_distance: i.cameraToCenterDistance,\n        u_viewport_size: [i.width, i.height]\n      };\n    },\n        Mi = function Mi(t, e, i) {\n      return void 0 === i && (i = 1), {\n        u_matrix: t,\n        u_color: e,\n        u_overlay: 0,\n        u_overlay_scale: i\n      };\n    },\n        Li = function Li(t) {\n      return {\n        u_matrix: t\n      };\n    },\n        Ri = function Ri(t, e, i, o) {\n      return {\n        u_matrix: t,\n        u_extrude_scale: pe(e, 1, i),\n        u_intensity: o\n      };\n    },\n        ki = function ki(e, i, o) {\n      var r = e.transform;\n      return {\n        u_matrix: Ni(e, i, o),\n        u_ratio: 1 / pe(i, 1, r.zoom),\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_units_to_pixels: [1 / r.pixelsToGLUnits[0], 1 / r.pixelsToGLUnits[1]]\n      };\n    },\n        Bi = function Bi(e, i, o, r) {\n      return t.extend(ki(e, i, o), {\n        u_image: 0,\n        u_image_height: r\n      });\n    },\n        Oi = function Oi(e, i, o, r) {\n      var a = e.transform,\n          n = Ui(i, a);\n      return {\n        u_matrix: Ni(e, i, o),\n        u_texsize: i.imageAtlasTexture.size,\n        u_ratio: 1 / pe(i, 1, a.zoom),\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_image: 0,\n        u_scale: [n, r.fromScale, r.toScale],\n        u_fade: r.t,\n        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]]\n      };\n    },\n        Fi = function Fi(e, i, o, r, a) {\n      var n = e.lineAtlas,\n          s = Ui(i, e.transform),\n          l = "round" === o.layout.get("line-cap"),\n          c = n.getDash(r.from, l),\n          u = n.getDash(r.to, l),\n          h = c.width * a.fromScale,\n          p = u.width * a.toScale;\n      return t.extend(ki(e, i, o), {\n        u_patternscale_a: [s / h, -c.height / 2],\n        u_patternscale_b: [s / p, -u.height / 2],\n        u_sdfgamma: n.width / (256 * Math.min(h, p) * t.browser.devicePixelRatio) / 2,\n        u_image: 0,\n        u_tex_y_a: c.y,\n        u_tex_y_b: u.y,\n        u_mix: a.t\n      });\n    };\n\n    function Ui(t, e) {\n      return 1 / pe(t, 1, e.tileZoom);\n    }\n\n    function Ni(t, e, i) {\n      return t.translatePosMatrix(e.tileID.posMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));\n    }\n\n    var Zi = function Zi(t, e, i, o, r) {\n      return {\n        u_matrix: t,\n        u_tl_parent: e,\n        u_scale_parent: i,\n        u_buffer_scale: 1,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * r.paint.get("raster-opacity"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: r.paint.get("raster-brightness-min"),\n        u_brightness_high: r.paint.get("raster-brightness-max"),\n        u_saturation_factor: (n = r.paint.get("raster-saturation"), n > 0 ? 1 - 1 / (1.001 - n) : -n),\n        u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a),\n        u_spin_weights: qi(r.paint.get("raster-hue-rotate"))\n      };\n      var a, n;\n    };\n\n    function qi(t) {\n      t *= Math.PI / 180;\n      var e = Math.sin(t),\n          i = Math.cos(t);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];\n    }\n\n    var ji,\n        Vi = function Vi(t, e, i, o, r, a, n, s, l, c) {\n      var u = r.transform;\n      return {\n        u_is_size_zoom_constant: +("constant" === t || "source" === t),\n        u_is_size_feature_constant: +("constant" === t || "camera" === t),\n        u_size_t: e ? e.uSizeT : 0,\n        u_size: e ? e.uSize : 0,\n        u_camera_to_center_distance: u.cameraToCenterDistance,\n        u_pitch: u.pitch / 360 * 2 * Math.PI,\n        u_rotate_symbol: +i,\n        u_aspect_ratio: u.width / u.height,\n        u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,\n        u_matrix: a,\n        u_label_plane_matrix: n,\n        u_coord_matrix: s,\n        u_is_text: +l,\n        u_pitch_with_map: +o,\n        u_texsize: c,\n        u_texture: 0\n      };\n    },\n        Gi = function Gi(e, i, o, r, a, n, s, l, c, u, h) {\n      var p = a.transform;\n      return t.extend(Vi(e, i, o, r, a, n, s, l, c, u), {\n        u_gamma_scale: r ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1,\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_is_halo: +h\n      });\n    },\n        Wi = function Wi(e, i, o, r, a, n, s, l, c, u) {\n      return t.extend(Gi(e, i, o, r, a, n, s, l, !0, c, !0), {\n        u_texsize_icon: u,\n        u_texture_icon: 1\n      });\n    },\n        Xi = function Xi(t, e, i) {\n      return {\n        u_matrix: t,\n        u_opacity: e,\n        u_color: i\n      };\n    },\n        Hi = function Hi(e, i, o, r, a, n) {\n      return t.extend(function (t, e, i, o) {\n        var r = i.imageManager.getPattern(t.from.toString()),\n            a = i.imageManager.getPattern(t.to.toString()),\n            n = i.imageManager.getPixelSize(),\n            s = n.width,\n            l = n.height,\n            c = Math.pow(2, o.tileID.overscaledZ),\n            u = o.tileSize * Math.pow(2, i.transform.tileZoom) / c,\n            h = u * (o.tileID.canonical.x + o.tileID.wrap * c),\n            p = u * o.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl_a: r.tl,\n          u_pattern_br_a: r.br,\n          u_pattern_tl_b: a.tl,\n          u_pattern_br_b: a.br,\n          u_texsize: [s, l],\n          u_mix: e.t,\n          u_pattern_size_a: r.displaySize,\n          u_pattern_size_b: a.displaySize,\n          u_scale_a: e.fromScale,\n          u_scale_b: e.toScale,\n          u_tile_units_to_pixels: 1 / pe(o, 1, i.transform.tileZoom),\n          u_pixel_coord_upper: [h >> 16, p >> 16],\n          u_pixel_coord_lower: [65535 & h, 65535 & p]\n        };\n      }(r, n, o, a), {\n        u_matrix: e,\n        u_opacity: i\n      });\n    },\n        Ki = {\n      fillExtrusion: function fillExtrusion(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n          u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n          u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n          u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      fillExtrusionPattern: function fillExtrusionPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n          u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n          u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n          u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n          u_height_factor: new t.Uniform1f(e, i.u_height_factor),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      fill: function fill(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      fillPattern: function fillPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      fillOutline: function fillOutline(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world)\n        };\n      },\n      fillOutlinePattern: function fillOutlinePattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      circle: function circle(e, i) {\n        return {\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_scale_with_map: new t.Uniform1i(e, i.u_scale_with_map),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      collisionBox: function collisionBox(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pixels_to_tile_units: new t.Uniform1f(e, i.u_pixels_to_tile_units),\n          u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n          u_overscale_factor: new t.Uniform1f(e, i.u_overscale_factor)\n        };\n      },\n      collisionCircle: function collisionCircle(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_inv_matrix: new t.UniformMatrix4f(e, i.u_inv_matrix),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_viewport_size: new t.Uniform2f(e, i.u_viewport_size)\n        };\n      },\n      debug: function debug(e, i) {\n        return {\n          u_color: new t.UniformColor(e, i.u_color),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_overlay: new t.Uniform1i(e, i.u_overlay),\n          u_overlay_scale: new t.Uniform1f(e, i.u_overlay_scale)\n        };\n      },\n      clippingMask: function clippingMask(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      heatmap: function heatmap(e, i) {\n        return {\n          u_extrude_scale: new t.Uniform1f(e, i.u_extrude_scale),\n          u_intensity: new t.Uniform1f(e, i.u_intensity),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      heatmapTexture: function heatmapTexture(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_color_ramp: new t.Uniform1i(e, i.u_color_ramp),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      hillshade: function hillshade(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_latrange: new t.Uniform2f(e, i.u_latrange),\n          u_light: new t.Uniform2f(e, i.u_light),\n          u_shadow: new t.UniformColor(e, i.u_shadow),\n          u_highlight: new t.UniformColor(e, i.u_highlight),\n          u_accent: new t.UniformColor(e, i.u_accent)\n        };\n      },\n      hillshadePrepare: function hillshadePrepare(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_dimension: new t.Uniform2f(e, i.u_dimension),\n          u_zoom: new t.Uniform1f(e, i.u_zoom),\n          u_unpack: new t.Uniform4f(e, i.u_unpack)\n        };\n      },\n      line: function line(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels)\n        };\n      },\n      lineGradient: function lineGradient(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_image_height: new t.Uniform1f(e, i.u_image_height)\n        };\n      },\n      linePattern: function linePattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      lineSDF: function lineSDF(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_patternscale_a: new t.Uniform2f(e, i.u_patternscale_a),\n          u_patternscale_b: new t.Uniform2f(e, i.u_patternscale_b),\n          u_sdfgamma: new t.Uniform1f(e, i.u_sdfgamma),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_tex_y_a: new t.Uniform1f(e, i.u_tex_y_a),\n          u_tex_y_b: new t.Uniform1f(e, i.u_tex_y_b),\n          u_mix: new t.Uniform1f(e, i.u_mix)\n        };\n      },\n      raster: function raster(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_tl_parent: new t.Uniform2f(e, i.u_tl_parent),\n          u_scale_parent: new t.Uniform1f(e, i.u_scale_parent),\n          u_buffer_scale: new t.Uniform1f(e, i.u_buffer_scale),\n          u_fade_t: new t.Uniform1f(e, i.u_fade_t),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_image0: new t.Uniform1i(e, i.u_image0),\n          u_image1: new t.Uniform1i(e, i.u_image1),\n          u_brightness_low: new t.Uniform1f(e, i.u_brightness_low),\n          u_brightness_high: new t.Uniform1f(e, i.u_brightness_high),\n          u_saturation_factor: new t.Uniform1f(e, i.u_saturation_factor),\n          u_contrast_factor: new t.Uniform1f(e, i.u_contrast_factor),\n          u_spin_weights: new t.Uniform3f(e, i.u_spin_weights)\n        };\n      },\n      symbolIcon: function symbolIcon(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texture: new t.Uniform1i(e, i.u_texture)\n        };\n      },\n      symbolSDF: function symbolSDF(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texture: new t.Uniform1i(e, i.u_texture),\n          u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n        };\n      },\n      symbolTextAndIcon: function symbolTextAndIcon(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texsize_icon: new t.Uniform2f(e, i.u_texsize_icon),\n          u_texture: new t.Uniform1i(e, i.u_texture),\n          u_texture_icon: new t.Uniform1i(e, i.u_texture_icon),\n          u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n        };\n      },\n      background: function background(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_color: new t.UniformColor(e, i.u_color)\n        };\n      },\n      backgroundPattern: function backgroundPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_pattern_tl_a: new t.Uniform2f(e, i.u_pattern_tl_a),\n          u_pattern_br_a: new t.Uniform2f(e, i.u_pattern_br_a),\n          u_pattern_tl_b: new t.Uniform2f(e, i.u_pattern_tl_b),\n          u_pattern_br_b: new t.Uniform2f(e, i.u_pattern_br_b),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_mix: new t.Uniform1f(e, i.u_mix),\n          u_pattern_size_a: new t.Uniform2f(e, i.u_pattern_size_a),\n          u_pattern_size_b: new t.Uniform2f(e, i.u_pattern_size_b),\n          u_scale_a: new t.Uniform1f(e, i.u_scale_a),\n          u_scale_b: new t.Uniform1f(e, i.u_scale_b),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_tile_units_to_pixels: new t.Uniform1f(e, i.u_tile_units_to_pixels)\n        };\n      }\n    };\n\n    function Yi(e, i, o, r, a, n, s) {\n      for (var l = e.context, c = l.gl, u = e.useProgram("collisionBox"), h = [], p = 0, d = 0, _ = 0; _ < r.length; _++) {\n        var f = r[_],\n            m = i.getTile(f),\n            g = m.getBucket(o);\n\n        if (g) {\n          var v = f.posMatrix;\n          0 === a[0] && 0 === a[1] || (v = e.translatePosMatrix(f.posMatrix, m, a, n));\n          var y = s ? g.textCollisionBox : g.iconCollisionBox,\n              x = g.collisionCircleArray;\n\n          if (x.length > 0) {\n            var b = t.create(),\n                w = v;\n            t.mul(b, g.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(b, b, g.placementViewportMatrix), h.push({\n              circleArray: x,\n              circleOffset: d,\n              transform: w,\n              invTransform: b\n            }), d = p += x.length / 4;\n          }\n\n          y && u.draw(l, c.LINES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, Di(v, e.transform, m), o.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, null, e.transform.zoom, null, null, y.collisionVertexBuffer);\n        }\n      }\n\n      if (s && h.length) {\n        var T = e.useProgram("collisionCircle"),\n            E = new t.StructArrayLayout2f1f2i16();\n        E.resize(4 * p), E._trim();\n\n        for (var I = 0, P = 0, S = h; P < S.length; P += 1) {\n          for (var C = S[P], z = 0; z < C.circleArray.length / 4; z++) {\n            var D = 4 * z,\n                A = C.circleArray[D + 0],\n                M = C.circleArray[D + 1],\n                L = C.circleArray[D + 2],\n                R = C.circleArray[D + 3];\n            E.emplace(I++, A, M, L, R, 0), E.emplace(I++, A, M, L, R, 1), E.emplace(I++, A, M, L, R, 2), E.emplace(I++, A, M, L, R, 3);\n          }\n        }\n\n        (!ji || ji.length < 2 * p) && (ji = function (e) {\n          var i = 2 * e,\n              o = new t.StructArrayLayout3ui6();\n          o.resize(i), o._trim();\n\n          for (var r = 0; r < i; r++) {\n            var a = 6 * r;\n            o.uint16[a + 0] = 4 * r + 0, o.uint16[a + 1] = 4 * r + 1, o.uint16[a + 2] = 4 * r + 2, o.uint16[a + 3] = 4 * r + 2, o.uint16[a + 4] = 4 * r + 3, o.uint16[a + 5] = 4 * r + 0;\n          }\n\n          return o;\n        }(p));\n\n        for (var k = l.createIndexBuffer(ji, !0), B = l.createVertexBuffer(E, t.collisionCircleLayout.members, !0), O = 0, F = h; O < F.length; O += 1) {\n          var U = F[O],\n              N = Ai(U.transform, U.invTransform, e.transform);\n          T.draw(l, c.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, N, o.id, B, k, t.SegmentVector.simpleSegment(0, 2 * U.circleOffset, U.circleArray.length, U.circleArray.length / 2), null, e.transform.zoom, null, null, null);\n        }\n\n        B.destroy(), k.destroy();\n      }\n    }\n\n    var Ji = t.identity(new Float32Array(16));\n\n    function Qi(e, i, o, r, a, n) {\n      var s = t.getAnchorAlignment(e),\n          l = -(s.horizontalAlign - .5) * i,\n          c = -(s.verticalAlign - .5) * o,\n          u = t.evaluateVariableOffset(e, r);\n      return new t.Point((l / a + u[0]) * n, (c / a + u[1]) * n);\n    }\n\n    function $i(e, i, o, r, a, n, s, l, c, u, h) {\n      var p = e.text.placedSymbolArray,\n          d = e.text.dynamicLayoutVertexArray,\n          _ = e.icon.dynamicLayoutVertexArray,\n          f = {};\n      d.clear();\n\n      for (var m = 0; m < p.length; m++) {\n        var g = p.get(m),\n            v = g.hidden || !g.crossTileID || e.allowVerticalPlacement && !g.placedOrientation ? null : r[g.crossTileID];\n\n        if (v) {\n          var y = new t.Point(g.anchorX, g.anchorY),\n              x = $t(y, o ? l : s),\n              b = te(n.cameraToCenterDistance, x.signedDistanceFromCamera),\n              w = a.evaluateSizeForFeature(e.textSizeData, u, g) * b / t.ONE_EM;\n          o && (w *= e.tilePixelRatio / c);\n\n          for (var T = Qi(v.anchor, v.width, v.height, v.textOffset, v.textBoxScale, w), E = o ? $t(y.add(T), s).point : x.point.add(i ? T.rotate(-n.angle) : T), I = e.allowVerticalPlacement && g.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P = 0; P < g.numGlyphs; P++) {\n            t.addDynamicAttributes(d, E, I);\n          }\n\n          h && g.associatedIconIndex >= 0 && (f[g.associatedIconIndex] = {\n            shiftedAnchor: E,\n            angle: I\n          });\n        } else ce(g.numGlyphs, d);\n      }\n\n      if (h) {\n        _.clear();\n\n        for (var S = e.icon.placedSymbolArray, C = 0; C < S.length; C++) {\n          var z = S.get(C);\n          if (z.hidden) ce(z.numGlyphs, _);else {\n            var D = f[C];\n            if (D) for (var A = 0; A < z.numGlyphs; A++) {\n              t.addDynamicAttributes(_, D.shiftedAnchor, D.angle);\n            } else ce(z.numGlyphs, _);\n          }\n        }\n\n        e.icon.dynamicLayoutVertexBuffer.updateData(_);\n      }\n\n      e.text.dynamicLayoutVertexBuffer.updateData(d);\n    }\n\n    function to(t, e, i) {\n      return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon";\n    }\n\n    function eo(e, i, o, r, a, n, s, l, c, u, h, p) {\n      for (var d = e.context, _ = d.gl, f = e.transform, m = "map" === l, g = "map" === c, v = m && "point" !== o.layout.get("symbol-placement"), y = m && !g && !v, x = void 0 !== o.layout.get("symbol-sort-key").constantOr(1), b = !1, w = e.depthModeForSublayer(0, It.ReadOnly), T = o.layout.get("text-variable-anchor"), E = [], I = 0, P = r; I < P.length; I += 1) {\n        var S = P[I],\n            C = i.getTile(S),\n            z = C.getBucket(o);\n\n        if (z) {\n          var D = a ? z.text : z.icon;\n\n          if (D && D.segments.get().length) {\n            var A = D.programConfigurations.get(o.id),\n                M = a || z.sdfIcons,\n                L = a ? z.textSizeData : z.iconSizeData,\n                R = g || 0 !== f.pitch,\n                k = e.useProgram(to(M, a, z), A),\n                B = t.evaluateSizeForZoom(L, f.zoom),\n                O = void 0,\n                F = [0, 0],\n                U = void 0,\n                N = void 0,\n                Z = null,\n                q = void 0;\n            if (a) U = C.glyphAtlasTexture, N = _.LINEAR, O = C.glyphAtlasTexture.size, z.iconsInText && (F = C.imageAtlasTexture.size, Z = C.imageAtlasTexture, q = R || e.options.rotating || e.options.zooming || "composite" === L.kind || "camera" === L.kind ? _.LINEAR : _.NEAREST);else {\n              var j = 1 !== o.layout.get("icon-size").constantOr(0) || z.iconsNeedLinear;\n              U = C.imageAtlasTexture, N = M || e.options.rotating || e.options.zooming || j || R ? _.LINEAR : _.NEAREST, O = C.imageAtlasTexture.size;\n            }\n            var V = pe(C, 1, e.transform.zoom),\n                G = Jt(S.posMatrix, g, m, e.transform, V),\n                W = Qt(S.posMatrix, g, m, e.transform, V),\n                X = T && z.hasTextData(),\n                H = "none" !== o.layout.get("icon-text-fit") && X && z.hasIconData();\n            v && ie(z, S.posMatrix, e, a, G, W, g, u);\n            var K = e.translatePosMatrix(S.posMatrix, C, n, s),\n                Y = v || a && T || H ? Ji : G,\n                J = e.translatePosMatrix(W, C, n, s, !0),\n                Q = M && 0 !== o.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1),\n                $ = {\n              program: k,\n              buffers: D,\n              uniformValues: M ? z.iconsInText ? Wi(L.kind, B, y, g, e, K, Y, J, O, F) : Gi(L.kind, B, y, g, e, K, Y, J, a, O, !0) : Vi(L.kind, B, y, g, e, K, Y, J, a, O),\n              atlasTexture: U,\n              atlasTextureIcon: Z,\n              atlasInterpolation: N,\n              atlasInterpolationIcon: q,\n              isSDF: M,\n              hasHalo: Q\n            };\n\n            if (x && z.canOverlap) {\n              b = !0;\n\n              for (var tt = 0, et = D.segments.get(); tt < et.length; tt += 1) {\n                var it = et[tt];\n                E.push({\n                  segments: new t.SegmentVector([it]),\n                  sortKey: it.sortKey,\n                  state: $\n                });\n              }\n            } else E.push({\n              segments: D.segments,\n              sortKey: 0,\n              state: $\n            });\n          }\n        }\n      }\n\n      b && E.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var ot = 0, rt = E; ot < rt.length; ot += 1) {\n        var at = rt[ot],\n            nt = at.state;\n\n        if (d.activeTexture.set(_.TEXTURE0), nt.atlasTexture.bind(nt.atlasInterpolation, _.CLAMP_TO_EDGE), nt.atlasTextureIcon && (d.activeTexture.set(_.TEXTURE1), nt.atlasTextureIcon && nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon, _.CLAMP_TO_EDGE)), nt.isSDF) {\n          var st = nt.uniformValues;\n          nt.hasHalo && (st.u_is_halo = 1, io(nt.buffers, at.segments, o, e, nt.program, w, h, p, st)), st.u_is_halo = 0;\n        }\n\n        io(nt.buffers, at.segments, o, e, nt.program, w, h, p, nt.uniformValues);\n      }\n    }\n\n    function io(t, e, i, o, r, a, n, s, l) {\n      var c = o.context;\n      r.draw(c, c.gl.TRIANGLES, a, n, s, Ct.disabled, l, i.id, t.layoutVertexBuffer, t.indexBuffer, e, i.paint, o.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);\n    }\n\n    function oo(t, e, i, o, r, a, n) {\n      var s,\n          l,\n          c,\n          u,\n          h,\n          p = t.context.gl,\n          d = i.paint.get("fill-pattern"),\n          _ = d && d.constantOr(1),\n          f = i.getCrossfadeParameters();\n\n      n ? (l = _ && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s = p.LINES) : (l = _ ? "fillPattern" : "fill", s = p.TRIANGLES);\n\n      for (var m = 0, g = o; m < g.length; m += 1) {\n        var v = g[m],\n            y = e.getTile(v);\n\n        if (!_ || y.patternsLoaded()) {\n          var x = y.getBucket(i);\n\n          if (x) {\n            var b = x.programConfigurations.get(i.id),\n                w = t.useProgram(l, b);\n            _ && (t.context.activeTexture.set(p.TEXTURE0), y.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), b.updatePaintBuffers(f));\n            var T = d.constantOr(null);\n\n            if (T && y.imageAtlas) {\n              var E = y.imageAtlas,\n                  I = E.patternPositions[T.to.toString()],\n                  P = E.patternPositions[T.from.toString()];\n              I && P && b.setConstantPatternPositions(I, P);\n            }\n\n            var S = t.translatePosMatrix(v.posMatrix, y, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"));\n\n            if (n) {\n              u = x.indexBuffer2, h = x.segments2;\n              var C = [p.drawingBufferWidth, p.drawingBufferHeight];\n              c = "fillOutlinePattern" === l && _ ? Ci(S, t, f, y, C) : Si(S, C);\n            } else u = x.indexBuffer, h = x.segments, c = _ ? Pi(S, t, f, y) : Ii(S);\n\n            w.draw(t.context, s, r, t.stencilModeForClipping(v), a, Ct.disabled, c, i.id, x.layoutVertexBuffer, u, h, i.paint, t.transform.zoom, b);\n          }\n        }\n      }\n    }\n\n    function ro(t, e, i, o, r, a, n) {\n      for (var s = t.context, l = s.gl, c = i.paint.get("fill-extrusion-pattern"), u = c.constantOr(1), h = i.getCrossfadeParameters(), p = i.paint.get("fill-extrusion-opacity"), d = 0, _ = o; d < _.length; d += 1) {\n        var f = _[d],\n            m = e.getTile(f),\n            g = m.getBucket(i);\n\n        if (g) {\n          var v = g.programConfigurations.get(i.id),\n              y = t.useProgram(u ? "fillExtrusionPattern" : "fillExtrusion", v);\n          u && (t.context.activeTexture.set(l.TEXTURE0), m.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers(h));\n          var x = c.constantOr(null);\n\n          if (x && m.imageAtlas) {\n            var b = m.imageAtlas,\n                w = b.patternPositions[x.to.toString()],\n                T = b.patternPositions[x.from.toString()];\n            w && T && v.setConstantPatternPositions(w, T);\n          }\n\n          var E = t.translatePosMatrix(f.posMatrix, m, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),\n              I = i.paint.get("fill-extrusion-vertical-gradient"),\n              P = u ? Ei(E, t, I, p, f, h, m) : Ti(E, t, I, p);\n          y.draw(s, s.gl.TRIANGLES, r, a, n, Ct.backCCW, P, i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, i.paint, t.transform.zoom, v);\n        }\n      }\n    }\n\n    function ao(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl,\n          c = i.fbo;\n\n      if (c) {\n        var u = e.useProgram("hillshade");\n        s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());\n\n        var h = function (e, i, o) {\n          var r = o.paint.get("hillshade-shadow-color"),\n              a = o.paint.get("hillshade-highlight-color"),\n              n = o.paint.get("hillshade-accent-color"),\n              s = o.paint.get("hillshade-illumination-direction") * (Math.PI / 180);\n          "viewport" === o.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);\n          var l,\n              c,\n              u,\n              h = !e.options.moving;\n          return {\n            u_matrix: e.transform.calculatePosMatrix(i.tileID.toUnwrapped(), h),\n            u_image: 0,\n            u_latrange: (l = i.tileID, c = Math.pow(2, l.canonical.z), u = l.canonical.y, [new t.MercatorCoordinate(0, u / c).toLngLat().lat, new t.MercatorCoordinate(0, (u + 1) / c).toLngLat().lat]),\n            u_light: [o.paint.get("hillshade-exaggeration"), s],\n            u_shadow: r,\n            u_highlight: a,\n            u_accent: n\n          };\n        }(e, i, o);\n\n        u.draw(s, l.TRIANGLES, r, a, n, Ct.disabled, h, o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments);\n      }\n    }\n\n    function no(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl,\n          c = i.dem;\n\n      if (c && c.data) {\n        var u = c.dim,\n            h = c.stride,\n            p = c.getPixels();\n\n        if (s.activeTexture.set(l.TEXTURE1), s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(h), i.demTexture) {\n          var d = i.demTexture;\n          d.update(p, {\n            premultiply: !1\n          }), d.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n        } else i.demTexture = new t.Texture(s, p, l.RGBA, {\n          premultiply: !1\n        }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n\n        s.activeTexture.set(l.TEXTURE0);\n        var _ = i.fbo;\n\n        if (!_) {\n          var f = new t.Texture(s, {\n            width: u,\n            height: u,\n            data: null\n          }, l.RGBA);\n          f.bind(l.LINEAR, l.CLAMP_TO_EDGE), (_ = i.fbo = s.createFramebuffer(u, u, !0)).colorAttachment.set(f.texture);\n        }\n\n        s.bindFramebuffer.set(_.framebuffer), s.viewport.set([0, 0, u, u]), e.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, r, a, n, Ct.disabled, function (e, i) {\n          var o = i.stride,\n              r = t.create();\n          return t.ortho(r, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r, r, [0, -t.EXTENT, 0]), {\n            u_matrix: r,\n            u_image: 1,\n            u_dimension: [o, o],\n            u_zoom: e.overscaledZ,\n            u_unpack: i.getUnpackVector()\n          };\n        }(i.tileID, c), o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1;\n      }\n    }\n\n    function so(e, i, o, r, a) {\n      var n = r.paint.get("raster-fade-duration");\n\n      if (n > 0) {\n        var s = t.browser.now(),\n            l = (s - e.timeAdded) / n,\n            c = i ? (s - i.timeAdded) / n : -1,\n            u = o.getSource(),\n            h = a.coveringZoomLevel({\n          tileSize: u.tileSize,\n          roundZoom: u.roundZoom\n        }),\n            p = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h),\n            d = p && e.refreshedUponExpiration ? 1 : t.clamp(p ? l : 1 - c, 0, 1);\n        return e.refreshedUponExpiration && l >= 1 && (e.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - d\n        } : {\n          opacity: d,\n          mix: 0\n        };\n      }\n\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n\n    var lo = new t.Color(1, 0, 0, 1),\n        co = new t.Color(0, 1, 0, 1),\n        uo = new t.Color(0, 0, 1, 1),\n        ho = new t.Color(1, 0, 1, 1),\n        po = new t.Color(0, 1, 1, 1);\n\n    function _o(t, e, i, o) {\n      mo(t, 0, e + i / 2, t.transform.width, i, o);\n    }\n\n    function fo(t, e, i, o) {\n      mo(t, e - i / 2, 0, i, t.transform.height, o);\n    }\n\n    function mo(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * t.browser.devicePixelRatio, o * t.browser.devicePixelRatio, r * t.browser.devicePixelRatio, a * t.browser.devicePixelRatio), s.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n\n    function go(e, i, o) {\n      var r = e.context,\n          a = r.gl,\n          n = o.posMatrix,\n          s = e.useProgram("debug"),\n          l = It.disabled,\n          c = Pt.disabled,\n          u = e.colorModeForRenderPass();\n      r.activeTexture.set(a.TEXTURE0), e.emptyTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), s.draw(r, a.LINE_STRIP, l, c, u, Ct.disabled, Mi(n, t.Color.red), "$debug", e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments);\n\n      var h = i.getTileByID(o.key).latestRawTileData,\n          p = Math.floor((h && h.byteLength || 0) / 1024),\n          d = i.getTile(o).tileSize,\n          _ = 512 / Math.min(d, 512) * (o.overscaledZ / e.transform.zoom) * .5,\n          f = o.canonical.toString();\n\n      o.overscaledZ !== o.canonical.z && (f += " => " + o.overscaledZ), function (t, e) {\n        t.initDebugOverlayCanvas();\n        var i = t.debugOverlayCanvas,\n            o = t.context.gl,\n            r = t.debugOverlayCanvas.getContext("2d");\n        r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(e, 5, 5), r.strokeText(e, 5, 5), t.debugOverlayTexture.update(i), t.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(e, f + " " + p + "kb"), s.draw(r, a.TRIANGLES, l, c, St.alphaBlended, Ct.disabled, Mi(n, t.Color.transparent, _), "$debug", e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments);\n    }\n\n    var vo = {\n      symbol: function symbol(e, i, o, r, a) {\n        if ("translucent" === e.renderPass) {\n          var n = Pt.disabled,\n              s = e.colorModeForRenderPass();\n          o.layout.get("text-variable-anchor") && function (e, i, o, r, a, n, s) {\n            for (var l = i.transform, c = "map" === a, u = "map" === n, h = 0, p = e; h < p.length; h += 1) {\n              var d = p[h],\n                  _ = r.getTile(d),\n                  f = _.getBucket(o);\n\n              if (f && f.text && f.text.segments.get().length) {\n                var m = t.evaluateSizeForZoom(f.textSizeData, l.zoom),\n                    g = pe(_, 1, i.transform.zoom),\n                    v = Jt(d.posMatrix, u, c, i.transform, g),\n                    y = "none" !== o.layout.get("icon-text-fit") && f.hasIconData();\n\n                if (m) {\n                  var x = Math.pow(2, l.zoom - _.tileID.overscaledZ);\n                  $i(f, c, u, s, t.symbolSize, l, v, d.posMatrix, x, m, y);\n                }\n              }\n            }\n          }(r, e, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), a), 0 !== o.paint.get("icon-opacity").constantOr(1) && eo(e, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), n, s), 0 !== o.paint.get("text-opacity").constantOr(1) && eo(e, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), n, s), i.map.showCollisionBoxes && (Yi(e, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Yi(e, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));\n        }\n      },\n      circle: function circle(e, i, o, r) {\n        if ("translucent" === e.renderPass) {\n          var a = o.paint.get("circle-opacity"),\n              n = o.paint.get("circle-stroke-width"),\n              s = o.paint.get("circle-stroke-opacity"),\n              l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);\n\n          if (0 !== a.constantOr(1) || 0 !== n.constantOr(1) && 0 !== s.constantOr(1)) {\n            for (var c = e.context, u = c.gl, h = e.depthModeForSublayer(0, It.ReadOnly), p = Pt.disabled, d = e.colorModeForRenderPass(), _ = [], f = 0; f < r.length; f++) {\n              var m = r[f],\n                  g = i.getTile(m),\n                  v = g.getBucket(o);\n\n              if (v) {\n                var y = v.programConfigurations.get(o.id),\n                    x = {\n                  programConfiguration: y,\n                  program: e.useProgram("circle", y),\n                  layoutVertexBuffer: v.layoutVertexBuffer,\n                  indexBuffer: v.indexBuffer,\n                  uniformValues: zi(e, m, g, o)\n                };\n                if (l) for (var b = 0, w = v.segments.get(); b < w.length; b += 1) {\n                  var T = w[b];\n\n                  _.push({\n                    segments: new t.SegmentVector([T]),\n                    sortKey: T.sortKey,\n                    state: x\n                  });\n                } else _.push({\n                  segments: v.segments,\n                  sortKey: 0,\n                  state: x\n                });\n              }\n            }\n\n            l && _.sort(function (t, e) {\n              return t.sortKey - e.sortKey;\n            });\n\n            for (var E = 0, I = _; E < I.length; E += 1) {\n              var P = I[E],\n                  S = P.state;\n              S.program.draw(c, u.TRIANGLES, h, p, d, Ct.disabled, S.uniformValues, o.id, S.layoutVertexBuffer, S.indexBuffer, P.segments, o.paint, e.transform.zoom, S.programConfiguration);\n            }\n          }\n        }\n      },\n      heatmap: function heatmap(e, i, o, r) {\n        if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === e.renderPass) {\n          var a = e.context,\n              n = a.gl,\n              s = Pt.disabled,\n              l = new St([n.ONE, n.ONE], t.Color.transparent, [!0, !0, !0, !0]);\n          !function (t, e, i) {\n            var o = t.gl;\n            t.activeTexture.set(o.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]);\n            var r = i.heatmapFbo;\n            if (r) o.bindTexture(o.TEXTURE_2D, r.colorAttachment.get()), t.bindFramebuffer.set(r.framebuffer);else {\n              var a = o.createTexture();\n              o.bindTexture(o.TEXTURE_2D, a), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), r = i.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, i, o) {\n                var r = t.gl;\n                r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e.width / 4, e.height / 4, 0, r.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n              }(t, e, a, r);\n            }\n          }(a, e, o), a.clear({\n            color: t.Color.transparent\n          });\n\n          for (var c = 0; c < r.length; c++) {\n            var u = r[c];\n\n            if (!i.hasRenderableParent(u)) {\n              var h = i.getTile(u),\n                  p = h.getBucket(o);\n\n              if (p) {\n                var d = p.programConfigurations.get(o.id);\n                e.useProgram("heatmap", d).draw(a, n.TRIANGLES, It.disabled, s, l, Ct.disabled, Ri(u.posMatrix, h, e.transform.zoom, o.paint.get("heatmap-intensity")), o.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, o.paint, e.transform.zoom, d);\n              }\n            }\n          }\n\n          a.viewport.set([0, 0, e.width, e.height]);\n        } else "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, i) {\n          var o = e.context,\n              r = o.gl,\n              a = i.heatmapFbo;\n\n          if (a) {\n            o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n            var n = i.colorRampTexture;\n            n || (n = i.colorRampTexture = new t.Texture(o, i.colorRamp, r.RGBA)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(o, r.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, function (e, i, o, r) {\n              var a = t.create();\n              t.ortho(a, 0, e.width, e.height, 0, 0, 1);\n              var n = e.context.gl;\n              return {\n                u_matrix: a,\n                u_world: [n.drawingBufferWidth, n.drawingBufferHeight],\n                u_image: 0,\n                u_color_ramp: 1,\n                u_opacity: i.paint.get("heatmap-opacity")\n              };\n            }(e, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom);\n          }\n        }(e, o));\n      },\n      line: function line(e, i, o, r) {\n        if ("translucent" === e.renderPass) {\n          var a = o.paint.get("line-opacity"),\n              n = o.paint.get("line-width");\n          if (0 !== a.constantOr(1) && 0 !== n.constantOr(1)) for (var s = e.depthModeForSublayer(0, It.ReadOnly), l = e.colorModeForRenderPass(), c = o.paint.get("line-dasharray"), u = o.paint.get("line-pattern"), h = u.constantOr(1), p = o.paint.get("line-gradient"), d = o.getCrossfadeParameters(), _ = h ? "linePattern" : c ? "lineSDF" : p ? "lineGradient" : "line", f = e.context, m = f.gl, g = !0, v = 0, y = r; v < y.length; v += 1) {\n            var x = y[v],\n                b = i.getTile(x);\n\n            if (!h || b.patternsLoaded()) {\n              var w = b.getBucket(o);\n\n              if (w) {\n                var T = w.programConfigurations.get(o.id),\n                    E = e.context.program.get(),\n                    I = e.useProgram(_, T),\n                    P = g || I.program !== E,\n                    S = u.constantOr(null);\n\n                if (S && b.imageAtlas) {\n                  var C = b.imageAtlas,\n                      z = C.patternPositions[S.to.toString()],\n                      D = C.patternPositions[S.from.toString()];\n                  z && D && T.setConstantPatternPositions(z, D);\n                }\n\n                var A = h ? Oi(e, b, o, d) : c ? Fi(e, b, o, c, d) : p ? Bi(e, b, o, w.lineClipsArray.length) : ki(e, b, o);\n                if (h) f.activeTexture.set(m.TEXTURE0), b.imageAtlasTexture.bind(m.LINEAR, m.CLAMP_TO_EDGE), T.updatePaintBuffers(d);else if (c && (P || e.lineAtlas.dirty)) f.activeTexture.set(m.TEXTURE0), e.lineAtlas.bind(f);else if (p) {\n                  var M = w.gradients[o.id],\n                      L = M.texture;\n\n                  if (o.gradientVersion !== M.version) {\n                    var R = 256;\n\n                    if (o.stepInterpolant) {\n                      var k = i.getSource().maxzoom,\n                          B = x.canonical.z === k ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1;\n                      R = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * B), 256, f.maxTextureSize);\n                    }\n\n                    M.gradient = t.renderColorRamp({\n                      expression: o.gradientExpression(),\n                      evaluationKey: "lineProgress",\n                      resolution: R,\n                      image: M.gradient || void 0,\n                      clips: w.lineClipsArray\n                    }), M.texture ? M.texture.update(M.gradient) : M.texture = new t.Texture(f, M.gradient, m.RGBA), M.version = o.gradientVersion, L = M.texture;\n                  }\n\n                  f.activeTexture.set(m.TEXTURE0), L.bind(o.stepInterpolant ? m.NEAREST : m.LINEAR, m.CLAMP_TO_EDGE);\n                }\n                I.draw(f, m.TRIANGLES, s, e.stencilModeForClipping(x), l, Ct.disabled, A, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, e.transform.zoom, T, w.layoutVertexBuffer2), g = !1;\n              }\n            }\n          }\n        }\n      },\n      fill: function fill(e, i, o, r) {\n        var a = o.paint.get("fill-color"),\n            n = o.paint.get("fill-opacity");\n\n        if (0 !== n.constantOr(1)) {\n          var s = e.colorModeForRenderPass(),\n              l = o.paint.get("fill-pattern"),\n              c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === a.constantOr(t.Color.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";\n\n          if (e.renderPass === c) {\n            var u = e.depthModeForSublayer(1, "opaque" === e.renderPass ? It.ReadWrite : It.ReadOnly);\n            oo(e, i, o, r, u, s, !1);\n          }\n\n          if ("translucent" === e.renderPass && o.paint.get("fill-antialias")) {\n            var h = e.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);\n            oo(e, i, o, r, h, s, !0);\n          }\n        }\n      },\n      "fill-extrusion": function fillExtrusion(t, e, i, o) {\n        var r = i.paint.get("fill-extrusion-opacity");\n\n        if (0 !== r && "translucent" === t.renderPass) {\n          var a = new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D);\n          if (1 !== r || i.paint.get("fill-extrusion-pattern").constantOr(1)) ro(t, e, i, o, a, Pt.disabled, St.disabled), ro(t, e, i, o, a, t.stencilModeFor3D(), t.colorModeForRenderPass());else {\n            var n = t.colorModeForRenderPass();\n            ro(t, e, i, o, a, Pt.disabled, n);\n          }\n        }\n      },\n      hillshade: function hillshade(t, e, i, o) {\n        if ("offscreen" === t.renderPass || "translucent" === t.renderPass) {\n          for (var r = t.context, a = t.depthModeForSublayer(0, It.ReadOnly), n = t.colorModeForRenderPass(), s = "translucent" === t.renderPass ? t.stencilConfigForOverlap(o) : [{}, o], l = s[0], c = 0, u = s[1]; c < u.length; c += 1) {\n            var h = u[c],\n                p = e.getTile(h);\n            p.needsHillshadePrepare && "offscreen" === t.renderPass ? no(t, p, i, a, Pt.disabled, n) : "translucent" === t.renderPass && ao(t, p, i, a, l[h.overscaledZ], n);\n          }\n\n          r.viewport.set([0, 0, t.width, t.height]);\n        }\n      },\n      raster: function raster(t, e, i, o) {\n        if ("translucent" === t.renderPass && 0 !== i.paint.get("raster-opacity") && o.length) for (var r = t.context, a = r.gl, n = e.getSource(), s = t.useProgram("raster"), l = t.colorModeForRenderPass(), c = n instanceof M ? [{}, o] : t.stencilConfigForOverlap(o), u = c[0], h = c[1], p = h[h.length - 1].overscaledZ, d = !t.options.moving, _ = 0, f = h; _ < f.length; _ += 1) {\n          var m = f[_],\n              g = t.depthModeForSublayer(m.overscaledZ - p, 1 === i.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a.LESS),\n              v = e.getTile(m),\n              y = t.transform.calculatePosMatrix(m.toUnwrapped(), d);\n          v.registerFadeDuration(i.paint.get("raster-fade-duration"));\n          var x = e.findLoadedParent(m, 0),\n              b = so(v, x, e, i, t.transform),\n              w = void 0,\n              T = void 0,\n              E = "nearest" === i.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR;\n          r.activeTexture.set(a.TEXTURE0), v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), r.activeTexture.set(a.TEXTURE1), x ? (x.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - v.tileID.overscaledZ), T = [v.tileID.canonical.x * w % 1, v.tileID.canonical.y * w % 1]) : v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);\n          var I = Zi(y, T || [0, 0], w || 1, b, i);\n          n instanceof M ? s.draw(r, a.TRIANGLES, g, Pt.disabled, l, Ct.disabled, I, i.id, n.boundsBuffer, t.quadTriangleIndexBuffer, n.boundsSegments) : s.draw(r, a.TRIANGLES, g, u[m.overscaledZ], l, Ct.disabled, I, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments);\n        }\n      },\n      background: function background(t, e, i) {\n        var o = i.paint.get("background-color"),\n            r = i.paint.get("background-opacity");\n\n        if (0 !== r) {\n          var a = t.context,\n              n = a.gl,\n              s = t.transform,\n              l = s.tileSize,\n              c = i.paint.get("background-pattern");\n\n          if (!t.isPatternMissing(c)) {\n            var u = !c && 1 === o.a && 1 === r && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";\n\n            if (t.renderPass === u) {\n              var h = Pt.disabled,\n                  p = t.depthModeForSublayer(0, "opaque" === u ? It.ReadWrite : It.ReadOnly),\n                  d = t.colorModeForRenderPass(),\n                  _ = t.useProgram(c ? "backgroundPattern" : "background"),\n                  f = s.coveringTiles({\n                tileSize: l\n              });\n\n              c && (a.activeTexture.set(n.TEXTURE0), t.imageManager.bind(t.context));\n\n              for (var m = i.getCrossfadeParameters(), g = 0, v = f; g < v.length; g += 1) {\n                var y = v[g],\n                    x = t.transform.calculatePosMatrix(y.toUnwrapped()),\n                    b = c ? Hi(x, r, t, c, {\n                  tileID: y,\n                  tileSize: l\n                }, m) : Xi(x, r, o);\n\n                _.draw(a, n.TRIANGLES, p, h, d, Ct.disabled, b, i.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments);\n              }\n            }\n          }\n        }\n      },\n      debug: function debug(t, e, i) {\n        for (var o = 0; o < i.length; o++) {\n          go(t, e, i[o]);\n        }\n      },\n      custom: function custom(t, e, i) {\n        var o = t.context,\n            r = i.implementation;\n\n        if ("offscreen" === t.renderPass) {\n          var a = r.prerender;\n          a && (t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), a.call(r, o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState());\n        } else if ("translucent" === t.renderPass) {\n          t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), o.setStencilMode(Pt.disabled);\n          var n = "3d" === r.renderingMode ? new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, It.ReadOnly);\n          o.setDepthMode(n), r.render(o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState(), o.bindFramebuffer.set(null);\n        }\n      }\n    },\n        yo = function yo(t, e) {\n      this.context = new zt(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};\n    };\n\n    yo.prototype.resize = function (e, i) {\n      if (this.width = e * t.browser.devicePixelRatio, this.height = i * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var o = 0, r = this.style._order; o < r.length; o += 1) {\n        this.style._layers[r[o]].resize();\n      }\n    }, yo.prototype.setup = function () {\n      var e = this.context,\n          i = new t.StructArrayLayout2i4();\n      i.emplaceBack(0, 0), i.emplaceBack(t.EXTENT, 0), i.emplaceBack(0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(i, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var o = new t.StructArrayLayout2i4();\n      o.emplaceBack(0, 0), o.emplaceBack(t.EXTENT, 0), o.emplaceBack(0, t.EXTENT), o.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(o, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);\n      var r = new t.StructArrayLayout4i8();\n      r.emplaceBack(0, 0, 0, 0), r.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(r, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var a = new t.StructArrayLayout2i4();\n      a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var n = new t.StructArrayLayout1ui2();\n      n.emplaceBack(0), n.emplaceBack(1), n.emplaceBack(3), n.emplaceBack(2), n.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(n);\n      var s = new t.StructArrayLayout3ui6();\n      s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s), this.emptyTexture = new t.Texture(e, {\n        width: 1,\n        height: 1,\n        data: new Uint8Array([0, 0, 0, 0])\n      }, e.gl.RGBA);\n      var l = this.context.gl;\n      this.stencilClearMode = new Pt({\n        func: l.ALWAYS,\n        mask: 0\n      }, 0, 255, l.ZERO, l.ZERO, l.ZERO);\n    }, yo.prototype.clearStencil = function () {\n      var e = this.context,\n          i = e.gl;\n      this.nextStencilID = 1, this.currentStencilSource = void 0;\n      var o = t.create();\n      t.ortho(o, 0, this.width, this.height, 0, 0, 1), t.scale(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, i.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n    }, yo.prototype._renderTileClippingMasks = function (t, e) {\n      if (this.currentStencilSource !== t.source && t.isTileClipped() && e && e.length) {\n        this.currentStencilSource = t.source;\n        var i = this.context,\n            o = i.gl;\n        this.nextStencilID + e.length > 256 && this.clearStencil(), i.setColorMode(St.disabled), i.setDepthMode(It.disabled);\n        var r = this.useProgram("clippingMask");\n        this._tileClippingMaskIDs = {};\n\n        for (var a = 0, n = e; a < n.length; a += 1) {\n          var s = n[a],\n              l = this._tileClippingMaskIDs[s.key] = this.nextStencilID++;\n          r.draw(i, o.TRIANGLES, It.disabled, new Pt({\n            func: o.ALWAYS,\n            mask: 0\n          }, l, 255, o.KEEP, o.KEEP, o.REPLACE), St.disabled, Ct.disabled, Li(s.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n      }\n    }, yo.prototype.stencilModeFor3D = function () {\n      this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n      var t = this.nextStencilID++,\n          e = this.context.gl;\n      return new Pt({\n        func: e.NOTEQUAL,\n        mask: 255\n      }, t, 255, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilModeForClipping = function (t) {\n      var e = this.context.gl;\n      return new Pt({\n        func: e.EQUAL,\n        mask: 255\n      }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilConfigForOverlap = function (t) {\n      var e,\n          i = this.context.gl,\n          o = t.sort(function (t, e) {\n        return e.overscaledZ - t.overscaledZ;\n      }),\n          r = o[o.length - 1].overscaledZ,\n          a = o[0].overscaledZ - r + 1;\n\n      if (a > 1) {\n        this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();\n\n        for (var n = {}, s = 0; s < a; s++) {\n          n[s + r] = new Pt({\n            func: i.GEQUAL,\n            mask: 255\n          }, s + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);\n        }\n\n        return this.nextStencilID += a, [n, o];\n      }\n\n      return [(e = {}, e[r] = Pt.disabled, e), o];\n    }, yo.prototype.colorModeForRenderPass = function () {\n      var e = this.context.gl;\n      return this._showOverdrawInspector ? new St([e.CONSTANT_COLOR, e.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;\n    }, yo.prototype.depthModeForSublayer = function (t, e, i) {\n      if (!this.opaquePassEnabledForLayer()) return It.disabled;\n      var o = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n      return new It(i || this.context.gl.LEQUAL, e, [o, o]);\n    }, yo.prototype.opaquePassEnabledForLayer = function () {\n      return this.currentLayer < this.opaquePassCutoff;\n    }, yo.prototype.render = function (e, i) {\n      var o = this;\n      this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();\n      var r = this.style._order,\n          a = this.style.sourceCaches;\n\n      for (var n in a) {\n        var s = a[n];\n        s.used && s.prepare(this.context);\n      }\n\n      var l,\n          c,\n          u = {},\n          h = {},\n          p = {};\n\n      for (var d in a) {\n        var _ = a[d];\n        u[d] = _.getVisibleCoordinates(), h[d] = u[d].slice().reverse(), p[d] = _.getVisibleCoordinates(!0).reverse();\n      }\n\n      this.opaquePassCutoff = 1 / 0;\n\n      for (var f = 0; f < r.length; f++) {\n        if (this.style._layers[r[f]].is3D()) {\n          this.opaquePassCutoff = f;\n          break;\n        }\n      }\n\n      this.renderPass = "offscreen";\n\n      for (var m = 0, g = r; m < g.length; m += 1) {\n        var v = this.style._layers[g[m]];\n\n        if (v.hasOffscreenPass() && !v.isHidden(this.transform.zoom)) {\n          var y = h[v.source];\n          ("custom" === v.type || y.length) && this.renderLayer(this, a[v.source], v, y);\n        }\n      }\n\n      for (this.context.bindFramebuffer.set(null), this.context.clear({\n        color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,\n        depth: 1\n      }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n        var x = this.style._layers[r[this.currentLayer]],\n            b = a[x.source],\n            w = u[x.source];\n        this._renderTileClippingMasks(x, w), this.renderLayer(this, b, x, w);\n      }\n\n      for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {\n        var T = this.style._layers[r[this.currentLayer]],\n            E = a[T.source],\n            I = ("symbol" === T.type ? p : h)[T.source];\n        this._renderTileClippingMasks(T, u[T.source]), this.renderLayer(this, E, T, I);\n      }\n\n      this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function (t) {\n        t.source && !t.isHidden(o.transform.zoom) && (t.source !== (c && c.id) && (c = o.style.sourceCaches[t.source]), (!l || l.getSource().maxzoom < c.getSource().maxzoom) && (l = c));\n      }), l && vo.debug(this, l, l.getVisibleCoordinates())), this.options.showPadding && function (t) {\n        var e = t.transform.padding;\n        _o(t, t.transform.height - (e.top || 0), 3, lo), _o(t, e.bottom || 0, 3, co), fo(t, e.left || 0, 3, uo), fo(t, t.transform.width - (e.right || 0), 3, ho);\n        var i = t.transform.centerPoint;\n        !function (t, e, i, o) {\n          mo(t, e - 1, i - 10, 2, 20, o), mo(t, e - 10, i - 1, 20, 2, o);\n        }(t, i.x, t.transform.height - i.y, po);\n      }(this), this.context.setDefault();\n    }, yo.prototype.renderLayer = function (t, e, i, o) {\n      i.isHidden(this.transform.zoom) || ("background" === i.type || "custom" === i.type || o.length) && (this.id = i.id, this.gpuTimingStart(i), vo[i.type](t, e, i, o, this.style.placement.variableOffsets), this.gpuTimingEnd());\n    }, yo.prototype.gpuTimingStart = function (t) {\n      if (this.options.gpuTiming) {\n        var e = this.context.extTimerQuery,\n            i = this.gpuTimers[t.id];\n        i || (i = this.gpuTimers[t.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: e.createQueryEXT()\n        }), i.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query);\n      }\n    }, yo.prototype.gpuTimingEnd = function () {\n      if (this.options.gpuTiming) {\n        var t = this.context.extTimerQuery;\n        t.endQueryEXT(t.TIME_ELAPSED_EXT);\n      }\n    }, yo.prototype.collectGpuTimers = function () {\n      var t = this.gpuTimers;\n      return this.gpuTimers = {}, t;\n    }, yo.prototype.queryGpuTimers = function (t) {\n      var e = {};\n\n      for (var i in t) {\n        var o = t[i],\n            r = this.context.extTimerQuery,\n            a = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;\n        r.deleteQueryEXT(o.query), e[i] = a;\n      }\n\n      return e;\n    }, yo.prototype.translatePosMatrix = function (e, i, o, r, a) {\n      if (!o[0] && !o[1]) return e;\n      var n = a ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;\n\n      if (n) {\n        var s = Math.sin(n),\n            l = Math.cos(n);\n        o = [o[0] * l - o[1] * s, o[0] * s + o[1] * l];\n      }\n\n      var c = [a ? o[0] : pe(i, o[0], this.transform.zoom), a ? o[1] : pe(i, o[1], this.transform.zoom), 0],\n          u = new Float32Array(16);\n      return t.translate(u, e, c), u;\n    }, yo.prototype.saveTileTexture = function (t) {\n      var e = this._tileTextures[t.size[0]];\n      e ? e.push(t) : this._tileTextures[t.size[0]] = [t];\n    }, yo.prototype.getTileTexture = function (t) {\n      var e = this._tileTextures[t];\n      return e && e.length > 0 ? e.pop() : null;\n    }, yo.prototype.isPatternMissing = function (t) {\n      if (!t) return !1;\n      if (!t.from || !t.to) return !0;\n      var e = this.imageManager.getPattern(t.from.toString()),\n          i = this.imageManager.getPattern(t.to.toString());\n      return !e || !i;\n    }, yo.prototype.useProgram = function (t, e) {\n      this.cache = this.cache || {};\n      var i = "" + t + (e ? e.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");\n      return this.cache[i] || (this.cache[i] = new bi(this.context, t, vi[t], e, Ki[t], this._showOverdrawInspector)), this.cache[i];\n    }, yo.prototype.setCustomLayerDefaults = function () {\n      this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n    }, yo.prototype.setBaseState = function () {\n      var t = this.context.gl;\n      this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);\n    }, yo.prototype.initDebugOverlayCanvas = function () {\n      null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n    }, yo.prototype.destroy = function () {\n      this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();\n    };\n\n    var xo = function xo(t, e) {\n      this.points = t, this.planes = e;\n    };\n\n    xo.fromInvProjectionMatrix = function (e, i, o) {\n      var r = Math.pow(2, o),\n          a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function (i) {\n        return t.transformMat4([], i, e);\n      }).map(function (e) {\n        return t.scale$1([], e, 1 / e[3] / i * r);\n      }),\n          n = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function (e) {\n        var i = t.sub([], a[e[0]], a[e[1]]),\n            o = t.sub([], a[e[2]], a[e[1]]),\n            r = t.normalize([], t.cross([], i, o)),\n            n = -t.dot(r, a[e[1]]);\n        return r.concat(n);\n      });\n      return new xo(a, n);\n    };\n\n    var bo = function bo(e, i) {\n      this.min = e, this.max = i, this.center = t.scale$2([], t.add([], this.min, this.max), .5);\n    };\n\n    bo.prototype.quadrant = function (e) {\n      for (var i = [e % 2 == 0, e < 2], o = t.clone$2(this.min), r = t.clone$2(this.max), a = 0; a < i.length; a++) {\n        o[a] = i[a] ? this.min[a] : this.center[a], r[a] = i[a] ? this.center[a] : this.max[a];\n      }\n\n      return r[2] = this.max[2], new bo(o, r);\n    }, bo.prototype.distanceX = function (t) {\n      return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n    }, bo.prototype.distanceY = function (t) {\n      return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n    }, bo.prototype.intersects = function (e) {\n      for (var i = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o = !0, r = 0; r < e.planes.length; r++) {\n        for (var a = e.planes[r], n = 0, s = 0; s < i.length; s++) {\n          n += t.dot$1(a, i[s]) >= 0;\n        }\n\n        if (0 === n) return 0;\n        n !== i.length && (o = !1);\n      }\n\n      if (o) return 2;\n\n      for (var l = 0; l < 3; l++) {\n        for (var c = Number.MAX_VALUE, u = -Number.MAX_VALUE, h = 0; h < e.points.length; h++) {\n          var p = e.points[h][l] - this.min[l];\n          c = Math.min(c, p), u = Math.max(u, p);\n        }\n\n        if (u < 0 || c > this.max[l] - this.min[l]) return 0;\n      }\n\n      return 1;\n    };\n\n    var wo = function wo(t, e, i, o) {\n      if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");\n      this.top = t, this.bottom = e, this.left = i, this.right = o;\n    };\n\n    wo.prototype.interpolate = function (e, i, o) {\n      return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, o)), null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, o)), null != i.left && null != e.left && (this.left = t.number(e.left, i.left, o)), null != i.right && null != e.right && (this.right = t.number(e.right, i.right, o)), this;\n    }, wo.prototype.getCenter = function (e, i) {\n      var o = t.clamp((this.left + e - this.right) / 2, 0, e),\n          r = t.clamp((this.top + i - this.bottom) / 2, 0, i);\n      return new t.Point(o, r);\n    }, wo.prototype.equals = function (t) {\n      return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;\n    }, wo.prototype.clone = function () {\n      return new wo(this.top, this.bottom, this.left, this.right);\n    }, wo.prototype.toJSON = function () {\n      return {\n        top: this.top,\n        bottom: this.bottom,\n        left: this.left,\n        right: this.right\n      };\n    };\n\n    var To = function To(e, i, o, r, a) {\n      this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a || a, this._minZoom = e || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n    },\n        Eo = {\n      minZoom: {\n        configurable: !0\n      },\n      maxZoom: {\n        configurable: !0\n      },\n      minPitch: {\n        configurable: !0\n      },\n      maxPitch: {\n        configurable: !0\n      },\n      renderWorldCopies: {\n        configurable: !0\n      },\n      worldSize: {\n        configurable: !0\n      },\n      centerOffset: {\n        configurable: !0\n      },\n      size: {\n        configurable: !0\n      },\n      bearing: {\n        configurable: !0\n      },\n      pitch: {\n        configurable: !0\n      },\n      fov: {\n        configurable: !0\n      },\n      zoom: {\n        configurable: !0\n      },\n      center: {\n        configurable: !0\n      },\n      padding: {\n        configurable: !0\n      },\n      centerPoint: {\n        configurable: !0\n      },\n      unmodified: {\n        configurable: !0\n      },\n      point: {\n        configurable: !0\n      }\n    };\n\n    To.prototype.clone = function () {\n      var t = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n      return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t;\n    }, Eo.minZoom.get = function () {\n      return this._minZoom;\n    }, Eo.minZoom.set = function (t) {\n      this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));\n    }, Eo.maxZoom.get = function () {\n      return this._maxZoom;\n    }, Eo.maxZoom.set = function (t) {\n      this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));\n    }, Eo.minPitch.get = function () {\n      return this._minPitch;\n    }, Eo.minPitch.set = function (t) {\n      this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));\n    }, Eo.maxPitch.get = function () {\n      return this._maxPitch;\n    }, Eo.maxPitch.set = function (t) {\n      this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));\n    }, Eo.renderWorldCopies.get = function () {\n      return this._renderWorldCopies;\n    }, Eo.renderWorldCopies.set = function (t) {\n      void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t;\n    }, Eo.worldSize.get = function () {\n      return this.tileSize * this.scale;\n    }, Eo.centerOffset.get = function () {\n      return this.centerPoint._sub(this.size._div(2));\n    }, Eo.size.get = function () {\n      return new t.Point(this.width, this.height);\n    }, Eo.bearing.get = function () {\n      return -this.angle / Math.PI * 180;\n    }, Eo.bearing.set = function (e) {\n      var i = -t.wrap(e, -180, 180) * Math.PI / 180;\n      this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));\n    }, Eo.pitch.get = function () {\n      return this._pitch / Math.PI * 180;\n    }, Eo.pitch.set = function (e) {\n      var i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;\n      this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n    }, Eo.fov.get = function () {\n      return this._fov / Math.PI * 180;\n    }, Eo.fov.set = function (t) {\n      t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());\n    }, Eo.zoom.get = function () {\n      return this._zoom;\n    }, Eo.zoom.set = function (t) {\n      var e = Math.min(Math.max(t, this.minZoom), this.maxZoom);\n      this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices());\n    }, Eo.center.get = function () {\n      return this._center;\n    }, Eo.center.set = function (t) {\n      t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());\n    }, Eo.padding.get = function () {\n      return this._edgeInsets.toJSON();\n    }, Eo.padding.set = function (t) {\n      this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());\n    }, Eo.centerPoint.get = function () {\n      return this._edgeInsets.getCenter(this.width, this.height);\n    }, To.prototype.isPaddingEqual = function (t) {\n      return this._edgeInsets.equals(t);\n    }, To.prototype.interpolatePadding = function (t, e, i) {\n      this._unmodified = !1, this._edgeInsets.interpolate(t, e, i), this._constrain(), this._calcMatrices();\n    }, To.prototype.coveringZoomLevel = function (t) {\n      var e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));\n      return Math.max(0, e);\n    }, To.prototype.getVisibleUnwrappedCoordinates = function (e) {\n      var i = [new t.UnwrappedTileID(0, e)];\n      if (this._renderWorldCopies) for (var o = this.pointCoordinate(new t.Point(0, 0)), r = this.pointCoordinate(new t.Point(this.width, 0)), a = this.pointCoordinate(new t.Point(this.width, this.height)), n = this.pointCoordinate(new t.Point(0, this.height)), s = Math.floor(Math.min(o.x, r.x, a.x, n.x)), l = Math.floor(Math.max(o.x, r.x, a.x, n.x)), c = s - 1; c <= l + 1; c++) {\n        0 !== c && i.push(new t.UnwrappedTileID(c, e));\n      }\n      return i;\n    }, To.prototype.coveringTiles = function (e) {\n      var i = this.coveringZoomLevel(e),\n          o = i;\n      if (void 0 !== e.minzoom && i < e.minzoom) return [];\n      void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);\n      var r = t.MercatorCoordinate.fromLngLat(this.center),\n          a = Math.pow(2, i),\n          n = [a * r.x, a * r.y, 0],\n          s = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i),\n          l = e.minzoom || 0;\n      this.pitch <= 60 && this._edgeInsets.top < .1 && (l = i);\n\n      var c = function c(t) {\n        return {\n          aabb: new bo([t * a, 0, 0], [(t + 1) * a, a, 0]),\n          zoom: 0,\n          x: 0,\n          y: 0,\n          wrap: t,\n          fullyVisible: !1\n        };\n      },\n          u = [],\n          h = [],\n          p = i,\n          d = e.reparseOverscaled ? o : i;\n\n      if (this._renderWorldCopies) for (var _ = 1; _ <= 3; _++) {\n        u.push(c(-_)), u.push(c(_));\n      }\n\n      for (u.push(c(0)); u.length > 0;) {\n        var f = u.pop(),\n            m = f.x,\n            g = f.y,\n            v = f.fullyVisible;\n\n        if (!v) {\n          var y = f.aabb.intersects(s);\n          if (0 === y) continue;\n          v = 2 === y;\n        }\n\n        var x = f.aabb.distanceX(n),\n            b = f.aabb.distanceY(n),\n            w = Math.max(Math.abs(x), Math.abs(b));\n        if (f.zoom === p || w > 3 + (1 << p - f.zoom) - 2 && f.zoom >= l) h.push({\n          tileID: new t.OverscaledTileID(f.zoom === p ? d : f.zoom, f.wrap, f.zoom, m, g),\n          distanceSq: t.sqrLen([n[0] - .5 - m, n[1] - .5 - g])\n        });else for (var T = 0; T < 4; T++) {\n          var E = (m << 1) + T % 2,\n              I = (g << 1) + (T >> 1);\n          u.push({\n            aabb: f.aabb.quadrant(T),\n            zoom: f.zoom + 1,\n            x: E,\n            y: I,\n            wrap: f.wrap,\n            fullyVisible: v\n          });\n        }\n      }\n\n      return h.sort(function (t, e) {\n        return t.distanceSq - e.distanceSq;\n      }).map(function (t) {\n        return t.tileID;\n      });\n    }, To.prototype.resize = function (t, e) {\n      this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices();\n    }, Eo.unmodified.get = function () {\n      return this._unmodified;\n    }, To.prototype.zoomScale = function (t) {\n      return Math.pow(2, t);\n    }, To.prototype.scaleZoom = function (t) {\n      return Math.log(t) / Math.LN2;\n    }, To.prototype.project = function (e) {\n      var i = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude);\n      return new t.Point(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(i) * this.worldSize);\n    }, To.prototype.unproject = function (e) {\n      return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat();\n    }, Eo.point.get = function () {\n      return this.project(this.center);\n    }, To.prototype.setLocationAtPoint = function (e, i) {\n      var o = this.pointCoordinate(i),\n          r = this.pointCoordinate(this.centerPoint),\n          a = this.locationCoordinate(e),\n          n = new t.MercatorCoordinate(a.x - (o.x - r.x), a.y - (o.y - r.y));\n      this.center = this.coordinateLocation(n), this._renderWorldCopies && (this.center = this.center.wrap());\n    }, To.prototype.locationPoint = function (t) {\n      return this.coordinatePoint(this.locationCoordinate(t));\n    }, To.prototype.pointLocation = function (t) {\n      return this.coordinateLocation(this.pointCoordinate(t));\n    }, To.prototype.locationCoordinate = function (e) {\n      return t.MercatorCoordinate.fromLngLat(e);\n    }, To.prototype.coordinateLocation = function (t) {\n      return t.toLngLat();\n    }, To.prototype.pointCoordinate = function (e) {\n      var i = [e.x, e.y, 0, 1],\n          o = [e.x, e.y, 1, 1];\n      t.transformMat4(i, i, this.pixelMatrixInverse), t.transformMat4(o, o, this.pixelMatrixInverse);\n      var r = i[3],\n          a = o[3],\n          n = i[1] / r,\n          s = o[1] / a,\n          l = i[2] / r,\n          c = o[2] / a,\n          u = l === c ? 0 : (0 - l) / (c - l);\n      return new t.MercatorCoordinate(t.number(i[0] / r, o[0] / a, u) / this.worldSize, t.number(n, s, u) / this.worldSize);\n    }, To.prototype.coordinatePoint = function (e) {\n      var i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix), new t.Point(i[0] / i[3], i[1] / i[3]);\n    }, To.prototype.getBounds = function () {\n      return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));\n    }, To.prototype.getMaxBounds = function () {\n      return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;\n    }, To.prototype.setMaxBounds = function (t) {\n      t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);\n    }, To.prototype.calculatePosMatrix = function (e, i) {\n      void 0 === i && (i = !1);\n      var o = e.key,\n          r = i ? this._alignedPosMatrixCache : this._posMatrixCache;\n      if (r[o]) return r[o];\n      var a = e.canonical,\n          n = this.worldSize / this.zoomScale(a.z),\n          s = a.x + Math.pow(2, a.z) * e.wrap,\n          l = t.identity(new Float64Array(16));\n      return t.translate(l, l, [s * n, a.y * n, 0]), t.scale(l, l, [n / t.EXTENT, n / t.EXTENT, 1]), t.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), r[o] = new Float32Array(l), r[o];\n    }, To.prototype.customLayerMatrix = function () {\n      return this.mercatorMatrix.slice();\n    }, To.prototype._constrain = function () {\n      if (this.center && this.width && this.height && !this._constraining) {\n        this._constraining = !0;\n        var e,\n            i,\n            o,\n            r,\n            a = -90,\n            n = 90,\n            s = -180,\n            l = 180,\n            c = this.size,\n            u = this._unmodified;\n\n        if (this.latRange) {\n          var h = this.latRange;\n          a = t.mercatorYfromLat(h[1]) * this.worldSize, e = (n = t.mercatorYfromLat(h[0]) * this.worldSize) - a < c.y ? c.y / (n - a) : 0;\n        }\n\n        if (this.lngRange) {\n          var p = this.lngRange;\n          s = t.mercatorXfromLng(p[0]) * this.worldSize, i = (l = t.mercatorXfromLng(p[1]) * this.worldSize) - s < c.x ? c.x / (l - s) : 0;\n        }\n\n        var d = this.point,\n            _ = Math.max(i || 0, e || 0);\n\n        if (_) return this.center = this.unproject(new t.Point(i ? (l + s) / 2 : d.x, e ? (n + a) / 2 : d.y)), this.zoom += this.scaleZoom(_), this._unmodified = u, void (this._constraining = !1);\n\n        if (this.latRange) {\n          var f = d.y,\n              m = c.y / 2;\n          f - m < a && (r = a + m), f + m > n && (r = n - m);\n        }\n\n        if (this.lngRange) {\n          var g = d.x,\n              v = c.x / 2;\n          g - v < s && (o = s + v), g + v > l && (o = l - v);\n        }\n\n        void 0 === o && void 0 === r || (this.center = this.unproject(new t.Point(void 0 !== o ? o : d.x, void 0 !== r ? r : d.y))), this._unmodified = u, this._constraining = !1;\n      }\n    }, To.prototype._calcMatrices = function () {\n      if (this.height) {\n        var e = this.centerOffset;\n        this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height;\n        var i = Math.PI / 2 + this._pitch,\n            o = this._fov * (.5 + e.y / this.height),\n            r = Math.sin(o) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i - o, .01, Math.PI - .01)),\n            a = this.point,\n            n = a.x,\n            s = a.y,\n            l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r + this.cameraToCenterDistance),\n            c = this.height / 50,\n            u = new Float64Array(16);\n        t.perspective(u, this._fov, this.width / this.height, c, l), u[8] = 2 * -e.x / this.width, u[9] = 2 * e.y / this.height, t.scale(u, u, [1, -1, 1]), t.translate(u, u, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u, u, this._pitch), t.rotateZ(u, u, this.angle), t.translate(u, u, [-n, -s, 0]), this.mercatorMatrix = t.scale([], u, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u, u, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u, this.invProjMatrix = t.invert([], this.projMatrix);\n\n        var h = this.width % 2 / 2,\n            p = this.height % 2 / 2,\n            d = Math.cos(this.angle),\n            _ = Math.sin(this.angle),\n            f = n - Math.round(n) + d * h + _ * p,\n            m = s - Math.round(s) + d * p + _ * h,\n            g = new Float64Array(u);\n\n        if (t.translate(g, g, [f > .5 ? f - 1 : f, m > .5 ? m - 1 : m, 0]), this.alignedProjMatrix = g, u = t.create(), t.scale(u, u, [this.width / 2, -this.height / 2, 1]), t.translate(u, u, [1, -1, 0]), this.labelPlaneMatrix = u, u = t.create(), t.scale(u, u, [1, -1, 1]), t.translate(u, u, [-1, -1, 0]), t.scale(u, u, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u = t.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix");\n        this.pixelMatrixInverse = u, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      }\n    }, To.prototype.maxPitchScaleFactor = function () {\n      if (!this.pixelMatrixInverse) return 1;\n      var e = this.pointCoordinate(new t.Point(0, 0)),\n          i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance;\n    }, To.prototype.getCameraPoint = function () {\n      var e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n      return this.centerPoint.add(new t.Point(0, e));\n    }, To.prototype.getCameraQueryGeometry = function (e) {\n      var i = this.getCameraPoint();\n      if (1 === e.length) return [e[0], i];\n\n      for (var o = i.x, r = i.y, a = i.x, n = i.y, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s];\n        o = Math.min(o, c.x), r = Math.min(r, c.y), a = Math.max(a, c.x), n = Math.max(n, c.y);\n      }\n\n      return [new t.Point(o, r), new t.Point(a, r), new t.Point(a, n), new t.Point(o, n), new t.Point(o, r)];\n    }, Object.defineProperties(To.prototype, Eo);\n\n    var Io = function Io(e) {\n      var i, o, r, _a3;\n\n      this._hashName = e && encodeURIComponent(e), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i = this._updateHashUnthrottled.bind(this), o = !1, r = null, _a3 = function a() {\n        r = null, o && (i(), r = setTimeout(_a3, 300), o = !1);\n      }, function () {\n        return o = !0, r || _a3(), r;\n      });\n    };\n\n    Io.prototype.addTo = function (e) {\n      return this._map = e, t.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;\n    }, Io.prototype.remove = function () {\n      return t.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;\n    }, Io.prototype.getHashString = function (e) {\n      var i = this._map.getCenter(),\n          o = Math.round(100 * this._map.getZoom()) / 100,\n          r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n          a = Math.pow(10, r),\n          n = Math.round(i.lng * a) / a,\n          s = Math.round(i.lat * a) / a,\n          l = this._map.getBearing(),\n          c = this._map.getPitch(),\n          u = "";\n\n      if (u += e ? "/" + n + "/" + s + "/" + o : o + "/" + s + "/" + n, (l || c) && (u += "/" + Math.round(10 * l) / 10), c && (u += "/" + Math.round(c)), this._hashName) {\n        var h = this._hashName,\n            p = !1,\n            d = t.window.location.hash.slice(1).split("&").map(function (t) {\n          var e = t.split("=")[0];\n          return e === h ? (p = !0, e + "=" + u) : t;\n        }).filter(function (t) {\n          return t;\n        });\n        return p || d.push(h + "=" + u), "#" + d.join("&");\n      }\n\n      return "#" + u;\n    }, Io.prototype._getCurrentHash = function () {\n      var e,\n          i = this,\n          o = t.window.location.hash.replace("#", "");\n      return this._hashName ? (o.split("&").map(function (t) {\n        return t.split("=");\n      }).forEach(function (t) {\n        t[0] === i._hashName && (e = t);\n      }), (e && e[1] || "").split("/")) : o.split("/");\n    }, Io.prototype._onHashChange = function () {\n      var t = this._getCurrentHash();\n\n      if (t.length >= 3 && !t.some(function (t) {\n        return isNaN(t);\n      })) {\n        var e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing();\n        return this._map.jumpTo({\n          center: [+t[2], +t[1]],\n          zoom: +t[0],\n          bearing: e,\n          pitch: +(t[4] || 0)\n        }), !0;\n      }\n\n      return !1;\n    }, Io.prototype._updateHashUnthrottled = function () {\n      var e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());\n\n      try {\n        t.window.history.replaceState(t.window.history.state, null, e);\n      } catch (t) {}\n    };\n\n    var Po = {\n      linearity: .3,\n      easing: t.bezier(0, 0, .3, 1)\n    },\n        So = t.extend({\n      deceleration: 2500,\n      maxSpeed: 1400\n    }, Po),\n        Co = t.extend({\n      deceleration: 20,\n      maxSpeed: 1400\n    }, Po),\n        zo = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 360\n    }, Po),\n        Do = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 90\n    }, Po),\n        Ao = function Ao(t) {\n      this._map = t, this.clear();\n    };\n\n    function Mo(t, e) {\n      (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing);\n    }\n\n    function Lo(e, i, o) {\n      var r = o.maxSpeed,\n          a = o.linearity,\n          n = o.deceleration,\n          s = t.clamp(e * a / (i / 1e3), -r, r),\n          l = Math.abs(s) / (n * a);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: s * (l / 2)\n      };\n    }\n\n    Ao.prototype.clear = function () {\n      this._inertiaBuffer = [];\n    }, Ao.prototype.record = function (e) {\n      this._drainInertiaBuffer(), this._inertiaBuffer.push({\n        time: t.browser.now(),\n        settings: e\n      });\n    }, Ao.prototype._drainInertiaBuffer = function () {\n      for (var e = this._inertiaBuffer, i = t.browser.now(); e.length > 0 && i - e[0].time > 160;) {\n        e.shift();\n      }\n    }, Ao.prototype._onMoveEnd = function (e) {\n      if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {\n        for (var i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new t.Point(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        }, o = 0, r = this._inertiaBuffer; o < r.length; o += 1) {\n          var a = r[o].settings;\n          i.zoom += a.zoomDelta || 0, i.bearing += a.bearingDelta || 0, i.pitch += a.pitchDelta || 0, a.panDelta && i.pan._add(a.panDelta), a.around && (i.around = a.around), a.pinchAround && (i.pinchAround = a.pinchAround);\n        }\n\n        var n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n            s = {};\n\n        if (i.pan.mag()) {\n          var l = Lo(i.pan.mag(), n, t.extend({}, So, e || {}));\n          s.offset = i.pan.mult(l.amount / i.pan.mag()), s.center = this._map.transform.center, Mo(s, l);\n        }\n\n        if (i.zoom) {\n          var c = Lo(i.zoom, n, Co);\n          s.zoom = this._map.transform.zoom + c.amount, Mo(s, c);\n        }\n\n        if (i.bearing) {\n          var u = Lo(i.bearing, n, zo);\n          s.bearing = this._map.transform.bearing + t.clamp(u.amount, -179, 179), Mo(s, u);\n        }\n\n        if (i.pitch) {\n          var h = Lo(i.pitch, n, Do);\n          s.pitch = this._map.transform.pitch + h.amount, Mo(s, h);\n        }\n\n        if (s.zoom || s.bearing) {\n          var p = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          s.around = p ? this._map.unproject(p) : this._map.getCenter();\n        }\n\n        return this.clear(), t.extend(s, {\n          noMoveStart: !0\n        });\n      }\n    };\n\n    var Ro = function (e) {\n      function o(o, r, a, n) {\n        void 0 === n && (n = {});\n        var s = i.mousePos(r.getCanvasContainer(), a),\n            l = r.unproject(s);\n        e.call(this, o, t.extend({\n          point: s,\n          lngLat: l,\n          originalEvent: a\n        }, n)), this._defaultPrevented = !1, this.target = r;\n      }\n\n      e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n      var r = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return o.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, r.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(o.prototype, r), o;\n    }(t.Event),\n        ko = function (e) {\n      function o(o, r, a) {\n        var n = "touchend" === o ? a.changedTouches : a.touches,\n            s = i.touchPos(r.getCanvasContainer(), n),\n            l = s.map(function (t) {\n          return r.unproject(t);\n        }),\n            c = s.reduce(function (t, e, i, o) {\n          return t.add(e.div(o.length));\n        }, new t.Point(0, 0)),\n            u = r.unproject(c);\n        e.call(this, o, {\n          points: s,\n          point: c,\n          lngLats: l,\n          lngLat: u,\n          originalEvent: a\n        }), this._defaultPrevented = !1;\n      }\n\n      e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n      var r = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return o.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, r.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(o.prototype, r), o;\n    }(t.Event),\n        Bo = function (t) {\n      function e(e, i, o) {\n        t.call(this, e, {\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var i = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return e.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, i.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(e.prototype, i), e;\n    }(t.Event),\n        Oo = function Oo(t, e) {\n      this._map = t, this._clickTolerance = e.clickTolerance;\n    };\n\n    Oo.prototype.reset = function () {\n      delete this._mousedownPos;\n    }, Oo.prototype.wheel = function (t) {\n      return this._firePreventable(new Bo(t.type, this._map, t));\n    }, Oo.prototype.mousedown = function (t, e) {\n      return this._mousedownPos = e, this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseup = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.click = function (t, e) {\n      this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.dblclick = function (t) {\n      return this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseover = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseout = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.touchstart = function (t) {\n      return this._firePreventable(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchmove = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchend = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchcancel = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype._firePreventable = function (t) {\n      if (this._map.fire(t), t.defaultPrevented) return {};\n    }, Oo.prototype.isEnabled = function () {\n      return !0;\n    }, Oo.prototype.isActive = function () {\n      return !1;\n    }, Oo.prototype.enable = function () {}, Oo.prototype.disable = function () {};\n\n    var Fo = function Fo(t) {\n      this._map = t;\n    };\n\n    Fo.prototype.reset = function () {\n      this._delayContextMenu = !1, delete this._contextMenuEvent;\n    }, Fo.prototype.mousemove = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Fo.prototype.mousedown = function () {\n      this._delayContextMenu = !0;\n    }, Fo.prototype.mouseup = function () {\n      this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n    }, Fo.prototype.contextmenu = function (t) {\n      this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Ro(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();\n    }, Fo.prototype.isEnabled = function () {\n      return !0;\n    }, Fo.prototype.isActive = function () {\n      return !1;\n    }, Fo.prototype.enable = function () {}, Fo.prototype.disable = function () {};\n\n    var Uo = function Uo(t, e) {\n      this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1;\n    };\n\n    function No(t, e) {\n      for (var i = {}, o = 0; o < t.length; o++) {\n        i[t[o].identifier] = e[o];\n      }\n\n      return i;\n    }\n\n    Uo.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, Uo.prototype.isActive = function () {\n      return !!this._active;\n    }, Uo.prototype.enable = function () {\n      this.isEnabled() || (this._enabled = !0);\n    }, Uo.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, Uo.prototype.mousedown = function (t, e) {\n      this.isEnabled() && t.shiftKey && 0 === t.button && (i.disableDrag(), this._startPos = this._lastPos = e, this._active = !0);\n    }, Uo.prototype.mousemoveWindow = function (t, e) {\n      if (this._active) {\n        var o = e;\n\n        if (!(this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance)) {\n          var r = this._startPos;\n          this._lastPos = o, this._box || (this._box = i.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));\n          var a = Math.min(r.x, o.x),\n              n = Math.max(r.x, o.x),\n              s = Math.min(r.y, o.y),\n              l = Math.max(r.y, o.y);\n          i.setTransform(this._box, "translate(" + a + "px," + s + "px)"), this._box.style.width = n - a + "px", this._box.style.height = l - s + "px";\n        }\n      }\n    }, Uo.prototype.mouseupWindow = function (e, o) {\n      var r = this;\n\n      if (this._active && 0 === e.button) {\n        var a = this._startPos,\n            n = o;\n        if (this.reset(), i.suppressClick(), a.x !== n.x || a.y !== n.y) return this._map.fire(new t.Event("boxzoomend", {\n          originalEvent: e\n        })), {\n          cameraAnimation: function cameraAnimation(t) {\n            return t.fitScreenCoordinates(a, n, r._map.getBearing(), {\n              linear: !0\n            });\n          }\n        };\n\n        this._fireEvent("boxzoomcancel", e);\n      }\n    }, Uo.prototype.keydown = function (t) {\n      this._active && 27 === t.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t));\n    }, Uo.prototype.reset = function () {\n      this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;\n    }, Uo.prototype._fireEvent = function (e, i) {\n      return this._map.fire(new t.Event(e, {\n        originalEvent: i\n      }));\n    };\n\n    var Zo = function Zo(t) {\n      this.reset(), this.numTouches = t.numTouches;\n    };\n\n    Zo.prototype.reset = function () {\n      delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;\n    }, Zo.prototype.touchstart = function (e, i, o) {\n      (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function (e) {\n        for (var i = new t.Point(0, 0), o = 0, r = e; o < r.length; o += 1) {\n          i._add(r[o]);\n        }\n\n        return i.div(e.length);\n      }(i), this.touches = No(o, i)));\n    }, Zo.prototype.touchmove = function (t, e, i) {\n      if (!this.aborted && this.centroid) {\n        var o = No(i, e);\n\n        for (var r in this.touches) {\n          var a = o[r];\n          (!a || a.dist(this.touches[r]) > 30) && (this.aborted = !0);\n        }\n      }\n    }, Zo.prototype.touchend = function (t, e, i) {\n      if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n        var o = !this.aborted && this.centroid;\n        if (this.reset(), o) return o;\n      }\n    };\n\n    var qo = function qo(t) {\n      this.singleTap = new Zo(t), this.numTaps = t.numTaps, this.reset();\n    };\n\n    qo.prototype.reset = function () {\n      this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();\n    }, qo.prototype.touchstart = function (t, e, i) {\n      this.singleTap.touchstart(t, e, i);\n    }, qo.prototype.touchmove = function (t, e, i) {\n      this.singleTap.touchmove(t, e, i);\n    }, qo.prototype.touchend = function (t, e, i) {\n      var o = this.singleTap.touchend(t, e, i);\n\n      if (o) {\n        var r = t.timeStamp - this.lastTime < 500,\n            a = !this.lastTap || this.lastTap.dist(o) < 30;\n        if (r && a || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n      }\n    };\n\n    var jo = function jo() {\n      this._zoomIn = new qo({\n        numTouches: 1,\n        numTaps: 2\n      }), this._zoomOut = new qo({\n        numTouches: 2,\n        numTaps: 1\n      }), this.reset();\n    };\n\n    jo.prototype.reset = function () {\n      this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n    }, jo.prototype.touchstart = function (t, e, i) {\n      this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);\n    }, jo.prototype.touchmove = function (t, e, i) {\n      this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);\n    }, jo.prototype.touchend = function (t, e, i) {\n      var o = this,\n          r = this._zoomIn.touchend(t, e, i),\n          a = this._zoomOut.touchend(t, e, i);\n\n      return r ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function cameraAnimation(e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() + 1,\n            around: e.unproject(r)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : a ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function cameraAnimation(e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() - 1,\n            around: e.unproject(a)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : void 0;\n    }, jo.prototype.touchcancel = function () {\n      this.reset();\n    }, jo.prototype.enable = function () {\n      this._enabled = !0;\n    }, jo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, jo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, jo.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Vo = {\n      0: 1,\n      2: 2\n    },\n        Go = function Go(t) {\n      this.reset(), this._clickTolerance = t.clickTolerance || 1;\n    };\n\n    Go.prototype.reset = function () {\n      this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;\n    }, Go.prototype._correctButton = function (t, e) {\n      return !1;\n    }, Go.prototype._move = function (t, e) {\n      return {};\n    }, Go.prototype.mousedown = function (t, e) {\n      if (!this._lastPoint) {\n        var o = i.mouseButton(t);\n        this._correctButton(t, o) && (this._lastPoint = e, this._eventButton = o);\n      }\n    }, Go.prototype.mousemoveWindow = function (t, e) {\n      var i = this._lastPoint;\n      if (i) if (t.preventDefault(), function (t, e) {\n        var i = Vo[e];\n        return void 0 === t.buttons || (t.buttons & i) !== i;\n      }(t, this._eventButton)) this.reset();else if (this._moved || !(e.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(i, e);\n    }, Go.prototype.mouseupWindow = function (t) {\n      this._lastPoint && i.mouseButton(t) === this._eventButton && (this._moved && i.suppressClick(), this.reset());\n    }, Go.prototype.enable = function () {\n      this._enabled = !0;\n    }, Go.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Go.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Go.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Wo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.mousedown = function (e, i) {\n        t.prototype.mousedown.call(this, e, i), this._lastPoint && (this._active = !0);\n      }, e.prototype._correctButton = function (t, e) {\n        return 0 === e && !t.ctrlKey;\n      }, e.prototype._move = function (t, e) {\n        return {\n          around: e,\n          panDelta: e.sub(t)\n        };\n      }, e;\n    }(Go),\n        Xo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }, e.prototype._move = function (t, e) {\n        var i = .8 * (e.x - t.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }, e.prototype.contextmenu = function (t) {\n        t.preventDefault();\n      }, e;\n    }(Go),\n        Ho = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }, e.prototype._move = function (t, e) {\n        var i = -.5 * (e.y - t.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }, e.prototype.contextmenu = function (t) {\n        t.preventDefault();\n      }, e;\n    }(Go),\n        Ko = function Ko(t) {\n      this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset();\n    };\n\n    Ko.prototype.reset = function () {\n      this._active = !1, this._touches = {}, this._sum = new t.Point(0, 0);\n    }, Ko.prototype.touchstart = function (t, e, i) {\n      return this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchmove = function (t, e, i) {\n      if (this._active && !(i.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchend = function (t, e, i) {\n      this._calculateTransform(t, e, i), this._active && i.length < this._minTouches && this.reset();\n    }, Ko.prototype.touchcancel = function () {\n      this.reset();\n    }, Ko.prototype._calculateTransform = function (e, i, o) {\n      o.length > 0 && (this._active = !0);\n      var r = No(o, i),\n          a = new t.Point(0, 0),\n          n = new t.Point(0, 0),\n          s = 0;\n\n      for (var l in r) {\n        var c = r[l],\n            u = this._touches[l];\n        u && (a._add(c), n._add(c.sub(u)), s++, r[l] = c);\n      }\n\n      if (this._touches = r, !(s < this._minTouches) && n.mag()) {\n        var h = n.div(s);\n        if (this._sum._add(h), !(this._sum.mag() < this._clickTolerance)) return {\n          around: a.div(s),\n          panDelta: h\n        };\n      }\n    }, Ko.prototype.enable = function () {\n      this._enabled = !0;\n    }, Ko.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Ko.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Ko.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Yo = function Yo() {\n      this.reset();\n    };\n\n    function Jo(t, e, i) {\n      for (var o = 0; o < t.length; o++) {\n        if (t[o].identifier === i) return e[o];\n      }\n    }\n\n    function Qo(t, e) {\n      return Math.log(t / e) / Math.LN2;\n    }\n\n    Yo.prototype.reset = function () {\n      this._active = !1, delete this._firstTwoTouches;\n    }, Yo.prototype._start = function (t) {}, Yo.prototype._move = function (t, e, i) {\n      return {};\n    }, Yo.prototype.touchstart = function (t, e, i) {\n      this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([e[0], e[1]]));\n    }, Yo.prototype.touchmove = function (t, e, i) {\n      if (this._firstTwoTouches) {\n        t.preventDefault();\n        var o = this._firstTwoTouches,\n            r = o[1],\n            a = Jo(i, e, o[0]),\n            n = Jo(i, e, r);\n\n        if (a && n) {\n          var s = this._aroundCenter ? null : a.add(n).div(2);\n          return this._move([a, n], s, t);\n        }\n      }\n    }, Yo.prototype.touchend = function (t, e, o) {\n      if (this._firstTwoTouches) {\n        var r = this._firstTwoTouches,\n            a = r[1],\n            n = Jo(o, e, r[0]),\n            s = Jo(o, e, a);\n        n && s || (this._active && i.suppressClick(), this.reset());\n      }\n    }, Yo.prototype.touchcancel = function () {\n      this.reset();\n    }, Yo.prototype.enable = function (t) {\n      this._enabled = !0, this._aroundCenter = !!t && "center" === t.around;\n    }, Yo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Yo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Yo.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var $o = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._distance, delete this._startDistance;\n      }, e.prototype._start = function (t) {\n        this._startDistance = this._distance = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._distance;\n        if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Qo(this._distance, i),\n          pinchAround: e\n        };\n      }, e;\n    }(Yo);\n\n    function tr(t, e) {\n      return 180 * t.angleWith(e) / Math.PI;\n    }\n\n    var er = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;\n      }, e.prototype._start = function (t) {\n        this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._vector;\n        if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {\n          bearingDelta: tr(this._vector, i),\n          pinchAround: e\n        };\n      }, e.prototype._isBelowThreshold = function (t) {\n        this._minDiameter = Math.min(this._minDiameter, t.mag());\n        var e = 25 / (Math.PI * this._minDiameter) * 360,\n            i = tr(t, this._startVector);\n        return Math.abs(i) < e;\n      }, e;\n    }(Yo);\n\n    function ir(t) {\n      return Math.abs(t.y) > Math.abs(t.x);\n    }\n\n    var or = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;\n      }, e.prototype._start = function (t) {\n        this._lastPoints = t, ir(t[0].sub(t[1])) && (this._valid = !1);\n      }, e.prototype._move = function (t, e, i) {\n        var o = t[0].sub(this._lastPoints[0]),\n            r = t[1].sub(this._lastPoints[1]);\n        if (this._valid = this.gestureBeginsVertically(o, r, i.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, {\n          pitchDelta: (o.y + r.y) / 2 * -.5\n        };\n      }, e.prototype.gestureBeginsVertically = function (t, e, i) {\n        if (void 0 !== this._valid) return this._valid;\n        var o = t.mag() >= 2,\n            r = e.mag() >= 2;\n\n        if (o || r) {\n          if (!o || !r) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n          var a = t.y > 0 == e.y > 0;\n          return ir(t) && ir(e) && a;\n        }\n      }, e;\n    }(Yo),\n        rr = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    },\n        ar = function ar() {\n      var t = rr;\n      this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;\n    };\n\n    function nr(t) {\n      return t * (2 - t);\n    }\n\n    ar.prototype.reset = function () {\n      this._active = !1;\n    }, ar.prototype.keydown = function (t) {\n      var e = this;\n\n      if (!(t.altKey || t.ctrlKey || t.metaKey)) {\n        var i = 0,\n            o = 0,\n            r = 0,\n            a = 0,\n            n = 0;\n\n        switch (t.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            i = 1;\n            break;\n\n          case 189:\n          case 109:\n          case 173:\n            i = -1;\n            break;\n\n          case 37:\n            t.shiftKey ? o = -1 : (t.preventDefault(), a = -1);\n            break;\n\n          case 39:\n            t.shiftKey ? o = 1 : (t.preventDefault(), a = 1);\n            break;\n\n          case 38:\n            t.shiftKey ? r = 1 : (t.preventDefault(), n = -1);\n            break;\n\n          case 40:\n            t.shiftKey ? r = -1 : (t.preventDefault(), n = 1);\n            break;\n\n          default:\n            return;\n        }\n\n        return this._rotationDisabled && (o = 0, r = 0), {\n          cameraAnimation: function cameraAnimation(s) {\n            var l = s.getZoom();\n            s.easeTo({\n              duration: 300,\n              easeId: "keyboardHandler",\n              easing: nr,\n              zoom: i ? Math.round(l) + i * (t.shiftKey ? 2 : 1) : l,\n              bearing: s.getBearing() + o * e._bearingStep,\n              pitch: s.getPitch() + r * e._pitchStep,\n              offset: [-a * e._panStep, -n * e._panStep],\n              center: s.getCenter()\n            }, {\n              originalEvent: t\n            });\n          }\n        };\n      }\n    }, ar.prototype.enable = function () {\n      this._enabled = !0;\n    }, ar.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ar.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ar.prototype.isActive = function () {\n      return this._active;\n    }, ar.prototype.disableRotation = function () {\n      this._rotationDisabled = !0;\n    }, ar.prototype.enableRotation = function () {\n      this._rotationDisabled = !1;\n    };\n\n    var sr = function sr(e, i) {\n      this._map = e, this._el = e.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);\n    };\n\n    sr.prototype.setZoomRate = function (t) {\n      this._defaultZoomRate = t;\n    }, sr.prototype.setWheelZoomRate = function (t) {\n      this._wheelZoomRate = t;\n    }, sr.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, sr.prototype.isActive = function () {\n      return !!this._active || void 0 !== this._finishTimeout;\n    }, sr.prototype.isZooming = function () {\n      return !!this._zooming;\n    }, sr.prototype.enable = function (t) {\n      this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around);\n    }, sr.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, sr.prototype.wheel = function (e) {\n      if (this.isEnabled()) {\n        var i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY,\n            o = t.browser.now(),\n            r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();\n      }\n    }, sr.prototype._onTimeout = function (t) {\n      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);\n    }, sr.prototype._start = function (e) {\n      if (this._delta) {\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        var o = i.mousePos(this._el, e);\n        this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n    }, sr.prototype.renderFrame = function () {\n      var e = this;\n\n      if (this._frameId && (this._frameId = null, this.isActive())) {\n        var i = this._map.transform;\n\n        if (0 !== this._delta) {\n          var o = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate,\n              r = 2 / (1 + Math.exp(-Math.abs(this._delta * o)));\n          this._delta < 0 && 0 !== r && (r = 1 / r);\n          var a = "number" == typeof this._targetZoom ? i.zoomScale(this._targetZoom) : i.scale;\n          this._targetZoom = Math.min(i.maxZoom, Math.max(i.minZoom, i.scaleZoom(a * r))), "wheel" === this._type && (this._startZoom = i.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n\n        var n,\n            s = "number" == typeof this._targetZoom ? this._targetZoom : i.zoom,\n            l = this._startZoom,\n            c = this._easing,\n            u = !1;\n\n        if ("wheel" === this._type && l && c) {\n          var h = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1),\n              p = c(h);\n          n = t.number(l, s, p), h < 1 ? this._frameId || (this._frameId = !0) : u = !0;\n        } else n = s, u = !0;\n\n        return this._active = !0, u && (this._active = !1, this._finishTimeout = setTimeout(function () {\n          e._zooming = !1, e._handler._triggerRenderFrame(), delete e._targetZoom, delete e._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !u,\n          zoomDelta: n - i.zoom,\n          around: this._aroundPoint,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n    }, sr.prototype._smoothOutEasing = function (e) {\n      var i = t.ease;\n\n      if (this._prevEase) {\n        var o = this._prevEase,\n            r = (t.browser.now() - o.start) / o.duration,\n            a = o.easing(r + .01) - o.easing(r),\n            n = .27 / Math.sqrt(a * a + 1e-4) * .01,\n            s = Math.sqrt(.0729 - n * n);\n        i = t.bezier(n, s, .25, 1);\n      }\n\n      return this._prevEase = {\n        start: t.browser.now(),\n        duration: e,\n        easing: i\n      }, i;\n    }, sr.prototype.reset = function () {\n      this._active = !1;\n    };\n\n    var lr = function lr(t, e) {\n      this._clickZoom = t, this._tapZoom = e;\n    };\n\n    lr.prototype.enable = function () {\n      this._clickZoom.enable(), this._tapZoom.enable();\n    }, lr.prototype.disable = function () {\n      this._clickZoom.disable(), this._tapZoom.disable();\n    }, lr.prototype.isEnabled = function () {\n      return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n    }, lr.prototype.isActive = function () {\n      return this._clickZoom.isActive() || this._tapZoom.isActive();\n    };\n\n    var cr = function cr() {\n      this.reset();\n    };\n\n    cr.prototype.reset = function () {\n      this._active = !1;\n    }, cr.prototype.dblclick = function (t, e) {\n      return t.preventDefault(), {\n        cameraAnimation: function cameraAnimation(i) {\n          i.easeTo({\n            duration: 300,\n            zoom: i.getZoom() + (t.shiftKey ? -1 : 1),\n            around: i.unproject(e)\n          }, {\n            originalEvent: t\n          });\n        }\n      };\n    }, cr.prototype.enable = function () {\n      this._enabled = !0;\n    }, cr.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, cr.prototype.isEnabled = function () {\n      return this._enabled;\n    }, cr.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var ur = function ur() {\n      this._tap = new qo({\n        numTouches: 1,\n        numTaps: 1\n      }), this.reset();\n    };\n\n    ur.prototype.reset = function () {\n      this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();\n    }, ur.prototype.touchstart = function (t, e, i) {\n      this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i));\n    }, ur.prototype.touchmove = function (t, e, i) {\n      if (this._tapTime) {\n        if (this._swipePoint) {\n          if (i[0].identifier !== this._swipeTouch) return;\n          var o = e[0],\n              r = o.y - this._swipePoint.y;\n          return this._swipePoint = o, t.preventDefault(), this._active = !0, {\n            zoomDelta: r / 128\n          };\n        }\n      } else this._tap.touchmove(t, e, i);\n    }, ur.prototype.touchend = function (t, e, i) {\n      this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp);\n    }, ur.prototype.touchcancel = function () {\n      this.reset();\n    }, ur.prototype.enable = function () {\n      this._enabled = !0;\n    }, ur.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ur.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ur.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var hr = function hr(t, e, i) {\n      this._el = t, this._mousePan = e, this._touchPan = i;\n    };\n\n    hr.prototype.enable = function (t) {\n      this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");\n    }, hr.prototype.disable = function () {\n      this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");\n    }, hr.prototype.isEnabled = function () {\n      return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n    }, hr.prototype.isActive = function () {\n      return this._mousePan.isActive() || this._touchPan.isActive();\n    };\n\n    var pr = function pr(t, e, i) {\n      this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = i;\n    };\n\n    pr.prototype.enable = function () {\n      this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n    }, pr.prototype.disable = function () {\n      this._mouseRotate.disable(), this._mousePitch.disable();\n    }, pr.prototype.isEnabled = function () {\n      return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n    }, pr.prototype.isActive = function () {\n      return this._mouseRotate.isActive() || this._mousePitch.isActive();\n    };\n\n    var dr = function dr(t, e, i, o) {\n      this._el = t, this._touchZoom = e, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n    };\n\n    dr.prototype.enable = function (t) {\n      this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");\n    }, dr.prototype.disable = function () {\n      this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");\n    }, dr.prototype.isEnabled = function () {\n      return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n    }, dr.prototype.isActive = function () {\n      return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n    }, dr.prototype.disableRotation = function () {\n      this._rotationDisabled = !0, this._touchRotate.disable();\n    }, dr.prototype.enableRotation = function () {\n      this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n    };\n\n    var _r = function _r(t) {\n      return t.zoom || t.drag || t.pitch || t.rotate;\n    },\n        fr = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(t.Event);\n\n    function mr(t) {\n      return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta;\n    }\n\n    var gr = function gr(e, o) {\n      this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e), this._bearingSnap = o.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o), t.bindAll(["handleEvent", "handleWindowEvent"], this);\n      var r = this._el;\n      this._listeners = [[r, "touchstart", {\n        passive: !0\n      }], [r, "touchmove", {\n        passive: !1\n      }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [t.window.document, "mousemove", {\n        capture: !0\n      }], [t.window.document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", {\n        capture: !1\n      }], [r, "keyup", void 0], [r, "wheel", {\n        passive: !1\n      }], [r, "contextmenu", void 0], [t.window, "blur", void 0]];\n\n      for (var a = 0, n = this._listeners; a < n.length; a += 1) {\n        var s = n[a],\n            l = s[0];\n        i.addEventListener(l, s[1], l === t.window.document ? this.handleWindowEvent : this.handleEvent, s[2]);\n      }\n    };\n\n    gr.prototype.destroy = function () {\n      for (var e = 0, o = this._listeners; e < o.length; e += 1) {\n        var r = o[e],\n            a = r[0];\n        i.removeEventListener(a, r[1], a === t.window.document ? this.handleWindowEvent : this.handleEvent, r[2]);\n      }\n    }, gr.prototype._addDefaultHandlers = function (t) {\n      var e = this._map,\n          i = e.getCanvasContainer();\n\n      this._add("mapEvent", new Oo(e, t));\n\n      var o = e.boxZoom = new Uo(e, t);\n\n      this._add("boxZoom", o);\n\n      var r = new jo(),\n          a = new cr();\n      e.doubleClickZoom = new lr(a, r), this._add("tapZoom", r), this._add("clickZoom", a);\n      var n = new ur();\n\n      this._add("tapDragZoom", n);\n\n      var s = e.touchPitch = new or();\n\n      this._add("touchPitch", s);\n\n      var l = new Xo(t),\n          c = new Ho(t);\n      e.dragRotate = new pr(t, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);\n      var u = new Wo(t),\n          h = new Ko(t);\n      e.dragPan = new hr(i, u, h), this._add("mousePan", u), this._add("touchPan", h, ["touchZoom", "touchRotate"]);\n      var p = new er(),\n          d = new $o();\n      e.touchZoomRotate = new dr(i, d, p, n), this._add("touchRotate", p, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]);\n\n      var _ = e.scrollZoom = new sr(e, this);\n\n      this._add("scrollZoom", _, ["mousePan"]);\n\n      var f = e.keyboard = new ar();\n      this._add("keyboard", f), this._add("blockableMapEvent", new Fo(e));\n\n      for (var m = 0, g = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m < g.length; m += 1) {\n        var v = g[m];\n        t.interactive && t[v] && e[v].enable(t[v]);\n      }\n    }, gr.prototype._add = function (t, e, i) {\n      this._handlers.push({\n        handlerName: t,\n        handler: e,\n        allowed: i\n      }), this._handlersById[t] = e;\n    }, gr.prototype.stop = function (t) {\n      if (!this._updatingCamera) {\n        for (var e = 0, i = this._handlers; e < i.length; e += 1) {\n          i[e].handler.reset();\n        }\n\n        this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];\n      }\n    }, gr.prototype.isActive = function () {\n      for (var t = 0, e = this._handlers; t < e.length; t += 1) {\n        if (e[t].handler.isActive()) return !0;\n      }\n\n      return !1;\n    }, gr.prototype.isZooming = function () {\n      return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n    }, gr.prototype.isRotating = function () {\n      return !!this._eventsInProgress.rotate;\n    }, gr.prototype.isMoving = function () {\n      return Boolean(_r(this._eventsInProgress)) || this.isZooming();\n    }, gr.prototype._blockedByActive = function (t, e, i) {\n      for (var o in t) {\n        if (o !== i && (!e || e.indexOf(o) < 0)) return !0;\n      }\n\n      return !1;\n    }, gr.prototype.handleWindowEvent = function (t) {\n      this.handleEvent(t, t.type + "Window");\n    }, gr.prototype._getMapTouches = function (t) {\n      for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n        var r = o[i];\n        this._el.contains(r.target) && e.push(r);\n      }\n\n      return e;\n    }, gr.prototype.handleEvent = function (t, e) {\n      if ("blur" !== t.type) {\n        this._updatingCamera = !0;\n\n        for (var o = "renderFrame" === t.type ? void 0 : t, r = {\n          needsRenderFrame: !1\n        }, a = {}, n = {}, s = t.touches ? this._getMapTouches(t.touches) : void 0, l = s ? i.touchPos(this._el, s) : i.mousePos(this._el, t), c = 0, u = this._handlers; c < u.length; c += 1) {\n          var h = u[c],\n              p = h.handlerName,\n              d = h.handler,\n              _ = h.allowed;\n\n          if (d.isEnabled()) {\n            var f = void 0;\n            this._blockedByActive(n, _, p) ? d.reset() : d[e || t.type] && (f = d[e || t.type](t, l, s), this.mergeHandlerResult(r, a, f, p, o), f && f.needsRenderFrame && this._triggerRenderFrame()), (f || d.isActive()) && (n[p] = d);\n          }\n        }\n\n        var m = {};\n\n        for (var g in this._previousActiveHandlers) {\n          n[g] || (m[g] = o);\n        }\n\n        this._previousActiveHandlers = n, (Object.keys(m).length || mr(r)) && (this._changes.push([r, a, m]), this._triggerRenderFrame()), (Object.keys(n).length || mr(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        var v = r.cameraAnimation;\n        v && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], v(this._map));\n      } else this.stop(!0);\n    }, gr.prototype.mergeHandlerResult = function (e, i, o, r, a) {\n      if (o) {\n        t.extend(e, o);\n        var n = {\n          handlerName: r,\n          originalEvent: o.originalEvent || a\n        };\n        void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);\n      }\n    }, gr.prototype._applyChanges = function () {\n      for (var e = {}, i = {}, o = {}, r = 0, a = this._changes; r < a.length; r += 1) {\n        var n = a[r],\n            s = n[0],\n            l = n[1],\n            c = n[2];\n        s.panDelta && (e.panDelta = (e.panDelta || new t.Point(0, 0))._add(s.panDelta)), s.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (e.around = s.around), void 0 !== s.pinchAround && (e.pinchAround = s.pinchAround), s.noInertia && (e.noInertia = s.noInertia), t.extend(i, l), t.extend(o, c);\n      }\n\n      this._updateMapTransform(e, i, o), this._changes = [];\n    }, gr.prototype._updateMapTransform = function (t, e, i) {\n      var o = this._map,\n          r = o.transform;\n      if (!mr(t)) return this._fireEvents(e, i, !0);\n      var a = t.panDelta,\n          n = t.zoomDelta,\n          s = t.bearingDelta,\n          l = t.pitchDelta,\n          c = t.around,\n          u = t.pinchAround;\n      void 0 !== u && (c = u), o._stop(!0), c = c || o.transform.centerPoint;\n      var h = r.pointLocation(a ? c.sub(a) : c);\n      s && (r.bearing += s), l && (r.pitch += l), n && (r.zoom += n), r.setLocationAtPoint(h, c), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, i, !0);\n    }, gr.prototype._fireEvents = function (e, i, o) {\n      var r = this,\n          a = _r(this._eventsInProgress),\n          n = _r(e),\n          s = {};\n\n      for (var l in e) {\n        this._eventsInProgress[l] || (s[l + "start"] = e[l].originalEvent), this._eventsInProgress[l] = e[l];\n      }\n\n      for (var c in !a && n && this._fireEvent("movestart", n.originalEvent), s) {\n        this._fireEvent(c, s[c]);\n      }\n\n      for (var u in n && this._fireEvent("move", n.originalEvent), e) {\n        this._fireEvent(u, e[u].originalEvent);\n      }\n\n      var h,\n          p = {};\n\n      for (var d in this._eventsInProgress) {\n        var _ = this._eventsInProgress[d],\n            f = _.handlerName,\n            m = _.originalEvent;\n        this._handlersById[f].isActive() || (delete this._eventsInProgress[d], p[d + "end"] = h = i[f] || m);\n      }\n\n      for (var g in p) {\n        this._fireEvent(g, p[g]);\n      }\n\n      var v = _r(this._eventsInProgress);\n\n      if (o && (a || n) && !v) {\n        this._updatingCamera = !0;\n\n        var y = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            x = function x(t) {\n          return 0 !== t && -r._bearingSnap < t && t < r._bearingSnap;\n        };\n\n        y ? (x(y.bearing || this._map.getBearing()) && (y.bearing = 0), this._map.easeTo(y, {\n          originalEvent: h\n        })) : (this._map.fire(new t.Event("moveend", {\n          originalEvent: h\n        })), x(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n      }\n    }, gr.prototype._fireEvent = function (e, i) {\n      this._map.fire(new t.Event(e, i ? {\n        originalEvent: i\n      } : {}));\n    }, gr.prototype._requestFrame = function () {\n      var t = this;\n      return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function (e) {\n        delete t._frameId, t.handleEvent(new fr("renderFrame", {\n          timeStamp: e\n        })), t._applyChanges();\n      });\n    }, gr.prototype._triggerRenderFrame = function () {\n      void 0 === this._frameId && (this._frameId = this._requestFrame());\n    };\n\n    var vr = function (e) {\n      function i(i, o) {\n        e.call(this), this._moving = !1, this._zooming = !1, this.transform = i, this._bearingSnap = o.bearingSnap, t.bindAll(["_renderFrameCallback"], this);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getCenter = function () {\n        return new t.LngLat(this.transform.center.lng, this.transform.center.lat);\n      }, i.prototype.setCenter = function (t, e) {\n        return this.jumpTo({\n          center: t\n        }, e);\n      }, i.prototype.panBy = function (e, i, o) {\n        return e = t.Point.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({\n          offset: e\n        }, i), o);\n      }, i.prototype.panTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          center: e\n        }, i), o);\n      }, i.prototype.getZoom = function () {\n        return this.transform.zoom;\n      }, i.prototype.setZoom = function (t, e) {\n        return this.jumpTo({\n          zoom: t\n        }, e), this;\n      }, i.prototype.zoomTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          zoom: e\n        }, i), o);\n      }, i.prototype.zoomIn = function (t, e) {\n        return this.zoomTo(this.getZoom() + 1, t, e), this;\n      }, i.prototype.zoomOut = function (t, e) {\n        return this.zoomTo(this.getZoom() - 1, t, e), this;\n      }, i.prototype.getBearing = function () {\n        return this.transform.bearing;\n      }, i.prototype.setBearing = function (t, e) {\n        return this.jumpTo({\n          bearing: t\n        }, e), this;\n      }, i.prototype.getPadding = function () {\n        return this.transform.padding;\n      }, i.prototype.setPadding = function (t, e) {\n        return this.jumpTo({\n          padding: t\n        }, e), this;\n      }, i.prototype.rotateTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          bearing: e\n        }, i), o);\n      }, i.prototype.resetNorth = function (e, i) {\n        return this.rotateTo(0, t.extend({\n          duration: 1e3\n        }, e), i), this;\n      }, i.prototype.resetNorthPitch = function (e, i) {\n        return this.easeTo(t.extend({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, e), i), this;\n      }, i.prototype.snapToNorth = function (t, e) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this;\n      }, i.prototype.getPitch = function () {\n        return this.transform.pitch;\n      }, i.prototype.setPitch = function (t, e) {\n        return this.jumpTo({\n          pitch: t\n        }, e), this;\n      }, i.prototype.cameraForBounds = function (e, i) {\n        e = t.LngLatBounds.convert(e);\n        var o = i && i.bearing || 0;\n        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i);\n      }, i.prototype._cameraForBoxAndBearing = function (e, i, o, r) {\n        var a = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n\n        if ("number" == typeof (r = t.extend({\n          padding: a,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, r)).padding) {\n          var n = r.padding;\n          r.padding = {\n            top: n,\n            bottom: n,\n            right: n,\n            left: n\n          };\n        }\n\n        r.padding = t.extend(a, r.padding);\n\n        var s = this.transform,\n            l = s.padding,\n            c = s.project(t.LngLat.convert(e)),\n            u = s.project(t.LngLat.convert(i)),\n            h = c.rotate(-o * Math.PI / 180),\n            p = u.rotate(-o * Math.PI / 180),\n            d = new t.Point(Math.max(h.x, p.x), Math.max(h.y, p.y)),\n            _ = new t.Point(Math.min(h.x, p.x), Math.min(h.y, p.y)),\n            f = d.sub(_),\n            m = (s.width - (l.left + l.right + r.padding.left + r.padding.right)) / f.x,\n            g = (s.height - (l.top + l.bottom + r.padding.top + r.padding.bottom)) / f.y;\n\n        if (!(g < 0 || m < 0)) {\n          var v = Math.min(s.scaleZoom(s.scale * Math.min(m, g)), r.maxZoom),\n              y = "number" == typeof r.offset.x ? new t.Point(r.offset.x, r.offset.y) : t.Point.convert(r.offset),\n              x = new t.Point((r.padding.left - r.padding.right) / 2, (r.padding.top - r.padding.bottom) / 2).rotate(o * Math.PI / 180),\n              b = y.add(x).mult(s.scale / s.zoomScale(v));\n          return {\n            center: s.unproject(c.add(u).div(2).sub(b)),\n            zoom: v,\n            bearing: o\n          };\n        }\n\n        t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");\n      }, i.prototype.fitBounds = function (t, e, i) {\n        return this._fitInternal(this.cameraForBounds(t, e), e, i);\n      }, i.prototype.fitScreenCoordinates = function (e, i, o, r, a) {\n        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)), this.transform.pointLocation(t.Point.convert(i)), o, r), r, a);\n      }, i.prototype._fitInternal = function (e, i, o) {\n        return e ? (delete (i = t.extend(e, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }, i.prototype.jumpTo = function (e, i) {\n        this.stop();\n        var o = this.transform,\n            r = !1,\n            a = !1,\n            n = !1;\n        return "zoom" in e && o.zoom !== +e.zoom && (r = !0, o.zoom = +e.zoom), void 0 !== e.center && (o.center = t.LngLat.convert(e.center)), "bearing" in e && o.bearing !== +e.bearing && (a = !0, o.bearing = +e.bearing), "pitch" in e && o.pitch !== +e.pitch && (n = !0, o.pitch = +e.pitch), null == e.padding || o.isPaddingEqual(e.padding) || (o.padding = e.padding), this.fire(new t.Event("movestart", i)).fire(new t.Event("move", i)), r && this.fire(new t.Event("zoomstart", i)).fire(new t.Event("zoom", i)).fire(new t.Event("zoomend", i)), a && this.fire(new t.Event("rotatestart", i)).fire(new t.Event("rotate", i)).fire(new t.Event("rotateend", i)), n && this.fire(new t.Event("pitchstart", i)).fire(new t.Event("pitch", i)).fire(new t.Event("pitchend", i)), this.fire(new t.Event("moveend", i));\n      }, i.prototype.easeTo = function (e, i) {\n        var o = this;\n        this._stop(!1, e.easeId), (!1 === (e = t.extend({\n          offset: [0, 0],\n          duration: 500,\n          easing: t.ease\n        }, e)).animate || !e.essential && t.browser.prefersReducedMotion) && (e.duration = 0);\n\n        var r = this.transform,\n            a = this.getZoom(),\n            n = this.getBearing(),\n            s = this.getPitch(),\n            l = this.getPadding(),\n            c = "zoom" in e ? +e.zoom : a,\n            u = "bearing" in e ? this._normalizeBearing(e.bearing, n) : n,\n            h = "pitch" in e ? +e.pitch : s,\n            p = "padding" in e ? e.padding : r.padding,\n            d = t.Point.convert(e.offset),\n            _ = r.centerPoint.add(d),\n            f = r.pointLocation(_),\n            m = t.LngLat.convert(e.center || f);\n\n        this._normalizeCenter(m);\n\n        var g,\n            v,\n            y = r.project(f),\n            x = r.project(m).sub(y),\n            b = r.zoomScale(c - a);\n        e.around && (g = t.LngLat.convert(e.around), v = r.locationPoint(g));\n        var w = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = this._zooming || c !== a, this._rotating = this._rotating || n !== u, this._pitching = this._pitching || h !== s, this._padding = !r.isPaddingEqual(p), this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, w), this._ease(function (e) {\n          if (o._zooming && (r.zoom = t.number(a, c, e)), o._rotating && (r.bearing = t.number(n, u, e)), o._pitching && (r.pitch = t.number(s, h, e)), o._padding && (r.interpolatePadding(l, p, e), _ = r.centerPoint.add(d)), g) r.setLocationAtPoint(g, v);else {\n            var f = r.zoomScale(r.zoom - a),\n                m = c > a ? Math.min(2, b) : Math.max(.5, b),\n                w = Math.pow(m, 1 - e),\n                T = r.unproject(y.add(x.mult(e * w)).mult(f));\n            r.setLocationAtPoint(r.renderWorldCopies ? T.wrap() : T, _);\n          }\n\n          o._fireMoveEvents(i);\n        }, function (t) {\n          o._afterEase(i, t);\n        }, e), this;\n      }, i.prototype._prepareEase = function (e, i, o) {\n        void 0 === o && (o = {}), this._moving = !0, i || o.moving || this.fire(new t.Event("movestart", e)), this._zooming && !o.zooming && this.fire(new t.Event("zoomstart", e)), this._rotating && !o.rotating && this.fire(new t.Event("rotatestart", e)), this._pitching && !o.pitching && this.fire(new t.Event("pitchstart", e));\n      }, i.prototype._fireMoveEvents = function (e) {\n        this.fire(new t.Event("move", e)), this._zooming && this.fire(new t.Event("zoom", e)), this._rotating && this.fire(new t.Event("rotate", e)), this._pitching && this.fire(new t.Event("pitch", e));\n      }, i.prototype._afterEase = function (e, i) {\n        if (!this._easeId || !i || this._easeId !== i) {\n          delete this._easeId;\n          var o = this._zooming,\n              r = this._rotating,\n              a = this._pitching;\n          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new t.Event("zoomend", e)), r && this.fire(new t.Event("rotateend", e)), a && this.fire(new t.Event("pitchend", e)), this.fire(new t.Event("moveend", e));\n        }\n      }, i.prototype.flyTo = function (e, i) {\n        var o = this;\n\n        if (!e.essential && t.browser.prefersReducedMotion) {\n          var r = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);\n          return this.jumpTo(r, i);\n        }\n\n        this.stop(), e = t.extend({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: t.ease\n        }, e);\n\n        var a = this.transform,\n            n = this.getZoom(),\n            s = this.getBearing(),\n            l = this.getPitch(),\n            c = this.getPadding(),\n            u = "zoom" in e ? t.clamp(+e.zoom, a.minZoom, a.maxZoom) : n,\n            h = "bearing" in e ? this._normalizeBearing(e.bearing, s) : s,\n            p = "pitch" in e ? +e.pitch : l,\n            d = "padding" in e ? e.padding : a.padding,\n            _ = a.zoomScale(u - n),\n            f = t.Point.convert(e.offset),\n            m = a.centerPoint.add(f),\n            g = a.pointLocation(m),\n            v = t.LngLat.convert(e.center || g);\n\n        this._normalizeCenter(v);\n\n        var y = a.project(g),\n            x = a.project(v).sub(y),\n            b = e.curve,\n            w = Math.max(a.width, a.height),\n            T = w / _,\n            E = x.mag();\n\n        if ("minZoom" in e) {\n          var I = t.clamp(Math.min(e.minZoom, n, u), a.minZoom, a.maxZoom),\n              P = w / a.zoomScale(I - n);\n          b = Math.sqrt(P / E * 2);\n        }\n\n        var S = b * b;\n\n        function C(t) {\n          var e = (T * T - w * w + (t ? -1 : 1) * S * S * E * E) / (2 * (t ? T : w) * S * E);\n          return Math.log(Math.sqrt(e * e + 1) - e);\n        }\n\n        function z(t) {\n          return (Math.exp(t) - Math.exp(-t)) / 2;\n        }\n\n        function D(t) {\n          return (Math.exp(t) + Math.exp(-t)) / 2;\n        }\n\n        var A = C(0),\n            M = function M(t) {\n          return D(A) / D(A + b * t);\n        },\n            L = function L(t) {\n          return w * ((D(A) * (z(e = A + b * t) / D(e)) - z(A)) / S) / E;\n          var e;\n        },\n            R = (C(1) - A) / b;\n\n        if (Math.abs(E) < 1e-6 || !isFinite(R)) {\n          if (Math.abs(w - T) < 1e-6) return this.easeTo(e, i);\n          var k = T < w ? -1 : 1;\n          R = Math.abs(Math.log(T / w)) / b, L = function L() {\n            return 0;\n          }, M = function M(t) {\n            return Math.exp(k * b * t);\n          };\n        }\n\n        return e.duration = "duration" in e ? +e.duration : 1e3 * R / ("screenSpeed" in e ? +e.screenSpeed / b : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== h, this._pitching = p !== l, this._padding = !a.isPaddingEqual(d), this._prepareEase(i, !1), this._ease(function (e) {\n          var r = e * R,\n              _ = 1 / M(r);\n\n          a.zoom = 1 === e ? u : n + a.scaleZoom(_), o._rotating && (a.bearing = t.number(s, h, e)), o._pitching && (a.pitch = t.number(l, p, e)), o._padding && (a.interpolatePadding(c, d, e), m = a.centerPoint.add(f));\n          var g = 1 === e ? v : a.unproject(y.add(x.mult(L(r))).mult(_));\n          a.setLocationAtPoint(a.renderWorldCopies ? g.wrap() : g, m), o._fireMoveEvents(i);\n        }, function () {\n          return o._afterEase(i);\n        }, e), this;\n      }, i.prototype.isEasing = function () {\n        return !!this._easeFrameId;\n      }, i.prototype.stop = function () {\n        return this._stop();\n      }, i.prototype._stop = function (t, e) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {\n          var i = this._onEaseEnd;\n          delete this._onEaseEnd, i.call(this, e);\n        }\n\n        if (!t) {\n          var o = this.handlers;\n          o && o.stop(!1);\n        }\n\n        return this;\n      }, i.prototype._ease = function (e, i, o) {\n        !1 === o.animate || 0 === o.duration ? (e(1), i()) : (this._easeStart = t.browser.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }, i.prototype._renderFrameCallback = function () {\n        var e = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n        this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }, i.prototype._normalizeBearing = function (e, i) {\n        e = t.wrap(e, -180, 180);\n        var o = Math.abs(e - i);\n        return Math.abs(e - 360 - i) < o && (e -= 360), Math.abs(e + 360 - i) < o && (e += 360), e;\n      }, i.prototype._normalizeCenter = function (t) {\n        var e = this.transform;\n\n        if (e.renderWorldCopies && !e.lngRange) {\n          var i = t.lng - e.center.lng;\n          t.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n        }\n      }, i;\n    }(t.Evented),\n        yr = function yr(e) {\n      void 0 === e && (e = {}), this.options = e, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);\n    };\n\n    yr.prototype.getDefaultPosition = function () {\n      return "bottom-right";\n    }, yr.prototype.onAdd = function (t) {\n      var e = this.options && this.options.compact;\n      return this._map = t, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;\n    }, yr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n    }, yr.prototype._setElementTitle = function (t, e) {\n      var i = this._map._getUIString("AttributionControl." + e);\n\n      t.title = i, t.setAttribute("aria-label", i);\n    }, yr.prototype._toggleAttribution = function () {\n      this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));\n    }, yr.prototype._updateEditLink = function () {\n      var e = this._editLink;\n      e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map"));\n      var i = [{\n        key: "owner",\n        value: this.styleOwner\n      }, {\n        key: "id",\n        value: this.styleId\n      }, {\n        key: "access_token",\n        value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN\n      }];\n\n      if (e) {\n        var o = i.reduce(function (t, e, o) {\n          return e.value && (t += e.key + "=" + e.value + (o < i.length - 1 ? "&" : "")), t;\n        }, "?");\n        e.href = t.config.FEEDBACK_URL + "/" + o + (this._map._hash ? this._map._hash.getHashString(!0) : ""), e.rel = "noopener nofollow", this._setElementTitle(e, "MapFeedback");\n      }\n    }, yr.prototype._updateData = function (t) {\n      !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(), this._updateEditLink());\n    }, yr.prototype._updateAttributions = function () {\n      if (this._map.style) {\n        var t = [];\n\n        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(function (t) {\n          return "string" != typeof t ? "" : t;\n        })) : "string" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) {\n          var e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n\n        var i = this._map.style.sourceCaches;\n\n        for (var o in i) {\n          var r = i[o];\n\n          if (r.used) {\n            var a = r.getSource();\n            a.attribution && t.indexOf(a.attribution) < 0 && t.push(a.attribution);\n          }\n        }\n\n        t.sort(function (t, e) {\n          return t.length - e.length;\n        });\n        var n = (t = t.filter(function (e, i) {\n          for (var o = i + 1; o < t.length; o++) {\n            if (t[o].indexOf(e) >= 0) return !1;\n          }\n\n          return !0;\n        })).join(" | ");\n        n !== this._attribHTML && (this._attribHTML = n, t.length ? (this._innerContainer.innerHTML = n, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);\n      }\n    }, yr.prototype._updateCompact = function () {\n      this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");\n    };\n\n    var xr = function xr() {\n      t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);\n    };\n\n    xr.prototype.onAdd = function (t) {\n      this._map = t, this._container = i.create("div", "mapboxgl-ctrl");\n      var e = i.create("a", "mapboxgl-ctrl-logo");\n      return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://www.mapbox.com/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;\n    }, xr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);\n    }, xr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, xr.prototype._updateLogo = function (t) {\n      t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");\n    }, xr.prototype._logoRequired = function () {\n      if (this._map.style) {\n        var t = this._map.style.sourceCaches;\n\n        for (var e in t) {\n          if (t[e].getSource().mapbox_logo) return !0;\n        }\n\n        return !1;\n      }\n    }, xr.prototype._updateCompact = function () {\n      var t = this._container.children;\n\n      if (t.length) {\n        var e = t[0];\n        this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("mapboxgl-compact") : e.classList.remove("mapboxgl-compact");\n      }\n    };\n\n    var br = function br() {\n      this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n    };\n\n    br.prototype.add = function (t) {\n      var e = ++this._id;\n      return this._queue.push({\n        callback: t,\n        id: e,\n        cancelled: !1\n      }), e;\n    }, br.prototype.remove = function (t) {\n      for (var e = this._currentlyRunning, i = 0, o = e ? this._queue.concat(e) : this._queue; i < o.length; i += 1) {\n        var r = o[i];\n        if (r.id === t) return void (r.cancelled = !0);\n      }\n    }, br.prototype.run = function (t) {\n      void 0 === t && (t = 0);\n      var e = this._currentlyRunning = this._queue;\n      this._queue = [];\n\n      for (var i = 0, o = e; i < o.length; i += 1) {\n        var r = o[i];\n        if (!r.cancelled && (r.callback(t), this._cleared)) break;\n      }\n\n      this._cleared = !1, this._currentlyRunning = !1;\n    }, br.prototype.clear = function () {\n      this._currentlyRunning && (this._cleared = !0), this._queue = [];\n    };\n\n    var wr = {\n      "AttributionControl.ToggleAttribution": "Toggle attribution",\n      "AttributionControl.MapFeedback": "Map feedback",\n      "FullscreenControl.Enter": "Enter fullscreen",\n      "FullscreenControl.Exit": "Exit fullscreen",\n      "GeolocateControl.FindMyLocation": "Find my location",\n      "GeolocateControl.LocationNotAvailable": "Location not available",\n      "LogoControl.Title": "Mapbox logo",\n      "NavigationControl.ResetBearing": "Reset bearing to north",\n      "NavigationControl.ZoomIn": "Zoom in",\n      "NavigationControl.ZoomOut": "Zoom out",\n      "ScaleControl.Feet": "ft",\n      "ScaleControl.Meters": "m",\n      "ScaleControl.Kilometers": "km",\n      "ScaleControl.Miles": "mi",\n      "ScaleControl.NauticalMiles": "nm"\n    },\n        Tr = t.window.HTMLImageElement,\n        Er = t.window.HTMLElement,\n        Ir = t.window.ImageBitmap,\n        Pr = {\n      center: [0, 0],\n      zoom: 0,\n      bearing: 0,\n      pitch: 0,\n      minZoom: -2,\n      maxZoom: 22,\n      minPitch: 0,\n      maxPitch: 60,\n      interactive: !0,\n      scrollZoom: !0,\n      boxZoom: !0,\n      dragRotate: !0,\n      dragPan: !0,\n      keyboard: !0,\n      doubleClickZoom: !0,\n      touchZoomRotate: !0,\n      touchPitch: !0,\n      bearingSnap: 7,\n      clickTolerance: 3,\n      pitchWithRotate: !0,\n      hash: !1,\n      attributionControl: !0,\n      failIfMajorPerformanceCaveat: !1,\n      preserveDrawingBuffer: !1,\n      trackResize: !0,\n      renderWorldCopies: !0,\n      refreshExpiredTiles: !0,\n      maxTileCacheSize: null,\n      localIdeographFontFamily: "sans-serif",\n      transformRequest: null,\n      accessToken: null,\n      fadeDuration: 300,\n      crossSourceCollisions: !0\n    },\n        Sr = function (o) {\n      function r(e) {\n        var i = this;\n        if (null != (e = t.extend({}, Pr, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");\n        if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");\n        if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");\n        if (null != e.maxPitch && e.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60");\n        var r = new To(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies);\n\n        if (o.call(this, r, e), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e.locale), this._clickTolerance = e.clickTolerance, this._requestManager = new t.RequestManager(e.transformRequest, e.accessToken), "string" == typeof e.container) {\n          if (this._container = t.window.document.getElementById(e.container), !this._container) throw new Error("Container \'" + e.container + "\' not found.");\n        } else {\n          if (!(e.container instanceof Er)) throw new Error("Invalid type: \'container\' must be a String or HTMLElement.");\n          this._container = e.container;\n        }\n\n        if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");\n        this.on("move", function () {\n          return i._update(!1);\n        }), this.on("moveend", function () {\n          return i._update(!1);\n        }), this.on("zoom", function () {\n          return i._update(!0);\n        }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1), t.window.addEventListener("resize", this._onWindowResize, !1), t.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new gr(this, e), this._hash = e.hash && new Io("string" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n          center: e.center,\n          zoom: e.zoom,\n          bearing: e.bearing,\n          pitch: e.pitch\n        }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {\n          duration: 0\n        })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, {\n          localIdeographFontFamily: e.localIdeographFontFamily\n        }), e.attributionControl && this.addControl(new yr({\n          customAttribution: e.customAttribution\n        })), this.addControl(new xr(), e.logoPosition), this.on("style.load", function () {\n          i.transform.unmodified && i.jumpTo(i.style.stylesheet);\n        }), this.on("data", function (e) {\n          i._update("style" === e.dataType), i.fire(new t.Event(e.dataType + "data", e));\n        }), this.on("dataloading", function (e) {\n          i.fire(new t.Event(e.dataType + "dataloading", e));\n        });\n      }\n\n      o && (r.__proto__ = o), (r.prototype = Object.create(o && o.prototype)).constructor = r;\n      var a = {\n        showTileBoundaries: {\n          configurable: !0\n        },\n        showPadding: {\n          configurable: !0\n        },\n        showCollisionBoxes: {\n          configurable: !0\n        },\n        showOverdrawInspector: {\n          configurable: !0\n        },\n        repaint: {\n          configurable: !0\n        },\n        vertices: {\n          configurable: !0\n        },\n        version: {\n          configurable: !0\n        }\n      };\n      return r.prototype._getMapId = function () {\n        return this._mapId;\n      }, r.prototype.addControl = function (e, i) {\n        if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));\n        var o = e.onAdd(this);\n\n        this._controls.push(e);\n\n        var r = this._controlPositions[i];\n        return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n      }, r.prototype.removeControl = function (e) {\n        if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));\n\n        var i = this._controls.indexOf(e);\n\n        return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this;\n      }, r.prototype.hasControl = function (t) {\n        return this._controls.indexOf(t) > -1;\n      }, r.prototype.resize = function (e) {\n        var i = this._containerDimensions(),\n            o = i[0],\n            r = i[1];\n\n        this._resizeCanvas(o, r), this.transform.resize(o, r), this.painter.resize(o, r);\n        var a = !this._moving;\n        return a && (this.stop(), this.fire(new t.Event("movestart", e)).fire(new t.Event("move", e))), this.fire(new t.Event("resize", e)), a && this.fire(new t.Event("moveend", e)), this;\n      }, r.prototype.getBounds = function () {\n        return this.transform.getBounds();\n      }, r.prototype.getMaxBounds = function () {\n        return this.transform.getMaxBounds();\n      }, r.prototype.setMaxBounds = function (e) {\n        return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update();\n      }, r.prototype.setMinZoom = function (t) {\n        if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;\n        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");\n      }, r.prototype.getMinZoom = function () {\n        return this.transform.minZoom;\n      }, r.prototype.setMaxZoom = function (t) {\n        if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;\n        throw new Error("maxZoom must be greater than the current minZoom");\n      }, r.prototype.getMaxZoom = function () {\n        return this.transform.maxZoom;\n      }, r.prototype.setMinPitch = function (t) {\n        if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");\n        if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;\n        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");\n      }, r.prototype.getMinPitch = function () {\n        return this.transform.minPitch;\n      }, r.prototype.setMaxPitch = function (t) {\n        if ((t = null == t ? 60 : t) > 60) throw new Error("maxPitch must be less than or equal to 60");\n        if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;\n        throw new Error("maxPitch must be greater than the current minPitch");\n      }, r.prototype.getMaxPitch = function () {\n        return this.transform.maxPitch;\n      }, r.prototype.getRenderWorldCopies = function () {\n        return this.transform.renderWorldCopies;\n      }, r.prototype.setRenderWorldCopies = function (t) {\n        return this.transform.renderWorldCopies = t, this._update();\n      }, r.prototype.project = function (e) {\n        return this.transform.locationPoint(t.LngLat.convert(e));\n      }, r.prototype.unproject = function (e) {\n        return this.transform.pointLocation(t.Point.convert(e));\n      }, r.prototype.isMoving = function () {\n        return this._moving || this.handlers.isMoving();\n      }, r.prototype.isZooming = function () {\n        return this._zooming || this.handlers.isZooming();\n      }, r.prototype.isRotating = function () {\n        return this._rotating || this.handlers.isRotating();\n      }, r.prototype._createDelegatedListener = function (t, e, i) {\n        var o,\n            r = this;\n\n        if ("mouseenter" === t || "mouseover" === t) {\n          var a = !1;\n          return {\n            layer: e,\n            listener: i,\n            delegates: {\n              mousemove: function mousemove(o) {\n                var n = r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                  layers: [e]\n                }) : [];\n                n.length ? a || (a = !0, i.call(r, new Ro(t, r, o.originalEvent, {\n                  features: n\n                }))) : a = !1;\n              },\n              mouseout: function mouseout() {\n                a = !1;\n              }\n            }\n          };\n        }\n\n        if ("mouseleave" === t || "mouseout" === t) {\n          var n = !1;\n          return {\n            layer: e,\n            listener: i,\n            delegates: {\n              mousemove: function mousemove(o) {\n                (r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                  layers: [e]\n                }) : []).length ? n = !0 : n && (n = !1, i.call(r, new Ro(t, r, o.originalEvent)));\n              },\n              mouseout: function mouseout(e) {\n                n && (n = !1, i.call(r, new Ro(t, r, e.originalEvent)));\n              }\n            }\n          };\n        }\n\n        return {\n          layer: e,\n          listener: i,\n          delegates: (o = {}, o[t] = function (t) {\n            var o = r.getLayer(e) ? r.queryRenderedFeatures(t.point, {\n              layers: [e]\n            }) : [];\n            o.length && (t.features = o, i.call(r, t), delete t.features);\n          }, o)\n        };\n      }, r.prototype.on = function (t, e, i) {\n        if (void 0 === i) return o.prototype.on.call(this, t, e);\n\n        var r = this._createDelegatedListener(t, e, i);\n\n        for (var a in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(r), r.delegates) {\n          this.on(a, r.delegates[a]);\n        }\n\n        return this;\n      }, r.prototype.once = function (t, e, i) {\n        if (void 0 === i) return o.prototype.once.call(this, t, e);\n\n        var r = this._createDelegatedListener(t, e, i);\n\n        for (var a in r.delegates) {\n          this.once(a, r.delegates[a]);\n        }\n\n        return this;\n      }, r.prototype.off = function (t, e, i) {\n        var r = this;\n        return void 0 === i ? o.prototype.off.call(this, t, e) : (this._delegatedListeners && this._delegatedListeners[t] && function (o) {\n          for (var a = o[t], n = 0; n < a.length; n++) {\n            var s = a[n];\n\n            if (s.layer === e && s.listener === i) {\n              for (var l in s.delegates) {\n                r.off(l, s.delegates[l]);\n              }\n\n              return a.splice(n, 1), r;\n            }\n          }\n        }(this._delegatedListeners), this);\n      }, r.prototype.queryRenderedFeatures = function (e, i) {\n        if (!this.style) return [];\n        var o;\n        if (void 0 !== i || void 0 === e || e instanceof t.Point || Array.isArray(e) || (i = e, e = void 0), i = i || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e[0]) o = [t.Point.convert(e)];else {\n          var r = t.Point.convert(e[0]),\n              a = t.Point.convert(e[1]);\n          o = [r, new t.Point(a.x, r.y), a, new t.Point(r.x, a.y), r];\n        }\n        return this.style.queryRenderedFeatures(o, i, this.transform);\n      }, r.prototype.querySourceFeatures = function (t, e) {\n        return this.style.querySourceFeatures(t, e);\n      }, r.prototype.setStyle = function (e, i) {\n        return !1 !== (i = t.extend({}, {\n          localIdeographFontFamily: this._localIdeographFontFamily\n        }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i));\n      }, r.prototype._getUIString = function (t) {\n        var e = this._locale[t];\n        if (null == e) throw new Error("Missing UI string \'" + t + "\'");\n        return e;\n      }, r.prototype._updateStyle = function (t, e) {\n        return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new je(this, e || {}), this.style.setEventedParent(this, {\n          style: this.style\n        }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this);\n      }, r.prototype._lazyInitEmptyStyle = function () {\n        this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, {\n          style: this.style\n        }), this.style.loadEmpty());\n      }, r.prototype._diffStyle = function (e, i) {\n        var o = this;\n\n        if ("string" == typeof e) {\n          var r = this._requestManager.normalizeStyleURL(e),\n              a = this._requestManager.transformRequest(r, t.ResourceType.Style);\n\n          t.getJSON(a, function (e, r) {\n            e ? o.fire(new t.ErrorEvent(e)) : r && o._updateDiff(r, i);\n          });\n        } else "object" == typeof e && this._updateDiff(e, i);\n      }, r.prototype._updateDiff = function (e, i) {\n        try {\n          this.style.setState(e) && this._update(!0);\n        } catch (o) {\n          t.warnOnce("Unable to perform style diff: " + (o.message || o.error || o) + ".  Rebuilding the style from scratch."), this._updateStyle(e, i);\n        }\n      }, r.prototype.getStyle = function () {\n        if (this.style) return this.style.serialize();\n      }, r.prototype.isStyleLoaded = function () {\n        return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");\n      }, r.prototype.addSource = function (t, e) {\n        return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0);\n      }, r.prototype.isSourceLoaded = function (e) {\n        var i = this.style && this.style.sourceCaches[e];\n        if (void 0 !== i) return i.loaded();\n        this.fire(new t.ErrorEvent(new Error("There is no source with ID \'" + e + "\'")));\n      }, r.prototype.areTilesLoaded = function () {\n        var t = this.style && this.style.sourceCaches;\n\n        for (var e in t) {\n          var i = t[e]._tiles;\n\n          for (var o in i) {\n            var r = i[o];\n            if ("loaded" !== r.state && "errored" !== r.state) return !1;\n          }\n        }\n\n        return !0;\n      }, r.prototype.addSourceType = function (t, e, i) {\n        return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, i);\n      }, r.prototype.removeSource = function (t) {\n        return this.style.removeSource(t), this._update(!0);\n      }, r.prototype.getSource = function (t) {\n        return this.style.getSource(t);\n      }, r.prototype.addImage = function (e, i, o) {\n        void 0 === o && (o = {});\n        var r = o.pixelRatio;\n        void 0 === r && (r = 1);\n        var a = o.sdf;\n        void 0 === a && (a = !1);\n        var n = o.stretchX,\n            s = o.stretchY,\n            l = o.content;\n\n        if (this._lazyInitEmptyStyle(), i instanceof Tr || Ir && i instanceof Ir) {\n          var c = t.browser.getImageData(i);\n          this.style.addImage(e, {\n            data: new t.RGBAImage({\n              width: c.width,\n              height: c.height\n            }, c.data),\n            pixelRatio: r,\n            stretchX: n,\n            stretchY: s,\n            content: l,\n            sdf: a,\n            version: 0\n          });\n        } else {\n          if (void 0 === i.width || void 0 === i.height) return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));\n          var u = i;\n          this.style.addImage(e, {\n            data: new t.RGBAImage({\n              width: i.width,\n              height: i.height\n            }, new Uint8Array(i.data)),\n            pixelRatio: r,\n            stretchX: n,\n            stretchY: s,\n            content: l,\n            sdf: a,\n            version: 0,\n            userImage: u\n          }), u.onAdd && u.onAdd(this, e);\n        }\n      }, r.prototype.updateImage = function (e, i) {\n        var o = this.style.getImage(e);\n        if (!o) return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));\n        var r = i instanceof Tr || Ir && i instanceof Ir ? t.browser.getImageData(i) : i,\n            a = r.width,\n            n = r.height,\n            s = r.data;\n        return void 0 === a || void 0 === n ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a !== o.data.width || n !== o.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o.data.replace(s, !(i instanceof Tr || Ir && i instanceof Ir)), void this.style.updateImage(e, o));\n      }, r.prototype.hasImage = function (e) {\n        return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1);\n      }, r.prototype.removeImage = function (t) {\n        this.style.removeImage(t);\n      }, r.prototype.loadImage = function (e, i) {\n        t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), i);\n      }, r.prototype.listImages = function () {\n        return this.style.listImages();\n      }, r.prototype.addLayer = function (t, e) {\n        return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0);\n      }, r.prototype.moveLayer = function (t, e) {\n        return this.style.moveLayer(t, e), this._update(!0);\n      }, r.prototype.removeLayer = function (t) {\n        return this.style.removeLayer(t), this._update(!0);\n      }, r.prototype.getLayer = function (t) {\n        return this.style.getLayer(t);\n      }, r.prototype.setLayerZoomRange = function (t, e, i) {\n        return this.style.setLayerZoomRange(t, e, i), this._update(!0);\n      }, r.prototype.setFilter = function (t, e, i) {\n        return void 0 === i && (i = {}), this.style.setFilter(t, e, i), this._update(!0);\n      }, r.prototype.getFilter = function (t) {\n        return this.style.getFilter(t);\n      }, r.prototype.setPaintProperty = function (t, e, i, o) {\n        return void 0 === o && (o = {}), this.style.setPaintProperty(t, e, i, o), this._update(!0);\n      }, r.prototype.getPaintProperty = function (t, e) {\n        return this.style.getPaintProperty(t, e);\n      }, r.prototype.setLayoutProperty = function (t, e, i, o) {\n        return void 0 === o && (o = {}), this.style.setLayoutProperty(t, e, i, o), this._update(!0);\n      }, r.prototype.getLayoutProperty = function (t, e) {\n        return this.style.getLayoutProperty(t, e);\n      }, r.prototype.setLight = function (t, e) {\n        return void 0 === e && (e = {}), this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0);\n      }, r.prototype.getLight = function () {\n        return this.style.getLight();\n      }, r.prototype.setFeatureState = function (t, e) {\n        return this.style.setFeatureState(t, e), this._update();\n      }, r.prototype.removeFeatureState = function (t, e) {\n        return this.style.removeFeatureState(t, e), this._update();\n      }, r.prototype.getFeatureState = function (t) {\n        return this.style.getFeatureState(t);\n      }, r.prototype.getContainer = function () {\n        return this._container;\n      }, r.prototype.getCanvasContainer = function () {\n        return this._canvasContainer;\n      }, r.prototype.getCanvas = function () {\n        return this._canvas;\n      }, r.prototype._containerDimensions = function () {\n        var t = 0,\n            e = 0;\n        return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e];\n      }, r.prototype._detectMissingCSS = function () {\n        "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");\n      }, r.prototype._setupContainer = function () {\n        var t = this._container;\n        t.classList.add("mapboxgl-map"), (this._missingCSSCanary = i.create("div", "mapboxgl-canary", t)).style.visibility = "hidden", this._detectMissingCSS();\n        var e = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t);\n        this._interactive && e.classList.add("mapboxgl-interactive"), this._canvas = i.create("canvas", "mapboxgl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");\n\n        var o = this._containerDimensions();\n\n        this._resizeCanvas(o[0], o[1]);\n\n        var r = this._controlContainer = i.create("div", "mapboxgl-control-container", t),\n            a = this._controlPositions = {};\n        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function (t) {\n          a[t] = i.create("div", "mapboxgl-ctrl-" + t, r);\n        }), this._container.addEventListener("scroll", this._onMapScroll, !1);\n      }, r.prototype._resizeCanvas = function (e, i) {\n        var o = t.browser.devicePixelRatio || 1;\n        this._canvas.width = o * e, this._canvas.height = o * i, this._canvas.style.width = e + "px", this._canvas.style.height = i + "px";\n      }, r.prototype._setupPainter = function () {\n        var i = t.extend({}, e.webGLContextAttributes, {\n          failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n          preserveDrawingBuffer: this._preserveDrawingBuffer,\n          antialias: this._antialias || !1\n        }),\n            o = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i);\n\n        o ? (this.painter = new yo(o, this.transform), t.webpSupported.testSupport(o)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));\n      }, r.prototype._contextLost = function (e) {\n        e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", {\n          originalEvent: e\n        }));\n      }, r.prototype._contextRestored = function (e) {\n        this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", {\n          originalEvent: e\n        }));\n      }, r.prototype._onMapScroll = function (t) {\n        if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n      }, r.prototype.loaded = function () {\n        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n      }, r.prototype._update = function (t) {\n        return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n      }, r.prototype._requestRenderFrame = function (t) {\n        return this._update(), this._renderTaskQueue.add(t);\n      }, r.prototype._cancelRenderFrame = function (t) {\n        this._renderTaskQueue.remove(t);\n      }, r.prototype._render = function (e) {\n        var i,\n            o = this,\n            r = 0,\n            a = this.painter.context.extTimerQuery;\n\n        if (this.listens("gpu-timing-frame") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), r = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), !this._removed) {\n          var n = !1;\n\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            var s = this.transform.zoom,\n                l = t.browser.now();\n            this.style.zoomHistory.update(s, l);\n            var c = new t.EvaluationParameters(s, {\n              now: l,\n              fadeDuration: this._fadeDuration,\n              zoomHistory: this.style.zoomHistory,\n              transition: this.style.getTransition()\n            }),\n                u = c.crossFadingFactor();\n            1 === u && u === this._crossFadingFactor || (n = !0, this._crossFadingFactor = u), this.style.update(c);\n          }\n\n          if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens("gpu-timing-layer")\n          }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {\n            var h = t.browser.now() - r;\n            a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout(function () {\n              var e = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6;\n              a.deleteQueryEXT(i), o.fire(new t.Event("gpu-timing-frame", {\n                cpuTime: h,\n                gpuTime: e\n              }));\n            }, 50);\n          }\n\n          if (this.listens("gpu-timing-layer")) {\n            var p = this.painter.collectGpuTimers();\n            setTimeout(function () {\n              var e = o.painter.queryGpuTimers(p);\n              o.fire(new t.Event("gpu-timing-layer", {\n                layerTimes: e\n              }));\n            }, 50);\n          }\n\n          var d = this._sourcesDirty || this._styleDirty || this._placementDirty;\n          return d || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0), this;\n        }\n      }, r.prototype.remove = function () {\n        this._hash && this._hash.remove();\n\n        for (var e = 0, i = this._controls; e < i.length; e += 1) {\n          i[e].onRemove(this);\n        }\n\n        this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1), t.window.removeEventListener("orientationchange", this._onWindowResize, !1), t.window.removeEventListener("online", this._onWindowOnline, !1));\n        var o = this.painter.context.gl.getExtension("WEBGL_lose_context");\n        o && o.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), Cr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new t.Event("remove"));\n      }, r.prototype.triggerRepaint = function () {\n        var e = this;\n        this.style && !this._frame && (this._frame = t.browser.frame(function (t) {\n          e._frame = null, e._render(t);\n        }));\n      }, r.prototype._onWindowOnline = function () {\n        this._update();\n      }, r.prototype._onWindowResize = function (t) {\n        this._trackResize && this.resize({\n          originalEvent: t\n        })._update();\n      }, a.showTileBoundaries.get = function () {\n        return !!this._showTileBoundaries;\n      }, a.showTileBoundaries.set = function (t) {\n        this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());\n      }, a.showPadding.get = function () {\n        return !!this._showPadding;\n      }, a.showPadding.set = function (t) {\n        this._showPadding !== t && (this._showPadding = t, this._update());\n      }, a.showCollisionBoxes.get = function () {\n        return !!this._showCollisionBoxes;\n      }, a.showCollisionBoxes.set = function (t) {\n        this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());\n      }, a.showOverdrawInspector.get = function () {\n        return !!this._showOverdrawInspector;\n      }, a.showOverdrawInspector.set = function (t) {\n        this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());\n      }, a.repaint.get = function () {\n        return !!this._repaint;\n      }, a.repaint.set = function (t) {\n        this._repaint !== t && (this._repaint = t, this.triggerRepaint());\n      }, a.vertices.get = function () {\n        return !!this._vertices;\n      }, a.vertices.set = function (t) {\n        this._vertices = t, this._update();\n      }, r.prototype._setCacheLimits = function (e, i) {\n        t.setCacheLimits(e, i);\n      }, a.version.get = function () {\n        return t.version;\n      }, Object.defineProperties(r.prototype, a), r;\n    }(vr);\n\n    function Cr(t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    }\n\n    var zr = {\n      showCompass: !0,\n      showZoom: !0,\n      visualizePitch: !1\n    },\n        Dr = function Dr(e) {\n      var o = this;\n      this.options = t.extend({}, zr, e), this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function (t) {\n        return t.preventDefault();\n      }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function (t) {\n        return o._map.zoomIn({}, {\n          originalEvent: t\n        });\n      }), i.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function (t) {\n        return o._map.zoomOut({}, {\n          originalEvent: t\n        });\n      }), i.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function (t) {\n        o.options.visualizePitch ? o._map.resetNorthPitch({}, {\n          originalEvent: t\n        }) : o._map.resetNorth({}, {\n          originalEvent: t\n        });\n      }), this._compassIcon = i.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));\n    };\n\n    Dr.prototype._updateZoomButtons = function () {\n      var t = this._map.getZoom(),\n          e = t === this._map.getMaxZoom(),\n          i = t === this._map.getMinZoom();\n\n      this._zoomInButton.disabled = e, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", e.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());\n    }, Dr.prototype._rotateCompassArrow = function () {\n      var t = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";\n      this._compassIcon.style.transform = t;\n    }, Dr.prototype.onAdd = function (t) {\n      return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;\n    }, Dr.prototype.onRemove = function () {\n      i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;\n    }, Dr.prototype._createButton = function (t, e) {\n      var o = i.create("button", t, this._container);\n      return o.type = "button", o.addEventListener("click", e), o;\n    }, Dr.prototype._setButtonTitle = function (t, e) {\n      var i = this._map._getUIString("NavigationControl." + e);\n\n      t.title = i, t.setAttribute("aria-label", i);\n    };\n\n    var Ar = function Ar(e, o, r) {\n      void 0 === r && (r = !1), this._clickTolerance = 10, this.element = o, this.mouseRotate = new Xo({\n        clickTolerance: e.dragRotate._mouseRotate._clickTolerance\n      }), this.map = e, r && (this.mousePitch = new Ho({\n        clickTolerance: e.dragRotate._mousePitch._clickTolerance\n      })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(o, "mousedown", this.mousedown), i.addEventListener(o, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.addEventListener(o, "touchmove", this.touchmove), i.addEventListener(o, "touchend", this.touchend), i.addEventListener(o, "touchcancel", this.reset);\n    };\n\n    function Mr(e, i, o) {\n      if (e = new t.LngLat(e.lng, e.lat), i) {\n        var r = new t.LngLat(e.lng - 360, e.lat),\n            a = new t.LngLat(e.lng + 360, e.lat),\n            n = o.locationPoint(e).distSqr(i);\n        o.locationPoint(r).distSqr(i) < n ? e = r : o.locationPoint(a).distSqr(i) < n && (e = a);\n      }\n\n      for (; Math.abs(e.lng - o.center.lng) > 180;) {\n        var s = o.locationPoint(e);\n        if (s.x >= 0 && s.y >= 0 && s.x <= o.width && s.y <= o.height) break;\n        e.lng > o.center.lng ? e.lng -= 360 : e.lng += 360;\n      }\n\n      return e;\n    }\n\n    Ar.prototype.down = function (t, e) {\n      this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), i.disableDrag();\n    }, Ar.prototype.move = function (t, e) {\n      var i = this.map,\n          o = this.mouseRotate.mousemoveWindow(t, e);\n\n      if (o && o.bearingDelta && i.setBearing(i.getBearing() + o.bearingDelta), this.mousePitch) {\n        var r = this.mousePitch.mousemoveWindow(t, e);\n        r && r.pitchDelta && i.setPitch(i.getPitch() + r.pitchDelta);\n      }\n    }, Ar.prototype.off = function () {\n      var t = this.element;\n      i.removeEventListener(t, "mousedown", this.mousedown), i.removeEventListener(t, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.removeEventListener(t, "touchmove", this.touchmove), i.removeEventListener(t, "touchend", this.touchend), i.removeEventListener(t, "touchcancel", this.reset), this.offTemp();\n    }, Ar.prototype.offTemp = function () {\n      i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousedown = function (e) {\n      this.down(t.extend({}, e, {\n        ctrlKey: !0,\n        preventDefault: function preventDefault() {\n          return e.preventDefault();\n        }\n      }), i.mousePos(this.element, e)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousemove = function (t) {\n      this.move(t, i.mousePos(this.element, t));\n    }, Ar.prototype.mouseup = function (t) {\n      this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();\n    }, Ar.prototype.touchstart = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.down({\n        type: "mousedown",\n        button: 0,\n        ctrlKey: !0,\n        preventDefault: function preventDefault() {\n          return t.preventDefault();\n        }\n      }, this._startPos));\n    }, Ar.prototype.touchmove = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.move({\n        preventDefault: function preventDefault() {\n          return t.preventDefault();\n        }\n      }, this._lastPos));\n    }, Ar.prototype.touchend = function (t) {\n      0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n    }, Ar.prototype.reset = function () {\n      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n    };\n    var Lr = {\n      center: "translate(-50%,-50%)",\n      top: "translate(-50%,0)",\n      "top-left": "translate(0,0)",\n      "top-right": "translate(-100%,0)",\n      bottom: "translate(-50%,-100%)",\n      "bottom-left": "translate(0,-100%)",\n      "bottom-right": "translate(-100%,-100%)",\n      left: "translate(0,-50%)",\n      right: "translate(-100%,-50%)"\n    };\n\n    function Rr(t, e, i) {\n      var o = t.classList;\n\n      for (var r in Lr) {\n        o.remove("mapboxgl-" + i + "-anchor-" + r);\n      }\n\n      o.add("mapboxgl-" + i + "-anchor-" + e);\n    }\n\n    var kr,\n        Br = function (e) {\n      function o(o, r) {\n        if (e.call(this), (o instanceof t.window.HTMLElement || r) && (o = t.extend({\n          element: o\n        }, r)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o && o.anchor || "center", this._color = o && o.color || "#3FB1CE", this._scale = o && o.scale || 1, this._draggable = o && o.draggable || !1, this._clickTolerance = o && o.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = o && o.rotation || 0, this._rotationAlignment = o && o.rotationAlignment || "auto", this._pitchAlignment = o && o.pitchAlignment && "auto" !== o.pitchAlignment ? o.pitchAlignment : this._rotationAlignment, o && o.element) this._element = o.element, this._offset = t.Point.convert(o && o.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");\n          var a = i.createNS("http://www.w3.org/2000/svg", "svg");\n          a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", "41px"), a.setAttributeNS(null, "width", "27px"), a.setAttributeNS(null, "viewBox", "0 0 27 41");\n          var n = i.createNS("http://www.w3.org/2000/svg", "g");\n          n.setAttributeNS(null, "stroke", "none"), n.setAttributeNS(null, "stroke-width", "1"), n.setAttributeNS(null, "fill", "none"), n.setAttributeNS(null, "fill-rule", "evenodd");\n          var s = i.createNS("http://www.w3.org/2000/svg", "g");\n          s.setAttributeNS(null, "fill-rule", "nonzero");\n          var l = i.createNS("http://www.w3.org/2000/svg", "g");\n          l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");\n\n          for (var c = 0, u = [{\n            rx: "10.5",\n            ry: "5.25002273"\n          }, {\n            rx: "10.5",\n            ry: "5.25002273"\n          }, {\n            rx: "9.5",\n            ry: "4.77275007"\n          }, {\n            rx: "8.5",\n            ry: "4.29549936"\n          }, {\n            rx: "7.5",\n            ry: "3.81822308"\n          }, {\n            rx: "6.5",\n            ry: "3.34094679"\n          }, {\n            rx: "5.5",\n            ry: "2.86367051"\n          }, {\n            rx: "4.5",\n            ry: "2.38636864"\n          }]; c < u.length; c += 1) {\n            var h = u[c],\n                p = i.createNS("http://www.w3.org/2000/svg", "ellipse");\n            p.setAttributeNS(null, "opacity", "0.04"), p.setAttributeNS(null, "cx", "10.5"), p.setAttributeNS(null, "cy", "5.80029008"), p.setAttributeNS(null, "rx", h.rx), p.setAttributeNS(null, "ry", h.ry), l.appendChild(p);\n          }\n\n          var d = i.createNS("http://www.w3.org/2000/svg", "g");\n          d.setAttributeNS(null, "fill", this._color);\n\n          var _ = i.createNS("http://www.w3.org/2000/svg", "path");\n\n          _.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d.appendChild(_);\n          var f = i.createNS("http://www.w3.org/2000/svg", "g");\n          f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "fill", "#000000");\n          var m = i.createNS("http://www.w3.org/2000/svg", "path");\n          m.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f.appendChild(m);\n          var g = i.createNS("http://www.w3.org/2000/svg", "g");\n          g.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g.setAttributeNS(null, "fill", "#FFFFFF");\n          var v = i.createNS("http://www.w3.org/2000/svg", "g");\n          v.setAttributeNS(null, "transform", "translate(8.0, 8.0)");\n          var y = i.createNS("http://www.w3.org/2000/svg", "circle");\n          y.setAttributeNS(null, "fill", "#000000"), y.setAttributeNS(null, "opacity", "0.25"), y.setAttributeNS(null, "cx", "5.5"), y.setAttributeNS(null, "cy", "5.5"), y.setAttributeNS(null, "r", "5.4999962");\n          var x = i.createNS("http://www.w3.org/2000/svg", "circle");\n          x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), v.appendChild(y), v.appendChild(x), s.appendChild(l), s.appendChild(d), s.appendChild(f), s.appendChild(g), s.appendChild(v), a.appendChild(s), a.setAttributeNS(null, "height", 41 * this._scale + "px"), a.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a), this._offset = t.Point.convert(o && o.offset || [0, -14]);\n        }\n        this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function (t) {\n          t.preventDefault();\n        }), this._element.addEventListener("mousedown", function (t) {\n          t.preventDefault();\n        }), Rr(this._element, this._anchor, "marker"), this._popup = null;\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (t) {\n        return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;\n      }, o.prototype.remove = function () {\n        return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;\n      }, o.prototype.getLngLat = function () {\n        return this._lngLat;\n      }, o.prototype.setLngLat = function (e) {\n        return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;\n      }, o.prototype.getElement = function () {\n        return this._element;\n      }, o.prototype.setPopup = function (t) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {\n          if (!("offset" in t.options)) {\n            var e = Math.sqrt(Math.pow(13.5, 2) / 2);\n            t.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              "top-left": [0, 0],\n              "top-right": [0, 0],\n              bottom: [0, -38.1],\n              "bottom-left": [e, -1 * (24.6 + e)],\n              "bottom-right": [-e, -1 * (24.6 + e)],\n              left: [13.5, -24.6],\n              right: [-13.5, -24.6]\n            } : this._offset;\n          }\n\n          this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);\n        }\n\n        return this;\n      }, o.prototype._onKeyPress = function (t) {\n        var e = t.code,\n            i = t.charCode || t.keyCode;\n        "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup();\n      }, o.prototype._onMapClick = function (t) {\n        var e = t.originalEvent.target,\n            i = this._element;\n        this._popup && (e === i || i.contains(e)) && this.togglePopup();\n      }, o.prototype.getPopup = function () {\n        return this._popup;\n      }, o.prototype.togglePopup = function () {\n        var t = this._popup;\n        return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this;\n      }, o.prototype._update = function (t) {\n        if (this._map) {\n          this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);\n          var e = "";\n          "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");\n          var o = "";\n          "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o = "rotateX(0deg)" : "map" === this._pitchAlignment && (o = "rotateX(" + this._map.getPitch() + "deg)"), t && "moveend" !== t.type || (this._pos = this._pos.round()), i.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o + " " + e);\n        }\n      }, o.prototype.getOffset = function () {\n        return this._offset;\n      }, o.prototype.setOffset = function (e) {\n        return this._offset = t.Point.convert(e), this._update(), this;\n      }, o.prototype._onMove = function (e) {\n        if (!this._isDragging) {\n          var i = this._clickTolerance || this._map._clickTolerance;\n          this._isDragging = e.point.dist(this._pointerdownPos) >= i;\n        }\n\n        this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));\n      }, o.prototype._onUp = function () {\n        this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";\n      }, o.prototype._addDragHandler = function (t) {\n        this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));\n      }, o.prototype.setDraggable = function (t) {\n        return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;\n      }, o.prototype.isDraggable = function () {\n        return this._draggable;\n      }, o.prototype.setRotation = function (t) {\n        return this._rotation = t || 0, this._update(), this;\n      }, o.prototype.getRotation = function () {\n        return this._rotation;\n      }, o.prototype.setRotationAlignment = function (t) {\n        return this._rotationAlignment = t || "auto", this._update(), this;\n      }, o.prototype.getRotationAlignment = function () {\n        return this._rotationAlignment;\n      }, o.prototype.setPitchAlignment = function (t) {\n        return this._pitchAlignment = t && "auto" !== t ? t : this._rotationAlignment, this._update(), this;\n      }, o.prototype.getPitchAlignment = function () {\n        return this._pitchAlignment;\n      }, o;\n    }(t.Evented),\n        Or = {\n      positionOptions: {\n        enableHighAccuracy: !1,\n        maximumAge: 0,\n        timeout: 6e3\n      },\n      fitBoundsOptions: {\n        maxZoom: 15\n      },\n      trackUserLocation: !1,\n      showAccuracyCircle: !0,\n      showUserLocation: !0\n    },\n        Fr = 0,\n        Ur = !1,\n        Nr = function (e) {\n      function o(i) {\n        e.call(this), this.options = t.extend({}, Or, i), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.onAdd = function (e) {\n        var o;\n        return this._map = e, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), o = this._setupUI, void 0 !== kr ? o(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({\n          name: "geolocation"\n        }).then(function (t) {\n          o(kr = "denied" !== t.state);\n        }) : o(kr = !!t.window.navigator.geolocation), this._container;\n      }, o.prototype.onRemove = function () {\n        void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = !1;\n      }, o.prototype._isOutOfMapMaxBounds = function (t) {\n        var e = this._map.getMaxBounds(),\n            i = t.coords;\n\n        return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());\n      }, o.prototype._setErrorState = function () {\n        switch (this._watchState) {\n          case "WAITING_ACTIVE":\n            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");\n            break;\n\n          case "ACTIVE_LOCK":\n            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");\n            break;\n\n          case "BACKGROUND":\n            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");\n        }\n      }, o.prototype._onSuccess = function (e) {\n        if (this._map) {\n          if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e)), this._updateMarker(), void this._finish();\n          if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {\n            case "WAITING_ACTIVE":\n            case "ACTIVE_LOCK":\n            case "ACTIVE_ERROR":\n              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");\n              break;\n\n            case "BACKGROUND":\n            case "BACKGROUND_ERROR":\n              this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");\n          }\n          this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e)), this._finish();\n        }\n      }, o.prototype._updateCamera = function (e) {\n        var i = new t.LngLat(e.coords.longitude, e.coords.latitude),\n            o = e.coords.accuracy,\n            r = this._map.getBearing(),\n            a = t.extend({\n          bearing: r\n        }, this.options.fitBoundsOptions);\n\n        this._map.fitBounds(i.toBounds(o), a, {\n          geolocateSource: !0\n        });\n      }, o.prototype._updateMarker = function (e) {\n        if (e) {\n          var i = new t.LngLat(e.coords.longitude, e.coords.latitude);\n          this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n      }, o.prototype._updateCircleRadius = function () {\n        var t = this._map._container.clientHeight / 2,\n            e = this._map.unproject([0, t]),\n            i = this._map.unproject([1, t]),\n            o = e.distanceTo(i),\n            r = Math.ceil(2 * this._accuracy / o);\n\n        this._circleElement.style.width = r + "px", this._circleElement.style.height = r + "px";\n      }, o.prototype._onZoom = function () {\n        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n      }, o.prototype._onError = function (e) {\n        if (this._map) {\n          if (this.options.trackUserLocation) if (1 === e.code) {\n            this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;\n\n            var i = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n\n            this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), void 0 !== this._geolocationWatchID && this._clearWatch();\n          } else {\n            if (3 === e.code && Ur) return;\n\n            this._setErrorState();\n          }\n          "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e)), this._finish();\n        }\n      }, o.prototype._finish = function () {\n        this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n      }, o.prototype._setupUI = function (e) {\n        var o = this;\n\n        if (this._container.addEventListener("contextmenu", function (t) {\n          return t.preventDefault();\n        }), this._geolocateButton = i.create("button", "mapboxgl-ctrl-geolocate", this._container), i.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === e) {\n          t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");\n\n          var r = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n\n          this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);\n        } else {\n          var a = this._map._getUIString("GeolocateControl.FindMyLocation");\n\n          this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);\n        }\n\n        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({\n          element: this._circleElement,\n          pitchAlignment: "map"\n        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function (e) {\n          e.geolocateSource || "ACTIVE_LOCK" !== o._watchState || e.originalEvent && "resize" === e.originalEvent.type || (o._watchState = "BACKGROUND", o._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), o._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), o.fire(new t.Event("trackuserlocationend")));\n        });\n      }, o.prototype.trigger = function () {\n        if (!this._setup) return t.warnOnce("Geolocate control triggered before added to a map"), !1;\n\n        if (this.options.trackUserLocation) {\n          switch (this._watchState) {\n            case "OFF":\n              this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));\n              break;\n\n            case "WAITING_ACTIVE":\n            case "ACTIVE_LOCK":\n            case "ACTIVE_ERROR":\n            case "BACKGROUND_ERROR":\n              Fr--, Ur = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));\n              break;\n\n            case "BACKGROUND":\n              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));\n          }\n\n          switch (this._watchState) {\n            case "WAITING_ACTIVE":\n              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");\n              break;\n\n            case "ACTIVE_LOCK":\n              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");\n\n              break;\n\n            case "ACTIVE_ERROR":\n              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");\n              break;\n\n            case "BACKGROUND":\n              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");\n\n              break;\n\n            case "BACKGROUND_ERROR":\n              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");\n          }\n\n          if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n            var e;\n            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e = {\n              maximumAge: 6e5,\n              timeout: 0\n            }, Ur = !0) : (e = this.options.positionOptions, Ur = !1), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e);\n          }\n        } else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n\n        return !0;\n      }, o.prototype._clearWatch = function () {\n        t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);\n      }, o;\n    }(t.Evented),\n        Zr = {\n      maxWidth: 100,\n      unit: "metric"\n    },\n        qr = function qr(e) {\n      this.options = t.extend({}, Zr, e), t.bindAll(["_onMove", "setUnit"], this);\n    };\n\n    function jr(t, e, i) {\n      var o = i && i.maxWidth || 100,\n          r = t._container.clientHeight / 2,\n          a = t.unproject([0, r]),\n          n = t.unproject([o, r]),\n          s = a.distanceTo(n);\n\n      if (i && "imperial" === i.unit) {\n        var l = 3.2808 * s;\n        l > 5280 ? Vr(e, o, l / 5280, t._getUIString("ScaleControl.Miles")) : Vr(e, o, l, t._getUIString("ScaleControl.Feet"));\n      } else i && "nautical" === i.unit ? Vr(e, o, s / 1852, t._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? Vr(e, o, s / 1e3, t._getUIString("ScaleControl.Kilometers")) : Vr(e, o, s, t._getUIString("ScaleControl.Meters"));\n    }\n\n    function Vr(t, e, i, o) {\n      var r,\n          a,\n          n,\n          s = (r = i, (a = Math.pow(10, ("" + Math.floor(r)).length - 1)) * (n = (n = r / a) >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : n >= 1 ? 1 : function (t) {\n        var e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));\n        return Math.round(t * e) / e;\n      }(n)));\n      t.style.width = e * (s / i) + "px", t.innerHTML = s + "&nbsp;" + o;\n    }\n\n    qr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, qr.prototype._onMove = function () {\n      jr(this._map, this._container, this.options);\n    }, qr.prototype.onAdd = function (t) {\n      return this._map = t, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;\n    }, qr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;\n    }, qr.prototype.setUnit = function (t) {\n      this.options.unit = t, jr(this._map, this._container, this.options);\n    };\n\n    var Gr = function Gr(e) {\n      this._fullscreen = !1, e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control \'container\' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");\n    };\n\n    Gr.prototype.onAdd = function (e) {\n      return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;\n    }, Gr.prototype.onRemove = function () {\n      i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._checkFullscreenSupport = function () {\n      return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);\n    }, Gr.prototype._setupUI = function () {\n      var e = this._fullscreenButton = i.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);\n      i.create("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", !0), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._updateTitle = function () {\n      var t = this._getTitle();\n\n      this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t;\n    }, Gr.prototype._getTitle = function () {\n      return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");\n    }, Gr.prototype._isFullscreen = function () {\n      return this._fullscreen;\n    }, Gr.prototype._changeIcon = function () {\n      (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());\n    }, Gr.prototype._onClickFullscreen = function () {\n      this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n    };\n\n    var Wr = {\n      closeButton: !0,\n      closeOnClick: !0,\n      focusAfterOpen: !0,\n      className: "",\n      maxWidth: "240px"\n    },\n        Xr = ["a[href]", "[tabindex]:not([tabindex=\'-1\'])", "[contenteditable]:not([contenteditable=\'false\'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "),\n        Hr = function (e) {\n      function o(i) {\n        e.call(this), this.options = t.extend(Object.create(Wr), i), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (e) {\n        return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;\n      }, o.prototype.isOpen = function () {\n        return !!this._map;\n      }, o.prototype.remove = function () {\n        return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;\n      }, o.prototype.getLngLat = function () {\n        return this._lngLat;\n      }, o.prototype.setLngLat = function (e) {\n        return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;\n      }, o.prototype.trackPointer = function () {\n        return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;\n      }, o.prototype.getElement = function () {\n        return this._container;\n      }, o.prototype.setText = function (e) {\n        return this.setDOMContent(t.window.document.createTextNode(e));\n      }, o.prototype.setHTML = function (e) {\n        var i,\n            o = t.window.document.createDocumentFragment(),\n            r = t.window.document.createElement("body");\n\n        for (r.innerHTML = e; i = r.firstChild;) {\n          o.appendChild(i);\n        }\n\n        return this.setDOMContent(o);\n      }, o.prototype.getMaxWidth = function () {\n        return this._container && this._container.style.maxWidth;\n      }, o.prototype.setMaxWidth = function (t) {\n        return this.options.maxWidth = t, this._update(), this;\n      }, o.prototype.setDOMContent = function (t) {\n        if (this._content) for (; this._content.hasChildNodes();) {\n          this._content.firstChild && this._content.removeChild(this._content.firstChild);\n        } else this._content = i.create("div", "mapboxgl-popup-content", this._container);\n        return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;\n      }, o.prototype.addClassName = function (t) {\n        this._container && this._container.classList.add(t);\n      }, o.prototype.removeClassName = function (t) {\n        this._container && this._container.classList.remove(t);\n      }, o.prototype.setOffset = function (t) {\n        return this.options.offset = t, this._update(), this;\n      }, o.prototype.toggleClassName = function (t) {\n        if (this._container) return this._container.classList.toggle(t);\n      }, o.prototype._createCloseButton = function () {\n        this.options.closeButton && (this._closeButton = i.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));\n      }, o.prototype._onMouseUp = function (t) {\n        this._update(t.point);\n      }, o.prototype._onMouseMove = function (t) {\n        this._update(t.point);\n      }, o.prototype._onDrag = function (t) {\n        this._update(t.point);\n      }, o.prototype._update = function (e) {\n        var o = this;\n\n        if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function (t) {\n          return o._container.classList.add(t);\n        }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e)) {\n          var r = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat),\n              a = this.options.anchor,\n              n = function e(i) {\n            if (i) {\n              if ("number" == typeof i) {\n                var o = Math.round(Math.sqrt(.5 * Math.pow(i, 2)));\n                return {\n                  center: new t.Point(0, 0),\n                  top: new t.Point(0, i),\n                  "top-left": new t.Point(o, o),\n                  "top-right": new t.Point(-o, o),\n                  bottom: new t.Point(0, -i),\n                  "bottom-left": new t.Point(o, -o),\n                  "bottom-right": new t.Point(-o, -o),\n                  left: new t.Point(i, 0),\n                  right: new t.Point(-i, 0)\n                };\n              }\n\n              if (i instanceof t.Point || Array.isArray(i)) {\n                var r = t.Point.convert(i);\n                return {\n                  center: r,\n                  top: r,\n                  "top-left": r,\n                  "top-right": r,\n                  bottom: r,\n                  "bottom-left": r,\n                  "bottom-right": r,\n                  left: r,\n                  right: r\n                };\n              }\n\n              return {\n                center: t.Point.convert(i.center || [0, 0]),\n                top: t.Point.convert(i.top || [0, 0]),\n                "top-left": t.Point.convert(i["top-left"] || [0, 0]),\n                "top-right": t.Point.convert(i["top-right"] || [0, 0]),\n                bottom: t.Point.convert(i.bottom || [0, 0]),\n                "bottom-left": t.Point.convert(i["bottom-left"] || [0, 0]),\n                "bottom-right": t.Point.convert(i["bottom-right"] || [0, 0]),\n                left: t.Point.convert(i.left || [0, 0]),\n                right: t.Point.convert(i.right || [0, 0])\n              };\n            }\n\n            return e(new t.Point(0, 0));\n          }(this.options.offset);\n\n          if (!a) {\n            var s,\n                l = this._container.offsetWidth,\n                c = this._container.offsetHeight;\n            s = r.y + n.bottom.y < c ? ["top"] : r.y > this._map.transform.height - c ? ["bottom"] : [], r.x < l / 2 ? s.push("left") : r.x > this._map.transform.width - l / 2 && s.push("right"), a = 0 === s.length ? "bottom" : s.join("-");\n          }\n\n          var u = r.add(n[a]).round();\n          i.setTransform(this._container, Lr[a] + " translate(" + u.x + "px," + u.y + "px)"), Rr(this._container, a, "popup");\n        }\n      }, o.prototype._focusFirstElement = function () {\n        if (this.options.focusAfterOpen && this._container) {\n          var t = this._container.querySelector(Xr);\n\n          t && t.focus();\n        }\n      }, o.prototype._onClose = function () {\n        this.remove();\n      }, o;\n    }(t.Evented),\n        Kr = {\n      version: t.version,\n      supported: e,\n      setRTLTextPlugin: t.setRTLTextPlugin,\n      getRTLTextPluginStatus: t.getRTLTextPluginStatus,\n      Map: Sr,\n      NavigationControl: Dr,\n      GeolocateControl: Nr,\n      AttributionControl: yr,\n      ScaleControl: qr,\n      FullscreenControl: Gr,\n      Popup: Hr,\n      Marker: Br,\n      Style: je,\n      LngLat: t.LngLat,\n      LngLatBounds: t.LngLatBounds,\n      Point: t.Point,\n      MercatorCoordinate: t.MercatorCoordinate,\n      Evented: t.Evented,\n      config: t.config,\n      prewarm: function prewarm() {\n        Ft().acquire(Rt);\n      },\n      clearPrewarmedResources: function clearPrewarmedResources() {\n        var t = Bt;\n        t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));\n      },\n\n      get accessToken() {\n        return t.config.ACCESS_TOKEN;\n      },\n\n      set accessToken(e) {\n        t.config.ACCESS_TOKEN = e;\n      },\n\n      get baseApiUrl() {\n        return t.config.API_URL;\n      },\n\n      set baseApiUrl(e) {\n        t.config.API_URL = e;\n      },\n\n      get workerCount() {\n        return kt.workerCount;\n      },\n\n      set workerCount(t) {\n        kt.workerCount = t;\n      },\n\n      get maxParallelImageRequests() {\n        return t.config.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n\n      set maxParallelImageRequests(e) {\n        t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;\n      },\n\n      clearStorage: function clearStorage(e) {\n        t.clearTileCache(e);\n      },\n      workerUrl: ""\n    };\n\n    return Kr;\n  }); //\n\n  return mapboxgl;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvZGlzdC9tYXBib3gtZ2wuanM/M2E5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWtDOztBQUUxQztBQUNBO0FBQ0EsRUFBRSxLQUE0RCxnQ0FBZ0MsQ0FBcUg7QUFDbk4sQ0FBQztBQUNEO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxxREFBcUQsK0JBQStCLCtCQUErQjtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHlDQUF5QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVAsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFP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S0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELGlEQUFpRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFFQUFxRSx3QkFBd0I7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsd0RBQXdELGtLQUFrSztBQUMxTjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQixrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCw4RUFBOEUsNENBQTRDLGNBQWM7QUFDeEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLGVBQWUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSx3REFBd0Q7QUFDeEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxxREFBcUQsZ0NBQWdDO0FBQ2xJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVCx3Q0FBd0Msa0NBQWtDO0FBQzFFOztBQUVBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZ0JBQWdCLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQiw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxJQUFJLElBQUksbUlBQW1JLCtEQUErRDtBQUN4UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxpS0FBaUs7QUFDeEs7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLHlEQUF5RCxVQUFVLCtCQUErQixNQUFNLHlEQUF5RCxNQUFNO0FBQzlOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsS0FBSztBQUNMO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5SkFBeUosUUFBUTtBQUNqSyx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQSwrRUFBK0UsdUJBQXVCO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkUsY0FBYztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUFxQztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsY0FBYztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEZBQTRGLE9BQU87QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsMkRBQTJELE9BQU87QUFDbEU7QUFDQSxPQUFPO0FBQ1AsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Qsb0NBQW9DO0FBQ25HO0FBQ0EsU0FBUywwQ0FBMEMsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esc0dBQXNHLGNBQWM7QUFDcEg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxzR0FBc0csY0FBYztBQUNwSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUUsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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ZTtBQUN6VCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELE9BQU87QUFDbEUsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtCQUErQjs7QUFFL0IscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELHlEQUF5RCx5R0FBeUc7QUFDN047QUFDQSxPQUFPLGlIQUFpSDtBQUN4SDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrREFBK0Qsb0hBQW9ILHNDQUFzQztBQUN6TixzR0FBc0c7QUFDdEc7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLHNCQUFzQixpQ0FBaUM7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVCx1RUFBdUUsK0RBQStELGNBQWM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUEsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsMEVBQTBFLGNBQWM7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGNBQWM7QUFDcEUscUVBQXFFLGNBQWM7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBOztBQUVBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPLGdCQUFnQixjQUFjO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU8sUUFBUSxjQUFjO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkMsY0FBYztBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QyxjQUFjO0FBQzVELGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBGQUEwRiw2SEFBNkg7QUFDdk47O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlOztBQUVmLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxjQUFjO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLGNBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLGVBQWUsY0FBYztBQUNsRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc1RBQXNUO0FBQ3RUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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O0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1RkFBdUYscUNBQXFDO0FBQzVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix1Q0FBdUM7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw0QkFBNEIscUZBQXFGLGNBQWM7QUFDL0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdNQUFnTSxjQUFjO0FBQzlNO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMGRBQTBkO0FBQzFkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0V0FBNFcsWUFBWTtBQUN4WDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUUsb0JBQW9CLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsNERBQTRELHFDQUFxQztBQUNqRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlDQUFpQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHNDQUFzQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHNDQUFzQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFFBQVEsY0FBYztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQ0FBcUM7QUFDNUMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLHVDQUF1QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0R0FBNEcscUhBQXFILDZCQUE2QjtBQUM5UDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRKQUE0SixjQUFjO0FBQzFLO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBOztBQUVBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0EsS0FBSztBQUNMLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFFBQVEsUUFBUSxnSkFBZ0osY0FBYztBQUN2TDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixRQUFRLFFBQVEsMkJBQTJCLGNBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPLEtBQUs7QUFDWixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK1BBQStQO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsK0JBQStCO0FBQy9CLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCw4RkFBOEYsY0FBYztBQUM1RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpcUJBQWlxQjtBQUNqcUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUVBQW1FO0FBQzVFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7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V0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVyxFQUFFLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLGdRQUFnUTtBQUNoUSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBLENBQUMiLCJmaWxlIjoiMjk3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qc1wiKTtcblxuLyogTWFwYm94IEdMIEpTIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSAzLUNsYXVzZSBCU0QgTGljZW5zZS4gRnVsbCB0ZXh0IG9mIGxpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvdjEuMTMuMS9MSUNFTlNFLnR4dCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5tYXBib3hnbCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICB2YXIgc2hhcmVkLCB3b3JrZXIsIG1hcGJveGdsOyAvLyBkZWZpbmUgZ2V0cyBjYWxsZWQgdGhyZWUgdGltZXM6IG9uZSBmb3IgZWFjaCBjaHVuay4gd2UgcmVseSBvbiB0aGUgb3JkZXJcbiAgLy8gdGhleSdyZSBpbXBvcnRlZCB0byBrbm93IHdoaWNoIGlzIHdoaWNoXG5cbiAgZnVuY3Rpb24gZGVmaW5lKF8sIGNodW5rKSB7XG4gICAgaWYgKCFzaGFyZWQpIHtcbiAgICAgIHNoYXJlZCA9IGNodW5rO1xuICAgIH0gZWxzZSBpZiAoIXdvcmtlcikge1xuICAgICAgd29ya2VyID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3b3JrZXJCdW5kbGVTdHJpbmcgPSAndmFyIHNoYXJlZENodW5rID0ge307ICgnICsgc2hhcmVkICsgJykoc2hhcmVkQ2h1bmspOyAoJyArIHdvcmtlciArICcpKHNoYXJlZENodW5rKTsnO1xuICAgICAgdmFyIHNoYXJlZENodW5rID0ge307XG4gICAgICBzaGFyZWQoc2hhcmVkQ2h1bmspO1xuICAgICAgbWFwYm94Z2wgPSBjaHVuayhzaGFyZWRDaHVuayk7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtYXBib3hnbC53b3JrZXJVcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd29ya2VyQnVuZGxlU3RyaW5nXSwge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGUodCwgZSkge1xuICAgICAgcmV0dXJuIHQoZSA9IHtcbiAgICAgICAgZXhwb3J0czoge31cbiAgICAgIH0sIGUuZXhwb3J0cyksIGUuZXhwb3J0cztcbiAgICB9XG5cbiAgICB2YXIgciA9IG47XG5cbiAgICBmdW5jdGlvbiBuKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMuY3ggPSAzICogdCwgdGhpcy5ieCA9IDMgKiAociAtIHQpIC0gdGhpcy5jeCwgdGhpcy5heCA9IDEgLSB0aGlzLmN4IC0gdGhpcy5ieCwgdGhpcy5jeSA9IDMgKiBlLCB0aGlzLmJ5ID0gMyAqIChuIC0gZSkgLSB0aGlzLmN5LCB0aGlzLmF5ID0gMSAtIHRoaXMuY3kgLSB0aGlzLmJ5LCB0aGlzLnAxeCA9IHQsIHRoaXMucDF5ID0gbiwgdGhpcy5wMnggPSByLCB0aGlzLnAyeSA9IG47XG4gICAgfVxuXG4gICAgbi5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xuICAgIH0sIG4ucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbiAgICB9LCBuLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAoMyAqIHRoaXMuYXggKiB0ICsgMiAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG4gICAgfSwgbi5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsIG4sIGksIGEsIG87XG5cbiAgICAgIGZvciAodm9pZCAwID09PSBlICYmIChlID0gMWUtNiksIGkgPSB0LCBvID0gMDsgbyA8IDg7IG8rKykge1xuICAgICAgICBpZiAoYSA9IHRoaXMuc2FtcGxlQ3VydmVYKGkpIC0gdCwgTWF0aC5hYnMoYSkgPCBlKSByZXR1cm4gaTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgoaSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhzKSA8IDFlLTYpIGJyZWFrO1xuICAgICAgICBpIC09IGEgLyBzO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgPSB0KSA8IChyID0gMCkpIHJldHVybiByO1xuICAgICAgaWYgKGkgPiAobiA9IDEpKSByZXR1cm4gbjtcblxuICAgICAgZm9yICg7IHIgPCBuOykge1xuICAgICAgICBpZiAoYSA9IHRoaXMuc2FtcGxlQ3VydmVYKGkpLCBNYXRoLmFicyhhIC0gdCkgPCBlKSByZXR1cm4gaTtcbiAgICAgICAgdCA+IGEgPyByID0gaSA6IG4gPSBpLCBpID0gLjUgKiAobiAtIHIpICsgcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgbi5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgodCwgZSkpO1xuICAgIH07XG4gICAgdmFyIGkgPSBhO1xuXG4gICAgZnVuY3Rpb24gYSh0LCBlKSB7XG4gICAgICB0aGlzLnggPSB0LCB0aGlzLnkgPSBlO1xuICAgIH1cblxuICAgIGEucHJvdG90eXBlID0ge1xuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IGEodGhpcy54LCB0aGlzLnkpO1xuICAgICAgfSxcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHQpO1xuICAgICAgfSxcbiAgICAgIHN1YjogZnVuY3Rpb24gc3ViKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHQpO1xuICAgICAgfSxcbiAgICAgIG11bHRCeVBvaW50OiBmdW5jdGlvbiBtdWx0QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX211bHRCeVBvaW50KHQpO1xuICAgICAgfSxcbiAgICAgIGRpdkJ5UG9pbnQ6IGZ1bmN0aW9uIGRpdkJ5UG9pbnQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZCeVBvaW50KHQpO1xuICAgICAgfSxcbiAgICAgIG11bHQ6IGZ1bmN0aW9uIG11bHQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KHQpO1xuICAgICAgfSxcbiAgICAgIGRpdjogZnVuY3Rpb24gZGl2KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KHQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKHQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gcm90YXRlQXJvdW5kKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlQXJvdW5kKHQsIGUpO1xuICAgICAgfSxcbiAgICAgIG1hdE11bHQ6IGZ1bmN0aW9uIG1hdE11bHQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KHQpO1xuICAgICAgfSxcbiAgICAgIHVuaXQ6IGZ1bmN0aW9uIHVuaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTtcbiAgICAgIH0sXG4gICAgICBwZXJwOiBmdW5jdGlvbiBwZXJwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7XG4gICAgICB9LFxuICAgICAgcm91bmQ6IGZ1bmN0aW9uIHJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xuICAgICAgfSxcbiAgICAgIG1hZzogZnVuY3Rpb24gbWFnKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgICB9LFxuICAgICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHModCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gICAgICB9LFxuICAgICAgZGlzdDogZnVuY3Rpb24gZGlzdCh0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHQpKTtcbiAgICAgIH0sXG4gICAgICBkaXN0U3FyOiBmdW5jdGlvbiBkaXN0U3FyKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LnggLSB0aGlzLngsXG4gICAgICAgICAgICByID0gdC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZSAqIGUgKyByICogcjtcbiAgICAgIH0sXG4gICAgICBhbmdsZTogZnVuY3Rpb24gYW5nbGUoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICAgIH0sXG4gICAgICBhbmdsZVRvOiBmdW5jdGlvbiBhbmdsZVRvKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gdC55LCB0aGlzLnggLSB0LngpO1xuICAgICAgfSxcbiAgICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24gYW5nbGVXaXRoKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKHQueCwgdC55KTtcbiAgICAgIH0sXG4gICAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uIGFuZ2xlV2l0aFNlcCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueCAqIGUgLSB0aGlzLnkgKiB0LCB0aGlzLnggKiB0ICsgdGhpcy55ICogZSk7XG4gICAgICB9LFxuICAgICAgX21hdE11bHQ6IGZ1bmN0aW9uIF9tYXRNdWx0KHQpIHtcbiAgICAgICAgdmFyIGUgPSB0WzJdICogdGhpcy54ICsgdFszXSAqIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IHRbMF0gKiB0aGlzLnggKyB0WzFdICogdGhpcy55LCB0aGlzLnkgPSBlLCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9hZGQ6IGZ1bmN0aW9uIF9hZGQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICs9IHQueCwgdGhpcy55ICs9IHQueSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfc3ViOiBmdW5jdGlvbiBfc3ViKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtPSB0LngsIHRoaXMueSAtPSB0LnksIHRoaXM7XG4gICAgICB9LFxuICAgICAgX211bHQ6IGZ1bmN0aW9uIF9tdWx0KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfZGl2OiBmdW5jdGlvbiBfZGl2KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAvPSB0LCB0aGlzLnkgLz0gdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfbXVsdEJ5UG9pbnQ6IGZ1bmN0aW9uIF9tdWx0QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKj0gdC54LCB0aGlzLnkgKj0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9kaXZCeVBvaW50OiBmdW5jdGlvbiBfZGl2QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLz0gdC54LCB0aGlzLnkgLz0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF91bml0OiBmdW5jdGlvbiBfdW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpdih0aGlzLm1hZygpKSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcGVycDogZnVuY3Rpb24gX3BlcnAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy55O1xuICAgICAgICByZXR1cm4gdGhpcy55ID0gdGhpcy54LCB0aGlzLnggPSAtdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcm90YXRlOiBmdW5jdGlvbiBfcm90YXRlKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNvcyh0KSxcbiAgICAgICAgICAgIHIgPSBNYXRoLnNpbih0KSxcbiAgICAgICAgICAgIG4gPSByICogdGhpcy54ICsgZSAqIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IGUgKiB0aGlzLnggLSByICogdGhpcy55LCB0aGlzLnkgPSBuLCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9yb3RhdGVBcm91bmQ6IGZ1bmN0aW9uIF9yb3RhdGVBcm91bmQodCwgZSkge1xuICAgICAgICB2YXIgciA9IE1hdGguY29zKHQpLFxuICAgICAgICAgICAgbiA9IE1hdGguc2luKHQpLFxuICAgICAgICAgICAgaSA9IGUueSArIG4gKiAodGhpcy54IC0gZS54KSArIHIgKiAodGhpcy55IC0gZS55KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IGUueCArIHIgKiAodGhpcy54IC0gZS54KSAtIG4gKiAodGhpcy55IC0gZS55KSwgdGhpcy55ID0gaSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcm91bmQ6IGZ1bmN0aW9uIF9yb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzO1xuICAgICAgfVxuICAgIH0sIGEuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIGEgPyB0IDogQXJyYXkuaXNBcnJheSh0KSA/IG5ldyBhKHRbMF0sIHRbMV0pIDogdDtcbiAgICB9O1xuICAgIHZhciBvID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB7fSxcbiAgICAgICAgcyA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgICBmdW5jdGlvbiB1KHQsIGUsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gbmV3IHIodCwgZSwgbiwgaSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGEuc29sdmUodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsID0gdSguMjUsIC4xLCAuMjUsIDEpO1xuXG4gICAgZnVuY3Rpb24gcCh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4ociwgTWF0aC5tYXgoZSwgdCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGModCwgZSwgcikge1xuICAgICAgdmFyIG4gPSByIC0gZSxcbiAgICAgICAgICBpID0gKCh0IC0gZSkgJSBuICsgbikgJSBuICsgZTtcbiAgICAgIHJldHVybiBpID09PSBlID8gciA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIHIgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgci0tID4gMDspIHtcbiAgICAgICAgZVtyXSA9IGFyZ3VtZW50c1tyICsgMV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gYSkge1xuICAgICAgICAgIHRbb10gPSBhW29dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIHZhciBmID0gMTtcblxuICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICByZXR1cm4gZisrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdChlKSB7XG4gICAgICAgIHJldHVybiBlID8gKGUgXiAxNiAqIE1hdGgucmFuZG9tKCkgPj4gZSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC1bMWUzXSArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIHQpO1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG0odCkge1xuICAgICAgcmV0dXJuICEhdCAmJiAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVs0XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaS50ZXN0KHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHYodCwgZSkge1xuICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGVbdF0gJiYgKGVbdF0gPSBlW3RdLmJpbmQoZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZyh0LCBlKSB7XG4gICAgICByZXR1cm4gLTEgIT09IHQuaW5kZXhPZihlLCB0Lmxlbmd0aCAtIGUubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdCkge1xuICAgICAgICBuW2ldID0gZS5jYWxsKHIgfHwgdGhpcywgdFtpXSwgaSwgdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGIodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiB0KSB7XG4gICAgICAgIGUuY2FsbChyIHx8IHRoaXMsIHRbaV0sIGksIHQpICYmIChuW2ldID0gdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHcodCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcCh3KSA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgdCA/IHgodCwgdykgOiB0O1xuICAgIH1cblxuICAgIHZhciBfID0ge307XG5cbiAgICBmdW5jdGlvbiBBKHQpIHtcbiAgICAgIF9bdF0gfHwgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKHQpLCBfW3RdID0gITApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFModCwgZSwgcikge1xuICAgICAgcmV0dXJuIChyLnkgLSB0LnkpICogKGUueCAtIHQueCkgPiAoZS55IC0gdC55KSAqIChyLnggLSB0LngpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGsodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gdC5sZW5ndGgsIGkgPSBuIC0gMSwgYSA9IHZvaWQgMCwgbyA9IHZvaWQgMDsgciA8IG47IGkgPSByKyspIHtcbiAgICAgICAgZSArPSAoKG8gPSB0W2ldKS54IC0gKGEgPSB0W3JdKS54KSAqIChhLnkgKyBvLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHoodCkge1xuICAgICAgdmFyIGUgPSB7fTtcblxuICAgICAgaWYgKHQucmVwbGFjZSgvKD86XnwoPzpcXHMqXFwsXFxzKikpKFteXFx4MDAtXFx4MjBcXChcXCk8PkBcXCw7XFw6XFxcXFwiXFwvXFxbXFxdXFw/XFw9XFx7XFx9XFx4N0ZdKykoPzpcXD0oPzooW15cXHgwMC1cXHgyMFxcKFxcKTw+QFxcLDtcXDpcXFxcXCJcXC9cXFtcXF1cXD9cXD1cXHtcXH1cXHg3Rl0rKXwoPzpcXFwiKCg/OlteXCJcXFxcXXxcXFxcLikqKVxcXCIpKSk/L2csIGZ1bmN0aW9uICh0LCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gbiB8fCBpO1xuICAgICAgICByZXR1cm4gZVtyXSA9ICFhIHx8IGEudG9Mb3dlckNhc2UoKSwgXCJcIjtcbiAgICAgIH0pLCBlW1wibWF4LWFnZVwiXSkge1xuICAgICAgICB2YXIgciA9IHBhcnNlSW50KGVbXCJtYXgtYWdlXCJdLCAxMCk7XG4gICAgICAgIGlzTmFOKHIpID8gZGVsZXRlIGVbXCJtYXgtYWdlXCJdIDogZVtcIm1heC1hZ2VcIl0gPSByO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBFKHQpIHtcbiAgICAgIGlmIChudWxsID09IEMpIHtcbiAgICAgICAgdmFyIGUgPSB0Lm5hdmlnYXRvciA/IHQubmF2aWdhdG9yLnVzZXJBZ2VudCA6IG51bGw7XG4gICAgICAgIEMgPSAhIXQuc2FmYXJpIHx8ICEoIWUgfHwgISgvXFxiKGlQYWR8aVBob25lfGlQb2QpXFxiLy50ZXN0KGUpIHx8IGUubWF0Y2goXCJTYWZhcmlcIikgJiYgIWUubWF0Y2goXCJDaHJvbWVcIikpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUCh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZSA9IG9bdF07XG4gICAgICAgIHJldHVybiBlLnNldEl0ZW0oXCJfbWFwYm94X3Rlc3RfXCIsIDEpLCBlLnJlbW92ZUl0ZW0oXCJfbWFwYm94X3Rlc3RfXCIpLCAhMDtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBNLFxuICAgICAgICBCLFxuICAgICAgICBULFxuICAgICAgICBWLFxuICAgICAgICBGID0gby5wZXJmb3JtYW5jZSAmJiBvLnBlcmZvcm1hbmNlLm5vdyA/IG8ucGVyZm9ybWFuY2Uubm93LmJpbmQoby5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdy5iaW5kKERhdGUpLFxuICAgICAgICBEID0gby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgTCA9IG8uY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgby5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBvLndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IG8ubXNDYW5jZWxBbmltYXRpb25GcmFtZSxcbiAgICAgICAgTyA9IHtcbiAgICAgIG5vdzogRixcbiAgICAgIGZyYW1lOiBmdW5jdGlvbiBmcmFtZSh0KSB7XG4gICAgICAgIHZhciBlID0gRCh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBMKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uIGdldEltYWdlRGF0YSh0LCBlKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApO1xuICAgICAgICB2YXIgciA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgIG4gPSByLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyAyZCBjb250ZXh0XCIpO1xuICAgICAgICByZXR1cm4gci53aWR0aCA9IHQud2lkdGgsIHIuaGVpZ2h0ID0gdC5oZWlnaHQsIG4uZHJhd0ltYWdlKHQsIDAsIDAsIHQud2lkdGgsIHQuaGVpZ2h0KSwgbi5nZXRJbWFnZURhdGEoLWUsIC1lLCB0LndpZHRoICsgMiAqIGUsIHQuaGVpZ2h0ICsgMiAqIGUpO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVVUkw6IGZ1bmN0aW9uIHJlc29sdmVVUkwodCkge1xuICAgICAgICByZXR1cm4gTSB8fCAoTSA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpLCBNLmhyZWYgPSB0LCBNLmhyZWY7XG4gICAgICB9LFxuICAgICAgaGFyZHdhcmVDb25jdXJyZW5jeTogby5uYXZpZ2F0b3IgJiYgby5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCA0LFxuXG4gICAgICBnZXQgZGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIG8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBwcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhby5tYXRjaE1lZGlhICYmIChudWxsID09IEIgJiYgKEIgPSBvLm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKSksIEIubWF0Y2hlcyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgICAgICBSID0ge1xuICAgICAgQVBJX1VSTDogXCJodHRwczovL2FwaS5tYXBib3guY29tXCIsXG5cbiAgICAgIGdldCBFVkVOVFNfVVJMKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BUElfVVJMID8gMCA9PT0gdGhpcy5BUElfVVJMLmluZGV4T2YoXCJodHRwczovL2FwaS5tYXBib3guY25cIikgPyBcImh0dHBzOi8vZXZlbnRzLm1hcGJveC5jbi9ldmVudHMvdjJcIiA6IDAgPT09IHRoaXMuQVBJX1VSTC5pbmRleE9mKFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbVwiKSA/IFwiaHR0cHM6Ly9ldmVudHMubWFwYm94LmNvbS9ldmVudHMvdjJcIiA6IG51bGwgOiBudWxsO1xuICAgICAgfSxcblxuICAgICAgRkVFREJBQ0tfVVJMOiBcImh0dHBzOi8vYXBwcy5tYXBib3guY29tL2ZlZWRiYWNrXCIsXG4gICAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogITAsXG4gICAgICBBQ0NFU1NfVE9LRU46IG51bGwsXG4gICAgICBNQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFM6IDE2XG4gICAgfSxcbiAgICAgICAgVSA9IHtcbiAgICAgIHN1cHBvcnRlZDogITEsXG4gICAgICB0ZXN0U3VwcG9ydDogZnVuY3Rpb24gdGVzdFN1cHBvcnQodCkge1xuICAgICAgICAhaiAmJiBWICYmIChxID8gTih0KSA6IFQgPSB0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBqID0gITEsXG4gICAgICAgIHEgPSAhMTtcblxuICAgIGZ1bmN0aW9uIE4odCkge1xuICAgICAgdmFyIGUgPSB0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELCBlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsIDAsIHQuUkdCQSwgdC5SR0JBLCB0LlVOU0lHTkVEX0JZVEUsIFYpLCB0LmlzQ29udGV4dExvc3QoKSkgcmV0dXJuO1xuICAgICAgICBVLnN1cHBvcnRlZCA9ICEwO1xuICAgICAgfSBjYXRjaCAodCkge31cblxuICAgICAgdC5kZWxldGVUZXh0dXJlKGUpLCBqID0gITA7XG4gICAgfVxuXG4gICAgby5kb2N1bWVudCAmJiAoKFYgPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIikpLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFQgJiYgTihUKSwgVCA9IG51bGwsIHEgPSAhMDtcbiAgICB9LCBWLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBqID0gITAsIFQgPSBudWxsO1xuICAgIH0sIFYuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaDRBQUFCWFJVSlFWbEE0VEJFQUFBQXZBUUFBQUFmUS8vNzN2LytCaU9oL0FBQT1cIik7XG5cbiAgICB2YXIgSyA9IFwiMDFcIixcbiAgICAgICAgRyA9IGZ1bmN0aW9uIEcodCwgZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuID0gdCwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gPSBlLCB0aGlzLl9jcmVhdGVTa3VUb2tlbigpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBaKHQpIHtcbiAgICAgIHJldHVybiAwID09PSB0LmluZGV4T2YoXCJtYXBib3g6XCIpO1xuICAgIH1cblxuICAgIEcucHJvdG90eXBlLl9jcmVhdGVTa3VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0ID0gXCJcIiwgZSA9IDA7IGUgPCAxMDsgZSsrKSB7XG4gICAgICAgICAgdCArPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCJbTWF0aC5mbG9vcig2MiAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW46IFtcIjFcIiwgSywgdF0uam9pbihcIlwiKSxcbiAgICAgICAgICB0b2tlbkV4cGlyZXNBdDogRGF0ZS5ub3coKSArIDQzMmU1XG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIHRoaXMuX3NrdVRva2VuID0gdC50b2tlbiwgdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQgPSB0LnRva2VuRXhwaXJlc0F0O1xuICAgIH0sIEcucHJvdG90eXBlLl9pc1NrdVRva2VuRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpID4gdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQ7XG4gICAgfSwgRy5wcm90b3R5cGUudHJhbnNmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuICYmIHRoaXMuX3RyYW5zZm9ybVJlcXVlc3RGbih0LCBlKSB8fCB7XG4gICAgICAgIHVybDogdFxuICAgICAgfTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL3N0eWxlcy92MVwiICsgci5wYXRoLCB0aGlzLl9tYWtlQVBJVVJMKHIsIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IGUpO1xuICAgIH0sIEcucHJvdG90eXBlLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL2ZvbnRzL3YxXCIgKyByLnBhdGgsIHRoaXMuX21ha2VBUElVUkwociwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgZSk7XG4gICAgfSwgRy5wcm90b3R5cGUubm9ybWFsaXplU291cmNlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghWih0KSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgciA9IFkodCk7XG4gICAgICByZXR1cm4gci5wYXRoID0gXCIvdjQvXCIgKyByLmF1dGhvcml0eSArIFwiLmpzb25cIiwgci5wYXJhbXMucHVzaChcInNlY3VyZVwiKSwgdGhpcy5fbWFrZUFQSVVSTChyLCB0aGlzLl9jdXN0b21BY2Nlc3NUb2tlbiB8fCBlKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTcHJpdGVVUkwgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBZKHQpO1xuICAgICAgcmV0dXJuIFoodCkgPyAoaS5wYXRoID0gXCIvc3R5bGVzL3YxXCIgKyBpLnBhdGggKyBcIi9zcHJpdGVcIiArIGUgKyByLCB0aGlzLl9tYWtlQVBJVVJMKGksIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IG4pKSA6IChpLnBhdGggKz0gXCJcIiArIGUgKyByLCAkKGkpKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NrdVRva2VuRXhwaXJlZCgpICYmIHRoaXMuX2NyZWF0ZVNrdVRva2VuKCksIHQgJiYgIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgci5wYXRoID0gci5wYXRoLnJlcGxhY2UoLyhcXC4ocG5nfGpwZylcXGQqKSg/PSQpLywgKE8uZGV2aWNlUGl4ZWxSYXRpbyA+PSAyIHx8IDUxMiA9PT0gZSA/IFwiQDJ4XCIgOiBcIlwiKSArIChVLnN1cHBvcnRlZCA/IFwiLndlYnBcIiA6IFwiJDFcIikpLCByLnBhdGggPSByLnBhdGgucmVwbGFjZSgvXi4rXFwvdjRcXC8vLCBcIi9cIiksIHIucGF0aCA9IFwiL3Y0XCIgKyByLnBhdGg7XG5cbiAgICAgIHZhciBuID0gdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgIHZhciBuID0gcltlXS5tYXRjaCgvXmFjY2Vzc190b2tlbj0oLiopJC8pO1xuICAgICAgICAgIGlmIChuKSByZXR1cm4gblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfShyLnBhcmFtcykgfHwgUi5BQ0NFU1NfVE9LRU47XG5cbiAgICAgIHJldHVybiBSLlJFUVVJUkVfQUNDRVNTX1RPS0VOICYmIG4gJiYgdGhpcy5fc2t1VG9rZW4gJiYgci5wYXJhbXMucHVzaChcInNrdT1cIiArIHRoaXMuX3NrdVRva2VuKSwgdGhpcy5fbWFrZUFQSVVSTChyLCBuKTtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gWSh0KTtcbiAgICAgIGlmICghci5wYXRoLm1hdGNoKC8oXlxcL3Y0XFwvKS8pIHx8ICFyLnBhdGgubWF0Y2goL1xcLltcXHddKyQvKSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgbiA9IFwibWFwYm94Oi8vdGlsZXMvXCI7XG4gICAgICBuICs9IHIucGF0aC5yZXBsYWNlKFwiL3Y0L1wiLCBcIlwiKTtcbiAgICAgIHZhciBpID0gci5wYXJhbXM7XG4gICAgICByZXR1cm4gZSAmJiAoaSA9IGkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhdC5tYXRjaCgvXmFjY2Vzc190b2tlbj0vKTtcbiAgICAgIH0pKSwgaS5sZW5ndGggJiYgKG4gKz0gXCI/XCIgKyBpLmpvaW4oXCImXCIpKSwgbjtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlc2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAhIWUgJiYgWihlKSwgbiA9IFtdLCBpID0gMCwgYSA9IHQudGlsZXMgfHwgW107IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgSihvKSA/IG4ucHVzaCh0aGlzLmNhbm9uaWNhbGl6ZVRpbGVVUkwobywgcikpIDogbi5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBHLnByb3RvdHlwZS5fbWFrZUFQSVVSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IFwiU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYXBpLWRvY3VtZW50YXRpb24vI2FjY2Vzcy10b2tlbnMtYW5kLXRva2VuLXNjb3Blc1wiLFxuICAgICAgICAgIG4gPSBZKFIuQVBJX1VSTCk7XG5cbiAgICAgIGlmICh0LnByb3RvY29sID0gbi5wcm90b2NvbCwgdC5hdXRob3JpdHkgPSBuLmF1dGhvcml0eSwgXCJodHRwXCIgPT09IHQucHJvdG9jb2wpIHtcbiAgICAgICAgdmFyIGkgPSB0LnBhcmFtcy5pbmRleE9mKFwic2VjdXJlXCIpO1xuICAgICAgICBpID49IDAgJiYgdC5wYXJhbXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCIvXCIgIT09IG4ucGF0aCAmJiAodC5wYXRoID0gXCJcIiArIG4ucGF0aCArIHQucGF0aCksICFSLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSByZXR1cm4gJCh0KTtcbiAgICAgIGlmICghKGUgPSBlIHx8IFIuQUNDRVNTX1RPS0VOKSkgdGhyb3cgbmV3IEVycm9yKFwiQW4gQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IEdMLiBcIiArIHIpO1xuICAgICAgaWYgKFwic1wiID09PSBlWzBdKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgYSBwdWJsaWMgYWNjZXNzIHRva2VuIChway4qKSB3aXRoIE1hcGJveCBHTCwgbm90IGEgc2VjcmV0IGFjY2VzcyB0b2tlbiAoc2suKikuIFwiICsgcik7XG4gICAgICByZXR1cm4gdC5wYXJhbXMgPSB0LnBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIC0xID09PSB0LmluZGV4T2YoXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgICB9KSwgdC5wYXJhbXMucHVzaChcImFjY2Vzc190b2tlbj1cIiArIGUpLCAkKHQpO1xuICAgIH07XG4gICAgdmFyIFggPSAvXigoaHR0cHM/Oik/XFwvXFwvKT8oW15cXC9dK1xcLik/bWFwYm94XFwuYyhufG9tKShcXC98XFw/fCQpL2k7XG5cbiAgICBmdW5jdGlvbiBKKHQpIHtcbiAgICAgIHJldHVybiBYLnRlc3QodCk7XG4gICAgfVxuXG4gICAgdmFyIEggPSAvXihcXHcrKTpcXC9cXC8oW14vP10qKShcXC9bXj9dKyk/XFw/PyguKyk/LztcblxuICAgIGZ1bmN0aW9uIFkodCkge1xuICAgICAgdmFyIGUgPSB0Lm1hdGNoKEgpO1xuICAgICAgaWYgKCFlKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgVVJMIG9iamVjdFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3RvY29sOiBlWzFdLFxuICAgICAgICBhdXRob3JpdHk6IGVbMl0sXG4gICAgICAgIHBhdGg6IGVbM10gfHwgXCIvXCIsXG4gICAgICAgIHBhcmFtczogZVs0XSA/IGVbNF0uc3BsaXQoXCImXCIpIDogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCh0KSB7XG4gICAgICB2YXIgZSA9IHQucGFyYW1zLmxlbmd0aCA/IFwiP1wiICsgdC5wYXJhbXMuam9pbihcIiZcIikgOiBcIlwiO1xuICAgICAgcmV0dXJuIHQucHJvdG9jb2wgKyBcIjovL1wiICsgdC5hdXRob3JpdHkgKyB0LnBhdGggKyBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFcodCkge1xuICAgICAgaWYgKCF0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBlID0gdC5zcGxpdChcIi5cIik7XG4gICAgICBpZiAoIWUgfHwgMyAhPT0gZS5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQoby5hdG9iKGVbMV0pLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyB0LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgIH0pLmpvaW4oXCJcIikpKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFEgPSBmdW5jdGlvbiBRKHQpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuYW5vbklkID0gbnVsbCwgdGhpcy5ldmVudERhdGEgPSB7fSwgdGhpcy5xdWV1ZSA9IFtdLCB0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgUS5wcm90b3R5cGUuZ2V0U3RvcmFnZUtleSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgICByID0gVyhSLkFDQ0VTU19UT0tFTik7XG4gICAgICByZXR1cm4gZSA9IHIgJiYgci51ID8gby5idG9hKGVuY29kZVVSSUNvbXBvbmVudChyLnUpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihcIjB4XCIgKyBlKSk7XG4gICAgICB9KSkgOiBSLkFDQ0VTU19UT0tFTiB8fCBcIlwiLCB0ID8gXCJtYXBib3guZXZlbnREYXRhLlwiICsgdCArIFwiOlwiICsgZSA6IFwibWFwYm94LmV2ZW50RGF0YTpcIiArIGU7XG4gICAgfSwgUS5wcm90b3R5cGUuZmV0Y2hFdmVudERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFAoXCJsb2NhbFN0b3JhZ2VcIiksXG4gICAgICAgICAgZSA9IHRoaXMuZ2V0U3RvcmFnZUtleSgpLFxuICAgICAgICAgIHIgPSB0aGlzLmdldFN0b3JhZ2VLZXkoXCJ1dWlkXCIpO1xuICAgICAgaWYgKHQpIHRyeSB7XG4gICAgICAgIHZhciBuID0gby5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICAgICAgbiAmJiAodGhpcy5ldmVudERhdGEgPSBKU09OLnBhcnNlKG4pKTtcbiAgICAgICAgdmFyIGkgPSBvLmxvY2FsU3RvcmFnZS5nZXRJdGVtKHIpO1xuICAgICAgICBpICYmICh0aGlzLmFub25JZCA9IGkpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICBBKFwiVW5hYmxlIHRvIHJlYWQgZnJvbSBMb2NhbFN0b3JhZ2VcIik7XG4gICAgICB9XG4gICAgfSwgUS5wcm90b3R5cGUuc2F2ZUV2ZW50RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gUChcImxvY2FsU3RvcmFnZVwiKSxcbiAgICAgICAgICBlID0gdGhpcy5nZXRTdG9yYWdlS2V5KCksXG4gICAgICAgICAgciA9IHRoaXMuZ2V0U3RvcmFnZUtleShcInV1aWRcIik7XG4gICAgICBpZiAodCkgdHJ5IHtcbiAgICAgICAgby5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyLCB0aGlzLmFub25JZCksIE9iamVjdC5rZXlzKHRoaXMuZXZlbnREYXRhKS5sZW5ndGggPj0gMSAmJiBvLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGUsIEpTT04uc3RyaW5naWZ5KHRoaXMuZXZlbnREYXRhKSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIEEoXCJVbmFibGUgdG8gd3JpdGUgdG8gTG9jYWxTdG9yYWdlXCIpO1xuICAgICAgfVxuICAgIH0sIFEucHJvdG90eXBlLnByb2Nlc3NSZXF1ZXN0cyA9IGZ1bmN0aW9uICh0KSB7fSwgUS5wcm90b3R5cGUucG9zdEV2ZW50ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gdGhpcztcblxuICAgICAgaWYgKFIuRVZFTlRTX1VSTCkge1xuICAgICAgICB2YXIgYSA9IFkoUi5FVkVOVFNfVVJMKTtcbiAgICAgICAgYS5wYXJhbXMucHVzaChcImFjY2Vzc190b2tlbj1cIiArIChuIHx8IFIuQUNDRVNTX1RPS0VOIHx8IFwiXCIpKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgZXZlbnQ6IHRoaXMudHlwZSxcbiAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZSh0KS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHNka0lkZW50aWZpZXI6IFwibWFwYm94LWdsLWpzXCIsXG4gICAgICAgICAgc2RrVmVyc2lvbjogXCIxLjEzLjFcIixcbiAgICAgICAgICBza3VJZDogSyxcbiAgICAgICAgICB1c2VySWQ6IHRoaXMuYW5vbklkXG4gICAgICAgIH0sXG4gICAgICAgICAgICBzID0gZSA/IGgobywgZSkgOiBvLFxuICAgICAgICAgICAgdSA9IHtcbiAgICAgICAgICB1cmw6ICQoYSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KFtzXSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdCA9IHd0KHUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaS5wZW5kaW5nUmVxdWVzdCA9IG51bGwsIHIodCksIGkuc2F2ZUV2ZW50RGF0YSgpLCBpLnByb2Nlc3NSZXF1ZXN0cyhuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgUS5wcm90b3R5cGUucXVldWVSZXF1ZXN0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh0KSwgdGhpcy5wcm9jZXNzUmVxdWVzdHMoZSk7XG4gICAgfTtcblxuICAgIHZhciB0dCxcbiAgICAgICAgZXQsXG4gICAgICAgIHJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBcIm1hcC5sb2FkXCIpLCB0aGlzLnN1Y2Nlc3MgPSB7fSwgdGhpcy5za3VUb2tlbiA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnBvc3RNYXBMb2FkRXZlbnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB0aGlzLnNrdVRva2VuID0gciwgKFIuRVZFTlRTX1VSTCAmJiBuIHx8IFIuQUNDRVNTX1RPS0VOICYmIEFycmF5LmlzQXJyYXkodCkgJiYgdC5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFoodCkgfHwgSih0KTtcbiAgICAgICAgfSkpICYmIHRoaXMucXVldWVSZXF1ZXN0KHtcbiAgICAgICAgICBpZDogZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSwgbik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5wcm9jZXNzUmVxdWVzdHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdSZXF1ZXN0ICYmIDAgIT09IHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnF1ZXVlLnNoaWZ0KCksXG4gICAgICAgICAgICAgIG4gPSByLmlkLFxuICAgICAgICAgICAgICBpID0gci50aW1lc3RhbXA7XG4gICAgICAgICAgbiAmJiB0aGlzLnN1Y2Nlc3Nbbl0gfHwgKHRoaXMuYW5vbklkIHx8IHRoaXMuZmV0Y2hFdmVudERhdGEoKSwgbSh0aGlzLmFub25JZCkgfHwgKHRoaXMuYW5vbklkID0gZCgpKSwgdGhpcy5wb3N0RXZlbnQoaSwge1xuICAgICAgICAgICAgc2t1VG9rZW46IHRoaXMuc2t1VG9rZW5cbiAgICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdCB8fCBuICYmIChlLnN1Y2Nlc3Nbbl0gPSAhMCk7XG4gICAgICAgICAgfSwgdCkpO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oUSksXG4gICAgICAgIG50ID0gbmV3IChmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBcImFwcFVzZXJUdXJuc3RpbGVcIiksIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuID0gZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucG9zdFR1cm5zdGlsZUV2ZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgUi5FVkVOVFNfVVJMICYmIFIuQUNDRVNTX1RPS0VOICYmIEFycmF5LmlzQXJyYXkodCkgJiYgdC5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFoodCkgfHwgSih0KTtcbiAgICAgICAgfSkgJiYgdGhpcy5xdWV1ZVJlcXVlc3QoRGF0ZS5ub3coKSwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5wcm9jZXNzUmVxdWVzdHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdSZXF1ZXN0ICYmIDAgIT09IHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5hbm9uSWQgJiYgdGhpcy5ldmVudERhdGEubGFzdFN1Y2Nlc3MgJiYgdGhpcy5ldmVudERhdGEudG9rZW5VIHx8IHRoaXMuZmV0Y2hFdmVudERhdGEoKTtcbiAgICAgICAgICB2YXIgciA9IFcoUi5BQ0NFU1NfVE9LRU4pLFxuICAgICAgICAgICAgICBuID0gciA/IHIudSA6IFIuQUNDRVNTX1RPS0VOLFxuICAgICAgICAgICAgICBpID0gbiAhPT0gdGhpcy5ldmVudERhdGEudG9rZW5VO1xuICAgICAgICAgIG0odGhpcy5hbm9uSWQpIHx8ICh0aGlzLmFub25JZCA9IGQoKSwgaSA9ICEwKTtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMucXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YS5sYXN0U3VjY2Vzcykge1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgRGF0ZSh0aGlzLmV2ZW50RGF0YS5sYXN0U3VjY2VzcyksXG4gICAgICAgICAgICAgICAgcyA9IG5ldyBEYXRlKGEpLFxuICAgICAgICAgICAgICAgIHUgPSAoYSAtIHRoaXMuZXZlbnREYXRhLmxhc3RTdWNjZXNzKSAvIDg2NGU1O1xuICAgICAgICAgICAgaSA9IGkgfHwgdSA+PSAxIHx8IHUgPCAtMSB8fCBvLmdldERhdGUoKSAhPT0gcy5nZXREYXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGkgPSAhMDtcblxuICAgICAgICAgIGlmICghaSkgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5wb3N0RXZlbnQoYSwge1xuICAgICAgICAgICAgXCJlbmFibGVkLnRlbGVtZXRyeVwiOiAhMVxuICAgICAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0IHx8IChlLmV2ZW50RGF0YS5sYXN0U3VjY2VzcyA9IGEsIGUuZXZlbnREYXRhLnRva2VuVSA9IG4pO1xuICAgICAgICAgIH0sIHQpO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oUSkpKCksXG4gICAgICAgIGl0ID0gbnQucG9zdFR1cm5zdGlsZUV2ZW50LmJpbmQobnQpLFxuICAgICAgICBhdCA9IG5ldyBydCgpLFxuICAgICAgICBvdCA9IGF0LnBvc3RNYXBMb2FkRXZlbnQuYmluZChhdCksXG4gICAgICAgIHN0ID0gNTAwLFxuICAgICAgICB1dCA9IDUwO1xuXG4gICAgZnVuY3Rpb24gbHQoKSB7XG4gICAgICBvLmNhY2hlcyAmJiAhdHQgJiYgKHR0ID0gby5jYWNoZXMub3BlbihcIm1hcGJveC10aWxlc1wiKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHQodCkge1xuICAgICAgdmFyIGUgPSB0LmluZGV4T2YoXCI/XCIpO1xuICAgICAgcmV0dXJuIGUgPCAwID8gdCA6IHQuc2xpY2UoMCwgZSk7XG4gICAgfVxuXG4gICAgdmFyIGN0LFxuICAgICAgICBodCA9IDEgLyAwO1xuXG4gICAgZnVuY3Rpb24gZnQoKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PSBjdCAmJiAoY3QgPSBvLk9mZnNjcmVlbkNhbnZhcyAmJiBuZXcgby5PZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dChcIjJkXCIpICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygby5jcmVhdGVJbWFnZUJpdG1hcCksIGN0O1xuICAgIH1cblxuICAgIHZhciB5dCA9IHtcbiAgICAgIFVua25vd246IFwiVW5rbm93blwiLFxuICAgICAgU3R5bGU6IFwiU3R5bGVcIixcbiAgICAgIFNvdXJjZTogXCJTb3VyY2VcIixcbiAgICAgIFRpbGU6IFwiVGlsZVwiLFxuICAgICAgR2x5cGhzOiBcIkdseXBoc1wiLFxuICAgICAgU3ByaXRlSW1hZ2U6IFwiU3ByaXRlSW1hZ2VcIixcbiAgICAgIFNwcml0ZUpTT046IFwiU3ByaXRlSlNPTlwiLFxuICAgICAgSW1hZ2U6IFwiSW1hZ2VcIlxuICAgIH07XG4gICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoeXQpO1xuXG4gICAgdmFyIGR0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgciwgbikge1xuICAgICAgICA0MDEgPT09IHIgJiYgSihuKSAmJiAoZSArPSBcIjogeW91IG1heSBoYXZlIHByb3ZpZGVkIGFuIGludmFsaWQgTWFwYm94IGFjY2VzcyB0b2tlbi4gU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYXBpLWRvY3VtZW50YXRpb24vI2FjY2Vzcy10b2tlbnMtYW5kLXRva2VuLXNjb3Blc1wiKSwgdC5jYWxsKHRoaXMsIGUpLCB0aGlzLnN0YXR1cyA9IHIsIHRoaXMudXJsID0gbiwgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCB0aGlzLm1lc3NhZ2UgPSBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIFwiIChcIiArIHRoaXMuc3RhdHVzICsgXCIpOiBcIiArIHRoaXMudXJsO1xuICAgICAgfSwgZTtcbiAgICB9KEVycm9yKSxcbiAgICAgICAgbXQgPSBJKCkgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi53b3JrZXIgJiYgc2VsZi53b3JrZXIucmVmZXJyZXI7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoXCJibG9iOlwiID09PSBvLmxvY2F0aW9uLnByb3RvY29sID8gby5wYXJlbnQgOiBvKS5sb2NhdGlvbi5ocmVmO1xuICAgIH07XG5cbiAgICB2YXIgdnQsXG4gICAgICAgIGd0LFxuICAgICAgICB4dCA9IGZ1bmN0aW9uIHh0KHQsIGUpIHtcbiAgICAgIGlmICghKC9eZmlsZTovLnRlc3QociA9IHQudXJsKSB8fCAvXmZpbGU6Ly50ZXN0KG10KCkpICYmICEvXlxcdys6Ly50ZXN0KHIpKSkge1xuICAgICAgICBpZiAoby5mZXRjaCAmJiBvLlJlcXVlc3QgJiYgby5BYm9ydENvbnRyb2xsZXIgJiYgby5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInNpZ25hbFwiKSkgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICAgIG4gPSBuZXcgby5BYm9ydENvbnRyb2xsZXIoKSxcbiAgICAgICAgICAgICAgaSA9IG5ldyBvLlJlcXVlc3QodC51cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogdC5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgICAgIGJvZHk6IHQuYm9keSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0LmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgaGVhZGVyczogdC5oZWFkZXJzLFxuICAgICAgICAgICAgcmVmZXJyZXI6IG10KCksXG4gICAgICAgICAgICBzaWduYWw6IG4uc2lnbmFsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGEgPSAhMSxcbiAgICAgICAgICAgICAgcyA9ICExLFxuICAgICAgICAgICAgICB1ID0gKHIgPSBpLnVybCkuaW5kZXhPZihcInNrdT1cIikgPiAwICYmIEoocik7XG4gICAgICAgICAgXCJqc29uXCIgPT09IHQudHlwZSAmJiBpLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblxuICAgICAgICAgIHZhciBsID0gZnVuY3Rpb24gbChyLCBuLCBhKSB7XG4gICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgaWYgKHIgJiYgXCJTZWN1cml0eUVycm9yXCIgIT09IHIubWVzc2FnZSAmJiBBKHIpLCBuICYmIGEpIHJldHVybiBwKG4pO1xuICAgICAgICAgICAgICB2YXIgbCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgIG8uZmV0Y2goaSkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIGlmIChyLm9rKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbiA9IHUgPyByLmNsb25lKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHAociwgbiwgbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUobmV3IGR0KHIuc3RhdHVzVGV4dCwgci5zdGF0dXMsIHQudXJsKSk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgMjAgIT09IHQuY29kZSAmJiBlKG5ldyBFcnJvcih0Lm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHAociwgbiwgdSkge1xuICAgICAgICAgICAgKFwiYXJyYXlCdWZmZXJcIiA9PT0gdC50eXBlID8gci5hcnJheUJ1ZmZlcigpIDogXCJqc29uXCIgPT09IHQudHlwZSA/IHIuanNvbigpIDogci50ZXh0KCkpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcyB8fCAobiAmJiB1ICYmIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGx0KCksIHR0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgby5IZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBlLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5oZWFkZXJzLnNldChlLCB0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIGkgPSB6KGUuaGVhZGVycy5nZXQoXCJDYWNoZS1Db250cm9sXCIpIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgaVtcIm5vLXN0b3JlXCJdIHx8IChpW1wibWF4LWFnZVwiXSAmJiBuLmhlYWRlcnMuc2V0KFwiRXhwaXJlc1wiLCBuZXcgRGF0ZShyICsgMWUzICogaVtcIm1heC1hZ2VcIl0pLnRvVVRDU3RyaW5nKCkpLCBuZXcgRGF0ZShuLmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKSkuZ2V0VGltZSgpIC0gciA8IDQyZTQgfHwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZXQpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFJlc3BvbnNlKG5ldyBSZWFkYWJsZVN0cmVhbSgpKSwgZXQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgIGV0ID0gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXQgPyBlKHQuYm9keSkgOiB0LmJsb2IoKS50aGVuKGUpO1xuICAgICAgICAgICAgICAgICAgfShlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBvLlJlc3BvbnNlKGUsIG4pO1xuICAgICAgICAgICAgICAgICAgICBsdCgpLCB0dCAmJiB0dC50aGVuKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucHV0KHB0KHQudXJsKSwgcik7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEEodC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KGksIG4sIHUpLCBhID0gITAsIGUobnVsbCwgdCwgci5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIiksIHIuaGVhZGVycy5nZXQoXCJFeHBpcmVzXCIpKSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBzIHx8IGUobmV3IEVycm9yKHQubWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiB1ID8gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIGlmIChsdCgpLCAhdHQpIHJldHVybiBlKG51bGwpO1xuICAgICAgICAgICAgdmFyIHIgPSBwdCh0LnVybCk7XG4gICAgICAgICAgICB0dC50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHQubWF0Y2gocikudGhlbihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgRGF0ZSh0LmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICByID0geih0LmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlID4gRGF0ZS5ub3coKSAmJiAhcltcIm5vLWNhY2hlXCJdO1xuICAgICAgICAgICAgICAgIH0obik7XG5cbiAgICAgICAgICAgICAgICB0LmRlbGV0ZShyKSwgaSAmJiB0LnB1dChyLCBuLmNsb25lKCkpLCBlKG51bGwsIG4sIGkpO1xuICAgICAgICAgICAgICB9KS5jYXRjaChlKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGUpO1xuICAgICAgICAgIH0oaSwgbCkgOiBsKG51bGwsIG51bGwpLCB7XG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgcyA9ICEwLCBhIHx8IG4uYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KHQsIGUpO1xuICAgICAgICBpZiAoSSgpICYmIHNlbGYud29ya2VyICYmIHNlbGYud29ya2VyLmFjdG9yKSByZXR1cm4gc2VsZi53b3JrZXIuYWN0b3Iuc2VuZChcImdldFJlc291cmNlXCIsIHQsIGUsIHZvaWQgMCwgITApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IG5ldyBvLlhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgbiBpbiByLm9wZW4odC5tZXRob2QgfHwgXCJHRVRcIiwgdC51cmwsICEwKSwgXCJhcnJheUJ1ZmZlclwiID09PSB0LnR5cGUgJiYgKHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiKSwgdC5oZWFkZXJzKSB7XG4gICAgICAgICAgci5zZXRSZXF1ZXN0SGVhZGVyKG4sIHQuaGVhZGVyc1tuXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJqc29uXCIgPT09IHQudHlwZSAmJiAoci5yZXNwb25zZVR5cGUgPSBcInRleHRcIiwgci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKSksIHIud2l0aENyZWRlbnRpYWxzID0gXCJpbmNsdWRlXCIgPT09IHQuY3JlZGVudGlhbHMsIHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlKG5ldyBFcnJvcihyLnN0YXR1c1RleHQpKTtcbiAgICAgICAgfSwgci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKChyLnN0YXR1cyA+PSAyMDAgJiYgci5zdGF0dXMgPCAzMDAgfHwgMCA9PT0gci5zdGF0dXMpICYmIG51bGwgIT09IHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBuID0gci5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChcImpzb25cIiA9PT0gdC50eXBlKSB0cnkge1xuICAgICAgICAgICAgICBuID0gSlNPTi5wYXJzZShyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlKG51bGwsIG4sIHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIpLCByLmdldFJlc3BvbnNlSGVhZGVyKFwiRXhwaXJlc1wiKSk7XG4gICAgICAgICAgfSBlbHNlIGUobmV3IGR0KHIuc3RhdHVzVGV4dCwgci5zdGF0dXMsIHQudXJsKSk7XG4gICAgICAgIH0sIHIuc2VuZCh0LmJvZHkpLCB7XG4gICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0odCwgZSk7XG4gICAgfSxcbiAgICAgICAgYnQgPSBmdW5jdGlvbiBidCh0LCBlKSB7XG4gICAgICByZXR1cm4geHQoaCh0LCB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlCdWZmZXJcIlxuICAgICAgfSksIGUpO1xuICAgIH0sXG4gICAgICAgIHd0ID0gZnVuY3Rpb24gd3QodCwgZSkge1xuICAgICAgcmV0dXJuIHh0KGgodCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgICB9KSwgZSk7XG4gICAgfSxcbiAgICAgICAgX3QgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFDMGxFUVZRWVYyTmdBQUlBQUFVQUFhclZ5RkVBQUFBQVNVVk9SSzVDWUlJPVwiO1xuXG4gICAgdnQgPSBbXSwgZ3QgPSAwO1xuXG4gICAgdmFyIEF0ID0gZnVuY3Rpb24gQXQodCwgZSkge1xuICAgICAgaWYgKFUuc3VwcG9ydGVkICYmICh0LmhlYWRlcnMgfHwgKHQuaGVhZGVycyA9IHt9KSwgdC5oZWFkZXJzLmFjY2VwdCA9IFwiaW1hZ2Uvd2VicCwqLypcIiksIGd0ID49IFIuTUFYX1BBUkFMTEVMX0lNQUdFX1JFUVVFU1RTKSB7XG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJzOiB0LFxuICAgICAgICAgIGNhbGxiYWNrOiBlLFxuICAgICAgICAgIGNhbmNlbGxlZDogITEsXG4gICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZ0LnB1c2gociksIHI7XG4gICAgICB9XG5cbiAgICAgIGd0Kys7XG5cbiAgICAgIHZhciBuID0gITEsXG4gICAgICAgICAgaSA9IGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgIGlmICghbikgZm9yIChuID0gITAsIGd0LS07IHZ0Lmxlbmd0aCAmJiBndCA8IFIuTUFYX1BBUkFMTEVMX0lNQUdFX1JFUVVFU1RTOykge1xuICAgICAgICAgIHZhciB0ID0gdnQuc2hpZnQoKTtcbiAgICAgICAgICB0LmNhbmNlbGxlZCB8fCAodC5jYW5jZWwgPSBBdCh0LnJlcXVlc3RQYXJhbWV0ZXJzLCB0LmNhbGxiYWNrKS5jYW5jZWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgICAgIGEgPSBidCh0LCBmdW5jdGlvbiAodCwgciwgbiwgYSkge1xuICAgICAgICBpKCksIHQgPyBlKHQpIDogciAmJiAoZnQoKSA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBuZXcgby5CbG9iKFtuZXcgVWludDhBcnJheSh0KV0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvLmNyZWF0ZUltYWdlQml0bWFwKHIpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGUobnVsbCwgdCk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGUobmV3IEVycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2UgYmVjYXVzZSBvZiBcIiArIHQubWVzc2FnZSArIFwiLiBQbGVhc2UgbWFrZSBzdXJlIHRvIHVzZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlIHN1Y2ggYXMgUE5HIG9yIEpQRUcuIE5vdGUgdGhhdCBTVkdzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0ociwgZSkgOiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIHZhciBpID0gbmV3IG8uSW1hZ2UoKSxcbiAgICAgICAgICAgICAgYSA9IG8uVVJMO1xuICAgICAgICAgIGkub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZShudWxsLCBpKSwgYS5yZXZva2VPYmplY3RVUkwoaS5zcmMpLCBpLm9ubG9hZCA9IG51bGwsIG8ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaS5zcmMgPSBfdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGkub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBlKG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlLiBQbGVhc2UgbWFrZSBzdXJlIHRvIHVzZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlIHN1Y2ggYXMgUE5HIG9yIEpQRUcuIE5vdGUgdGhhdCBTVkdzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBvLkJsb2IoW25ldyBVaW50OEFycmF5KHQpXSwge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGkuY2FjaGVDb250cm9sID0gciwgaS5leHBpcmVzID0gbiwgaS5zcmMgPSB0LmJ5dGVMZW5ndGggPyBhLmNyZWF0ZU9iamVjdFVSTChzKSA6IF90O1xuICAgICAgICB9KHIsIGUsIG4sIGEpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICBhLmNhbmNlbCgpLCBpKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFN0KHQsIGUsIHIpIHtcbiAgICAgIHJbdF0gJiYgLTEgIT09IHJbdF0uaW5kZXhPZihlKSB8fCAoclt0XSA9IHJbdF0gfHwgW10sIHJbdF0ucHVzaChlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga3QodCwgZSwgcikge1xuICAgICAgaWYgKHIgJiYgclt0XSkge1xuICAgICAgICB2YXIgbiA9IHJbdF0uaW5kZXhPZihlKTtcbiAgICAgICAgLTEgIT09IG4gJiYgclt0XS5zcGxpY2UobiwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEl0ID0gZnVuY3Rpb24gSXQodCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0ge30pLCBoKHRoaXMsIGUpLCB0aGlzLnR5cGUgPSB0O1xuICAgIH0sXG4gICAgICAgIHp0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIHQuY2FsbCh0aGlzLCBcImVycm9yXCIsIGgoe1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0sIHIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZTtcbiAgICB9KEl0KSxcbiAgICAgICAgQ3QgPSBmdW5jdGlvbiBDdCgpIHt9O1xuXG4gICAgQ3QucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwge30sIFN0KHQsIGUsIHRoaXMuX2xpc3RlbmVycyksIHRoaXM7XG4gICAgfSwgQ3QucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4ga3QodCwgZSwgdGhpcy5fbGlzdGVuZXJzKSwga3QodCwgZSwgdGhpcy5fb25lVGltZUxpc3RlbmVycyksIHRoaXM7XG4gICAgfSwgQ3QucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMgPSB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzIHx8IHt9LCBTdCh0LCBlLCB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzKSwgdGhpcztcbiAgICB9LCBDdC5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmICh0ID0gbmV3IEl0KHQsIGUgfHwge30pKTtcbiAgICAgIHZhciByID0gdC50eXBlO1xuXG4gICAgICBpZiAodGhpcy5saXN0ZW5zKHIpKSB7XG4gICAgICAgIHQudGFyZ2V0ID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbcl0gPyB0aGlzLl9saXN0ZW5lcnNbcl0uc2xpY2UoKSA6IFtdOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIGlbbl0uY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gdGhpcy5fb25lVGltZUxpc3RlbmVycyAmJiB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzW3JdID8gdGhpcy5fb25lVGltZUxpc3RlbmVyc1tyXS5zbGljZSgpIDogW107IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgdmFyIHMgPSBvW2FdO1xuICAgICAgICAgIGt0KHIsIHMsIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMpLCBzLmNhbGwodGhpcywgdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdSA9IHRoaXMuX2V2ZW50ZWRQYXJlbnQ7XG4gICAgICAgIHUgJiYgKGgodCwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLl9ldmVudGVkUGFyZW50RGF0YSA/IHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhKCkgOiB0aGlzLl9ldmVudGVkUGFyZW50RGF0YSksIHUuZmlyZSh0KSk7XG4gICAgICB9IGVsc2UgdCBpbnN0YW5jZW9mIHp0ICYmIGNvbnNvbGUuZXJyb3IodC5lcnJvcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIEN0LnByb3RvdHlwZS5saXN0ZW5zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW3RdICYmIHRoaXMuX2xpc3RlbmVyc1t0XS5sZW5ndGggPiAwIHx8IHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMgJiYgdGhpcy5fb25lVGltZUxpc3RlbmVyc1t0XSAmJiB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzW3RdLmxlbmd0aCA+IDAgfHwgdGhpcy5fZXZlbnRlZFBhcmVudCAmJiB0aGlzLl9ldmVudGVkUGFyZW50Lmxpc3RlbnModCk7XG4gICAgfSwgQ3QucHJvdG90eXBlLnNldEV2ZW50ZWRQYXJlbnQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50ZWRQYXJlbnQgPSB0LCB0aGlzLl9ldmVudGVkUGFyZW50RGF0YSA9IGUsIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBFdCA9IHtcbiAgICAgICR2ZXJzaW9uOiA4LFxuICAgICAgJHJvb3Q6IHtcbiAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IFs4XVxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICB6b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBiZWFyaW5nOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIlxuICAgICAgICB9LFxuICAgICAgICBwaXRjaDoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiBcImxpZ2h0XCJcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlczoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcInNvdXJjZXNcIlxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGdseXBoczoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFwidHJhbnNpdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyczoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibGF5ZXJcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlczoge1xuICAgICAgICBcIipcIjoge1xuICAgICAgICAgIHR5cGU6IFwic291cmNlXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZTogW1wic291cmNlX3ZlY3RvclwiLCBcInNvdXJjZV9yYXN0ZXJcIiwgXCJzb3VyY2VfcmFzdGVyX2RlbVwiLCBcInNvdXJjZV9nZW9qc29uXCIsIFwic291cmNlX3ZpZGVvXCIsIFwic291cmNlX2ltYWdlXCJdLFxuICAgICAgc291cmNlX3ZlY3Rvcjoge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmVjdG9yOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICB0aWxlczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICAgIGRlZmF1bHQ6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1lOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB4eXo6IHt9LFxuICAgICAgICAgICAgdG1zOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ4eXpcIlxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1heHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIyXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0aW9uOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBwcm9tb3RlSWQ6IHtcbiAgICAgICAgICB0eXBlOiBcInByb21vdGVJZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHZvbGF0aWxlOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgfSxcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlX3Jhc3Rlcjoge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgcmFzdGVyOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICB0aWxlczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICAgIGRlZmF1bHQ6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgICAgICAgfSxcbiAgICAgICAgbWluem9vbToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBtYXh6b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAyMlxuICAgICAgICB9LFxuICAgICAgICB0aWxlU2l6ZToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogNTEyLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHNjaGVtZToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgeHl6OiB7fSxcbiAgICAgICAgICAgIHRtczoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwieHl6XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRpb246IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIHZvbGF0aWxlOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgfSxcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlX3Jhc3Rlcl9kZW06IHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIFwicmFzdGVyLWRlbVwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICB0aWxlczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICAgIGRlZmF1bHQ6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgICAgICAgfSxcbiAgICAgICAgbWluem9vbToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBtYXh6b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAyMlxuICAgICAgICB9LFxuICAgICAgICB0aWxlU2l6ZToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogNTEyLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0aW9uOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdGVycmFyaXVtOiB7fSxcbiAgICAgICAgICAgIG1hcGJveDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwibWFwYm94XCJcbiAgICAgICAgfSxcbiAgICAgICAgdm9sYXRpbGU6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICB9LFxuICAgICAgICBcIipcIjoge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3VyY2VfZ2VvanNvbjoge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgZ2VvanNvbjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICB9LFxuICAgICAgICBtYXh6b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxOFxuICAgICAgICB9LFxuICAgICAgICBhdHRyaWJ1dGlvbjoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxMjgsXG4gICAgICAgICAgbWF4aW11bTogNTEyLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgfSxcbiAgICAgICAgdG9sZXJhbmNlOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAuMzc1XG4gICAgICAgIH0sXG4gICAgICAgIGNsdXN0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICB9LFxuICAgICAgICBjbHVzdGVyUmFkaXVzOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiA1MCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNsdXN0ZXJNYXhab29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBjbHVzdGVyTWluUG9pbnRzOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBjbHVzdGVyUHJvcGVydGllczoge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVNZXRyaWNzOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZDoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExXG4gICAgICAgIH0sXG4gICAgICAgIHByb21vdGVJZDoge1xuICAgICAgICAgIHR5cGU6IFwicHJvbW90ZUlkXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZV92aWRlbzoge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlkZW86IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cmxzOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBjb29yZGluYXRlczoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZV9pbWFnZToge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW1hZ2U6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBjb29yZGluYXRlczoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgbGVuZ3RoOiA0LFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheWVyOiB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICByZXF1aXJlZDogITBcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgZmlsbDoge30sXG4gICAgICAgICAgICBsaW5lOiB7fSxcbiAgICAgICAgICAgIHN5bWJvbDoge30sXG4gICAgICAgICAgICBjaXJjbGU6IHt9LFxuICAgICAgICAgICAgaGVhdG1hcDoge30sXG4gICAgICAgICAgICBcImZpbGwtZXh0cnVzaW9uXCI6IHt9LFxuICAgICAgICAgICAgcmFzdGVyOiB7fSxcbiAgICAgICAgICAgIGhpbGxzaGFkZToge30sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcInNvdXJjZS1sYXllclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDI0XG4gICAgICAgIH0sXG4gICAgICAgIG1heHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMjRcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgdHlwZTogXCJmaWx0ZXJcIlxuICAgICAgICB9LFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICB0eXBlOiBcImxheW91dFwiXG4gICAgICAgIH0sXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgdHlwZTogXCJwYWludFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXQ6IFtcImxheW91dF9maWxsXCIsIFwibGF5b3V0X2xpbmVcIiwgXCJsYXlvdXRfY2lyY2xlXCIsIFwibGF5b3V0X2hlYXRtYXBcIiwgXCJsYXlvdXRfZmlsbC1leHRydXNpb25cIiwgXCJsYXlvdXRfc3ltYm9sXCIsIFwibGF5b3V0X3Jhc3RlclwiLCBcImxheW91dF9oaWxsc2hhZGVcIiwgXCJsYXlvdXRfYmFja2dyb3VuZFwiXSxcbiAgICAgIGxheW91dF9iYWNrZ3JvdW5kOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dF9maWxsOiB7XG4gICAgICAgIFwiZmlsbC1zb3J0LWtleVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5b3V0X2NpcmNsZToge1xuICAgICAgICBcImNpcmNsZS1zb3J0LWtleVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5b3V0X2hlYXRtYXA6IHtcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJsYXlvdXRfZmlsbC1leHRydXNpb25cIjoge1xuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXRfbGluZToge1xuICAgICAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGJ1dHQ6IHt9LFxuICAgICAgICAgICAgcm91bmQ6IHt9LFxuICAgICAgICAgICAgc3F1YXJlOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJidXR0XCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBiZXZlbDoge30sXG4gICAgICAgICAgICByb3VuZDoge30sXG4gICAgICAgICAgICBtaXRlcjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwibWl0ZXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLjA1LFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtc29ydC1rZXlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dF9zeW1ib2w6IHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHBvaW50OiB7fSxcbiAgICAgICAgICAgIGxpbmU6IHt9LFxuICAgICAgICAgICAgXCJsaW5lLWNlbnRlclwiOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJwb2ludFwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzeW1ib2wtc3BhY2luZ1wiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAyNTAsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzeW1ib2wtc29ydC1rZXlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3ltYm9sLXotb3JkZXJcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgYXV0bzoge30sXG4gICAgICAgICAgICBcInZpZXdwb3J0LXlcIjoge30sXG4gICAgICAgICAgICBzb3VyY2U6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9LFxuICAgICAgICAgICAgYXV0bzoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwiYXV0b1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXNpemVcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBub25lOiB7fSxcbiAgICAgICAgICAgIHdpZHRoOiB7fSxcbiAgICAgICAgICAgIGhlaWdodDoge30sXG4gICAgICAgICAgICBib3RoOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJub25lXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDAsIDAsIDBdLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwidGV4dC1maWVsZFwiLCB7XG4gICAgICAgICAgICBcImljb24tdGV4dC1maXRcIjogW1wiYm90aFwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24taW1hZ2VcIjoge1xuICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgIHRva2VuczogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBwZXJpb2Q6IDM2MCxcbiAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1wYWRkaW5nXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIHtcbiAgICAgICAgICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXCJsaW5lXCIsIFwibGluZS1jZW50ZXJcIl1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tYW5jaG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICBsZWZ0OiB7fSxcbiAgICAgICAgICAgIHJpZ2h0OiB7fSxcbiAgICAgICAgICAgIHRvcDoge30sXG4gICAgICAgICAgICBib3R0b206IHt9LFxuICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgICAgICAgXCJib3R0b20tbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImNlbnRlclwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge30sXG4gICAgICAgICAgICBhdXRvOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge30sXG4gICAgICAgICAgICBhdXRvOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge30sXG4gICAgICAgICAgICBhdXRvOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZm9ybWF0dGVkXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCJcIixcbiAgICAgICAgICB0b2tlbnM6ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGRlZmF1bHQ6IFtcIk9wZW4gU2FucyBSZWd1bGFyXCIsIFwiQXJpYWwgVW5pY29kZSBNUyBSZWd1bGFyXCJdLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxNixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLjIsXG4gICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWp1c3RpZnlcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgYXV0bzoge30sXG4gICAgICAgICAgICBsZWZ0OiB7fSxcbiAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICByaWdodDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1yYWRpYWwtb2Zmc2V0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIHVuaXRzOiBcImVtc1wiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC12YXJpYWJsZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBjZW50ZXI6IHt9LFxuICAgICAgICAgICAgbGVmdDoge30sXG4gICAgICAgICAgICByaWdodDoge30sXG4gICAgICAgICAgICB0b3A6IHt9LFxuICAgICAgICAgICAgYm90dG9tOiB7fSxcbiAgICAgICAgICAgIFwidG9wLWxlZnRcIjoge30sXG4gICAgICAgICAgICBcInRvcC1yaWdodFwiOiB7fSxcbiAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjoge30sXG4gICAgICAgICAgICBcImJvdHRvbS1yaWdodFwiOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcInBvaW50XCJdXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICBsZWZ0OiB7fSxcbiAgICAgICAgICAgIHJpZ2h0OiB7fSxcbiAgICAgICAgICAgIHRvcDoge30sXG4gICAgICAgICAgICBib3R0b206IHt9LFxuICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgICAgICAgXCJib3R0b20tbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImNlbnRlclwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgIFwiIVwiOiBcInRleHQtdmFyaWFibGUtYW5jaG9yXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiA0NSxcbiAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IHt9LFxuICAgICAgICAgICAgdmVydGljYWw6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wicG9pbnRcIl1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBwZXJpb2Q6IDM2MCxcbiAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1wYWRkaW5nXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXCJsaW5lXCIsIFwibGluZS1jZW50ZXJcIl1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbm9uZToge30sXG4gICAgICAgICAgICB1cHBlcmNhc2U6IHt9LFxuICAgICAgICAgICAgbG93ZXJjYXNlOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJub25lXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1vZmZzZXRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgIFwiIVwiOiBcInRleHQtcmFkaWFsLW9mZnNldFwiXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1vcHRpb25hbFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwgXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5b3V0X3Jhc3Rlcjoge1xuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXRfaGlsbHNoYWRlOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIHZhbHVlOiBcIipcIlxuICAgICAgfSxcbiAgICAgIGZpbHRlcl9vcGVyYXRvcjoge1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgXCI9PVwiOiB7fSxcbiAgICAgICAgICBcIiE9XCI6IHt9LFxuICAgICAgICAgIFwiPlwiOiB7fSxcbiAgICAgICAgICBcIj49XCI6IHt9LFxuICAgICAgICAgIFwiPFwiOiB7fSxcbiAgICAgICAgICBcIjw9XCI6IHt9LFxuICAgICAgICAgIGluOiB7fSxcbiAgICAgICAgICBcIiFpblwiOiB7fSxcbiAgICAgICAgICBhbGw6IHt9LFxuICAgICAgICAgIGFueToge30sXG4gICAgICAgICAgbm9uZToge30sXG4gICAgICAgICAgaGFzOiB7fSxcbiAgICAgICAgICBcIiFoYXNcIjoge30sXG4gICAgICAgICAgd2l0aGluOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2VvbWV0cnlfdHlwZToge1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgUG9pbnQ6IHt9LFxuICAgICAgICAgIExpbmVTdHJpbmc6IHt9LFxuICAgICAgICAgIFBvbHlnb246IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbjoge1xuICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgdHlwZTogXCJleHByZXNzaW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcHM6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJhc2U6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIkem9vbVwiXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGlkZW50aXR5OiB7fSxcbiAgICAgICAgICAgIGV4cG9uZW50aWFsOiB7fSxcbiAgICAgICAgICAgIGludGVydmFsOiB7fSxcbiAgICAgICAgICAgIGNhdGVnb3JpY2FsOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJleHBvbmVudGlhbFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yU3BhY2U6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHJnYjoge30sXG4gICAgICAgICAgICBsYWI6IHt9LFxuICAgICAgICAgICAgaGNsOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJyZ2JcIlxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdHlwZTogXCIqXCIsXG4gICAgICAgICAgcmVxdWlyZWQ6ICExXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbl9zdG9wOiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgbWF4aW11bTogMjQsXG4gICAgICAgIHZhbHVlOiBbXCJudW1iZXJcIiwgXCJjb2xvclwiXSxcbiAgICAgICAgbGVuZ3RoOiAyXG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIHZhbHVlOiBcIipcIixcbiAgICAgICAgbWluaW11bTogMVxuICAgICAgfSxcbiAgICAgIGxpZ2h0OiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlld3BvcnRcIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgZGVmYXVsdDogWzEuMTUsIDIxMCwgMzBdLFxuICAgICAgICAgIGxlbmd0aDogMyxcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiNmZmZmZmZcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITBcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZW5zaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgICAgICAgZGVmYXVsdDogLjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFpbnQ6IFtcInBhaW50X2ZpbGxcIiwgXCJwYWludF9saW5lXCIsIFwicGFpbnRfY2lyY2xlXCIsIFwicGFpbnRfaGVhdG1hcFwiLCBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsIFwicGFpbnRfc3ltYm9sXCIsIFwicGFpbnRfcmFzdGVyXCIsIFwicGFpbnRfaGlsbHNoYWRlXCIsIFwicGFpbnRfYmFja2dyb3VuZFwiXSxcbiAgICAgIHBhaW50X2ZpbGw6IHtcbiAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogITBcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiZmlsbC10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtcGF0dGVyblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCI6IHtcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCIhXCI6IFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB1bml0czogXCJtZXRlcnNcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1wiZmlsbC1leHRydXNpb24taGVpZ2h0XCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFpbnRfbGluZToge1xuICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1wibGluZS10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtd2lkdGhcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLWdhcC13aWR0aFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtb2Zmc2V0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtYmx1clwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJsaW5lIHdpZHRoc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1ncmFkaWVudFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCIhXCI6IFwibGluZS1kYXNoYXJyYXlcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgc291cmNlOiBcImdlb2pzb25cIixcbiAgICAgICAgICAgIGhhczoge1xuICAgICAgICAgICAgICBsaW5lTWV0cmljczogITBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wibGluZS1wcm9ncmVzc1wiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9jaXJjbGU6IHtcbiAgICAgICAgXCJjaXJjbGUtcmFkaXVzXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS1ibHVyXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiY2lyY2xlLXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aWV3cG9ydFwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFpbnRfaGVhdG1hcDoge1xuICAgICAgICBcImhlYXRtYXAtcmFkaXVzXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDMwLFxuICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImhlYXRtYXAtd2VpZ2h0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVhdG1hcC1pbnRlbnNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWF0bWFwLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJoZWF0bWFwLWRlbnNpdHlcIl0sIDAsIFwicmdiYSgwLCAwLCAyNTUsIDApXCIsIC4xLCBcInJveWFsYmx1ZVwiLCAuMywgXCJjeWFuXCIsIC41LCBcImxpbWVcIiwgLjcsIFwieWVsbG93XCIsIDEsIFwicmVkXCJdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJoZWF0bWFwLWRlbnNpdHlcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuICAgICAgICB9LFxuICAgICAgICBcImhlYXRtYXAtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9zeW1ib2w6IHtcbiAgICAgICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24taGFsby13aWR0aFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCBcImljb24tdHJhbnNsYXRlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBvdmVycmlkYWJsZTogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtaGFsby1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwgXCJ0ZXh0LXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9yYXN0ZXI6IHtcbiAgICAgICAgXCJyYXN0ZXItb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBwZXJpb2Q6IDM2MCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IC0xLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInJhc3Rlci1jb250cmFzdFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IC0xLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInJhc3Rlci1yZXNhbXBsaW5nXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGxpbmVhcjoge30sXG4gICAgICAgICAgICBuZWFyZXN0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJsaW5lYXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMzAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFpbnRfaGlsbHNoYWRlOiB7XG4gICAgICAgIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMzM1LFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMzU5LFxuICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImhpbGxzaGFkZS1leGFnZ2VyYXRpb25cIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogLjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoaWxsc2hhZGUtc2hhZG93LWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiNGRkZGRkZcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlsbHNoYWRlLWFjY2VudC1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhaW50X2JhY2tncm91bmQ6IHtcbiAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDMwMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiXG4gICAgICAgIH0sXG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiB7XG4gICAgICAgIFwiZGF0YS1kcml2ZW5cIjoge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3Jvc3MtZmFkZWRcIjoge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIjoge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sb3ItcmFtcFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWNvbnN0YW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIlxuICAgICAgICB9LFxuICAgICAgICBjb25zdGFudDoge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9tb3RlSWQ6IHtcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBQdCA9IGZ1bmN0aW9uIFB0KHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9ICh0ID8gdCArIFwiOiBcIiA6IFwiXCIpICsgciwgbiAmJiAodGhpcy5pZGVudGlmaWVyID0gbiksIG51bGwgIT0gZSAmJiBlLl9fbGluZV9fICYmICh0aGlzLmxpbmUgPSBlLl9fbGluZV9fKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTXQodCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlO1xuICAgICAgcmV0dXJuIGUgPyBbbmV3IFB0KHQua2V5LCBlLCBcImNvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OFwiKV0gOiBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCdCh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIHIgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgci0tID4gMDspIHtcbiAgICAgICAgZVtyXSA9IGFyZ3VtZW50c1tyICsgMV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gYSkge1xuICAgICAgICAgIHRbb10gPSBhW29dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFR0KHQpIHtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdCBpbnN0YW5jZW9mIEJvb2xlYW4gPyB0LnZhbHVlT2YoKSA6IHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnQodCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHJldHVybiB0Lm1hcChWdCk7XG5cbiAgICAgIGlmICh0IGluc3RhbmNlb2YgT2JqZWN0ICYmICEodCBpbnN0YW5jZW9mIE51bWJlciB8fCB0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHQgaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgICAgICB2YXIgZSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIHIgaW4gdCkge1xuICAgICAgICAgIGVbcl0gPSBWdCh0W3JdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVHQodCk7XG4gICAgfVxuXG4gICAgdmFyIEZ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgciksIHRoaXMubWVzc2FnZSA9IHIsIHRoaXMua2V5ID0gZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZTtcbiAgICB9KEVycm9yKSxcbiAgICAgICAgRHQgPSBmdW5jdGlvbiBEdCh0LCBlKSB7XG4gICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSBbXSksIHRoaXMucGFyZW50ID0gdCwgdGhpcy5iaW5kaW5ncyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciByID0gMCwgbiA9IGU7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgIHZhciBpID0gbltyXTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1tpWzBdXSA9IGlbMV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIER0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyBEdCh0aGlzLCB0KTtcbiAgICB9LCBEdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLmJpbmRpbmdzW3RdKSByZXR1cm4gdGhpcy5iaW5kaW5nc1t0XTtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkgcmV0dXJuIHRoaXMucGFyZW50LmdldCh0KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ICsgXCIgbm90IGZvdW5kIGluIHNjb3BlLlwiKTtcbiAgICB9LCBEdC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuYmluZGluZ3NbdF0gfHwgISF0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oYXModCk7XG4gICAgfTtcbiAgICB2YXIgTHQgPSB7XG4gICAgICBraW5kOiBcIm51bGxcIlxuICAgIH0sXG4gICAgICAgIE90ID0ge1xuICAgICAga2luZDogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgICAgIFJ0ID0ge1xuICAgICAga2luZDogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgICAgIFV0ID0ge1xuICAgICAga2luZDogXCJib29sZWFuXCJcbiAgICB9LFxuICAgICAgICBqdCA9IHtcbiAgICAgIGtpbmQ6IFwiY29sb3JcIlxuICAgIH0sXG4gICAgICAgIHF0ID0ge1xuICAgICAga2luZDogXCJvYmplY3RcIlxuICAgIH0sXG4gICAgICAgIE50ID0ge1xuICAgICAga2luZDogXCJ2YWx1ZVwiXG4gICAgfSxcbiAgICAgICAgS3QgPSB7XG4gICAgICBraW5kOiBcImNvbGxhdG9yXCJcbiAgICB9LFxuICAgICAgICBHdCA9IHtcbiAgICAgIGtpbmQ6IFwiZm9ybWF0dGVkXCJcbiAgICB9LFxuICAgICAgICBadCA9IHtcbiAgICAgIGtpbmQ6IFwicmVzb2x2ZWRJbWFnZVwiXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFh0KHQsIGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgaXRlbVR5cGU6IHQsXG4gICAgICAgIE46IGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSnQodCkge1xuICAgICAgaWYgKFwiYXJyYXlcIiA9PT0gdC5raW5kKSB7XG4gICAgICAgIHZhciBlID0gSnQodC5pdGVtVHlwZSk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0Lk4gPyBcImFycmF5PFwiICsgZSArIFwiLCBcIiArIHQuTiArIFwiPlwiIDogXCJ2YWx1ZVwiID09PSB0Lml0ZW1UeXBlLmtpbmQgPyBcImFycmF5XCIgOiBcImFycmF5PFwiICsgZSArIFwiPlwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5raW5kO1xuICAgIH1cblxuICAgIHZhciBIdCA9IFtMdCwgT3QsIFJ0LCBVdCwganQsIEd0LCBxdCwgWHQoTnQpLCBadF07XG5cbiAgICBmdW5jdGlvbiBZdCh0LCBlKSB7XG4gICAgICBpZiAoXCJlcnJvclwiID09PSBlLmtpbmQpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoXCJhcnJheVwiID09PSB0LmtpbmQpIHtcbiAgICAgICAgaWYgKFwiYXJyYXlcIiA9PT0gZS5raW5kICYmICgwID09PSBlLk4gJiYgXCJ2YWx1ZVwiID09PSBlLml0ZW1UeXBlLmtpbmQgfHwgIVl0KHQuaXRlbVR5cGUsIGUuaXRlbVR5cGUpKSAmJiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdC5OIHx8IHQuTiA9PT0gZS5OKSkgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodC5raW5kID09PSBlLmtpbmQpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiID09PSB0LmtpbmQpIGZvciAodmFyIHIgPSAwLCBuID0gSHQ7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgaWYgKCFZdChuW3JdLCBlKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBKdCh0KSArIFwiIGJ1dCBmb3VuZCBcIiArIEp0KGUpICsgXCIgaW5zdGVhZC5cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdCh0LCBlKSB7XG4gICAgICByZXR1cm4gZS5zb21lKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmtpbmQgPT09IHQua2luZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFd0KHQsIGUpIHtcbiAgICAgIHJldHVybiBlLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiID09PSBlID8gbnVsbCA9PT0gdCA6IFwiYXJyYXlcIiA9PT0gZSA/IEFycmF5LmlzQXJyYXkodCkgOiBcIm9iamVjdFwiID09PSBlID8gdCAmJiAhQXJyYXkuaXNBcnJheSh0KSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB0IDogZSA9PT0gdHlwZW9mIHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgUXQgPSBlKGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NSwgMV0sXG4gICAgICAgIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTUsIDFdLFxuICAgICAgICBhcXVhOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAgICAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMiwgMV0sXG4gICAgICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NSwgMV0sXG4gICAgICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICAgICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTYsIDFdLFxuICAgICAgICBibGFjazogWzAsIDAsIDAsIDFdLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAgICAgICBibHVlOiBbMCwgMCwgMjU1LCAxXSxcbiAgICAgICAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNiwgMV0sXG4gICAgICAgIGJyb3duOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAgICAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1LCAxXSxcbiAgICAgICAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwLCAxXSxcbiAgICAgICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwLCAxXSxcbiAgICAgICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwLCAxXSxcbiAgICAgICAgY29yYWw6IFsyNTUsIDEyNywgODAsIDFdLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAgICAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjAsIDFdLFxuICAgICAgICBjcmltc29uOiBbMjIwLCAyMCwgNjAsIDFdLFxuICAgICAgICBjeWFuOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAgICAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOSwgMV0sXG4gICAgICAgIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzksIDFdLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgICAgICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgICAgICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwLCAxXSxcbiAgICAgICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgICAgICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwNywgMV0sXG4gICAgICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzksIDFdLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgICAgICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwLCAxXSxcbiAgICAgICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNCwgMV0sXG4gICAgICAgIGRhcmtyZWQ6IFsxMzksIDAsIDAsIDFdLFxuICAgICAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMiwgMV0sXG4gICAgICAgIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDMsIDFdLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzksIDFdLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OSwgMV0sXG4gICAgICAgIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5LCAxXSxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5LCAxXSxcbiAgICAgICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExLCAxXSxcbiAgICAgICAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDcsIDFdLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1LCAxXSxcbiAgICAgICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAgICAgICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICAgICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAgICAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNCwgMV0sXG4gICAgICAgIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MCwgMV0sXG4gICAgICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAgICAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAgICAgICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwLCAxXSxcbiAgICAgICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAgICAgICBnb2xkOiBbMjU1LCAyMTUsIDAsIDFdLFxuICAgICAgICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzIsIDFdLFxuICAgICAgICBncmF5OiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICAgICAgIGdyZWVuOiBbMCwgMTI4LCAwLCAxXSxcbiAgICAgICAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDcsIDFdLFxuICAgICAgICBncmV5OiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICAgICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MCwgMV0sXG4gICAgICAgIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwLCAxXSxcbiAgICAgICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAgICAgICBpbmRpZ286IFs3NSwgMCwgMTMwLCAxXSxcbiAgICAgICAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwLCAxXSxcbiAgICAgICAga2hha2k6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgICAgICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwLCAxXSxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDUsIDFdLFxuICAgICAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMCwgMV0sXG4gICAgICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDUsIDFdLFxuICAgICAgICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwLCAxXSxcbiAgICAgICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAgICAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwLCAxXSxcbiAgICAgICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICAgICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0LCAxXSxcbiAgICAgICAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICAgICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAgICAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjIsIDFdLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwLCAxXSxcbiAgICAgICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICAgICAgIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICAgICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNCwgMV0sXG4gICAgICAgIGxpbWU6IFswLCAyNTUsIDAsIDFdLFxuICAgICAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MCwgMV0sXG4gICAgICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMCwgMV0sXG4gICAgICAgIG1hZ2VudGE6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICAgICAgIG1hcm9vbjogWzEyOCwgMCwgMCwgMV0sXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwLCAxXSxcbiAgICAgICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNSwgMV0sXG4gICAgICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMSwgMV0sXG4gICAgICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTksIDFdLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExMywgMV0sXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0LCAxXSxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0LCAxXSxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgICAgICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTIsIDFdLFxuICAgICAgICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwLCAxXSxcbiAgICAgICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICAgICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MSwgMV0sXG4gICAgICAgIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3MywgMV0sXG4gICAgICAgIG5hdnk6IFswLCAwLCAxMjgsIDFdLFxuICAgICAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMCwgMV0sXG4gICAgICAgIG9saXZlOiBbMTI4LCAxMjgsIDAsIDFdLFxuICAgICAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAgICAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMCwgMV0sXG4gICAgICAgIG9yYW5nZXJlZDogWzI1NSwgNjksIDAsIDFdLFxuICAgICAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzAsIDFdLFxuICAgICAgICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyLCAxXSxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0NywgMV0sXG4gICAgICAgIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzLCAxXSxcbiAgICAgICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICAgICAgIHBlcnU6IFsyMDUsIDEzMywgNjMsIDFdLFxuICAgICAgICBwaW5rOiBbMjU1LCAxOTIsIDIwMywgMV0sXG4gICAgICAgIHBsdW06IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgICAgICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzAsIDFdLFxuICAgICAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOCwgMV0sXG4gICAgICAgIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTMsIDFdLFxuICAgICAgICByZWQ6IFsyNTUsIDAsIDAsIDFdLFxuICAgICAgICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgICAgICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgICAgICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOSwgMV0sXG4gICAgICAgIHNhbG1vbjogWzI1MCwgMTI4LCAxMTQsIDFdLFxuICAgICAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgICAgICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4NywgMV0sXG4gICAgICAgIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICAgICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1LCAxXSxcbiAgICAgICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5MiwgMV0sXG4gICAgICAgIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1LCAxXSxcbiAgICAgICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgICAgICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICAgICAgIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAgICAgICBzbm93OiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICAgICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjcsIDFdLFxuICAgICAgICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODAsIDFdLFxuICAgICAgICB0YW46IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgICAgICAgdGVhbDogWzAsIDEyOCwgMTI4LCAxXSxcbiAgICAgICAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAgICAgICB0b21hdG86IFsyNTUsIDk5LCA3MSwgMV0sXG4gICAgICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOCwgMV0sXG4gICAgICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzgsIDFdLFxuICAgICAgICB3aGVhdDogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAgICAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTUsIDFdLFxuICAgICAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICAgICAgIHllbGxvdzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgICAgICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTAsIDFdXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBuKHQpIHtcbiAgICAgICAgcmV0dXJuICh0ID0gTWF0aC5yb3VuZCh0KSkgPCAwID8gMCA6IHQgPiAyNTUgPyAyNTUgOiB0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgcmV0dXJuIG4oXCIlXCIgPT09IHRbdC5sZW5ndGggLSAxXSA/IHBhcnNlRmxvYXQodCkgLyAxMDAgKiAyNTUgOiBwYXJzZUludCh0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGEodCkge1xuICAgICAgICByZXR1cm4gKGUgPSBcIiVcIiA9PT0gdFt0Lmxlbmd0aCAtIDFdID8gcGFyc2VGbG9hdCh0KSAvIDEwMCA6IHBhcnNlRmxvYXQodCkpIDwgMCA/IDAgOiBlID4gMSA/IDEgOiBlO1xuICAgICAgICB2YXIgZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbyh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiByIDwgMCA/IHIgKz0gMSA6IHIgPiAxICYmIChyIC09IDEpLCA2ICogciA8IDEgPyB0ICsgKGUgLSB0KSAqIHIgKiA2IDogMiAqIHIgPCAxID8gZSA6IDMgKiByIDwgMiA/IHQgKyAoZSAtIHQpICogKDIgLyAzIC0gcikgKiA2IDogdDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZS5wYXJzZUNTU0NvbG9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgICAgcyA9IHQucmVwbGFjZSgvIC9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChzIGluIHIpIHJldHVybiByW3NdLnNsaWNlKCk7XG4gICAgICAgICAgaWYgKFwiI1wiID09PSBzWzBdKSByZXR1cm4gNCA9PT0gcy5sZW5ndGggPyAoZSA9IHBhcnNlSW50KHMuc3Vic3RyKDEpLCAxNikpID49IDAgJiYgZSA8PSA0MDk1ID8gWygzODQwICYgZSkgPj4gNCB8ICgzODQwICYgZSkgPj4gOCwgMjQwICYgZSB8ICgyNDAgJiBlKSA+PiA0LCAxNSAmIGUgfCAoMTUgJiBlKSA8PCA0LCAxXSA6IG51bGwgOiA3ID09PSBzLmxlbmd0aCAmJiAoZSA9IHBhcnNlSW50KHMuc3Vic3RyKDEpLCAxNikpID49IDAgJiYgZSA8PSAxNjc3NzIxNSA/IFsoMTY3MTE2ODAgJiBlKSA+PiAxNiwgKDY1MjgwICYgZSkgPj4gOCwgMjU1ICYgZSwgMV0gOiBudWxsO1xuICAgICAgICAgIHZhciB1ID0gcy5pbmRleE9mKFwiKFwiKSxcbiAgICAgICAgICAgICAgbCA9IHMuaW5kZXhPZihcIilcIik7XG5cbiAgICAgICAgICBpZiAoLTEgIT09IHUgJiYgbCArIDEgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHMuc3Vic3RyKDAsIHUpLFxuICAgICAgICAgICAgICAgIGMgPSBzLnN1YnN0cih1ICsgMSwgbCAtICh1ICsgMSkpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgICAgICBoID0gMTtcblxuICAgICAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZ2JhXCI6XG4gICAgICAgICAgICAgICAgaWYgKDQgIT09IGMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBoID0gYShjLnBvcCgpKTtcblxuICAgICAgICAgICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgIT09IGMubGVuZ3RoID8gbnVsbCA6IFtpKGNbMF0pLCBpKGNbMV0pLCBpKGNbMl0pLCBoXTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaHNsYVwiOlxuICAgICAgICAgICAgICAgIGlmICg0ICE9PSBjLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaCA9IGEoYy5wb3AoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgICAgICAgICAgIGlmICgzICE9PSBjLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAocGFyc2VGbG9hdChjWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjAsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBhKGNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBkID0gYShjWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGQgPD0gLjUgPyBkICogKHkgKyAxKSA6IGQgKyB5IC0gZCAqIHksXG4gICAgICAgICAgICAgICAgICAgIHYgPSAyICogZCAtIG07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuKDI1NSAqIG8odiwgbSwgZiArIDEgLyAzKSksIG4oMjU1ICogbyh2LCBtLCBmKSksIG4oMjU1ICogbyh2LCBtLCBmIC0gMSAvIDMpKSwgaF07XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgfSkucGFyc2VDU1NDb2xvcixcbiAgICAgICAgdGUgPSBmdW5jdGlvbiB0ZSh0LCBlLCByLCBuKSB7XG4gICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAxKSwgdGhpcy5yID0gdCwgdGhpcy5nID0gZSwgdGhpcy5iID0gciwgdGhpcy5hID0gbjtcbiAgICB9O1xuXG4gICAgdGUucGFyc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiB0ZSkgcmV0dXJuIHQ7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICB2YXIgZSA9IFF0KHQpO1xuICAgICAgICAgIGlmIChlKSByZXR1cm4gbmV3IHRlKGVbMF0gLyAyNTUgKiBlWzNdLCBlWzFdIC8gMjU1ICogZVszXSwgZVsyXSAvIDI1NSAqIGVbM10sIGVbM10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnRvQXJyYXkoKSxcbiAgICAgICAgICBlID0gdFsxXSxcbiAgICAgICAgICByID0gdFsyXSxcbiAgICAgICAgICBuID0gdFszXTtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyBNYXRoLnJvdW5kKHRbMF0pICsgXCIsXCIgKyBNYXRoLnJvdW5kKGUpICsgXCIsXCIgKyBNYXRoLnJvdW5kKHIpICsgXCIsXCIgKyBuICsgXCIpXCI7XG4gICAgfSwgdGUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuYTtcbiAgICAgIHJldHVybiAwID09PSB0ID8gWzAsIDAsIDAsIDBdIDogWzI1NSAqIHRoaXMuciAvIHQsIDI1NSAqIHRoaXMuZyAvIHQsIDI1NSAqIHRoaXMuYiAvIHQsIHRdO1xuICAgIH0sIHRlLmJsYWNrID0gbmV3IHRlKDAsIDAsIDAsIDEpLCB0ZS53aGl0ZSA9IG5ldyB0ZSgxLCAxLCAxLCAxKSwgdGUudHJhbnNwYXJlbnQgPSBuZXcgdGUoMCwgMCwgMCwgMCksIHRlLnJlZCA9IG5ldyB0ZSgxLCAwLCAwLCAxKTtcblxuICAgIHZhciBlZSA9IGZ1bmN0aW9uIGVlKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSB0ID8gZSA/IFwidmFyaWFudFwiIDogXCJjYXNlXCIgOiBlID8gXCJhY2NlbnRcIiA6IFwiYmFzZVwiLCB0aGlzLmxvY2FsZSA9IHIsIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHtcbiAgICAgICAgc2Vuc2l0aXZpdHk6IHRoaXMuc2Vuc2l0aXZpdHksXG4gICAgICAgIHVzYWdlOiBcInNlYXJjaFwiXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IuY29tcGFyZSh0LCBlKTtcbiAgICB9LCBlZS5wcm90b3R5cGUucmVzb2x2ZWRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgfTtcblxuICAgIHZhciByZSA9IGZ1bmN0aW9uIHJlKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMudGV4dCA9IHQsIHRoaXMuaW1hZ2UgPSBlLCB0aGlzLnNjYWxlID0gciwgdGhpcy5mb250U3RhY2sgPSBuLCB0aGlzLnRleHRDb2xvciA9IGk7XG4gICAgfSxcbiAgICAgICAgbmUgPSBmdW5jdGlvbiBuZSh0KSB7XG4gICAgICB0aGlzLnNlY3Rpb25zID0gdDtcbiAgICB9O1xuXG4gICAgbmUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IG5lKFtuZXcgcmUodCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTtcbiAgICB9LCBuZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLnNlY3Rpb25zLmxlbmd0aCB8fCAhdGhpcy5zZWN0aW9ucy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAwICE9PSB0LnRleHQubGVuZ3RoIHx8IHQuaW1hZ2UgJiYgMCAhPT0gdC5pbWFnZS5uYW1lLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH0sIG5lLmZhY3RvcnkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBuZSA/IHQgOiBuZS5mcm9tU3RyaW5nKHQpO1xuICAgIH0sIG5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLnNlY3Rpb25zLmxlbmd0aCA/IFwiXCIgOiB0aGlzLnNlY3Rpb25zLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC50ZXh0O1xuICAgICAgfSkuam9pbihcIlwiKTtcbiAgICB9LCBuZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IFtcImZvcm1hdFwiXSwgZSA9IDAsIHIgPSB0aGlzLnNlY3Rpb25zOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgIGlmIChuLmltYWdlKSB0LnB1c2goW1wiaW1hZ2VcIiwgbi5pbWFnZS5uYW1lXSk7ZWxzZSB7XG4gICAgICAgICAgdC5wdXNoKG4udGV4dCk7XG4gICAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgICBuLmZvbnRTdGFjayAmJiAoaVtcInRleHQtZm9udFwiXSA9IFtcImxpdGVyYWxcIiwgbi5mb250U3RhY2suc3BsaXQoXCIsXCIpXSksIG4uc2NhbGUgJiYgKGlbXCJmb250LXNjYWxlXCJdID0gbi5zY2FsZSksIG4udGV4dENvbG9yICYmIChpW1widGV4dC1jb2xvclwiXSA9IFtcInJnYmFcIl0uY29uY2F0KG4udGV4dENvbG9yLnRvQXJyYXkoKSkpLCB0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciBpZSA9IGZ1bmN0aW9uIGllKHQpIHtcbiAgICAgIHRoaXMubmFtZSA9IHQubmFtZSwgdGhpcy5hdmFpbGFibGUgPSB0LmF2YWlsYWJsZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYWUodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgdCA+PSAwICYmIHQgPD0gMjU1ICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgJiYgZSA+PSAwICYmIGUgPD0gMjU1ICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIHIgJiYgciA+PSAwICYmIHIgPD0gMjU1ID8gdm9pZCAwID09PSBuIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIG4gJiYgbiA+PSAwICYmIG4gPD0gMSA/IG51bGwgOiBcIkludmFsaWQgcmdiYSB2YWx1ZSBbXCIgKyBbdCwgZSwgciwgbl0uam9pbihcIiwgXCIpICsgXCJdOiAnYScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXCIgOiBcIkludmFsaWQgcmdiYSB2YWx1ZSBbXCIgKyAoXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IFt0LCBlLCByLCBuXSA6IFt0LCBlLCByXSkuam9pbihcIiwgXCIpICsgXCJdOiAncicsICdnJywgYW5kICdiJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9lKHQpIHtcbiAgICAgIGlmIChudWxsID09PSB0KSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwiYm9vbGVhblwiID09IHR5cGVvZiB0KSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgdCkgcmV0dXJuICEwO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiB0ZSkgcmV0dXJuICEwO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBlZSkgcmV0dXJuICEwO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBuZSkgcmV0dXJuICEwO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBpZSkgcmV0dXJuICEwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgaWYgKCFvZShyW2VdKSkgcmV0dXJuICExO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICBmb3IgKHZhciBuIGluIHQpIHtcbiAgICAgICAgICBpZiAoIW9lKHRbbl0pKSByZXR1cm4gITE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZSh0KSB7XG4gICAgICBpZiAobnVsbCA9PT0gdCkgcmV0dXJuIEx0O1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHJldHVybiBSdDtcbiAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCkgcmV0dXJuIFV0O1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHQpIHJldHVybiBPdDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgdGUpIHJldHVybiBqdDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgZWUpIHJldHVybiBLdDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgbmUpIHJldHVybiBHdDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgaWUpIHJldHVybiBadDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgZm9yICh2YXIgZSwgciA9IHQubGVuZ3RoLCBuID0gMCwgaSA9IHQ7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSBzZShpW25dKTtcblxuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gYSkgY29udGludWU7XG4gICAgICAgICAgICBlID0gTnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBYdChlIHx8IE50LCByKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHF0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVlKHQpIHtcbiAgICAgIHZhciBlID0gdHlwZW9mIHQ7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gdCA/IFwiXCIgOiBcInN0cmluZ1wiID09PSBlIHx8IFwibnVtYmVyXCIgPT09IGUgfHwgXCJib29sZWFuXCIgPT09IGUgPyBTdHJpbmcodCkgOiB0IGluc3RhbmNlb2YgdGUgfHwgdCBpbnN0YW5jZW9mIG5lIHx8IHQgaW5zdGFuY2VvZiBpZSA/IHQudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHQpO1xuICAgIH1cblxuICAgIGllLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfSwgaWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCA/IG5ldyBpZSh7XG4gICAgICAgIG5hbWU6IHQsXG4gICAgICAgIGF2YWlsYWJsZTogITFcbiAgICAgIH0pIDogbnVsbDtcbiAgICB9LCBpZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcImltYWdlXCIsIHRoaXMubmFtZV07XG4gICAgfTtcblxuICAgIHZhciBsZSA9IGZ1bmN0aW9uIGxlKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMudmFsdWUgPSBlO1xuICAgIH07XG5cbiAgICBsZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiJ2xpdGVyYWwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIW9lKHRbMV0pKSByZXR1cm4gZS5lcnJvcihcImludmFsaWQgdmFsdWVcIik7XG4gICAgICB2YXIgciA9IHRbMV0sXG4gICAgICAgICAgbiA9IHNlKHIpLFxuICAgICAgICAgIGkgPSBlLmV4cGVjdGVkVHlwZTtcbiAgICAgIHJldHVybiBcImFycmF5XCIgIT09IG4ua2luZCB8fCAwICE9PSBuLk4gfHwgIWkgfHwgXCJhcnJheVwiICE9PSBpLmtpbmQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgaS5OICYmIDAgIT09IGkuTiB8fCAobiA9IGkpLCBuZXcgbGUobiwgcik7XG4gICAgfSwgbGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSwgbGUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICgpIHt9LCBsZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LCBsZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiYXJyYXlcIiA9PT0gdGhpcy50eXBlLmtpbmQgfHwgXCJvYmplY3RcIiA9PT0gdGhpcy50eXBlLmtpbmQgPyBbXCJsaXRlcmFsXCIsIHRoaXMudmFsdWVdIDogdGhpcy52YWx1ZSBpbnN0YW5jZW9mIHRlID8gW1wicmdiYVwiXS5jb25jYXQodGhpcy52YWx1ZS50b0FycmF5KCkpIDogdGhpcy52YWx1ZSBpbnN0YW5jZW9mIG5lID8gdGhpcy52YWx1ZS5zZXJpYWxpemUoKSA6IHRoaXMudmFsdWU7XG4gICAgfTtcblxuICAgIHZhciBwZSA9IGZ1bmN0aW9uIHBlKHQpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiRXhwcmVzc2lvbkV2YWx1YXRpb25FcnJvclwiLCB0aGlzLm1lc3NhZ2UgPSB0O1xuICAgIH07XG5cbiAgICBwZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgdmFyIGNlID0ge1xuICAgICAgc3RyaW5nOiBSdCxcbiAgICAgIG51bWJlcjogT3QsXG4gICAgICBib29sZWFuOiBVdCxcbiAgICAgIG9iamVjdDogcXRcbiAgICB9LFxuICAgICAgICBoZSA9IGZ1bmN0aW9uIGhlKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuYXJncyA9IGU7XG4gICAgfTtcblxuICAgIGhlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8IDIpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciByLFxuICAgICAgICAgIG4gPSAxLFxuICAgICAgICAgIGkgPSB0WzBdO1xuXG4gICAgICBpZiAoXCJhcnJheVwiID09PSBpKSB7XG4gICAgICAgIHZhciBhLCBvO1xuXG4gICAgICAgIGlmICh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgcyA9IHRbMV07XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHMgfHwgIShzIGluIGNlKSB8fCBcIm9iamVjdFwiID09PSBzKSByZXR1cm4gZS5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiBcImFycmF5XCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4nLCAxKTtcbiAgICAgICAgICBhID0gY2Vbc10sIG4rKztcbiAgICAgICAgfSBlbHNlIGEgPSBOdDtcblxuICAgICAgICBpZiAodC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHRbMl0gJiYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHRbMl0gfHwgdFsyXSA8IDAgfHwgdFsyXSAhPT0gTWF0aC5mbG9vcih0WzJdKSkpIHJldHVybiBlLmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgICAgbyA9IHRbMl0sIG4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSBYdChhLCBvKTtcbiAgICAgIH0gZWxzZSByID0gY2VbaV07XG5cbiAgICAgIGZvciAodmFyIHUgPSBbXTsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGwgPSBlLnBhcnNlKHRbbl0sIG4sIE50KTtcbiAgICAgICAgaWYgKCFsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdS5wdXNoKGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGhlKHIsIHUpO1xuICAgIH0sIGhlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuYXJncy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYXJnc1tlXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgaWYgKCFZdCh0aGlzLnR5cGUsIHNlKHIpKSkgcmV0dXJuIHI7XG4gICAgICAgIGlmIChlID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkgdGhyb3cgbmV3IHBlKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBcIiArIEp0KHRoaXMudHlwZSkgKyBcIiwgYnV0IGZvdW5kIFwiICsgSnQoc2UocikpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIGhlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5hcmdzLmZvckVhY2godCk7XG4gICAgfSwgaGUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH0sIGhlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMudHlwZSxcbiAgICAgICAgICBlID0gW3Qua2luZF07XG5cbiAgICAgIGlmIChcImFycmF5XCIgPT09IHQua2luZCkge1xuICAgICAgICB2YXIgciA9IHQuaXRlbVR5cGU7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHIua2luZCB8fCBcIm51bWJlclwiID09PSByLmtpbmQgfHwgXCJib29sZWFuXCIgPT09IHIua2luZCkge1xuICAgICAgICAgIGUucHVzaChyLmtpbmQpO1xuICAgICAgICAgIHZhciBuID0gdC5OO1xuICAgICAgICAgIChcIm51bWJlclwiID09IHR5cGVvZiBuIHx8IHRoaXMuYXJncy5sZW5ndGggPiAxKSAmJiBlLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUuY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuc2VyaWFsaXplKCk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHZhciBmZSA9IGZ1bmN0aW9uIGZlKHQpIHtcbiAgICAgIHRoaXMudHlwZSA9IEd0LCB0aGlzLnNlY3Rpb25zID0gdDtcbiAgICB9O1xuXG4gICAgZmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgMikgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSB0WzFdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIpIHJldHVybiBlLmVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbWFnZSBvciB0ZXh0IHNlY3Rpb24uXCIpO1xuXG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAhMSwgYSA9IDE7IGEgPD0gdC5sZW5ndGggLSAxOyArK2EpIHtcbiAgICAgICAgdmFyIG8gPSB0W2FdO1xuXG4gICAgICAgIGlmIChpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG8gJiYgIUFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgICBpID0gITE7XG4gICAgICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgICAgIGlmIChvW1wiZm9udC1zY2FsZVwiXSAmJiAhKHMgPSBlLnBhcnNlKG9bXCJmb250LXNjYWxlXCJdLCAxLCBPdCkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgdSA9IG51bGw7XG4gICAgICAgICAgaWYgKG9bXCJ0ZXh0LWZvbnRcIl0gJiYgISh1ID0gZS5wYXJzZShvW1widGV4dC1mb250XCJdLCAxLCBYdChSdCkpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIGwgPSBudWxsO1xuICAgICAgICAgIGlmIChvW1widGV4dC1jb2xvclwiXSAmJiAhKGwgPSBlLnBhcnNlKG9bXCJ0ZXh0LWNvbG9yXCJdLCAxLCBqdCkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcCA9IG5bbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICBwLnNjYWxlID0gcywgcC5mb250ID0gdSwgcC50ZXh0Q29sb3IgPSBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjID0gZS5wYXJzZSh0W2FdLCAxLCBOdCk7XG4gICAgICAgICAgaWYgKCFjKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgaCA9IGMudHlwZS5raW5kO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBoICYmIFwidmFsdWVcIiAhPT0gaCAmJiBcIm51bGxcIiAhPT0gaCAmJiBcInJlc29sdmVkSW1hZ2VcIiAhPT0gaCkgcmV0dXJuIGUuZXJyb3IoXCJGb3JtYXR0ZWQgdGV4dCB0eXBlIG11c3QgYmUgJ3N0cmluZycsICd2YWx1ZScsICdpbWFnZScgb3IgJ251bGwnLlwiKTtcbiAgICAgICAgICBpID0gITAsIG4ucHVzaCh7XG4gICAgICAgICAgICBjb250ZW50OiBjLFxuICAgICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgICBmb250OiBudWxsLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmZShuKTtcbiAgICB9LCBmZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyBuZSh0aGlzLnNlY3Rpb25zLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuY29udGVudC5ldmFsdWF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIHNlKHIpID09PSBadCA/IG5ldyByZShcIlwiLCByLCBudWxsLCBudWxsLCBudWxsKSA6IG5ldyByZSh1ZShyKSwgbnVsbCwgZS5zY2FsZSA/IGUuc2NhbGUuZXZhbHVhdGUodCkgOiBudWxsLCBlLmZvbnQgPyBlLmZvbnQuZXZhbHVhdGUodCkuam9pbihcIixcIikgOiBudWxsLCBlLnRleHRDb2xvciA/IGUudGV4dENvbG9yLmV2YWx1YXRlKHQpIDogbnVsbCk7XG4gICAgICB9KSk7XG4gICAgfSwgZmUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHRoaXMuc2VjdGlvbnM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXTtcbiAgICAgICAgdChuLmNvbnRlbnQpLCBuLnNjYWxlICYmIHQobi5zY2FsZSksIG4uZm9udCAmJiB0KG4uZm9udCksIG4udGV4dENvbG9yICYmIHQobi50ZXh0Q29sb3IpO1xuICAgICAgfVxuICAgIH0sIGZlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGZlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gW1wiZm9ybWF0XCJdLCBlID0gMCwgciA9IHRoaXMuc2VjdGlvbnM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXTtcbiAgICAgICAgdC5wdXNoKG4uY29udGVudC5zZXJpYWxpemUoKSk7XG4gICAgICAgIHZhciBpID0ge307XG4gICAgICAgIG4uc2NhbGUgJiYgKGlbXCJmb250LXNjYWxlXCJdID0gbi5zY2FsZS5zZXJpYWxpemUoKSksIG4uZm9udCAmJiAoaVtcInRleHQtZm9udFwiXSA9IG4uZm9udC5zZXJpYWxpemUoKSksIG4udGV4dENvbG9yICYmIChpW1widGV4dC1jb2xvclwiXSA9IG4udGV4dENvbG9yLnNlcmlhbGl6ZSgpKSwgdC5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgdmFyIHllID0gZnVuY3Rpb24geWUodCkge1xuICAgICAgdGhpcy50eXBlID0gWnQsIHRoaXMuaW5wdXQgPSB0O1xuICAgIH07XG5cbiAgICB5ZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSwgUnQpO1xuICAgICAgcmV0dXJuIHIgPyBuZXcgeWUocikgOiBlLmVycm9yKFwiTm8gaW1hZ2UgbmFtZSBwcm92aWRlZC5cIik7XG4gICAgfSwgeWUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KSxcbiAgICAgICAgICByID0gaWUuZnJvbVN0cmluZyhlKTtcbiAgICAgIHJldHVybiByICYmIHQuYXZhaWxhYmxlSW1hZ2VzICYmIChyLmF2YWlsYWJsZSA9IHQuYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YoZSkgPiAtMSksIHI7XG4gICAgfSwgeWUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMuaW5wdXQpO1xuICAgIH0sIHllLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIHllLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1wiaW1hZ2VcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV07XG4gICAgfTtcblxuICAgIHZhciBkZSA9IHtcbiAgICAgIFwidG8tYm9vbGVhblwiOiBVdCxcbiAgICAgIFwidG8tY29sb3JcIjoganQsXG4gICAgICBcInRvLW51bWJlclwiOiBPdCxcbiAgICAgIFwidG8tc3RyaW5nXCI6IFJ0XG4gICAgfSxcbiAgICAgICAgbWUgPSBmdW5jdGlvbiBtZSh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmFyZ3MgPSBlO1xuICAgIH07XG5cbiAgICBtZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCAyKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IHRbMF07XG4gICAgICBpZiAoKFwidG8tYm9vbGVhblwiID09PSByIHx8IFwidG8tc3RyaW5nXCIgPT09IHIpICYmIDIgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG5cbiAgICAgIGZvciAodmFyIG4gPSBkZVtyXSwgaSA9IFtdLCBhID0gMTsgYSA8IHQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIG8gPSBlLnBhcnNlKHRbYV0sIGEsIE50KTtcbiAgICAgICAgaWYgKCFvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaS5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IG1lKG4sIGkpO1xuICAgIH0sIG1lLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAoXCJib29sZWFuXCIgPT09IHRoaXMudHlwZS5raW5kKSByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUodCkpO1xuXG4gICAgICBpZiAoXCJjb2xvclwiID09PSB0aGlzLnR5cGUua2luZCkge1xuICAgICAgICBmb3IgKHZhciBlLCByLCBuID0gMCwgaSA9IHRoaXMuYXJnczsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICBpZiAociA9IG51bGwsIChlID0gaVtuXS5ldmFsdWF0ZSh0KSkgaW5zdGFuY2VvZiB0ZSkgcmV0dXJuIGU7XG5cbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgICAgICAgICAgdmFyIGEgPSB0LnBhcnNlQ29sb3IoZSk7XG4gICAgICAgICAgICBpZiAoYSkgcmV0dXJuIGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGUpICYmICEociA9IGUubGVuZ3RoIDwgMyB8fCBlLmxlbmd0aCA+IDQgPyBcIkludmFsaWQgcmJnYSB2YWx1ZSBcIiArIEpTT04uc3RyaW5naWZ5KGUpICsgXCI6IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuXCIgOiBhZShlWzBdLCBlWzFdLCBlWzJdLCBlWzNdKSkpIHJldHVybiBuZXcgdGUoZVswXSAvIDI1NSwgZVsxXSAvIDI1NSwgZVsyXSAvIDI1NSwgZVszXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgcGUociB8fCBcIkNvdWxkIG5vdCBwYXJzZSBjb2xvciBmcm9tIHZhbHVlICdcIiArIChcInN0cmluZ1wiID09IHR5cGVvZiBlID8gZSA6IFN0cmluZyhKU09OLnN0cmluZ2lmeShlKSkpICsgXCInXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdGhpcy50eXBlLmtpbmQpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IG51bGwsIHMgPSAwLCB1ID0gdGhpcy5hcmdzOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICAgIGlmIChudWxsID09PSAobyA9IHVbc10uZXZhbHVhdGUodCkpKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgbCA9IE51bWJlcihvKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGwpKSByZXR1cm4gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBwZShcIkNvdWxkIG5vdCBjb252ZXJ0IFwiICsgSlNPTi5zdHJpbmdpZnkobykgKyBcIiB0byBudW1iZXIuXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJmb3JtYXR0ZWRcIiA9PT0gdGhpcy50eXBlLmtpbmQgPyBuZS5mcm9tU3RyaW5nKHVlKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSkpIDogXCJyZXNvbHZlZEltYWdlXCIgPT09IHRoaXMudHlwZS5raW5kID8gaWUuZnJvbVN0cmluZyh1ZSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUodCkpKSA6IHVlKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSk7XG4gICAgfSwgbWUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaCh0KTtcbiAgICB9LCBtZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgbWUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChcImZvcm1hdHRlZFwiID09PSB0aGlzLnR5cGUua2luZCkgcmV0dXJuIG5ldyBmZShbe1xuICAgICAgICBjb250ZW50OiB0aGlzLmFyZ3NbMF0sXG4gICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICBmb250OiBudWxsLFxuICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgIH1dKS5zZXJpYWxpemUoKTtcbiAgICAgIGlmIChcInJlc29sdmVkSW1hZ2VcIiA9PT0gdGhpcy50eXBlLmtpbmQpIHJldHVybiBuZXcgeWUodGhpcy5hcmdzWzBdKS5zZXJpYWxpemUoKTtcbiAgICAgIHZhciB0ID0gW1widG8tXCIgKyB0aGlzLnR5cGUua2luZF07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcblxuICAgIHZhciB2ZSA9IFtcIlVua25vd25cIiwgXCJQb2ludFwiLCBcIkxpbmVTdHJpbmdcIiwgXCJQb2x5Z29uXCJdLFxuICAgICAgICBnZSA9IGZ1bmN0aW9uIGdlKCkge1xuICAgICAgdGhpcy5nbG9iYWxzID0gbnVsbCwgdGhpcy5mZWF0dXJlID0gbnVsbCwgdGhpcy5mZWF0dXJlU3RhdGUgPSBudWxsLCB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsLCB0aGlzLl9wYXJzZUNvbG9yQ2FjaGUgPSB7fSwgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSBudWxsLCB0aGlzLmNhbm9uaWNhbCA9IG51bGw7XG4gICAgfTtcblxuICAgIGdlLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgXCJpZFwiIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7XG4gICAgfSwgZ2UucHJvdG90eXBlLmdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgPyBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLmZlYXR1cmUudHlwZSA/IHZlW3RoaXMuZmVhdHVyZS50eXBlXSA6IHRoaXMuZmVhdHVyZS50eXBlIDogbnVsbDtcbiAgICB9LCBnZS5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmIFwiZ2VvbWV0cnlcIiBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsO1xuICAgIH0sIGdlLnByb3RvdHlwZS5jYW5vbmljYWxJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbDtcbiAgICB9LCBnZS5wcm90b3R5cGUucHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLnByb3BlcnRpZXMgfHwge307XG4gICAgfSwgZ2UucHJvdG90eXBlLnBhcnNlQ29sb3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbdF07XG4gICAgICByZXR1cm4gZSB8fCAoZSA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZVt0XSA9IHRlLnBhcnNlKHQpKSwgZTtcbiAgICB9O1xuXG4gICAgdmFyIHhlID0gZnVuY3Rpb24geGUodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5uYW1lID0gdCwgdGhpcy50eXBlID0gZSwgdGhpcy5fZXZhbHVhdGUgPSByLCB0aGlzLmFyZ3MgPSBuO1xuICAgIH07XG5cbiAgICB4ZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlKHQsIHRoaXMuYXJncyk7XG4gICAgfSwgeGUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaCh0KTtcbiAgICB9LCB4ZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCB4ZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm5hbWVdLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNlcmlhbGl6ZSgpO1xuICAgICAgfSkpO1xuICAgIH0sIHhlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByLFxuICAgICAgICAgIG4gPSB0WzBdLFxuICAgICAgICAgIGkgPSB4ZS5kZWZpbml0aW9uc1tuXTtcbiAgICAgIGlmICghaSkgcmV0dXJuIGUuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBuICsgJ1wiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLicsIDApO1xuXG4gICAgICBmb3IgKHZhciBhID0gQXJyYXkuaXNBcnJheShpKSA/IGlbMF0gOiBpLnR5cGUsIG8gPSBBcnJheS5pc0FycmF5KGkpID8gW1tpWzFdLCBpWzJdXV0gOiBpLm92ZXJsb2FkcywgcyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByID0gZVswXTtcbiAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoID09PSB0Lmxlbmd0aCAtIDE7XG4gICAgICB9KSwgdSA9IG51bGwsIGwgPSAwLCBwID0gczsgbCA8IHAubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBwW2xdLFxuICAgICAgICAgICAgaCA9IGNbMF0sXG4gICAgICAgICAgICBmID0gY1sxXTtcbiAgICAgICAgdSA9IG5ldyBqZShlLnJlZ2lzdHJ5LCBlLnBhdGgsIG51bGwsIGUuc2NvcGUpO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSBbXSwgZCA9ICExLCBtID0gMTsgbSA8IHQubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICB2YXIgdiA9IHRbbV0sXG4gICAgICAgICAgICAgIGcgPSBBcnJheS5pc0FycmF5KGgpID8gaFttIC0gMV0gOiBoLnR5cGUsXG4gICAgICAgICAgICAgIHggPSB1LnBhcnNlKHYsIDEgKyB5Lmxlbmd0aCwgZyk7XG5cbiAgICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICAgIGQgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHkucHVzaCh4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZCkgaWYgKEFycmF5LmlzQXJyYXkoaCkgJiYgaC5sZW5ndGggIT09IHkubGVuZ3RoKSB1LmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBoLmxlbmd0aCArIFwiIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgeS5sZW5ndGggKyBcIiBpbnN0ZWFkLlwiKTtlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHkubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gQXJyYXkuaXNBcnJheShoKSA/IGhbYl0gOiBoLnR5cGUsXG4gICAgICAgICAgICAgICAgXyA9IHlbYl07XG4gICAgICAgICAgICB1LmNvbmNhdChiICsgMSkuY2hlY2tTdWJ0eXBlKHcsIF8udHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKDAgPT09IHUuZXJyb3JzLmxlbmd0aCkgcmV0dXJuIG5ldyB4ZShuLCBhLCBmLCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoMSA9PT0gcy5sZW5ndGgpIChyID0gZS5lcnJvcnMpLnB1c2guYXBwbHkociwgdS5lcnJvcnMpO2Vsc2Uge1xuICAgICAgICBmb3IgKHZhciBBID0gKHMubGVuZ3RoID8gcyA6IG8pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlO1xuICAgICAgICAgIHJldHVybiBlID0gdFswXSwgQXJyYXkuaXNBcnJheShlKSA/IFwiKFwiICsgZS5tYXAoSnQpLmpvaW4oXCIsIFwiKSArIFwiKVwiIDogXCIoXCIgKyBKdChlLnR5cGUpICsgXCIuLi4pXCI7XG4gICAgICAgIH0pLmpvaW4oXCIgfCBcIiksIFMgPSBbXSwgayA9IDE7IGsgPCB0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIEkgPSBlLnBhcnNlKHRba10sIDEgKyBTLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFJKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBTLnB1c2goSnQoSS50eXBlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlLmVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgXCIgKyBBICsgXCIsIGJ1dCBmb3VuZCAoXCIgKyBTLmpvaW4oXCIsIFwiKSArIFwiKSBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIHhlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgaW4geGUuZGVmaW5pdGlvbnMgPSBlLCBlKSB7XG4gICAgICAgIHRbcl0gPSB4ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJlID0gZnVuY3Rpb24gYmUodCwgZSwgcikge1xuICAgICAgdGhpcy50eXBlID0gS3QsIHRoaXMubG9jYWxlID0gciwgdGhpcy5jYXNlU2Vuc2l0aXZlID0gdCwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUgPSBlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3ZSh0LCBlKSB7XG4gICAgICB0WzBdID0gTWF0aC5taW4odFswXSwgZVswXSksIHRbMV0gPSBNYXRoLm1pbih0WzFdLCBlWzFdKSwgdFsyXSA9IE1hdGgubWF4KHRbMl0sIGVbMF0pLCB0WzNdID0gTWF0aC5tYXgodFszXSwgZVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2UodCwgZSkge1xuICAgICAgcmV0dXJuICEodFswXSA8PSBlWzBdIHx8IHRbMl0gPj0gZVsyXSB8fCB0WzFdIDw9IGVbMV0gfHwgdFszXSA+PSBlWzNdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBZSh0LCBlKSB7XG4gICAgICB2YXIgciA9ICgxODAgKyB0WzBdKSAvIDM2MCxcbiAgICAgICAgICBuID0gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIHRbMV0gKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwLFxuICAgICAgICAgIGkgPSBNYXRoLnBvdygyLCBlLnopO1xuICAgICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiBpICogODE5MiksIE1hdGgucm91bmQobiAqIGkgKiA4MTkyKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2UodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGVbMV0gPiB0WzFdICE9IHJbMV0gPiB0WzFdICYmIHRbMF0gPCAoclswXSAtIGVbMF0pICogKHRbMV0gLSBlWzFdKSAvIChyWzFdIC0gZVsxXSkgKyBlWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtlKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwgPSAhMSwgcCA9IDAsIGMgPSBlLmxlbmd0aDsgcCA8IGM7IHArKykge1xuICAgICAgICBmb3IgKHZhciBoID0gZVtwXSwgZiA9IDAsIHkgPSBoLmxlbmd0aDsgZiA8IHkgLSAxOyBmKyspIHtcbiAgICAgICAgICBpZiAoKGEgPSAociA9IHQpWzBdIC0gKG4gPSBoW2ZdKVswXSkgKiAodSA9IHJbMV0gLSAoaSA9IGhbZiArIDFdKVsxXSkgLSAocyA9IHJbMF0gLSBpWzBdKSAqIChvID0gclsxXSAtIG5bMV0pID09IDAgJiYgYSAqIHMgPD0gMCAmJiBvICogdSA8PSAwKSByZXR1cm4gITE7XG4gICAgICAgICAgU2UodCwgaFtmXSwgaFtmICsgMV0pICYmIChsID0gIWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEllKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICBpZiAoa2UodCwgZVtyXSkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gblswXSAtIHJbMF0sXG4gICAgICAgICAgYSA9IG5bMV0gLSByWzFdLFxuICAgICAgICAgIG8gPSAodFswXSAtIHJbMF0pICogYSAtIGkgKiAodFsxXSAtIHJbMV0pLFxuICAgICAgICAgIHMgPSAoZVswXSAtIHJbMF0pICogYSAtIGkgKiAoZVsxXSAtIHJbMV0pO1xuICAgICAgcmV0dXJuIG8gPiAwICYmIHMgPCAwIHx8IG8gPCAwICYmIHMgPiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENlKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gcjsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IGlbbl0sIG8gPSAwOyBvIDwgYS5sZW5ndGggLSAxOyArK28pIHtcbiAgICAgICAgICBpZiAoMCAhPSAoYyA9IFsocCA9IGFbbyArIDFdKVswXSAtIChsID0gYVtvXSlbMF0sIHBbMV0gLSBsWzFdXSlbMF0gKiAoaCA9IFsodSA9IGUpWzBdIC0gKHMgPSB0KVswXSwgdVsxXSAtIHNbMV1dKVsxXSAtIGNbMV0gKiBoWzBdICYmIHplKHMsIHUsIGwsIHApICYmIHplKGwsIHAsIHMsIHUpKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHMsIHUsIGwsIHAsIGMsIGg7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRWUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSB7XG4gICAgICAgIGlmICgha2UodFtyXSwgZSkpIHJldHVybiAhMTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aCAtIDE7ICsrbikge1xuICAgICAgICBpZiAoQ2UodFtuXSwgdFtuICsgMV0sIGUpKSByZXR1cm4gITE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQZSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICAgICAgaWYgKEVlKHQsIGVbcl0pKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNZSh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBhID0gW10sIG8gPSAwOyBvIDwgdFtpXS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgIHZhciBzID0gQWUodFtpXVtvXSwgcik7XG4gICAgICAgICAgd2UoZSwgcyksIGEucHVzaChzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4ucHVzaChhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBNZSh0W2ldLCBlLCByKTtcbiAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUZSh0LCBlLCByLCBuKSB7XG4gICAgICBpZiAodFswXSA8IHJbMF0gfHwgdFswXSA+IHJbMl0pIHtcbiAgICAgICAgdmFyIGkgPSAuNSAqIG4sXG4gICAgICAgICAgICBhID0gdFswXSAtIHJbMF0gPiBpID8gLW4gOiByWzBdIC0gdFswXSA+IGkgPyBuIDogMDtcbiAgICAgICAgMCA9PT0gYSAmJiAoYSA9IHRbMF0gLSByWzJdID4gaSA/IC1uIDogclsyXSAtIHRbMF0gPiBpID8gbiA6IDApLCB0WzBdICs9IGE7XG4gICAgICB9XG5cbiAgICAgIHdlKGUsIHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZlKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSA4MTkyICogTWF0aC5wb3coMiwgbi56KSwgYSA9IFs4MTkyICogbi54LCA4MTkyICogbi55XSwgbyA9IFtdLCBzID0gMCwgdSA9IHQ7IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSAwLCBwID0gdVtzXTsgbCA8IHAubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICB2YXIgYyA9IHBbbF0sXG4gICAgICAgICAgICAgIGggPSBbYy54ICsgYVswXSwgYy55ICsgYVsxXV07XG4gICAgICAgICAgVGUoaCwgZSwgciwgaSksIG8ucHVzaChoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGZSh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpLCBhID0gODE5MiAqIE1hdGgucG93KDIsIG4ueiksIG8gPSBbODE5MiAqIG4ueCwgODE5MiAqIG4ueV0sIHMgPSBbXSwgdSA9IDAsIGwgPSB0OyB1IDwgbC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBwID0gW10sIGMgPSAwLCBoID0gbFt1XTsgYyA8IGgubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICB2YXIgZiA9IGhbY10sXG4gICAgICAgICAgICAgIHkgPSBbZi54ICsgb1swXSwgZi55ICsgb1sxXV07XG4gICAgICAgICAgd2UoZSwgeSksIHAucHVzaCh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMucHVzaChwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVbMl0gLSBlWzBdIDw9IGEgLyAyKSB7XG4gICAgICAgIChpID0gZSlbMF0gPSBpWzFdID0gMSAvIDAsIGlbMl0gPSBpWzNdID0gLTEgLyAwO1xuXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBtID0gczsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciB2ID0gMCwgZyA9IG1bZF07IHYgPCBnLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgICBUZShnW3ZdLCBlLCByLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgYmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDIgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IHRbMV07XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgciB8fCBBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gZS5lcnJvcihcIkNvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgdmFyIG4gPSBlLnBhcnNlKHZvaWQgMCAhPT0gcltcImNhc2Utc2Vuc2l0aXZlXCJdICYmIHJbXCJjYXNlLXNlbnNpdGl2ZVwiXSwgMSwgVXQpO1xuICAgICAgaWYgKCFuKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBpID0gZS5wYXJzZSh2b2lkIDAgIT09IHJbXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdICYmIHJbXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdLCAxLCBVdCk7XG4gICAgICBpZiAoIWkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGEgPSBudWxsO1xuICAgICAgcmV0dXJuIHIubG9jYWxlICYmICEoYSA9IGUucGFyc2Uoci5sb2NhbGUsIDEsIFJ0KSkgPyBudWxsIDogbmV3IGJlKG4sIGksIGEpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IGVlKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZSh0KSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuZXZhbHVhdGUodCksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUodCkgOiBudWxsKTtcbiAgICB9LCBiZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5jYXNlU2Vuc2l0aXZlKSwgdCh0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSksIHRoaXMubG9jYWxlICYmIHQodGhpcy5sb2NhbGUpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGJlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgcmV0dXJuIHRbXCJjYXNlLXNlbnNpdGl2ZVwiXSA9IHRoaXMuY2FzZVNlbnNpdGl2ZS5zZXJpYWxpemUoKSwgdFtcImRpYWNyaXRpYy1zZW5zaXRpdmVcIl0gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKSwgdGhpcy5sb2NhbGUgJiYgKHQubG9jYWxlID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCkpLCBbXCJjb2xsYXRvclwiLCB0XTtcbiAgICB9O1xuXG4gICAgdmFyIERlID0gZnVuY3Rpb24gRGUodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gVXQsIHRoaXMuZ2VvanNvbiA9IHQsIHRoaXMuZ2VvbWV0cmllcyA9IGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIExlKHQpIHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgeGUpIHtcbiAgICAgICAgaWYgKFwiZ2V0XCIgPT09IHQubmFtZSAmJiAxID09PSB0LmFyZ3MubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImZlYXR1cmUtc3RhdGVcIiA9PT0gdC5uYW1lKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImhhc1wiID09PSB0Lm5hbWUgJiYgMSA9PT0gdC5hcmdzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJwcm9wZXJ0aWVzXCIgPT09IHQubmFtZSB8fCBcImdlb21ldHJ5LXR5cGVcIiA9PT0gdC5uYW1lIHx8IFwiaWRcIiA9PT0gdC5uYW1lKSByZXR1cm4gITE7XG4gICAgICAgIGlmICgvXmZpbHRlci0vLnRlc3QodC5uYW1lKSkgcmV0dXJuICExO1xuICAgICAgfVxuXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIERlKSByZXR1cm4gITE7XG4gICAgICB2YXIgZSA9ICEwO1xuICAgICAgcmV0dXJuIHQuZWFjaENoaWxkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGUgJiYgIUxlKHQpICYmIChlID0gITEpO1xuICAgICAgfSksIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gT2UodCkge1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiB4ZSAmJiBcImZlYXR1cmUtc3RhdGVcIiA9PT0gdC5uYW1lKSByZXR1cm4gITE7XG4gICAgICB2YXIgZSA9ICEwO1xuICAgICAgcmV0dXJuIHQuZWFjaENoaWxkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGUgJiYgIU9lKHQpICYmIChlID0gITEpO1xuICAgICAgfSksIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmUodCwgZSkge1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiB4ZSAmJiBlLmluZGV4T2YodC5uYW1lKSA+PSAwKSByZXR1cm4gITE7XG4gICAgICB2YXIgciA9ICEwO1xuICAgICAgcmV0dXJuIHQuZWFjaENoaWxkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHIgJiYgIVJlKHQsIGUpICYmIChyID0gITEpO1xuICAgICAgfSksIHI7XG4gICAgfVxuXG4gICAgRGUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDIgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIid3aXRoaW4nIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIgaW5zdGVhZC5cIik7XG5cbiAgICAgIGlmIChvZSh0WzFdKSkge1xuICAgICAgICB2YXIgciA9IHRbMV07XG4gICAgICAgIGlmIChcIkZlYXR1cmVDb2xsZWN0aW9uXCIgPT09IHIudHlwZSkgZm9yICh2YXIgbiA9IDA7IG4gPCByLmZlYXR1cmVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgdmFyIGkgPSByLmZlYXR1cmVzW25dLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgaWYgKFwiUG9seWdvblwiID09PSBpIHx8IFwiTXVsdGlQb2x5Z29uXCIgPT09IGkpIHJldHVybiBuZXcgRGUociwgci5mZWF0dXJlc1tuXS5nZW9tZXRyeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJGZWF0dXJlXCIgPT09IHIudHlwZSkge1xuICAgICAgICAgIHZhciBhID0gci5nZW9tZXRyeS50eXBlO1xuICAgICAgICAgIGlmIChcIlBvbHlnb25cIiA9PT0gYSB8fCBcIk11bHRpUG9seWdvblwiID09PSBhKSByZXR1cm4gbmV3IERlKHIsIHIuZ2VvbWV0cnkpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiUG9seWdvblwiID09PSByLnR5cGUgfHwgXCJNdWx0aVBvbHlnb25cIiA9PT0gci50eXBlKSByZXR1cm4gbmV3IERlKHIsIHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZS5lcnJvcihcIid3aXRoaW4nIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH0sIERlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAobnVsbCAhPSB0Lmdlb21ldHJ5KCkgJiYgbnVsbCAhPSB0LmNhbm9uaWNhbElEKCkpIHtcbiAgICAgICAgaWYgKFwiUG9pbnRcIiA9PT0gdC5nZW9tZXRyeVR5cGUoKSkgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICAgIG4gPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICAgIGkgPSB0LmNhbm9uaWNhbElEKCk7XG5cbiAgICAgICAgICBpZiAoXCJQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBNZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgICBvID0gVmUodC5nZW9tZXRyeSgpLCByLCBuLCBpKTtcbiAgICAgICAgICAgIGlmICghX2UociwgbikpIHJldHVybiAhMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIHUgPSBvOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIWtlKHVbc10sIGEpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGwgPSBCZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgICBwID0gVmUodC5nZW9tZXRyeSgpLCByLCBuLCBpKTtcbiAgICAgICAgICAgIGlmICghX2UociwgbikpIHJldHVybiAhMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGggPSBwOyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIUllKGhbY10sIGwpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9KHQsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gdC5nZW9tZXRyeVR5cGUoKSkgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICAgIG4gPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICAgIGkgPSB0LmNhbm9uaWNhbElEKCk7XG5cbiAgICAgICAgICBpZiAoXCJQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBNZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgICBvID0gRmUodC5nZW9tZXRyeSgpLCByLCBuLCBpKTtcbiAgICAgICAgICAgIGlmICghX2UociwgbikpIHJldHVybiAhMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIHUgPSBvOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIUVlKHVbc10sIGEpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGwgPSBCZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgICBwID0gRmUodC5nZW9tZXRyeSgpLCByLCBuLCBpKTtcbiAgICAgICAgICAgIGlmICghX2UociwgbikpIHJldHVybiAhMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGggPSBwOyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIVBlKGhbY10sIGwpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9KHQsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBEZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKCkge30sIERlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIERlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1wid2l0aGluXCIsIHRoaXMuZ2VvanNvbl07XG4gICAgfTtcblxuICAgIHZhciBVZSA9IGZ1bmN0aW9uIFVlKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5uYW1lID0gdCwgdGhpcy5ib3VuZEV4cHJlc3Npb24gPSBlO1xuICAgIH07XG5cbiAgICBVZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGggfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdFsxXSkgcmV0dXJuIGUuZXJyb3IoXCIndmFyJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIHN0cmluZyBsaXRlcmFsIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciByID0gdFsxXTtcbiAgICAgIHJldHVybiBlLnNjb3BlLmhhcyhyKSA/IG5ldyBVZShyLCBlLnNjb3BlLmdldChyKSkgOiBlLmVycm9yKCdVbmtub3duIHZhcmlhYmxlIFwiJyArIHIgKyAnXCIuIE1ha2Ugc3VyZSBcIicgKyByICsgJ1wiIGhhcyBiZWVuIGJvdW5kIGluIGFuIGVuY2xvc2luZyBcImxldFwiIGV4cHJlc3Npb24gYmVmb3JlIHVzaW5nIGl0LicsIDEpO1xuICAgIH0sIFVlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUodCk7XG4gICAgfSwgVWUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICgpIHt9LCBVZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBVZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcInZhclwiLCB0aGlzLm5hbWVdO1xuICAgIH07XG5cbiAgICB2YXIgamUgPSBmdW5jdGlvbiBqZSh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSBbXSksIHZvaWQgMCA9PT0gbiAmJiAobiA9IG5ldyBEdCgpKSwgdm9pZCAwID09PSBpICYmIChpID0gW10pLCB0aGlzLnJlZ2lzdHJ5ID0gdCwgdGhpcy5wYXRoID0gZSwgdGhpcy5rZXkgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyB0ICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiXCIpLCB0aGlzLnNjb3BlID0gbiwgdGhpcy5lcnJvcnMgPSBpLCB0aGlzLmV4cGVjdGVkVHlwZSA9IHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHFlKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIsIG4gPSB0Lmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbiwgbyA9IDA7IGkgPD0gYTspIHtcbiAgICAgICAgaWYgKChyID0gdFtvID0gTWF0aC5mbG9vcigoaSArIGEpIC8gMildKSA8PSBlKSB7XG4gICAgICAgICAgaWYgKG8gPT09IG4gfHwgZSA8IHRbbyArIDFdKSByZXR1cm4gbztcbiAgICAgICAgICBpID0gbyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCEociA+IGUpKSB0aHJvdyBuZXcgcGUoXCJJbnB1dCBpcyBub3QgYSBudW1iZXIuXCIpO1xuICAgICAgICAgIGEgPSBvIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBqZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgZSA/IHRoaXMuY29uY2F0KGUsIHIsIG4pLl9wYXJzZSh0LCBpKSA6IHRoaXMuX3BhcnNlKHQsIGkpO1xuICAgIH0sIGplLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZnVuY3Rpb24gcih0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiBcImFzc2VydFwiID09PSByID8gbmV3IGhlKGUsIFt0XSkgOiBcImNvZXJjZVwiID09PSByID8gbmV3IG1lKGUsIFt0XSkgOiB0O1xuICAgICAgfVxuXG4gICAgICBpZiAobnVsbCAhPT0gdCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIFwiYm9vbGVhblwiICE9IHR5cGVvZiB0ICYmIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgfHwgKHQgPSBbXCJsaXRlcmFsXCIsIHRdKSwgQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGgpIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgW11dLicpO1xuICAgICAgICB2YXIgbiA9IHRbMF07XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBuKSByZXR1cm4gdGhpcy5lcnJvcihcIkV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgXCIgKyB0eXBlb2YgbiArICcgaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKSwgbnVsbDtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnJlZ2lzdHJ5W25dO1xuXG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFyIGEgPSBpLnBhcnNlKHQsIHRoaXMpO1xuICAgICAgICAgIGlmICghYSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5leHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5leHBlY3RlZFR5cGUsXG4gICAgICAgICAgICAgICAgcyA9IGEudHlwZTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBvLmtpbmQgJiYgXCJudW1iZXJcIiAhPT0gby5raW5kICYmIFwiYm9vbGVhblwiICE9PSBvLmtpbmQgJiYgXCJvYmplY3RcIiAhPT0gby5raW5kICYmIFwiYXJyYXlcIiAhPT0gby5raW5kIHx8IFwidmFsdWVcIiAhPT0gcy5raW5kKSB7XG4gICAgICAgICAgICAgIGlmIChcImNvbG9yXCIgIT09IG8ua2luZCAmJiBcImZvcm1hdHRlZFwiICE9PSBvLmtpbmQgJiYgXCJyZXNvbHZlZEltYWdlXCIgIT09IG8ua2luZCB8fCBcInZhbHVlXCIgIT09IHMua2luZCAmJiBcInN0cmluZ1wiICE9PSBzLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1N1YnR5cGUobywgcykpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgYSA9IHIoYSwgbywgZS50eXBlQW5ub3RhdGlvbiB8fCBcImNvZXJjZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBhID0gcihhLCBvLCBlLnR5cGVBbm5vdGF0aW9uIHx8IFwiYXNzZXJ0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKGEgaW5zdGFuY2VvZiBsZSkgJiYgXCJyZXNvbHZlZEltYWdlXCIgIT09IGEudHlwZS5raW5kICYmIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVZSkgcmV0dXJuIHQoZS5ib3VuZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiB4ZSAmJiBcImVycm9yXCIgPT09IGUubmFtZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBiZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBEZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgdmFyIHIgPSBlIGluc3RhbmNlb2YgbWUgfHwgZSBpbnN0YW5jZW9mIGhlLFxuICAgICAgICAgICAgICAgIG4gPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBlLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBuID0gciA/IG4gJiYgdChlKSA6IG4gJiYgZSBpbnN0YW5jZW9mIGxlO1xuICAgICAgICAgICAgfSksICEhbiAmJiBMZShlKSAmJiBSZShlLCBbXCJ6b29tXCIsIFwiaGVhdG1hcC1kZW5zaXR5XCIsIFwibGluZS1wcm9ncmVzc1wiLCBcImFjY3VtdWxhdGVkXCIsIFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiXSk7XG4gICAgICAgICAgfShhKSkge1xuICAgICAgICAgICAgdmFyIHUgPSBuZXcgZ2UoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYSA9IG5ldyBsZShhLnR5cGUsIGEuZXZhbHVhdGUodSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcih0Lm1lc3NhZ2UpLCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBuICsgJ1wiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLicsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcnJvcih2b2lkIDAgPT09IHQgPyBcIid1bmRlZmluZWQnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiB0ID8gJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC4nIDogXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kIFwiICsgdHlwZW9mIHQgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICB9LCBqZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgdCA/IHRoaXMucGF0aC5jb25jYXQodCkgOiB0aGlzLnBhdGgsXG4gICAgICAgICAgaSA9IHIgPyB0aGlzLnNjb3BlLmNvbmNhdChyKSA6IHRoaXMuc2NvcGU7XG4gICAgICByZXR1cm4gbmV3IGplKHRoaXMucmVnaXN0cnksIG4sIGUgfHwgbnVsbCwgaSwgdGhpcy5lcnJvcnMpO1xuICAgIH0sIGplLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIHIgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgci0tID4gMDspIHtcbiAgICAgICAgZVtyXSA9IGFyZ3VtZW50c1tyICsgMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gXCJcIiArIHRoaXMua2V5ICsgZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgdCArIFwiXVwiO1xuICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEZ0KG4sIHQpKTtcbiAgICB9LCBqZS5wcm90b3R5cGUuY2hlY2tTdWJ0eXBlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gWXQodCwgZSk7XG4gICAgICByZXR1cm4gciAmJiB0aGlzLmVycm9yKHIpLCByO1xuICAgIH07XG5cbiAgICB2YXIgTmUgPSBmdW5jdGlvbiBOZSh0LCBlLCByKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmlucHV0ID0gZSwgdGhpcy5sYWJlbHMgPSBbXSwgdGhpcy5vdXRwdXRzID0gW107XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gcjsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dLFxuICAgICAgICAgICAgbyA9IGFbMV07XG4gICAgICAgIHRoaXMubGFiZWxzLnB1c2goYVswXSksIHRoaXMub3V0cHV0cy5wdXNoKG8pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBLZSh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdCAqICgxIC0gcikgKyBlICogcjtcbiAgICB9XG5cbiAgICBOZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggLSAxIDwgNCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmICgodC5sZW5ndGggLSAxKSAlIDIgIT0gMCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIE90KTtcbiAgICAgIGlmICghcikgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbiA9IFtdLFxuICAgICAgICAgIGkgPSBudWxsO1xuICAgICAgZS5leHBlY3RlZFR5cGUgJiYgXCJ2YWx1ZVwiICE9PSBlLmV4cGVjdGVkVHlwZS5raW5kICYmIChpID0gZS5leHBlY3RlZFR5cGUpO1xuXG4gICAgICBmb3IgKHZhciBhID0gMTsgYSA8IHQubGVuZ3RoOyBhICs9IDIpIHtcbiAgICAgICAgdmFyIG8gPSAxID09PSBhID8gLTEgLyAwIDogdFthXSxcbiAgICAgICAgICAgIHMgPSB0W2EgKyAxXSxcbiAgICAgICAgICAgIHUgPSBhLFxuICAgICAgICAgICAgbCA9IGEgKyAxO1xuICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgbykgcmV0dXJuIGUuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgdSk7XG4gICAgICAgIGlmIChuLmxlbmd0aCAmJiBuW24ubGVuZ3RoIC0gMV1bMF0gPj0gbykgcmV0dXJuIGUuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgdSk7XG4gICAgICAgIHZhciBwID0gZS5wYXJzZShzLCBsLCBpKTtcbiAgICAgICAgaWYgKCFwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaSA9IGkgfHwgcC50eXBlLCBuLnB1c2goW28sIHBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOZShpLCByLCBuKTtcbiAgICB9LCBOZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgICByID0gdGhpcy5vdXRwdXRzO1xuICAgICAgaWYgKDEgPT09IGUubGVuZ3RoKSByZXR1cm4gclswXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBuID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmIChuIDw9IGVbMF0pIHJldHVybiByWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIGkgPSBlLmxlbmd0aDtcbiAgICAgIHJldHVybiBuID49IGVbaSAtIDFdID8gcltpIC0gMV0uZXZhbHVhdGUodCkgOiByW3FlKGUsIG4pXS5ldmFsdWF0ZSh0KTtcbiAgICB9LCBOZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5pbnB1dCk7XG5cbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5vdXRwdXRzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB0KHJbZV0pO1xuICAgICAgfVxuICAgIH0sIE5lLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBOZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IFtcInN0ZXBcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV0sIGUgPSAwOyBlIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgZSA+IDAgJiYgdC5wdXNoKHRoaXMubGFiZWxzW2VdKSwgdC5wdXNoKHRoaXMub3V0cHV0c1tlXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgdmFyIEdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBudW1iZXI6IEtlLFxuICAgICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0ZShLZSh0LnIsIGUuciwgciksIEtlKHQuZywgZS5nLCByKSwgS2UodC5iLCBlLmIsIHIpLCBLZSh0LmEsIGUuYSwgcikpO1xuICAgICAgfSxcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgIHJldHVybiBLZSh0LCBlW25dLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksXG4gICAgICAgIFplID0gNiAvIDI5ICogMyAqICg2IC8gMjkpLFxuICAgICAgICBYZSA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgIEplID0gMTgwIC8gTWF0aC5QSTtcblxuICAgIGZ1bmN0aW9uIEhlKHQpIHtcbiAgICAgIHJldHVybiB0ID4gLjAwODg1NjQ1MTY3OTAzNTYzMSA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyBaZSArIDQgLyAyOTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBZZSh0KSB7XG4gICAgICByZXR1cm4gdCA+IDYgLyAyOSA/IHQgKiB0ICogdCA6IFplICogKHQgLSA0IC8gMjkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRlKHQpIHtcbiAgICAgIHJldHVybiAyNTUgKiAodCA8PSAuMDAzMTMwOCA/IDEyLjkyICogdCA6IDEuMDU1ICogTWF0aC5wb3codCwgMSAvIDIuNCkgLSAuMDU1KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZSh0KSB7XG4gICAgICByZXR1cm4gKHQgLz0gMjU1KSA8PSAuMDQwNDUgPyB0IC8gMTIuOTIgOiBNYXRoLnBvdygodCArIC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUWUodCkge1xuICAgICAgdmFyIGUgPSBXZSh0LnIpLFxuICAgICAgICAgIHIgPSBXZSh0LmcpLFxuICAgICAgICAgIG4gPSBXZSh0LmIpLFxuICAgICAgICAgIGkgPSBIZSgoLjQxMjQ1NjQgKiBlICsgLjM1NzU3NjEgKiByICsgLjE4MDQzNzUgKiBuKSAvIC45NTA0NyksXG4gICAgICAgICAgYSA9IEhlKCguMjEyNjcyOSAqIGUgKyAuNzE1MTUyMiAqIHIgKyAuMDcyMTc1ICogbikgLyAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGw6IDExNiAqIGEgLSAxNixcbiAgICAgICAgYTogNTAwICogKGkgLSBhKSxcbiAgICAgICAgYjogMjAwICogKGEgLSBIZSgoLjAxOTMzMzkgKiBlICsgLjExOTE5MiAqIHIgKyAuOTUwMzA0MSAqIG4pIC8gMS4wODg4MykpLFxuICAgICAgICBhbHBoYTogdC5hXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyKHQpIHtcbiAgICAgIHZhciBlID0gKHQubCArIDE2KSAvIDExNixcbiAgICAgICAgICByID0gaXNOYU4odC5hKSA/IGUgOiBlICsgdC5hIC8gNTAwLFxuICAgICAgICAgIG4gPSBpc05hTih0LmIpID8gZSA6IGUgLSB0LmIgLyAyMDA7XG4gICAgICByZXR1cm4gZSA9IDEgKiBZZShlKSwgciA9IC45NTA0NyAqIFllKHIpLCBuID0gMS4wODg4MyAqIFllKG4pLCBuZXcgdGUoJGUoMy4yNDA0NTQyICogciAtIDEuNTM3MTM4NSAqIGUgLSAuNDk4NTMxNCAqIG4pLCAkZSgtLjk2OTI2NiAqIHIgKyAxLjg3NjAxMDggKiBlICsgLjA0MTU1NiAqIG4pLCAkZSguMDU1NjQzNCAqIHIgLSAuMjA0MDI1OSAqIGUgKyAxLjA1NzIyNTIgKiBuKSwgdC5hbHBoYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXIodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlIC0gdDtcbiAgICAgIHJldHVybiB0ICsgciAqIChuID4gMTgwIHx8IG4gPCAtMTgwID8gbiAtIDM2MCAqIE1hdGgucm91bmQobiAvIDM2MCkgOiBuKTtcbiAgICB9XG5cbiAgICB2YXIgcnIgPSB7XG4gICAgICBmb3J3YXJkOiBRZSxcbiAgICAgIHJldmVyc2U6IHRyLFxuICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsOiBLZSh0LmwsIGUubCwgciksXG4gICAgICAgICAgYTogS2UodC5hLCBlLmEsIHIpLFxuICAgICAgICAgIGI6IEtlKHQuYiwgZS5iLCByKSxcbiAgICAgICAgICBhbHBoYTogS2UodC5hbHBoYSwgZS5hbHBoYSwgcilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBuciA9IHtcbiAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQodCkge1xuICAgICAgICB2YXIgZSA9IFFlKHQpLFxuICAgICAgICAgICAgciA9IGUubCxcbiAgICAgICAgICAgIG4gPSBlLmEsXG4gICAgICAgICAgICBpID0gZS5iLFxuICAgICAgICAgICAgYSA9IE1hdGguYXRhbjIoaSwgbikgKiBKZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBhIDwgMCA/IGEgKyAzNjAgOiBhLFxuICAgICAgICAgIGM6IE1hdGguc3FydChuICogbiArIGkgKiBpKSxcbiAgICAgICAgICBsOiByLFxuICAgICAgICAgIGFscGhhOiB0LmFcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmggKiBYZSxcbiAgICAgICAgICAgIHIgPSB0LmM7XG4gICAgICAgIHJldHVybiB0cih7XG4gICAgICAgICAgbDogdC5sLFxuICAgICAgICAgIGE6IE1hdGguY29zKGUpICogcixcbiAgICAgICAgICBiOiBNYXRoLnNpbihlKSAqIHIsXG4gICAgICAgICAgYWxwaGE6IHQuYWxwaGFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBlcih0LmgsIGUuaCwgciksXG4gICAgICAgICAgYzogS2UodC5jLCBlLmMsIHIpLFxuICAgICAgICAgIGw6IEtlKHQubCwgZS5sLCByKSxcbiAgICAgICAgICBhbHBoYTogS2UodC5hbHBoYSwgZS5hbHBoYSwgcilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBpciA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgbGFiOiBycixcbiAgICAgIGhjbDogbnJcbiAgICB9KSxcbiAgICAgICAgYXIgPSBmdW5jdGlvbiBhcih0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLm9wZXJhdG9yID0gZSwgdGhpcy5pbnRlcnBvbGF0aW9uID0gciwgdGhpcy5pbnB1dCA9IG4sIHRoaXMubGFiZWxzID0gW10sIHRoaXMub3V0cHV0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBhID0gMCwgbyA9IGk7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gb1thXSxcbiAgICAgICAgICAgIHUgPSBzWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKHNbMF0pLCB0aGlzLm91dHB1dHMucHVzaCh1KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3IodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBuIC0gcixcbiAgICAgICAgICBhID0gdCAtIHI7XG4gICAgICByZXR1cm4gMCA9PT0gaSA/IDAgOiAxID09PSBlID8gYSAvIGkgOiAoTWF0aC5wb3coZSwgYSkgLSAxKSAvIChNYXRoLnBvdyhlLCBpKSAtIDEpO1xuICAgIH1cblxuICAgIGFyLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodCwgZSwgbiwgaSkge1xuICAgICAgdmFyIGEgPSAwO1xuICAgICAgaWYgKFwiZXhwb25lbnRpYWxcIiA9PT0gdC5uYW1lKSBhID0gb3IoZSwgdC5iYXNlLCBuLCBpKTtlbHNlIGlmIChcImxpbmVhclwiID09PSB0Lm5hbWUpIGEgPSBvcihlLCAxLCBuLCBpKTtlbHNlIGlmIChcImN1YmljLWJlemllclwiID09PSB0Lm5hbWUpIHtcbiAgICAgICAgdmFyIG8gPSB0LmNvbnRyb2xQb2ludHM7XG4gICAgICAgIGEgPSBuZXcgcihvWzBdLCBvWzFdLCBvWzJdLCBvWzNdKS5zb2x2ZShvcihlLCAxLCBuLCBpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBhci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRbMF0sXG4gICAgICAgICAgbiA9IHRbMV0sXG4gICAgICAgICAgaSA9IHRbMl0sXG4gICAgICAgICAgYSA9IHQuc2xpY2UoMyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobikgfHwgMCA9PT0gbi5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uXCIsIDEpO1xuICAgICAgaWYgKFwibGluZWFyXCIgPT09IG5bMF0pIG4gPSB7XG4gICAgICAgIG5hbWU6IFwibGluZWFyXCJcbiAgICAgIH07ZWxzZSBpZiAoXCJleHBvbmVudGlhbFwiID09PSBuWzBdKSB7XG4gICAgICAgIHZhciBvID0gblsxXTtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG8pIHJldHVybiBlLmVycm9yKFwiRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5cIiwgMSwgMSk7XG4gICAgICAgIG4gPSB7XG4gICAgICAgICAgbmFtZTogXCJleHBvbmVudGlhbFwiLFxuICAgICAgICAgIGJhc2U6IG9cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcImN1YmljLWJlemllclwiICE9PSBuWzBdKSByZXR1cm4gZS5lcnJvcihcIlVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlIFwiICsgU3RyaW5nKG5bMF0pLCAxLCAwKTtcbiAgICAgICAgdmFyIHMgPSBuLnNsaWNlKDEpO1xuICAgICAgICBpZiAoNCAhPT0gcy5sZW5ndGggfHwgcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgfHwgdCA8IDAgfHwgdCA+IDE7XG4gICAgICAgIH0pKSByZXR1cm4gZS5lcnJvcihcIkN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlwiLCAxKTtcbiAgICAgICAgbiA9IHtcbiAgICAgICAgICBuYW1lOiBcImN1YmljLWJlemllclwiLFxuICAgICAgICAgIGNvbnRyb2xQb2ludHM6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0Lmxlbmd0aCAtIDEgPCA0KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIuXCIpO1xuICAgICAgaWYgKCh0Lmxlbmd0aCAtIDEpICUgMiAhPSAwKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICBpZiAoIShpID0gZS5wYXJzZShpLCAyLCBPdCkpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB1ID0gW10sXG4gICAgICAgICAgbCA9IG51bGw7XG4gICAgICBcImludGVycG9sYXRlLWhjbFwiID09PSByIHx8IFwiaW50ZXJwb2xhdGUtbGFiXCIgPT09IHIgPyBsID0ganQgOiBlLmV4cGVjdGVkVHlwZSAmJiBcInZhbHVlXCIgIT09IGUuZXhwZWN0ZWRUeXBlLmtpbmQgJiYgKGwgPSBlLmV4cGVjdGVkVHlwZSk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYS5sZW5ndGg7IHAgKz0gMikge1xuICAgICAgICB2YXIgYyA9IGFbcF0sXG4gICAgICAgICAgICBoID0gYVtwICsgMV0sXG4gICAgICAgICAgICBmID0gcCArIDMsXG4gICAgICAgICAgICB5ID0gcCArIDQ7XG4gICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBjKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgZik7XG4gICAgICAgIGlmICh1Lmxlbmd0aCAmJiB1W3UubGVuZ3RoIC0gMV1bMF0gPj0gYykgcmV0dXJuIGUuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGYpO1xuICAgICAgICB2YXIgZCA9IGUucGFyc2UoaCwgeSwgbCk7XG4gICAgICAgIGlmICghZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGwgPSBsIHx8IGQudHlwZSwgdS5wdXNoKFtjLCBkXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIm51bWJlclwiID09PSBsLmtpbmQgfHwgXCJjb2xvclwiID09PSBsLmtpbmQgfHwgXCJhcnJheVwiID09PSBsLmtpbmQgJiYgXCJudW1iZXJcIiA9PT0gbC5pdGVtVHlwZS5raW5kICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGwuTiA/IG5ldyBhcihsLCByLCBuLCBpLCB1KSA6IGUuZXJyb3IoXCJUeXBlIFwiICsgSnQobCkgKyBcIiBpcyBub3QgaW50ZXJwb2xhdGFibGUuXCIpO1xuICAgIH0sIGFyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubGFiZWxzLFxuICAgICAgICAgIHIgPSB0aGlzLm91dHB1dHM7XG4gICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiByWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIG4gPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKG4gPD0gZVswXSkgcmV0dXJuIHJbMF0uZXZhbHVhdGUodCk7XG4gICAgICB2YXIgaSA9IGUubGVuZ3RoO1xuICAgICAgaWYgKG4gPj0gZVtpIC0gMV0pIHJldHVybiByW2kgLSAxXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBhID0gcWUoZSwgbiksXG4gICAgICAgICAgbyA9IGFyLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uLCBuLCBlW2FdLCBlW2EgKyAxXSksXG4gICAgICAgICAgcyA9IHJbYV0uZXZhbHVhdGUodCksXG4gICAgICAgICAgdSA9IHJbYSArIDFdLmV2YWx1YXRlKHQpO1xuICAgICAgcmV0dXJuIFwiaW50ZXJwb2xhdGVcIiA9PT0gdGhpcy5vcGVyYXRvciA/IEdlW3RoaXMudHlwZS5raW5kLnRvTG93ZXJDYXNlKCldKHMsIHUsIG8pIDogXCJpbnRlcnBvbGF0ZS1oY2xcIiA9PT0gdGhpcy5vcGVyYXRvciA/IG5yLnJldmVyc2UobnIuaW50ZXJwb2xhdGUobnIuZm9yd2FyZChzKSwgbnIuZm9yd2FyZCh1KSwgbykpIDogcnIucmV2ZXJzZShyci5pbnRlcnBvbGF0ZShyci5mb3J3YXJkKHMpLCByci5mb3J3YXJkKHUpLCBvKSk7XG4gICAgfSwgYXIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMuaW5wdXQpO1xuXG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHRoaXMub3V0cHV0czsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdChyW2VdKTtcbiAgICAgIH1cbiAgICB9LCBhci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgYXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0O1xuICAgICAgdCA9IFwibGluZWFyXCIgPT09IHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID8gW1wibGluZWFyXCJdIDogXCJleHBvbmVudGlhbFwiID09PSB0aGlzLmludGVycG9sYXRpb24ubmFtZSA/IDEgPT09IHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID8gW1wibGluZWFyXCJdIDogW1wiZXhwb25lbnRpYWxcIiwgdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2VdIDogW1wiY3ViaWMtYmV6aWVyXCJdLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG5cbiAgICAgIGZvciAodmFyIGUgPSBbdGhpcy5vcGVyYXRvciwgdCwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV0sIHIgPSAwOyByIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS5wdXNoKHRoaXMubGFiZWxzW3JdLCB0aGlzLm91dHB1dHNbcl0uc2VyaWFsaXplKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgdmFyIHNyID0gZnVuY3Rpb24gc3IodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5hcmdzID0gZTtcbiAgICB9O1xuXG4gICAgc3IucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgMikgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSBudWxsLFxuICAgICAgICAgIG4gPSBlLmV4cGVjdGVkVHlwZTtcbiAgICAgIG4gJiYgXCJ2YWx1ZVwiICE9PSBuLmtpbmQgJiYgKHIgPSBuKTtcblxuICAgICAgZm9yICh2YXIgaSA9IFtdLCBhID0gMCwgbyA9IHQuc2xpY2UoMSk7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gZS5wYXJzZShvW2FdLCAxICsgaS5sZW5ndGgsIHIsIHZvaWQgMCwge1xuICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiBcIm9taXRcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgciA9IHIgfHwgcy50eXBlLCBpLnB1c2gocyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1ID0gbiAmJiBpLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFl0KG4sIHQudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgc3IodSA/IE50IDogciwgaSk7XG4gICAgfSwgc3IucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUsIHIgPSBudWxsLCBuID0gMCwgaSA9IDAsIGEgPSB0aGlzLmFyZ3M7IGkgPCBhLmxlbmd0aCAmJiAobisrLCAociA9IGFbaV0uZXZhbHVhdGUodCkpICYmIHIgaW5zdGFuY2VvZiBpZSAmJiAhci5hdmFpbGFibGUgJiYgKGUgfHwgKGUgPSByLm5hbWUpLCByID0gbnVsbCwgbiA9PT0gdGhpcy5hcmdzLmxlbmd0aCAmJiAociA9IGUpKSwgbnVsbCA9PT0gcik7IGkgKz0gMSkge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHNyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5hcmdzLmZvckVhY2godCk7XG4gICAgfSwgc3IucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH0sIHNyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtcImNvYWxlc2NlXCJdO1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHQucHVzaChlLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH0pLCB0O1xuICAgIH07XG5cbiAgICB2YXIgdXIgPSBmdW5jdGlvbiB1cih0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQodCksIHRoaXMucmVzdWx0ID0gZTtcbiAgICB9O1xuXG4gICAgdXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZSh0KTtcbiAgICB9LCB1ci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5iaW5kaW5nczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdChyW2VdWzFdKTtcbiAgICAgIH1cblxuICAgICAgdCh0aGlzLnJlc3VsdCk7XG4gICAgfSwgdXIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgNCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcblxuICAgICAgZm9yICh2YXIgciA9IFtdLCBuID0gMTsgbiA8IHQubGVuZ3RoIC0gMTsgbiArPSAyKSB7XG4gICAgICAgIHZhciBpID0gdFtuXTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGkpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nLCBidXQgZm91bmQgXCIgKyB0eXBlb2YgaSArIFwiIGluc3RlYWQuXCIsIG4pO1xuICAgICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QoaSkpIHJldHVybiBlLmVycm9yKFwiVmFyaWFibGUgbmFtZXMgbXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgJ18nLlwiLCBuKTtcbiAgICAgICAgdmFyIGEgPSBlLnBhcnNlKHRbbiArIDFdLCBuICsgMSk7XG4gICAgICAgIGlmICghYSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHIucHVzaChbaSwgYV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbyA9IGUucGFyc2UodFt0Lmxlbmd0aCAtIDFdLCB0Lmxlbmd0aCAtIDEsIGUuZXhwZWN0ZWRUeXBlLCByKTtcbiAgICAgIHJldHVybiBvID8gbmV3IHVyKHIsIG8pIDogbnVsbDtcbiAgICB9LCB1ci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSwgdXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSBbXCJsZXRcIl0sIGUgPSAwLCByID0gdGhpcy5iaW5kaW5nczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0LnB1c2goblswXSwgblsxXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpLCB0O1xuICAgIH07XG5cbiAgICB2YXIgbHIgPSBmdW5jdGlvbiBscih0LCBlLCByKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmluZGV4ID0gZSwgdGhpcy5pbnB1dCA9IHI7XG4gICAgfTtcblxuICAgIGxyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBPdCksXG4gICAgICAgICAgbiA9IGUucGFyc2UodFsyXSwgMiwgWHQoZS5leHBlY3RlZFR5cGUgfHwgTnQpKTtcbiAgICAgIHJldHVybiByICYmIG4gPyBuZXcgbHIobi50eXBlLml0ZW1UeXBlLCByLCBuKSA6IG51bGw7XG4gICAgfSwgbHIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbmRleC5ldmFsdWF0ZSh0KSxcbiAgICAgICAgICByID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmIChlIDwgMCkgdGhyb3cgbmV3IHBlKFwiQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogXCIgKyBlICsgXCIgPCAwLlwiKTtcbiAgICAgIGlmIChlID49IHIubGVuZ3RoKSB0aHJvdyBuZXcgcGUoXCJBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiBcIiArIGUgKyBcIiA+IFwiICsgKHIubGVuZ3RoIC0gMSkgKyBcIi5cIik7XG4gICAgICBpZiAoZSAhPT0gTWF0aC5mbG9vcihlKSkgdGhyb3cgbmV3IHBlKFwiQXJyYXkgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZm91bmQgXCIgKyBlICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICByZXR1cm4gcltlXTtcbiAgICB9LCBsci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5pbmRleCksIHQodGhpcy5pbnB1dCk7XG4gICAgfSwgbHIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgbHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXCJhdFwiLCB0aGlzLmluZGV4LnNlcmlhbGl6ZSgpLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuXG4gICAgdmFyIHByID0gZnVuY3Rpb24gcHIodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gVXQsIHRoaXMubmVlZGxlID0gdCwgdGhpcy5oYXlzdGFjayA9IGU7XG4gICAgfTtcblxuICAgIHByLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBOdCksXG4gICAgICAgICAgbiA9IGUucGFyc2UodFsyXSwgMiwgTnQpO1xuICAgICAgcmV0dXJuIHIgJiYgbiA/ICR0KHIudHlwZSwgW1V0LCBSdCwgT3QsIEx0LCBOdF0pID8gbmV3IHByKHIsIG4pIDogZS5lcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiICsgSnQoci50eXBlKSArIFwiIGluc3RlYWRcIikgOiBudWxsO1xuICAgIH0sIHByLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKHQpLFxuICAgICAgICAgIHIgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKCFyKSByZXR1cm4gITE7XG4gICAgICBpZiAoIVd0KGUsIFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJudWxsXCJdKSkgdGhyb3cgbmV3IHBlKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgXCIgKyBKdChzZShlKSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGlmICghV3QociwgW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0pKSB0aHJvdyBuZXcgcGUoXCJFeHBlY3RlZCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIEp0KHNlKHIpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgcmV0dXJuIHIuaW5kZXhPZihlKSA+PSAwO1xuICAgIH0sIHByLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLm5lZWRsZSksIHQodGhpcy5oYXlzdGFjayk7XG4gICAgfSwgcHIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgcHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXCJpblwiLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKV07XG4gICAgfTtcblxuICAgIHZhciBjciA9IGZ1bmN0aW9uIGNyKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IE90LCB0aGlzLm5lZWRsZSA9IHQsIHRoaXMuaGF5c3RhY2sgPSBlLCB0aGlzLmZyb21JbmRleCA9IHI7XG4gICAgfTtcblxuICAgIGNyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8PSAyIHx8IHQubGVuZ3RoID49IDUpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBOdCksXG4gICAgICAgICAgbiA9IGUucGFyc2UodFsyXSwgMiwgTnQpO1xuICAgICAgaWYgKCFyIHx8ICFuKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICghJHQoci50eXBlLCBbVXQsIFJ0LCBPdCwgTHQsIE50XSkpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgXCIgKyBKdChyLnR5cGUpICsgXCIgaW5zdGVhZFwiKTtcblxuICAgICAgaWYgKDQgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpID0gZS5wYXJzZSh0WzNdLCAzLCBPdCk7XG4gICAgICAgIHJldHVybiBpID8gbmV3IGNyKHIsIG4sIGkpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjcihyLCBuKTtcbiAgICB9LCBjci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZSh0KSxcbiAgICAgICAgICByID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmICghV3QoZSwgW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcIm51bGxcIl0pKSB0aHJvdyBuZXcgcGUoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIiArIEp0KHNlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKCFXdChyLCBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSkpIHRocm93IG5ldyBwZShcIkV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kIFwiICsgSnQoc2UocikpICsgXCIgaW5zdGVhZC5cIik7XG5cbiAgICAgIGlmICh0aGlzLmZyb21JbmRleCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gci5pbmRleE9mKGUsIG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gci5pbmRleE9mKGUpO1xuICAgIH0sIGNyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLm5lZWRsZSksIHQodGhpcy5oYXlzdGFjayksIHRoaXMuZnJvbUluZGV4ICYmIHQodGhpcy5mcm9tSW5kZXgpO1xuICAgIH0sIGNyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGNyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobnVsbCAhPSB0aGlzLmZyb21JbmRleCAmJiB2b2lkIDAgIT09IHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5mcm9tSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbXCJpbmRleC1vZlwiLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKSwgdF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXCJpbmRleC1vZlwiLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKV07XG4gICAgfTtcblxuICAgIHZhciBociA9IGZ1bmN0aW9uIGhyKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHRoaXMuaW5wdXRUeXBlID0gdCwgdGhpcy50eXBlID0gZSwgdGhpcy5pbnB1dCA9IHIsIHRoaXMuY2FzZXMgPSBuLCB0aGlzLm91dHB1dHMgPSBpLCB0aGlzLm90aGVyd2lzZSA9IGE7XG4gICAgfTtcblxuICAgIGhyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8IDUpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5IFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIi5cIik7XG4gICAgICBpZiAodC5sZW5ndGggJSAyICE9IDEpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciByLCBuO1xuICAgICAgZS5leHBlY3RlZFR5cGUgJiYgXCJ2YWx1ZVwiICE9PSBlLmV4cGVjdGVkVHlwZS5raW5kICYmIChuID0gZS5leHBlY3RlZFR5cGUpO1xuXG4gICAgICBmb3IgKHZhciBpID0ge30sIGEgPSBbXSwgbyA9IDI7IG8gPCB0Lmxlbmd0aCAtIDE7IG8gKz0gMikge1xuICAgICAgICB2YXIgcyA9IHRbb10sXG4gICAgICAgICAgICB1ID0gdFtvICsgMV07XG4gICAgICAgIEFycmF5LmlzQXJyYXkocykgfHwgKHMgPSBbc10pO1xuICAgICAgICB2YXIgbCA9IGUuY29uY2F0KG8pO1xuICAgICAgICBpZiAoMCA9PT0gcy5sZW5ndGgpIHJldHVybiBsLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGJyYW5jaCBsYWJlbC5cIik7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IDAsIGMgPSBzOyBwIDwgYy5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICAgIHZhciBoID0gY1twXTtcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgaCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBoKSByZXR1cm4gbC5lcnJvcihcIkJyYW5jaCBsYWJlbHMgbXVzdCBiZSBudW1iZXJzIG9yIHN0cmluZ3MuXCIpO1xuICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBoICYmIE1hdGguYWJzKGgpID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHJldHVybiBsLmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXJzIG5vIGxhcmdlciB0aGFuIFwiICsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKyBcIi5cIik7XG4gICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGggJiYgTWF0aC5mbG9vcihoKSAhPT0gaCkgcmV0dXJuIGwuZXJyb3IoXCJOdW1lcmljIGJyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VyIHZhbHVlcy5cIik7XG5cbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgaWYgKGwuY2hlY2tTdWJ0eXBlKHIsIHNlKGgpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHIgPSBzZShoKTtcblxuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlbU3RyaW5nKGgpXSkgcmV0dXJuIGwuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgdW5pcXVlLlwiKTtcbiAgICAgICAgICBpW1N0cmluZyhoKV0gPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gZS5wYXJzZSh1LCBvLCBuKTtcbiAgICAgICAgaWYgKCFmKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbiA9IG4gfHwgZi50eXBlLCBhLnB1c2goZik7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ID0gZS5wYXJzZSh0WzFdLCAxLCBOdCk7XG4gICAgICBpZiAoIXkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGQgPSBlLnBhcnNlKHRbdC5sZW5ndGggLSAxXSwgdC5sZW5ndGggLSAxLCBuKTtcbiAgICAgIHJldHVybiBkID8gXCJ2YWx1ZVwiICE9PSB5LnR5cGUua2luZCAmJiBlLmNvbmNhdCgxKS5jaGVja1N1YnR5cGUociwgeS50eXBlKSA/IG51bGwgOiBuZXcgaHIociwgbiwgeSwgaSwgYSwgZCkgOiBudWxsO1xuICAgIH0sIGhyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCk7XG4gICAgICByZXR1cm4gKHNlKGUpID09PSB0aGlzLmlucHV0VHlwZSAmJiB0aGlzLm91dHB1dHNbdGhpcy5jYXNlc1tlXV0gfHwgdGhpcy5vdGhlcndpc2UpLmV2YWx1YXRlKHQpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KSwgdGhpcy5vdXRwdXRzLmZvckVhY2godCksIHQodGhpcy5vdGhlcndpc2UpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSwgaHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSB0aGlzLCBlID0gW1wibWF0Y2hcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV0sIHIgPSBbXSwgbiA9IHt9LCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICB2b2lkIDAgPT09IChjID0gblt0aGlzLmNhc2VzW29dXSkgPyAoblt0aGlzLmNhc2VzW29dXSA9IHIubGVuZ3RoLCByLnB1c2goW3RoaXMuY2FzZXNbb10sIFtvXV0pKSA6IHJbY11bMV0ucHVzaChvKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcyA9IGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIiA9PT0gdC5pbnB1dFR5cGUua2luZCA/IE51bWJlcihlKSA6IGU7XG4gICAgICB9LCB1ID0gMCwgbCA9IHI7IHUgPCBsLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBwID0gbFt1XSxcbiAgICAgICAgICAgIGMgPSBwWzBdLFxuICAgICAgICAgICAgaCA9IHBbMV07XG4gICAgICAgIGUucHVzaCgxID09PSBoLmxlbmd0aCA/IHMoaFswXSkgOiBoLm1hcChzKSksIGUucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXgkMV0uc2VyaWFsaXplKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZS5wdXNoKHRoaXMub3RoZXJ3aXNlLnNlcmlhbGl6ZSgpKSwgZTtcbiAgICB9O1xuXG4gICAgdmFyIGZyID0gZnVuY3Rpb24gZnIodCwgZSwgcikge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5icmFuY2hlcyA9IGUsIHRoaXMub3RoZXJ3aXNlID0gcjtcbiAgICB9O1xuXG4gICAgZnIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgNCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmICh0Lmxlbmd0aCAlIDIgIT0gMCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICB2YXIgcjtcbiAgICAgIGUuZXhwZWN0ZWRUeXBlICYmIFwidmFsdWVcIiAhPT0gZS5leHBlY3RlZFR5cGUua2luZCAmJiAociA9IGUuZXhwZWN0ZWRUeXBlKTtcblxuICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMTsgaSA8IHQubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciBhID0gZS5wYXJzZSh0W2ldLCBpLCBVdCk7XG4gICAgICAgIGlmICghYSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBvID0gZS5wYXJzZSh0W2kgKyAxXSwgaSArIDEsIHIpO1xuICAgICAgICBpZiAoIW8pIHJldHVybiBudWxsO1xuICAgICAgICBuLnB1c2goW2EsIG9dKSwgciA9IHIgfHwgby50eXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcyA9IGUucGFyc2UodFt0Lmxlbmd0aCAtIDFdLCB0Lmxlbmd0aCAtIDEsIHIpO1xuICAgICAgcmV0dXJuIHMgPyBuZXcgZnIociwgbiwgcykgOiBudWxsO1xuICAgIH0sIGZyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHRoaXMuYnJhbmNoZXM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXSxcbiAgICAgICAgICAgIGkgPSBuWzFdO1xuICAgICAgICBpZiAoblswXS5ldmFsdWF0ZSh0KSkgcmV0dXJuIGkuZXZhbHVhdGUodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZSh0KTtcbiAgICB9LCBmci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5icmFuY2hlczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdLFxuICAgICAgICAgICAgaSA9IG5bMV07XG4gICAgICAgIHQoblswXSksIHQoaSk7XG4gICAgICB9XG5cbiAgICAgIHQodGhpcy5vdGhlcndpc2UpO1xuICAgIH0sIGZyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnJhbmNoZXMuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRbMV0ub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0sIGZyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtcImNhc2VcIl07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcblxuICAgIHZhciB5ciA9IGZ1bmN0aW9uIHlyKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5wdXQgPSBlLCB0aGlzLmJlZ2luSW5kZXggPSByLCB0aGlzLmVuZEluZGV4ID0gbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZHIodCwgZSkge1xuICAgICAgcmV0dXJuIFwiPT1cIiA9PT0gdCB8fCBcIiE9XCIgPT09IHQgPyBcImJvb2xlYW5cIiA9PT0gZS5raW5kIHx8IFwic3RyaW5nXCIgPT09IGUua2luZCB8fCBcIm51bWJlclwiID09PSBlLmtpbmQgfHwgXCJudWxsXCIgPT09IGUua2luZCB8fCBcInZhbHVlXCIgPT09IGUua2luZCA6IFwic3RyaW5nXCIgPT09IGUua2luZCB8fCBcIm51bWJlclwiID09PSBlLmtpbmQgfHwgXCJ2YWx1ZVwiID09PSBlLmtpbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXIodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIDAgPT09IG4uY29tcGFyZShlLCByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2cih0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IFwiPT1cIiAhPT0gdCAmJiBcIiE9XCIgIT09IHQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBpKHQsIGUsIHIpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBVdCwgdGhpcy5saHMgPSB0LCB0aGlzLnJocyA9IGUsIHRoaXMuY29sbGF0b3IgPSByLCB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCA9IFwidmFsdWVcIiA9PT0gdC50eXBlLmtpbmQgfHwgXCJ2YWx1ZVwiID09PSBlLnR5cGUua2luZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBpZiAoMyAhPT0gdC5sZW5ndGggJiYgNCAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cIik7XG4gICAgICAgICAgdmFyIHIgPSB0WzBdLFxuICAgICAgICAgICAgICBhID0gZS5wYXJzZSh0WzFdLCAxLCBOdCk7XG4gICAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoIWRyKHIsIGEudHlwZSkpIHJldHVybiBlLmNvbmNhdCgxKS5lcnJvcignXCInICsgciArIFwiXFxcIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnXCIgKyBKdChhLnR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICB2YXIgbyA9IGUucGFyc2UodFsyXSwgMiwgTnQpO1xuICAgICAgICAgIGlmICghbykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKCFkcihyLCBvLnR5cGUpKSByZXR1cm4gZS5jb25jYXQoMikuZXJyb3IoJ1wiJyArIHIgKyBcIlxcXCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJ1wiICsgSnQoby50eXBlKSArIFwiJy5cIik7XG4gICAgICAgICAgaWYgKGEudHlwZS5raW5kICE9PSBvLnR5cGUua2luZCAmJiBcInZhbHVlXCIgIT09IGEudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gby50eXBlLmtpbmQpIHJldHVybiBlLmVycm9yKFwiQ2Fubm90IGNvbXBhcmUgdHlwZXMgJ1wiICsgSnQoYS50eXBlKSArIFwiJyBhbmQgJ1wiICsgSnQoby50eXBlKSArIFwiJy5cIik7XG4gICAgICAgICAgbiAmJiAoXCJ2YWx1ZVwiID09PSBhLnR5cGUua2luZCAmJiBcInZhbHVlXCIgIT09IG8udHlwZS5raW5kID8gYSA9IG5ldyBoZShvLnR5cGUsIFthXSkgOiBcInZhbHVlXCIgIT09IGEudHlwZS5raW5kICYmIFwidmFsdWVcIiA9PT0gby50eXBlLmtpbmQgJiYgKG8gPSBuZXcgaGUoYS50eXBlLCBbb10pKSk7XG4gICAgICAgICAgdmFyIHMgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKDQgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJzdHJpbmdcIiAhPT0gby50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiICE9PSBhLnR5cGUua2luZCAmJiBcInZhbHVlXCIgIT09IG8udHlwZS5raW5kKSByZXR1cm4gZS5lcnJvcihcIkNhbm5vdCB1c2UgY29sbGF0b3IgdG8gY29tcGFyZSBub24tc3RyaW5nIHR5cGVzLlwiKTtcbiAgICAgICAgICAgIGlmICghKHMgPSBlLnBhcnNlKHRbM10sIDMsIEt0KSkpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgaShhLCBvLCBzKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5saHMuZXZhbHVhdGUoaSksXG4gICAgICAgICAgICAgIG8gPSB0aGlzLnJocy5ldmFsdWF0ZShpKTtcblxuICAgICAgICAgIGlmIChuICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNlKGEpLFxuICAgICAgICAgICAgICAgIHUgPSBzZShvKTtcbiAgICAgICAgICAgIGlmIChzLmtpbmQgIT09IHUua2luZCB8fCBcInN0cmluZ1wiICE9PSBzLmtpbmQgJiYgXCJudW1iZXJcIiAhPT0gcy5raW5kKSB0aHJvdyBuZXcgcGUoJ0V4cGVjdGVkIGFyZ3VtZW50cyBmb3IgXCInICsgdCArICdcIiB0byBiZSAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIG51bWJlciksIGJ1dCBmb3VuZCAoJyArIHMua2luZCArIFwiLCBcIiArIHUua2luZCArIFwiKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhbiAmJiB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSBzZShhKSxcbiAgICAgICAgICAgICAgICBwID0gc2Uobyk7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gbC5raW5kIHx8IFwic3RyaW5nXCIgIT09IHAua2luZCkgcmV0dXJuIGUoaSwgYSwgbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IgPyByKGksIGEsIG8sIHRoaXMuY29sbGF0b3IuZXZhbHVhdGUoaSkpIDogZShpLCBhLCBvKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0KHRoaXMubGhzKSwgdCh0aGlzLnJocyksIHRoaXMuY29sbGF0b3IgJiYgdCh0aGlzLmNvbGxhdG9yKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IFt0XTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGUucHVzaCh0LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICB9KSwgZTtcbiAgICAgICAgfSwgaTtcbiAgICAgIH0oKTtcbiAgICB9XG5cbiAgICB5ci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPD0gMiB8fCB0Lmxlbmd0aCA+PSA1KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSwgTnQpLFxuICAgICAgICAgIG4gPSBlLnBhcnNlKHRbMl0sIDIsIE90KTtcbiAgICAgIGlmICghciB8fCAhbikgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoISR0KHIudHlwZSwgW1h0KE50KSwgUnQsIE50XSkpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIEp0KHIudHlwZSkgKyBcIiBpbnN0ZWFkXCIpO1xuXG4gICAgICBpZiAoNCA9PT0gdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGkgPSBlLnBhcnNlKHRbM10sIDMsIE90KTtcbiAgICAgICAgcmV0dXJuIGkgPyBuZXcgeXIoci50eXBlLCByLCBuLCBpKSA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgeXIoci50eXBlLCByLCBuKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpLFxuICAgICAgICAgIHIgPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUodCk7XG4gICAgICBpZiAoIVd0KGUsIFtcInN0cmluZ1wiLCBcImFycmF5XCJdKSkgdGhyb3cgbmV3IHBlKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIEp0KHNlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuXG4gICAgICBpZiAodGhpcy5lbmRJbmRleCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUodCk7XG4gICAgICAgIHJldHVybiBlLnNsaWNlKHIsIG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZS5zbGljZShyKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5pbnB1dCksIHQodGhpcy5iZWdpbkluZGV4KSwgdGhpcy5lbmRJbmRleCAmJiB0KHRoaXMuZW5kSW5kZXgpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIHlyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobnVsbCAhPSB0aGlzLmVuZEluZGV4ICYmIHZvaWQgMCAhPT0gdGhpcy5lbmRJbmRleCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZW5kSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbXCJzbGljZVwiLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpLCB0aGlzLmJlZ2luSW5kZXguc2VyaWFsaXplKCksIHRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1wic2xpY2VcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuXG4gICAgdmFyIGdyID0gdnIoXCI9PVwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgPT09IHI7XG4gICAgfSwgbXIpLFxuICAgICAgICB4ciA9IHZyKFwiIT1cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBlICE9PSByO1xuICAgIH0sIGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gIW1yKDAsIGUsIHIsIG4pO1xuICAgIH0pLFxuICAgICAgICBiciA9IHZyKFwiPFwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgPCByO1xuICAgIH0sIGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gbi5jb21wYXJlKGUsIHIpIDwgMDtcbiAgICB9KSxcbiAgICAgICAgd3IgPSB2cihcIj5cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBlID4gcjtcbiAgICB9LCBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG4uY29tcGFyZShlLCByKSA+IDA7XG4gICAgfSksXG4gICAgICAgIF9yID0gdnIoXCI8PVwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgPD0gcjtcbiAgICB9LCBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG4uY29tcGFyZShlLCByKSA8PSAwO1xuICAgIH0pLFxuICAgICAgICBBciA9IHZyKFwiPj1cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBlID49IHI7XG4gICAgfSwgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBuLmNvbXBhcmUoZSwgcikgPj0gMDtcbiAgICB9KSxcbiAgICAgICAgU3IgPSBmdW5jdGlvbiBTcih0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnR5cGUgPSBSdCwgdGhpcy5udW1iZXIgPSB0LCB0aGlzLmxvY2FsZSA9IGUsIHRoaXMuY3VycmVuY3kgPSByLCB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbiwgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IGk7XG4gICAgfTtcblxuICAgIFNyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBPdCk7XG4gICAgICBpZiAoIXIpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG4gPSB0WzJdO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIG4gfHwgQXJyYXkuaXNBcnJheShuKSkgcmV0dXJuIGUuZXJyb3IoXCJOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB2YXIgaSA9IG51bGw7XG4gICAgICBpZiAobi5sb2NhbGUgJiYgIShpID0gZS5wYXJzZShuLmxvY2FsZSwgMSwgUnQpKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgYSA9IG51bGw7XG4gICAgICBpZiAobi5jdXJyZW5jeSAmJiAhKGEgPSBlLnBhcnNlKG4uY3VycmVuY3ksIDEsIFJ0KSkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG8gPSBudWxsO1xuICAgICAgaWYgKG5bXCJtaW4tZnJhY3Rpb24tZGlnaXRzXCJdICYmICEobyA9IGUucGFyc2UobltcIm1pbi1mcmFjdGlvbi1kaWdpdHNcIl0sIDEsIE90KSkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgcmV0dXJuIG5bXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdICYmICEocyA9IGUucGFyc2UobltcIm1heC1mcmFjdGlvbi1kaWdpdHNcIl0sIDEsIE90KSkgPyBudWxsIDogbmV3IFNyKHIsIGksIGEsIG8sIHMpO1xuICAgIH0sIFNyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUodCkgOiBbXSwge1xuICAgICAgICBzdHlsZTogdGhpcy5jdXJyZW5jeSA/IFwiY3VycmVuY3lcIiA6IFwiZGVjaW1hbFwiLFxuICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUodCkgOiB2b2lkIDAsXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUodCkgOiB2b2lkIDAsXG4gICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUodCkgOiB2b2lkIDBcbiAgICAgIH0pLmZvcm1hdCh0aGlzLm51bWJlci5ldmFsdWF0ZSh0KSk7XG4gICAgfSwgU3IucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMubnVtYmVyKSwgdGhpcy5sb2NhbGUgJiYgdCh0aGlzLmxvY2FsZSksIHRoaXMuY3VycmVuY3kgJiYgdCh0aGlzLmN1cnJlbmN5KSwgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyAmJiB0KHRoaXMubWluRnJhY3Rpb25EaWdpdHMpLCB0aGlzLm1heEZyYWN0aW9uRGlnaXRzICYmIHQodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyk7XG4gICAgfSwgU3IucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgU3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0ge307XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbGUgJiYgKHQubG9jYWxlID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCkpLCB0aGlzLmN1cnJlbmN5ICYmICh0LmN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jeS5zZXJpYWxpemUoKSksIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgJiYgKHRbXCJtaW4tZnJhY3Rpb24tZGlnaXRzXCJdID0gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKSksIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgJiYgKHRbXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdID0gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKSksIFtcIm51bWJlci1mb3JtYXRcIiwgdGhpcy5udW1iZXIuc2VyaWFsaXplKCksIHRdO1xuICAgIH07XG5cbiAgICB2YXIga3IgPSBmdW5jdGlvbiBrcih0KSB7XG4gICAgICB0aGlzLnR5cGUgPSBPdCwgdGhpcy5pbnB1dCA9IHQ7XG4gICAgfTtcblxuICAgIGtyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEpO1xuICAgICAgcmV0dXJuIHIgPyBcImFycmF5XCIgIT09IHIudHlwZS5raW5kICYmIFwic3RyaW5nXCIgIT09IHIudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gci50eXBlLmtpbmQgPyBlLmVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCBcIiArIEp0KHIudHlwZSkgKyBcIiBpbnN0ZWFkLlwiKSA6IG5ldyBrcihyKSA6IG51bGw7XG4gICAgfSwga3IucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gZS5sZW5ndGg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIGUubGVuZ3RoO1xuICAgICAgdGhyb3cgbmV3IHBlKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCBcIiArIEp0KHNlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgIH0sIGtyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KTtcbiAgICB9LCBrci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBrci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXCJsZW5ndGhcIl07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcbiAgICB2YXIgSXIgPSB7XG4gICAgICBcIj09XCI6IGdyLFxuICAgICAgXCIhPVwiOiB4cixcbiAgICAgIFwiPlwiOiB3cixcbiAgICAgIFwiPFwiOiBicixcbiAgICAgIFwiPj1cIjogQXIsXG4gICAgICBcIjw9XCI6IF9yLFxuICAgICAgYXJyYXk6IGhlLFxuICAgICAgYXQ6IGxyLFxuICAgICAgYm9vbGVhbjogaGUsXG4gICAgICBjYXNlOiBmcixcbiAgICAgIGNvYWxlc2NlOiBzcixcbiAgICAgIGNvbGxhdG9yOiBiZSxcbiAgICAgIGZvcm1hdDogZmUsXG4gICAgICBpbWFnZTogeWUsXG4gICAgICBpbjogcHIsXG4gICAgICBcImluZGV4LW9mXCI6IGNyLFxuICAgICAgaW50ZXJwb2xhdGU6IGFyLFxuICAgICAgXCJpbnRlcnBvbGF0ZS1oY2xcIjogYXIsXG4gICAgICBcImludGVycG9sYXRlLWxhYlwiOiBhcixcbiAgICAgIGxlbmd0aDoga3IsXG4gICAgICBsZXQ6IHVyLFxuICAgICAgbGl0ZXJhbDogbGUsXG4gICAgICBtYXRjaDogaHIsXG4gICAgICBudW1iZXI6IGhlLFxuICAgICAgXCJudW1iZXItZm9ybWF0XCI6IFNyLFxuICAgICAgb2JqZWN0OiBoZSxcbiAgICAgIHNsaWNlOiB5cixcbiAgICAgIHN0ZXA6IE5lLFxuICAgICAgc3RyaW5nOiBoZSxcbiAgICAgIFwidG8tYm9vbGVhblwiOiBtZSxcbiAgICAgIFwidG8tY29sb3JcIjogbWUsXG4gICAgICBcInRvLW51bWJlclwiOiBtZSxcbiAgICAgIFwidG8tc3RyaW5nXCI6IG1lLFxuICAgICAgdmFyOiBVZSxcbiAgICAgIHdpdGhpbjogRGVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24genIodCwgZSkge1xuICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgIGkgPSBlWzJdLFxuICAgICAgICAgIGEgPSBlWzNdO1xuICAgICAgciA9IHIuZXZhbHVhdGUodCksIG4gPSBuLmV2YWx1YXRlKHQpLCBpID0gaS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBvID0gYSA/IGEuZXZhbHVhdGUodCkgOiAxLFxuICAgICAgICAgIHMgPSBhZShyLCBuLCBpLCBvKTtcbiAgICAgIGlmIChzKSB0aHJvdyBuZXcgcGUocyk7XG4gICAgICByZXR1cm4gbmV3IHRlKHIgLyAyNTUgKiBvLCBuIC8gMjU1ICogbywgaSAvIDI1NSAqIG8sIG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENyKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IGluIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRXIodCwgZSkge1xuICAgICAgdmFyIHIgPSBlW3RdO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gciA/IG51bGwgOiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFByKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTXIodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBcInN1Y2Nlc3NcIixcbiAgICAgICAgdmFsdWU6IHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQnIodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBcImVycm9yXCIsXG4gICAgICAgIHZhbHVlOiB0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRyKHQpIHtcbiAgICAgIHJldHVybiBcImRhdGEtZHJpdmVuXCIgPT09IHRbXCJwcm9wZXJ0eS10eXBlXCJdIHx8IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIiA9PT0gdFtcInByb3BlcnR5LXR5cGVcIl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnIodCkge1xuICAgICAgcmV0dXJuICEhdC5leHByZXNzaW9uICYmIHQuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoXCJ6b29tXCIpID4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRnIodCkge1xuICAgICAgcmV0dXJuICEhdC5leHByZXNzaW9uICYmIHQuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHIodCkge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBOdW1iZXIgPyBcIm51bWJlclwiIDogdCBpbnN0YW5jZW9mIFN0cmluZyA/IFwic3RyaW5nXCIgOiB0IGluc3RhbmNlb2YgQm9vbGVhbiA/IFwiYm9vbGVhblwiIDogQXJyYXkuaXNBcnJheSh0KSA/IFwiYXJyYXlcIiA6IG51bGwgPT09IHQgPyBcIm51bGxcIiA6IHR5cGVvZiB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExyKHQpIHtcbiAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIG51bGwgIT09IHQgJiYgIUFycmF5LmlzQXJyYXkodCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gT3IodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUnIodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdCA/IHQgOiB2b2lkIDAgIT09IGUgPyBlIDogdm9pZCAwICE9PSByID8gciA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVcih0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gUnIodHlwZW9mIHIgPT09IGkgPyBuW3JdIDogdm9pZCAwLCB0LmRlZmF1bHQsIGUuZGVmYXVsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ganIodCwgZSwgcikge1xuICAgICAgaWYgKFwibnVtYmVyXCIgIT09IERyKHIpKSByZXR1cm4gUnIodC5kZWZhdWx0LCBlLmRlZmF1bHQpO1xuICAgICAgdmFyIG4gPSB0LnN0b3BzLmxlbmd0aDtcbiAgICAgIGlmICgxID09PSBuKSByZXR1cm4gdC5zdG9wc1swXVsxXTtcbiAgICAgIGlmIChyIDw9IHQuc3RvcHNbMF1bMF0pIHJldHVybiB0LnN0b3BzWzBdWzFdO1xuICAgICAgaWYgKHIgPj0gdC5zdG9wc1tuIC0gMV1bMF0pIHJldHVybiB0LnN0b3BzW24gLSAxXVsxXTtcbiAgICAgIHZhciBpID0gcWUodC5zdG9wcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRbMF07XG4gICAgICB9KSwgcik7XG4gICAgICByZXR1cm4gdC5zdG9wc1tpXVsxXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxcih0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHZvaWQgMCAhPT0gdC5iYXNlID8gdC5iYXNlIDogMTtcbiAgICAgIGlmIChcIm51bWJlclwiICE9PSBEcihyKSkgcmV0dXJuIFJyKHQuZGVmYXVsdCwgZS5kZWZhdWx0KTtcbiAgICAgIHZhciBpID0gdC5zdG9wcy5sZW5ndGg7XG4gICAgICBpZiAoMSA9PT0gaSkgcmV0dXJuIHQuc3RvcHNbMF1bMV07XG4gICAgICBpZiAociA8PSB0LnN0b3BzWzBdWzBdKSByZXR1cm4gdC5zdG9wc1swXVsxXTtcbiAgICAgIGlmIChyID49IHQuc3RvcHNbaSAtIDFdWzBdKSByZXR1cm4gdC5zdG9wc1tpIC0gMV1bMV07XG5cbiAgICAgIHZhciBhID0gcWUodC5zdG9wcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRbMF07XG4gICAgICB9KSwgciksXG4gICAgICAgICAgbyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gbiAtIHIsXG4gICAgICAgICAgICBhID0gdCAtIHI7XG4gICAgICAgIHJldHVybiAwID09PSBpID8gMCA6IDEgPT09IGUgPyBhIC8gaSA6IChNYXRoLnBvdyhlLCBhKSAtIDEpIC8gKE1hdGgucG93KGUsIGkpIC0gMSk7XG4gICAgICB9KHIsIG4sIHQuc3RvcHNbYV1bMF0sIHQuc3RvcHNbYSArIDFdWzBdKSxcbiAgICAgICAgICBzID0gdC5zdG9wc1thXVsxXSxcbiAgICAgICAgICB1ID0gdC5zdG9wc1thICsgMV1bMV0sXG4gICAgICAgICAgbCA9IEdlW2UudHlwZV0gfHwgT3I7XG5cbiAgICAgIGlmICh0LmNvbG9yU3BhY2UgJiYgXCJyZ2JcIiAhPT0gdC5jb2xvclNwYWNlKSB7XG4gICAgICAgIHZhciBwID0gaXJbdC5jb2xvclNwYWNlXTtcblxuICAgICAgICBsID0gZnVuY3Rpb24gbCh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHAucmV2ZXJzZShwLmludGVycG9sYXRlKHAuZm9yd2FyZCh0KSwgcC5mb3J3YXJkKGUpLCBvKSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHMuZXZhbHVhdGUgPyB7XG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gW10sIGUgPSBhcmd1bWVudHMubGVuZ3RoOyBlLS07KSB7XG4gICAgICAgICAgICB0W2VdID0gYXJndW1lbnRzW2VdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByID0gcy5ldmFsdWF0ZS5hcHBseSh2b2lkIDAsIHQpLFxuICAgICAgICAgICAgICBuID0gdS5ldmFsdWF0ZS5hcHBseSh2b2lkIDAsIHQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIgJiYgdm9pZCAwICE9PSBuKSByZXR1cm4gbChyLCBuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSA6IGwocywgdSwgbyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTnIodCwgZSwgcikge1xuICAgICAgcmV0dXJuIFwiY29sb3JcIiA9PT0gZS50eXBlID8gciA9IHRlLnBhcnNlKHIpIDogXCJmb3JtYXR0ZWRcIiA9PT0gZS50eXBlID8gciA9IG5lLmZyb21TdHJpbmcoci50b1N0cmluZygpKSA6IFwicmVzb2x2ZWRJbWFnZVwiID09PSBlLnR5cGUgPyByID0gaWUuZnJvbVN0cmluZyhyLnRvU3RyaW5nKCkpIDogRHIocikgPT09IGUudHlwZSB8fCBcImVudW1cIiA9PT0gZS50eXBlICYmIGUudmFsdWVzW3JdIHx8IChyID0gdm9pZCAwKSwgUnIociwgdC5kZWZhdWx0LCBlLmRlZmF1bHQpO1xuICAgIH1cblxuICAgIHhlLnJlZ2lzdGVyKElyLCB7XG4gICAgICBlcnJvcjogW3tcbiAgICAgICAga2luZDogXCJlcnJvclwiXG4gICAgICB9LCBbUnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aHJvdyBuZXcgcGUoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHR5cGVvZjogW1J0LCBbTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gSnQoc2UoZVswXS5ldmFsdWF0ZSh0KSkpO1xuICAgICAgfV0sXG4gICAgICBcInRvLXJnYmFcIjogW1h0KE90LCA0KSwgW2p0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkudG9BcnJheSgpO1xuICAgICAgfV0sXG4gICAgICByZ2I6IFtqdCwgW090LCBPdCwgT3RdLCB6cl0sXG4gICAgICByZ2JhOiBbanQsIFtPdCwgT3QsIE90LCBPdF0sIHpyXSxcbiAgICAgIGhhczoge1xuICAgICAgICB0eXBlOiBVdCxcbiAgICAgICAgb3ZlcmxvYWRzOiBbW1tSdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIENyKGVbMF0uZXZhbHVhdGUodCksIHQucHJvcGVydGllcygpKTtcbiAgICAgICAgfV0sIFtbUnQsIHF0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIENyKGVbMF0uZXZhbHVhdGUodCksIHIuZXZhbHVhdGUodCkpO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBnZXQ6IHtcbiAgICAgICAgdHlwZTogTnQsXG4gICAgICAgIG92ZXJsb2FkczogW1tbUnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiBFcihlWzBdLmV2YWx1YXRlKHQpLCB0LnByb3BlcnRpZXMoKSk7XG4gICAgICAgIH1dLCBbW1J0LCBxdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBFcihlWzBdLmV2YWx1YXRlKHQpLCByLmV2YWx1YXRlKHQpKTtcbiAgICAgICAgfV1dXG4gICAgICB9LFxuICAgICAgXCJmZWF0dXJlLXN0YXRlXCI6IFtOdCwgW1J0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIEVyKGVbMF0uZXZhbHVhdGUodCksIHQuZmVhdHVyZVN0YXRlIHx8IHt9KTtcbiAgICAgIH1dLFxuICAgICAgcHJvcGVydGllczogW3F0LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQucHJvcGVydGllcygpO1xuICAgICAgfV0sXG4gICAgICBcImdlb21ldHJ5LXR5cGVcIjogW1J0LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZ2VvbWV0cnlUeXBlKCk7XG4gICAgICB9XSxcbiAgICAgIGlkOiBbTnQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZCgpO1xuICAgICAgfV0sXG4gICAgICB6b29tOiBbT3QsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5nbG9iYWxzLnpvb207XG4gICAgICB9XSxcbiAgICAgIFwiaGVhdG1hcC1kZW5zaXR5XCI6IFtPdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lmdsb2JhbHMuaGVhdG1hcERlbnNpdHkgfHwgMDtcbiAgICAgIH1dLFxuICAgICAgXCJsaW5lLXByb2dyZXNzXCI6IFtPdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lmdsb2JhbHMubGluZVByb2dyZXNzIHx8IDA7XG4gICAgICB9XSxcbiAgICAgIGFjY3VtdWxhdGVkOiBbTnQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0Lmdsb2JhbHMuYWNjdW11bGF0ZWQgPyBudWxsIDogdC5nbG9iYWxzLmFjY3VtdWxhdGVkO1xuICAgICAgfV0sXG4gICAgICBcIitcIjogW090LCBQcihPdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gMCwgaSA9IGU7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgciArPSBpW25dLmV2YWx1YXRlKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XSxcbiAgICAgIFwiKlwiOiBbT3QsIFByKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDEsIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICByICo9IGlbbl0uZXZhbHVhdGUodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1dLFxuICAgICAgXCItXCI6IHtcbiAgICAgICAgdHlwZTogT3QsXG4gICAgICAgIG92ZXJsb2FkczogW1tbT3QsIE90XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkgLSByLmV2YWx1YXRlKHQpO1xuICAgICAgICB9XSwgW1tPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIC1lWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBcIi9cIjogW090LCBbT3QsIE90XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KSAvIHIuZXZhbHVhdGUodCk7XG4gICAgICB9XSxcbiAgICAgIFwiJVwiOiBbT3QsIFtPdCwgT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpICUgci5ldmFsdWF0ZSh0KTtcbiAgICAgIH1dLFxuICAgICAgbG4yOiBbT3QsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLkxOMjtcbiAgICAgIH1dLFxuICAgICAgcGk6IFtPdCwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XSxcbiAgICAgIGU6IFtPdCwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguRTtcbiAgICAgIH1dLFxuICAgICAgXCJeXCI6IFtPdCwgW090LCBPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KGVbMF0uZXZhbHVhdGUodCksIHIuZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBzcXJ0OiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGxvZzEwOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyhlWzBdLmV2YWx1YXRlKHQpKSAvIE1hdGguTE4xMDtcbiAgICAgIH1dLFxuICAgICAgbG46IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBsb2cyOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyhlWzBdLmV2YWx1YXRlKHQpKSAvIE1hdGguTE4yO1xuICAgICAgfV0sXG4gICAgICBzaW46IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBjb3M6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY29zKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICB0YW46IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudGFuKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBhc2luOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGFjb3M6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgYXRhbjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBtaW46IFtPdCwgUHIoT3QpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfSkpO1xuICAgICAgfV0sXG4gICAgICBtYXg6IFtPdCwgUHIoT3QpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfSkpO1xuICAgICAgfV0sXG4gICAgICBhYnM6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICByb3VuZDogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0uZXZhbHVhdGUodCk7XG4gICAgICAgIHJldHVybiByIDwgMCA/IC1NYXRoLnJvdW5kKC1yKSA6IE1hdGgucm91bmQocik7XG4gICAgICB9XSxcbiAgICAgIGZsb29yOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBjZWlsOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLT09XCI6IFtVdCwgW1J0LCBOdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSBlWzFdO1xuICAgICAgICByZXR1cm4gdC5wcm9wZXJ0aWVzKClbci52YWx1ZV0gPT09IG4udmFsdWU7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWlkLT09XCI6IFtVdCwgW050XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdO1xuICAgICAgICByZXR1cm4gdC5pZCgpID09PSByLnZhbHVlO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci10eXBlLT09XCI6IFtVdCwgW1J0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdO1xuICAgICAgICByZXR1cm4gdC5nZW9tZXRyeVR5cGUoKSA9PT0gci52YWx1ZTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPFwiOiBbVXQsIFtSdCwgTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICAgIGEgPSBuLnZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGkgPT0gdHlwZW9mIGEgJiYgaSA8IGE7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWlkLTxcIjogW1V0LCBbTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gdC5pZCgpLFxuICAgICAgICAgICAgaSA9IHIudmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgaSAmJiBuIDwgaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPlwiOiBbVXQsIFtSdCwgTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICAgIGEgPSBuLnZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGkgPT0gdHlwZW9mIGEgJiYgaSA+IGE7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWlkLT5cIjogW1V0LCBbTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gdC5pZCgpLFxuICAgICAgICAgICAgaSA9IHIudmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgaSAmJiBuID4gaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPD1cIjogW1V0LCBbUnQsIE50XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgICAgICBpID0gdC5wcm9wZXJ0aWVzKClbci52YWx1ZV0sXG4gICAgICAgICAgICBhID0gbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpID09IHR5cGVvZiBhICYmIGkgPD0gYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPD1cIjogW1V0LCBbTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gdC5pZCgpLFxuICAgICAgICAgICAgaSA9IHIudmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgaSAmJiBuIDw9IGk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLT49XCI6IFtVdCwgW1J0LCBOdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgICAgaSA9IHQucHJvcGVydGllcygpW3IudmFsdWVdLFxuICAgICAgICAgICAgYSA9IG4udmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaSA9PSB0eXBlb2YgYSAmJiBpID49IGE7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWlkLT49XCI6IFtVdCwgW050XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgICAgbiA9IHQuaWQoKSxcbiAgICAgICAgICAgIGkgPSByLnZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT0gdHlwZW9mIGkgJiYgbiA+PSBpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1oYXNcIjogW1V0LCBbTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS52YWx1ZSBpbiB0LnByb3BlcnRpZXMoKTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaGFzLWlkXCI6IFtVdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBudWxsICE9PSB0LmlkKCkgJiYgdm9pZCAwICE9PSB0LmlkKCk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLXR5cGUtaW5cIjogW1V0LCBbWHQoUnQpXSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0udmFsdWUuaW5kZXhPZih0Lmdlb21ldHJ5VHlwZSgpKSA+PSAwO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1pZC1pblwiOiBbVXQsIFtYdChOdCldLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS52YWx1ZS5pbmRleE9mKHQuaWQoKSkgPj0gMDtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaW4tc21hbGxcIjogW1V0LCBbUnQsIFh0KE50KV0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXTtcbiAgICAgICAgcmV0dXJuIGVbMV0udmFsdWUuaW5kZXhPZih0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSkgPj0gMDtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaW4tbGFyZ2VcIjogW1V0LCBbUnQsIFh0KE50KV0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSBlWzFdO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICBmb3IgKDsgciA8PSBuOykge1xuICAgICAgICAgICAgdmFyIGkgPSByICsgbiA+PiAxO1xuICAgICAgICAgICAgaWYgKGVbaV0gPT09IHQpIHJldHVybiAhMDtcbiAgICAgICAgICAgIGVbaV0gPiB0ID8gbiA9IGkgLSAxIDogciA9IGkgKyAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSh0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSwgbi52YWx1ZSwgMCwgbi52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH1dLFxuICAgICAgYWxsOiB7XG4gICAgICAgIHR5cGU6IFV0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW1V0LCBVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpICYmIHIuZXZhbHVhdGUodCk7XG4gICAgICAgIH1dLCBbUHIoVXQpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gZTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbltyXS5ldmFsdWF0ZSh0KSkgcmV0dXJuICExO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfV1dXG4gICAgICB9LFxuICAgICAgYW55OiB7XG4gICAgICAgIHR5cGU6IFV0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW1V0LCBVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpIHx8IHIuZXZhbHVhdGUodCk7XG4gICAgICAgIH1dLCBbUHIoVXQpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gZTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChuW3JdLmV2YWx1YXRlKHQpKSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBcIiFcIjogW1V0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gIWVbMF0uZXZhbHVhdGUodCk7XG4gICAgICB9XSxcbiAgICAgIFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiOiBbVXQsIFtSdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gdC5nbG9iYWxzICYmIHQuZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgICAgcmV0dXJuICFyIHx8IHIoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHVwY2FzZTogW1J0LCBbUnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfV0sXG4gICAgICBkb3duY2FzZTogW1J0LCBbUnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfV0sXG4gICAgICBjb25jYXQ6IFtSdCwgUHIoTnQpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gdWUoZS5ldmFsdWF0ZSh0KSk7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9XSxcbiAgICAgIFwicmVzb2x2ZWQtbG9jYWxlXCI6IFtSdCwgW0t0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkucmVzb2x2ZWRMb2NhbGUoKTtcbiAgICAgIH1dXG4gICAgfSk7XG5cbiAgICB2YXIgS3IgPSBmdW5jdGlvbiBLcih0LCBlKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSB0LCB0aGlzLl93YXJuaW5nSGlzdG9yeSA9IHt9LCB0aGlzLl9ldmFsdWF0b3IgPSBuZXcgZ2UoKSwgdGhpcy5fZGVmYXVsdFZhbHVlID0gZSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcImNvbG9yXCIgPT09IHQudHlwZSAmJiBMcih0LmRlZmF1bHQpID8gbmV3IHRlKDAsIDAsIDAsIDApIDogXCJjb2xvclwiID09PSB0LnR5cGUgPyB0ZS5wYXJzZSh0LmRlZmF1bHQpIHx8IG51bGwgOiB2b2lkIDAgPT09IHQuZGVmYXVsdCA/IG51bGwgOiB0LmRlZmF1bHQ7XG4gICAgICB9KGUpIDogbnVsbCwgdGhpcy5fZW51bVZhbHVlcyA9IGUgJiYgXCJlbnVtXCIgPT09IGUudHlwZSA/IGUudmFsdWVzIDogbnVsbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gR3IodCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgJiYgdC5sZW5ndGggPiAwICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRbMF0gJiYgdFswXSBpbiBJcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBacih0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBqZShJciwgW10sIGUgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICBjb2xvcjoganQsXG4gICAgICAgICAgc3RyaW5nOiBSdCxcbiAgICAgICAgICBudW1iZXI6IE90LFxuICAgICAgICAgIGVudW06IFJ0LFxuICAgICAgICAgIGJvb2xlYW46IFV0LFxuICAgICAgICAgIGZvcm1hdHRlZDogR3QsXG4gICAgICAgICAgcmVzb2x2ZWRJbWFnZTogWnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIiA9PT0gdC50eXBlID8gWHQoZVt0LnZhbHVlXSB8fCBOdCwgdC5sZW5ndGgpIDogZVt0LnR5cGVdO1xuICAgICAgfShlKSA6IHZvaWQgMCksXG4gICAgICAgICAgbiA9IHIucGFyc2UodCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZSAmJiBcInN0cmluZ1wiID09PSBlLnR5cGUgPyB7XG4gICAgICAgIHR5cGVBbm5vdGF0aW9uOiBcImNvZXJjZVwiXG4gICAgICB9IDogdm9pZCAwKTtcbiAgICAgIHJldHVybiBuID8gTXIobmV3IEtyKG4sIGUpKSA6IEJyKHIuZXJyb3JzKTtcbiAgICB9XG5cbiAgICBLci5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSB0LCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IGUsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlU3RhdGUgPSByLCB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gbiwgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGkgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBhLCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgICB9LCBLci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSB0LCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IGUgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IHIgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IG4sIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBpIHx8IG51bGwsIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gYSB8fCBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICAgICAgICBpZiAobnVsbCA9PSBvIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIG8gJiYgbyAhPSBvKSByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fZW51bVZhbHVlcyAmJiAhKG8gaW4gdGhpcy5fZW51bVZhbHVlcykpIHRocm93IG5ldyBwZShcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiBcIiArIE9iamVjdC5rZXlzKHRoaXMuX2VudW1WYWx1ZXMpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0KTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIsIGJ1dCBmb3VuZCBcIiArIEpTT04uc3RyaW5naWZ5KG8pICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FybmluZ0hpc3RvcnlbdC5tZXNzYWdlXSB8fCAodGhpcy5fd2FybmluZ0hpc3RvcnlbdC5tZXNzYWdlXSA9ICEwLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjb25zb2xlICYmIGNvbnNvbGUud2Fybih0Lm1lc3NhZ2UpKSwgdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgWHIgPSBmdW5jdGlvbiBYcih0LCBlKSB7XG4gICAgICB0aGlzLmtpbmQgPSB0LCB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBlLCB0aGlzLmlzU3RhdGVEZXBlbmRlbnQgPSBcImNvbnN0YW50XCIgIT09IHQgJiYgIU9lKGUuZXhwcmVzc2lvbik7XG4gICAgfTtcblxuICAgIFhyLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyh0LCBlLCByLCBuLCBpLCBhKTtcbiAgICB9LCBYci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZSh0LCBlLCByLCBuLCBpLCBhKTtcbiAgICB9O1xuXG4gICAgdmFyIEpyID0gZnVuY3Rpb24gSnIodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5raW5kID0gdCwgdGhpcy56b29tU3RvcHMgPSByLCB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBlLCB0aGlzLmlzU3RhdGVEZXBlbmRlbnQgPSBcImNhbWVyYVwiICE9PSB0ICYmICFPZShlLmV4cHJlc3Npb24pLCB0aGlzLmludGVycG9sYXRpb25UeXBlID0gbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSHIodCwgZSkge1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gKHQgPSBacih0LCBlKSkucmVzdWx0KSByZXR1cm4gdDtcbiAgICAgIHZhciByID0gdC52YWx1ZS5leHByZXNzaW9uLFxuICAgICAgICAgIG4gPSBMZShyKTtcbiAgICAgIGlmICghbiAmJiAhVHIoZSkpIHJldHVybiBCcihbbmV3IEZ0KFwiXCIsIFwiZGF0YSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkXCIpXSk7XG4gICAgICB2YXIgaSA9IFJlKHIsIFtcInpvb21cIl0pO1xuICAgICAgaWYgKCFpICYmICFWcihlKSkgcmV0dXJuIEJyKFtuZXcgRnQoXCJcIiwgXCJ6b29tIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWRcIildKTtcblxuICAgICAgdmFyIGEgPSBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHVyKSByID0gdChlLnJlc3VsdCk7ZWxzZSBpZiAoZSBpbnN0YW5jZW9mIHNyKSBmb3IgKHZhciBuID0gMCwgaSA9IGUuYXJnczsgbiA8IGkubGVuZ3RoICYmICEociA9IHQoaVtuXSkpOyBuICs9IDEpIHtcbiAgICAgICAgICA7XG4gICAgICAgIH0gZWxzZSAoZSBpbnN0YW5jZW9mIE5lIHx8IGUgaW5zdGFuY2VvZiBhcikgJiYgZS5pbnB1dCBpbnN0YW5jZW9mIHhlICYmIFwiem9vbVwiID09PSBlLmlucHV0Lm5hbWUgJiYgKHIgPSBlKTtcbiAgICAgICAgcmV0dXJuIHIgaW5zdGFuY2VvZiBGdCB8fCBlLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBuID0gdChlKTtcbiAgICAgICAgICBuIGluc3RhbmNlb2YgRnQgPyByID0gbiA6ICFyICYmIG4gPyByID0gbmV3IEZ0KFwiXCIsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJykgOiByICYmIG4gJiYgciAhPT0gbiAmJiAociA9IG5ldyBGdChcIlwiLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpKTtcbiAgICAgICAgfSksIHI7XG4gICAgICB9KHIpO1xuXG4gICAgICByZXR1cm4gYSB8fCBpID8gYSBpbnN0YW5jZW9mIEZ0ID8gQnIoW2FdKSA6IGEgaW5zdGFuY2VvZiBhciAmJiAhRnIoZSkgPyBCcihbbmV3IEZ0KFwiXCIsICdcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgY2Fubm90IGJlIHVzZWQgd2l0aCB0aGlzIHByb3BlcnR5JyldKSA6IE1yKGEgPyBuZXcgSnIobiA/IFwiY2FtZXJhXCIgOiBcImNvbXBvc2l0ZVwiLCB0LnZhbHVlLCBhLmxhYmVscywgYSBpbnN0YW5jZW9mIGFyID8gYS5pbnRlcnBvbGF0aW9uIDogdm9pZCAwKSA6IG5ldyBYcihuID8gXCJjb25zdGFudFwiIDogXCJzb3VyY2VcIiwgdC52YWx1ZSkpIDogQnIoW25ldyBGdChcIlwiLCAnXCJ6b29tXCIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLicpXSk7XG4gICAgfVxuXG4gICAgSnIucHJvdG90eXBlLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKHQsIGUsIHIsIG4sIGksIGEpO1xuICAgIH0sIEpyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKHQsIGUsIHIsIG4sIGksIGEpO1xuICAgIH0sIEpyLnByb3RvdHlwZS5pbnRlcnBvbGF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRpb25UeXBlID8gYXIuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb25UeXBlLCB0LCBlLCByKSA6IDA7XG4gICAgfTtcblxuICAgIHZhciBZciA9IGZ1bmN0aW9uIFlyKHQsIGUpIHtcbiAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSB0LCB0aGlzLl9zcGVjaWZpY2F0aW9uID0gZSwgQnQodGhpcywgZnVuY3Rpb24gdChlLCByKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBvID0gXCJjb2xvclwiID09PSByLnR5cGUsXG4gICAgICAgICAgICBzID0gZS5zdG9wcyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlLnN0b3BzWzBdWzBdLFxuICAgICAgICAgICAgdSA9IHMgfHwgIShzIHx8IHZvaWQgMCAhPT0gZS5wcm9wZXJ0eSksXG4gICAgICAgICAgICBsID0gZS50eXBlIHx8IChGcihyKSA/IFwiZXhwb25lbnRpYWxcIiA6IFwiaW50ZXJ2YWxcIik7XG4gICAgICAgIGlmIChvICYmICgoZSA9IEJ0KHt9LCBlKSkuc3RvcHMgJiYgKGUuc3RvcHMgPSBlLnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBbdFswXSwgdGUucGFyc2UodFsxXSldO1xuICAgICAgICB9KSksIGUuZGVmYXVsdCA9IHRlLnBhcnNlKGUuZGVmYXVsdCA/IGUuZGVmYXVsdCA6IHIuZGVmYXVsdCkpLCBlLmNvbG9yU3BhY2UgJiYgXCJyZ2JcIiAhPT0gZS5jb2xvclNwYWNlICYmICFpcltlLmNvbG9yU3BhY2VdKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHNwYWNlOiBcIiArIGUuY29sb3JTcGFjZSk7XG4gICAgICAgIGlmIChcImV4cG9uZW50aWFsXCIgPT09IGwpIG4gPSBxcjtlbHNlIGlmIChcImludGVydmFsXCIgPT09IGwpIG4gPSBqcjtlbHNlIGlmIChcImNhdGVnb3JpY2FsXCIgPT09IGwpIHtcbiAgICAgICAgICBuID0gVXIsIGkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgZm9yICh2YXIgcCA9IDAsIGMgPSBlLnN0b3BzOyBwIDwgYy5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGggPSBjW3BdO1xuICAgICAgICAgICAgaVtoWzBdXSA9IGhbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYSA9IHR5cGVvZiBlLnN0b3BzWzBdWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcImlkZW50aXR5XCIgIT09IGwpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmdW5jdGlvbiB0eXBlIFwiJyArIGwgKyAnXCInKTtcbiAgICAgICAgICBuID0gTnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgIGZvciAodmFyIGYgPSB7fSwgeSA9IFtdLCBkID0gMDsgZCA8IGUuc3RvcHMubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIHZhciBtID0gZS5zdG9wc1tkXSxcbiAgICAgICAgICAgICAgICB2ID0gbVswXS56b29tO1xuICAgICAgICAgICAgdm9pZCAwID09PSBmW3ZdICYmIChmW3ZdID0ge1xuICAgICAgICAgICAgICB6b29tOiB2LFxuICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBlLnByb3BlcnR5LFxuICAgICAgICAgICAgICBkZWZhdWx0OiBlLmRlZmF1bHQsXG4gICAgICAgICAgICAgIHN0b3BzOiBbXVxuICAgICAgICAgICAgfSwgeS5wdXNoKHYpKSwgZlt2XS5zdG9wcy5wdXNoKFttWzBdLnZhbHVlLCBtWzFdXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgZyA9IFtdLCB4ID0gMCwgYiA9IHk7IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGJbeF07XG4gICAgICAgICAgICBnLnB1c2goW2Zbd10uem9vbSwgdChmW3ddLCByKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfID0ge1xuICAgICAgICAgICAgbmFtZTogXCJsaW5lYXJcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IFwiY29tcG9zaXRlXCIsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogXyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IGFyLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh2b2lkIDAsIF8pLFxuICAgICAgICAgICAgem9vbVN0b3BzOiBnLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKHQsIG4pIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSB0Lnpvb207XG4gICAgICAgICAgICAgIHJldHVybiBxcih7XG4gICAgICAgICAgICAgICAgc3RvcHM6IGcsXG4gICAgICAgICAgICAgICAgYmFzZTogZS5iYXNlXG4gICAgICAgICAgICAgIH0sIHIsIGkpLmV2YWx1YXRlKGksIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBBID0gXCJleHBvbmVudGlhbFwiID09PSBsID8ge1xuICAgICAgICAgICAgbmFtZTogXCJleHBvbmVudGlhbFwiLFxuICAgICAgICAgICAgYmFzZTogdm9pZCAwICE9PSBlLmJhc2UgPyBlLmJhc2UgOiAxXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IFwiY2FtZXJhXCIsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogQSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IGFyLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh2b2lkIDAsIEEpLFxuICAgICAgICAgICAgem9vbVN0b3BzOiBlLnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG4oZSwgciwgdC56b29tLCBpLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBcInNvdXJjZVwiLFxuICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZSh0LCBvKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG8gJiYgby5wcm9wZXJ0aWVzID8gby5wcm9wZXJ0aWVzW2UucHJvcGVydHldIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gcyA/IFJyKGUuZGVmYXVsdCwgci5kZWZhdWx0KSA6IG4oZSwgciwgcywgaSwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSh0aGlzLl9wYXJhbWV0ZXJzLCB0aGlzLl9zcGVjaWZpY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uICRyKHQpIHtcbiAgICAgIHZhciBlID0gdC5rZXksXG4gICAgICAgICAgciA9IHQudmFsdWUsXG4gICAgICAgICAgbiA9IHQudmFsdWVTcGVjIHx8IHt9LFxuICAgICAgICAgIGkgPSB0Lm9iamVjdEVsZW1lbnRWYWxpZGF0b3JzIHx8IHt9LFxuICAgICAgICAgIGEgPSB0LnN0eWxlLFxuICAgICAgICAgIG8gPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgdSA9IERyKHIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHUpIHJldHVybiBbbmV3IFB0KGUsIHIsIFwib2JqZWN0IGV4cGVjdGVkLCBcIiArIHUgKyBcIiBmb3VuZFwiKV07XG5cbiAgICAgIGZvciAodmFyIGwgaW4gcikge1xuICAgICAgICB2YXIgcCA9IGwuc3BsaXQoXCIuXCIpWzBdLFxuICAgICAgICAgICAgYyA9IG5bcF0gfHwgbltcIipcIl0sXG4gICAgICAgICAgICBoID0gdm9pZCAwO1xuICAgICAgICBpZiAoaVtwXSkgaCA9IGlbcF07ZWxzZSBpZiAobltwXSkgaCA9IEFuO2Vsc2UgaWYgKGlbXCIqXCJdKSBoID0gaVtcIipcIl07ZWxzZSB7XG4gICAgICAgICAgaWYgKCFuW1wiKlwiXSkge1xuICAgICAgICAgICAgcy5wdXNoKG5ldyBQdChlLCByW2xdLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBsICsgJ1wiJykpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaCA9IEFuO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzLmNvbmNhdChoKHtcbiAgICAgICAgICBrZXk6IChlID8gZSArIFwiLlwiIDogZSkgKyBsLFxuICAgICAgICAgIHZhbHVlOiByW2xdLFxuICAgICAgICAgIHZhbHVlU3BlYzogYyxcbiAgICAgICAgICBzdHlsZTogYSxcbiAgICAgICAgICBzdHlsZVNwZWM6IG8sXG4gICAgICAgICAgb2JqZWN0OiByLFxuICAgICAgICAgIG9iamVjdEtleTogbFxuICAgICAgICB9LCByKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGYgaW4gbikge1xuICAgICAgICBpW2ZdIHx8IG5bZl0ucmVxdWlyZWQgJiYgdm9pZCAwID09PSBuW2ZdLmRlZmF1bHQgJiYgdm9pZCAwID09PSByW2ZdICYmIHMucHVzaChuZXcgUHQoZSwgciwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCInICsgZiArICdcIicpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3IodCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgICBuID0gdC5zdHlsZSxcbiAgICAgICAgICBpID0gdC5zdHlsZVNwZWMsXG4gICAgICAgICAgYSA9IHQua2V5LFxuICAgICAgICAgIG8gPSB0LmFycmF5RWxlbWVudFZhbGlkYXRvciB8fCBBbjtcbiAgICAgIGlmIChcImFycmF5XCIgIT09IERyKGUpKSByZXR1cm4gW25ldyBQdChhLCBlLCBcImFycmF5IGV4cGVjdGVkLCBcIiArIERyKGUpICsgXCIgZm91bmRcIildO1xuICAgICAgaWYgKHIubGVuZ3RoICYmIGUubGVuZ3RoICE9PSByLmxlbmd0aCkgcmV0dXJuIFtuZXcgUHQoYSwgZSwgXCJhcnJheSBsZW5ndGggXCIgKyByLmxlbmd0aCArIFwiIGV4cGVjdGVkLCBsZW5ndGggXCIgKyBlLmxlbmd0aCArIFwiIGZvdW5kXCIpXTtcbiAgICAgIGlmIChyW1wibWluLWxlbmd0aFwiXSAmJiBlLmxlbmd0aCA8IHJbXCJtaW4tbGVuZ3RoXCJdKSByZXR1cm4gW25ldyBQdChhLCBlLCBcImFycmF5IGxlbmd0aCBhdCBsZWFzdCBcIiArIHJbXCJtaW4tbGVuZ3RoXCJdICsgXCIgZXhwZWN0ZWQsIGxlbmd0aCBcIiArIGUubGVuZ3RoICsgXCIgZm91bmRcIildO1xuICAgICAgdmFyIHMgPSB7XG4gICAgICAgIHR5cGU6IHIudmFsdWUsXG4gICAgICAgIHZhbHVlczogci52YWx1ZXNcbiAgICAgIH07XG4gICAgICBpLiR2ZXJzaW9uIDwgNyAmJiAocy5mdW5jdGlvbiA9IHIuZnVuY3Rpb24pLCBcIm9iamVjdFwiID09PSBEcihyLnZhbHVlKSAmJiAocyA9IHIudmFsdWUpO1xuXG4gICAgICBmb3IgKHZhciB1ID0gW10sIGwgPSAwOyBsIDwgZS5sZW5ndGg7IGwrKykge1xuICAgICAgICB1ID0gdS5jb25jYXQobyh7XG4gICAgICAgICAgYXJyYXk6IGUsXG4gICAgICAgICAgYXJyYXlJbmRleDogbCxcbiAgICAgICAgICB2YWx1ZTogZVtsXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IHMsXG4gICAgICAgICAgc3R5bGU6IG4sXG4gICAgICAgICAgc3R5bGVTcGVjOiBpLFxuICAgICAgICAgIGtleTogYSArIFwiW1wiICsgbCArIFwiXVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUXIodCkge1xuICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICBuID0gdC52YWx1ZVNwZWMsXG4gICAgICAgICAgaSA9IERyKHIpO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT09IGkgJiYgciAhPSByICYmIChpID0gXCJOYU5cIiksIFwibnVtYmVyXCIgIT09IGkgPyBbbmV3IFB0KGUsIHIsIFwibnVtYmVyIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKV0gOiBcIm1pbmltdW1cIiBpbiBuICYmIHIgPCBuLm1pbmltdW0gPyBbbmV3IFB0KGUsIHIsIHIgKyBcIiBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgXCIgKyBuLm1pbmltdW0pXSA6IFwibWF4aW11bVwiIGluIG4gJiYgciA+IG4ubWF4aW11bSA/IFtuZXcgUHQoZSwgciwgciArIFwiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSBcIiArIG4ubWF4aW11bSldIDogW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG4odCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIGkgPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgICBhID0gVHQodC52YWx1ZS50eXBlKSxcbiAgICAgICAgICBvID0ge30sXG4gICAgICAgICAgcyA9IFwiY2F0ZWdvcmljYWxcIiAhPT0gYSAmJiB2b2lkIDAgPT09IHQudmFsdWUucHJvcGVydHksXG4gICAgICAgICAgdSA9ICFzLFxuICAgICAgICAgIGwgPSBcImFycmF5XCIgPT09IERyKHQudmFsdWUuc3RvcHMpICYmIFwiYXJyYXlcIiA9PT0gRHIodC52YWx1ZS5zdG9wc1swXSkgJiYgXCJvYmplY3RcIiA9PT0gRHIodC52YWx1ZS5zdG9wc1swXVswXSksXG4gICAgICAgICAgcCA9ICRyKHtcbiAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgdmFsdWU6IHQudmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogdC5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgIHN0b3BzOiBmdW5jdGlvbiBzdG9wcyh0KSB7XG4gICAgICAgICAgICBpZiAoXCJpZGVudGl0eVwiID09PSBhKSByZXR1cm4gW25ldyBQdCh0LmtleSwgdC52YWx1ZSwgJ2lkZW50aXR5IGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBhIFwic3RvcHNcIiBwcm9wZXJ0eScpXTtcbiAgICAgICAgICAgIHZhciBlID0gW10sXG4gICAgICAgICAgICAgICAgciA9IHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZSA9IGUuY29uY2F0KFdyKHtcbiAgICAgICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgICAgICAgIHZhbHVlU3BlYzogdC52YWx1ZVNwZWMsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBhcnJheUVsZW1lbnRWYWxpZGF0b3I6IGNcbiAgICAgICAgICAgIH0pKSwgXCJhcnJheVwiID09PSBEcihyKSAmJiAwID09PSByLmxlbmd0aCAmJiBlLnB1c2gobmV3IFB0KHQua2V5LCByLCBcImFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcFwiKSksIGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gQW4oe1xuICAgICAgICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdC52YWx1ZSxcbiAgICAgICAgICAgICAgdmFsdWVTcGVjOiBpLFxuICAgICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBcImlkZW50aXR5XCIgPT09IGEgJiYgcyAmJiBwLnB1c2gobmV3IFB0KHQua2V5LCB0LnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInByb3BlcnR5XCInKSksIFwiaWRlbnRpdHlcIiA9PT0gYSB8fCB0LnZhbHVlLnN0b3BzIHx8IHAucHVzaChuZXcgUHQodC5rZXksIHQudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic3RvcHNcIicpKSwgXCJleHBvbmVudGlhbFwiID09PSBhICYmIHQudmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgIUZyKHQudmFsdWVTcGVjKSAmJiBwLnB1c2gobmV3IFB0KHQua2V5LCB0LnZhbHVlLCBcImV4cG9uZW50aWFsIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkXCIpKSwgdC5zdHlsZVNwZWMuJHZlcnNpb24gPj0gOCAmJiAodSAmJiAhVHIodC52YWx1ZVNwZWMpID8gcC5wdXNoKG5ldyBQdCh0LmtleSwgdC52YWx1ZSwgXCJwcm9wZXJ0eSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSkgOiBzICYmICFWcih0LnZhbHVlU3BlYykgJiYgcC5wdXNoKG5ldyBQdCh0LmtleSwgdC52YWx1ZSwgXCJ6b29tIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkXCIpKSksIFwiY2F0ZWdvcmljYWxcIiAhPT0gYSAmJiAhbCB8fCB2b2lkIDAgIT09IHQudmFsdWUucHJvcGVydHkgfHwgcC5wdXNoKG5ldyBQdCh0LmtleSwgdC52YWx1ZSwgJ1wicHJvcGVydHlcIiBwcm9wZXJ0eSBpcyByZXF1aXJlZCcpKSwgcDtcblxuICAgICAgZnVuY3Rpb24gYyh0KSB7XG4gICAgICAgIHZhciBlID0gW10sXG4gICAgICAgICAgICBhID0gdC52YWx1ZSxcbiAgICAgICAgICAgIHMgPSB0LmtleTtcbiAgICAgICAgaWYgKFwiYXJyYXlcIiAhPT0gRHIoYSkpIHJldHVybiBbbmV3IFB0KHMsIGEsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiICsgRHIoYSkgKyBcIiBmb3VuZFwiKV07XG4gICAgICAgIGlmICgyICE9PSBhLmxlbmd0aCkgcmV0dXJuIFtuZXcgUHQocywgYSwgXCJhcnJheSBsZW5ndGggMiBleHBlY3RlZCwgbGVuZ3RoIFwiICsgYS5sZW5ndGggKyBcIiBmb3VuZFwiKV07XG5cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gRHIoYVswXSkpIHJldHVybiBbbmV3IFB0KHMsIGEsIFwib2JqZWN0IGV4cGVjdGVkLCBcIiArIERyKGFbMF0pICsgXCIgZm91bmRcIildO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGFbMF0uem9vbSkgcmV0dXJuIFtuZXcgUHQocywgYSwgXCJvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb21cIildO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGFbMF0udmFsdWUpIHJldHVybiBbbmV3IFB0KHMsIGEsIFwib2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZVwiKV07XG4gICAgICAgICAgaWYgKG4gJiYgbiA+IFR0KGFbMF0uem9vbSkpIHJldHVybiBbbmV3IFB0KHMsIGFbMF0uem9vbSwgXCJzdG9wIHpvb20gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlclwiKV07XG4gICAgICAgICAgVHQoYVswXS56b29tKSAhPT0gbiAmJiAobiA9IFR0KGFbMF0uem9vbSksIHIgPSB2b2lkIDAsIG8gPSB7fSksIGUgPSBlLmNvbmNhdCgkcih7XG4gICAgICAgICAgICBrZXk6IHMgKyBcIlswXVwiLFxuICAgICAgICAgICAgdmFsdWU6IGFbMF0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICAgICAgem9vbToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICB6b29tOiBRcixcbiAgICAgICAgICAgICAgdmFsdWU6IGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBlID0gZS5jb25jYXQoaCh7XG4gICAgICAgICAga2V5OiBzICsgXCJbMF1cIixcbiAgICAgICAgICB2YWx1ZTogYVswXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IHt9LFxuICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWNcbiAgICAgICAgfSwgYSkpO1xuXG4gICAgICAgIHJldHVybiBHcihWdChhWzFdKSkgPyBlLmNvbmNhdChbbmV3IFB0KHMgKyBcIlsxXVwiLCBhWzFdLCBcImV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiBzdG9wcy5cIildKSA6IGUuY29uY2F0KEFuKHtcbiAgICAgICAgICBrZXk6IHMgKyBcIlsxXVwiLFxuICAgICAgICAgIHZhbHVlOiBhWzFdLFxuICAgICAgICAgIHZhbHVlU3BlYzogaSxcbiAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaCh0LCBuKSB7XG4gICAgICAgIHZhciBzID0gRHIodC52YWx1ZSksXG4gICAgICAgICAgICB1ID0gVHQodC52YWx1ZSksXG4gICAgICAgICAgICBsID0gbnVsbCAhPT0gdC52YWx1ZSA/IHQudmFsdWUgOiBuO1xuXG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgaWYgKHMgIT09IGUpIHJldHVybiBbbmV3IFB0KHQua2V5LCBsLCBzICsgXCIgc3RvcCBkb21haW4gdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3AgZG9tYWluIHR5cGUgXCIgKyBlKV07XG4gICAgICAgIH0gZWxzZSBlID0gcztcblxuICAgICAgICBpZiAoXCJudW1iZXJcIiAhPT0gcyAmJiBcInN0cmluZ1wiICE9PSBzICYmIFwiYm9vbGVhblwiICE9PSBzKSByZXR1cm4gW25ldyBQdCh0LmtleSwgbCwgXCJzdG9wIGRvbWFpbiB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBzdHJpbmcsIG9yIGJvb2xlYW5cIildO1xuXG4gICAgICAgIGlmIChcIm51bWJlclwiICE9PSBzICYmIFwiY2F0ZWdvcmljYWxcIiAhPT0gYSkge1xuICAgICAgICAgIHZhciBwID0gXCJudW1iZXIgZXhwZWN0ZWQsIFwiICsgcyArIFwiIGZvdW5kXCI7XG4gICAgICAgICAgcmV0dXJuIFRyKGkpICYmIHZvaWQgMCA9PT0gYSAmJiAocCArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nKSwgW25ldyBQdCh0LmtleSwgbCwgcCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcmljYWxcIiAhPT0gYSB8fCBcIm51bWJlclwiICE9PSBzIHx8IGlzRmluaXRlKHUpICYmIE1hdGguZmxvb3IodSkgPT09IHUgPyBcImNhdGVnb3JpY2FsXCIgIT09IGEgJiYgXCJudW1iZXJcIiA9PT0gcyAmJiB2b2lkIDAgIT09IHIgJiYgdSA8IHIgPyBbbmV3IFB0KHQua2V5LCBsLCBcInN0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXJcIildIDogKHIgPSB1LCBcImNhdGVnb3JpY2FsXCIgPT09IGEgJiYgdSBpbiBvID8gW25ldyBQdCh0LmtleSwgbCwgXCJzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWVcIildIDogKG9bdV0gPSAhMCwgW10pKSA6IFtuZXcgUHQodC5rZXksIGwsIFwiaW50ZWdlciBleHBlY3RlZCwgZm91bmQgXCIgKyB1KV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW4odCkge1xuICAgICAgdmFyIGUgPSAoXCJwcm9wZXJ0eVwiID09PSB0LmV4cHJlc3Npb25Db250ZXh0ID8gSHIgOiBacikoVnQodC52YWx1ZSksIHQudmFsdWVTcGVjKTtcbiAgICAgIGlmIChcImVycm9yXCIgPT09IGUucmVzdWx0KSByZXR1cm4gZS52YWx1ZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdChcIlwiICsgdC5rZXkgKyBlLmtleSwgdC52YWx1ZSwgZS5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHIgPSBlLnZhbHVlLmV4cHJlc3Npb24gfHwgZS52YWx1ZS5fc3R5bGVFeHByZXNzaW9uLmV4cHJlc3Npb247XG4gICAgICBpZiAoXCJwcm9wZXJ0eVwiID09PSB0LmV4cHJlc3Npb25Db250ZXh0ICYmIFwidGV4dC1mb250XCIgPT09IHQucHJvcGVydHlLZXkgJiYgIXIub3V0cHV0RGVmaW5lZCgpKSByZXR1cm4gW25ldyBQdCh0LmtleSwgdC52YWx1ZSwgJ0ludmFsaWQgZGF0YSBleHByZXNzaW9uIGZvciBcIicgKyB0LnByb3BlcnR5S2V5ICsgJ1wiLiBPdXRwdXQgdmFsdWVzIG11c3QgYmUgY29udGFpbmVkIGFzIGxpdGVyYWxzIHdpdGhpbiB0aGUgZXhwcmVzc2lvbi4nKV07XG4gICAgICBpZiAoXCJwcm9wZXJ0eVwiID09PSB0LmV4cHJlc3Npb25Db250ZXh0ICYmIFwibGF5b3V0XCIgPT09IHQucHJvcGVydHlUeXBlICYmICFPZShyKSkgcmV0dXJuIFtuZXcgUHQodC5rZXksIHQudmFsdWUsICdcImZlYXR1cmUtc3RhdGVcIiBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbGF5b3V0IHByb3BlcnRpZXMuJyldO1xuICAgICAgaWYgKFwiZmlsdGVyXCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgIU9lKHIpKSByZXR1cm4gW25ldyBQdCh0LmtleSwgdC52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBmaWx0ZXJzLicpXTtcblxuICAgICAgaWYgKHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgMCA9PT0gdC5leHByZXNzaW9uQ29udGV4dC5pbmRleE9mKFwiY2x1c3RlclwiKSkge1xuICAgICAgICBpZiAoIVJlKHIsIFtcInpvb21cIiwgXCJmZWF0dXJlLXN0YXRlXCJdKSkgcmV0dXJuIFtuZXcgUHQodC5rZXksIHQudmFsdWUsICdcInpvb21cIiBhbmQgXCJmZWF0dXJlLXN0YXRlXCIgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgICAgICBpZiAoXCJjbHVzdGVyLWluaXRpYWxcIiA9PT0gdC5leHByZXNzaW9uQ29udGV4dCAmJiAhTGUocikpIHJldHVybiBbbmV3IFB0KHQua2V5LCB0LnZhbHVlLCBcIkZlYXR1cmUgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGluaXRpYWwgZXhwcmVzc2lvbiBwYXJ0IG9mIGNsdXN0ZXIgcHJvcGVydGllcy5cIildO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm4odCkge1xuICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICBuID0gdC52YWx1ZVNwZWMsXG4gICAgICAgICAgaSA9IFtdO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobi52YWx1ZXMpID8gLTEgPT09IG4udmFsdWVzLmluZGV4T2YoVHQocikpICYmIGkucHVzaChuZXcgUHQoZSwgciwgXCJleHBlY3RlZCBvbmUgb2YgW1wiICsgbi52YWx1ZXMuam9pbihcIiwgXCIpICsgXCJdLCBcIiArIEpTT04uc3RyaW5naWZ5KHIpICsgXCIgZm91bmRcIikpIDogLTEgPT09IE9iamVjdC5rZXlzKG4udmFsdWVzKS5pbmRleE9mKFR0KHIpKSAmJiBpLnB1c2gobmV3IFB0KGUsIHIsIFwiZXhwZWN0ZWQgb25lIG9mIFtcIiArIE9iamVjdC5rZXlzKG4udmFsdWVzKS5qb2luKFwiLCBcIikgKyBcIl0sIFwiICsgSlNPTi5zdHJpbmdpZnkocikgKyBcIiBmb3VuZFwiKSksIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm4odCkge1xuICAgICAgaWYgKCEwID09PSB0IHx8ICExID09PSB0KSByZXR1cm4gITA7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkgfHwgMCA9PT0gdC5sZW5ndGgpIHJldHVybiAhMTtcblxuICAgICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgXCJoYXNcIjpcbiAgICAgICAgICByZXR1cm4gdC5sZW5ndGggPj0gMiAmJiBcIiRpZFwiICE9PSB0WzFdICYmIFwiJHR5cGVcIiAhPT0gdFsxXTtcblxuICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICByZXR1cm4gdC5sZW5ndGggPj0gMyAmJiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgdFsxXSB8fCBBcnJheS5pc0FycmF5KHRbMl0pKTtcblxuICAgICAgICBjYXNlIFwiIWluXCI6XG4gICAgICAgIGNhc2UgXCIhaGFzXCI6XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgcmV0dXJuICExO1xuXG4gICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgIHJldHVybiAzICE9PSB0Lmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KHRbMV0pIHx8IEFycmF5LmlzQXJyYXkodFsyXSk7XG5cbiAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0LnNsaWNlKDEpOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICAgICAgaWYgKCFubihuKSAmJiBcImJvb2xlYW5cIiAhPSB0eXBlb2YgbikgcmV0dXJuICExO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBZci5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IFlyKHQuX3BhcmFtZXRlcnMsIHQuX3NwZWNpZmljYXRpb24pO1xuICAgIH0sIFlyLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcGFyYW1ldGVyczogdC5fcGFyYW1ldGVycyxcbiAgICAgICAgX3NwZWNpZmljYXRpb246IHQuX3NwZWNpZmljYXRpb25cbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYW4gPSB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbih0KSB7XG4gICAgICBpZiAobnVsbCA9PSB0KSByZXR1cm4ge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0sXG4gICAgICAgIG5lZWRHZW9tZXRyeTogITFcbiAgICAgIH07XG4gICAgICBubih0KSB8fCAodCA9IHVuKHQpKTtcbiAgICAgIHZhciBlID0gWnIodCwgYW4pO1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gZS5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihlLnZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5rZXkgKyBcIjogXCIgKyB0Lm1lc3NhZ2U7XG4gICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIodCwgciwgbikge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlLmV2YWx1YXRlKHQsIHIsIHt9LCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmVlZEdlb21ldHJ5OiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpIHJldHVybiAhMTtcbiAgICAgICAgICBpZiAoXCJ3aXRoaW5cIiA9PT0gZVswXSkgcmV0dXJuICEwO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBpZiAodChlW3JdKSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSh0KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbih0LCBlKSB7XG4gICAgICByZXR1cm4gdCA8IGUgPyAtMSA6IHQgPiBlID8gMSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW4odCkge1xuICAgICAgaWYgKCF0KSByZXR1cm4gITA7XG4gICAgICB2YXIgZSxcbiAgICAgICAgICByID0gdFswXTtcbiAgICAgIHJldHVybiB0Lmxlbmd0aCA8PSAxID8gXCJhbnlcIiAhPT0gciA6IFwiPT1cIiA9PT0gciA/IGxuKHRbMV0sIHRbMl0sIFwiPT1cIikgOiBcIiE9XCIgPT09IHIgPyBobihsbih0WzFdLCB0WzJdLCBcIj09XCIpKSA6IFwiPFwiID09PSByIHx8IFwiPlwiID09PSByIHx8IFwiPD1cIiA9PT0gciB8fCBcIj49XCIgPT09IHIgPyBsbih0WzFdLCB0WzJdLCByKSA6IFwiYW55XCIgPT09IHIgPyAoZSA9IHQuc2xpY2UoMSksIFtcImFueVwiXS5jb25jYXQoZS5tYXAodW4pKSkgOiBcImFsbFwiID09PSByID8gW1wiYWxsXCJdLmNvbmNhdCh0LnNsaWNlKDEpLm1hcCh1bikpIDogXCJub25lXCIgPT09IHIgPyBbXCJhbGxcIl0uY29uY2F0KHQuc2xpY2UoMSkubWFwKHVuKS5tYXAoaG4pKSA6IFwiaW5cIiA9PT0gciA/IHBuKHRbMV0sIHQuc2xpY2UoMikpIDogXCIhaW5cIiA9PT0gciA/IGhuKHBuKHRbMV0sIHQuc2xpY2UoMikpKSA6IFwiaGFzXCIgPT09IHIgPyBjbih0WzFdKSA6IFwiIWhhc1wiID09PSByID8gaG4oY24odFsxXSkpIDogXCJ3aXRoaW5cIiAhPT0gciB8fCB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxuKHQsIGUsIHIpIHtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwiJHR5cGVcIjpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLXR5cGUtXCIgKyByLCBlXTtcblxuICAgICAgICBjYXNlIFwiJGlkXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1pZC1cIiArIHIsIGVdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1cIiArIHIsIHQsIGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBuKHQsIGUpIHtcbiAgICAgIGlmICgwID09PSBlLmxlbmd0aCkgcmV0dXJuICExO1xuXG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcIiR0eXBlXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci10eXBlLWluXCIsIFtcImxpdGVyYWxcIiwgZV1dO1xuXG4gICAgICAgIGNhc2UgXCIkaWRcIjpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLWlkLWluXCIsIFtcImxpdGVyYWxcIiwgZV1dO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID4gMjAwICYmICFlLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdCAhPSB0eXBlb2YgZVswXTtcbiAgICAgICAgICB9KSA/IFtcImZpbHRlci1pbi1sYXJnZVwiLCB0LCBbXCJsaXRlcmFsXCIsIGUuc29ydChzbildXSA6IFtcImZpbHRlci1pbi1zbWFsbFwiLCB0LCBbXCJsaXRlcmFsXCIsIGVdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbih0KSB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcIiR0eXBlXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuXG4gICAgICAgIGNhc2UgXCIkaWRcIjpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLWhhcy1pZFwiXTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItaGFzXCIsIHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhuKHQpIHtcbiAgICAgIHJldHVybiBbXCIhXCIsIHRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuKHQpIHtcbiAgICAgIHJldHVybiBubihWdCh0LnZhbHVlKSkgPyBlbihCdCh7fSwgdCwge1xuICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJmaWx0ZXJcIixcbiAgICAgICAgdmFsdWVTcGVjOiB7XG4gICAgICAgICAgdmFsdWU6IFwiYm9vbGVhblwiXG4gICAgICAgIH1cbiAgICAgIH0pKSA6IGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICB2YXIgciA9IGUudmFsdWUsXG4gICAgICAgICAgICBuID0gZS5rZXk7XG4gICAgICAgIGlmIChcImFycmF5XCIgIT09IERyKHIpKSByZXR1cm4gW25ldyBQdChuLCByLCBcImFycmF5IGV4cGVjdGVkLCBcIiArIERyKHIpICsgXCIgZm91bmRcIildO1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGEgPSBlLnN0eWxlU3BlYyxcbiAgICAgICAgICAgIG8gPSBbXTtcbiAgICAgICAgaWYgKHIubGVuZ3RoIDwgMSkgcmV0dXJuIFtuZXcgUHQobiwgciwgXCJmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudFwiKV07XG5cbiAgICAgICAgc3dpdGNoIChvID0gby5jb25jYXQocm4oe1xuICAgICAgICAgIGtleTogbiArIFwiWzBdXCIsXG4gICAgICAgICAgdmFsdWU6IHJbMF0sXG4gICAgICAgICAgdmFsdWVTcGVjOiBhLmZpbHRlcl9vcGVyYXRvcixcbiAgICAgICAgICBzdHlsZTogZS5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IGUuc3R5bGVTcGVjXG4gICAgICAgIH0pKSwgVHQoclswXSkpIHtcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgICByLmxlbmd0aCA+PSAyICYmIFwiJHR5cGVcIiA9PT0gVHQoclsxXSkgJiYgby5wdXNoKG5ldyBQdChuLCByLCAnXCIkdHlwZVwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcIicgKyByWzBdICsgJ1wiJykpO1xuXG4gICAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgICAzICE9PSByLmxlbmd0aCAmJiBvLnB1c2gobmV3IFB0KG4sIHIsICdmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJyArIHJbMF0gKyAnXCIgbXVzdCBoYXZlIDMgZWxlbWVudHMnKSk7XG5cbiAgICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICBjYXNlIFwiIWluXCI6XG4gICAgICAgICAgICByLmxlbmd0aCA+PSAyICYmIFwic3RyaW5nXCIgIT09IChpID0gRHIoclsxXSkpICYmIG8ucHVzaChuZXcgUHQobiArIFwiWzFdXCIsIHJbMV0sIFwic3RyaW5nIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAyOyBzIDwgci5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICBpID0gRHIocltzXSksIFwiJHR5cGVcIiA9PT0gVHQoclsxXSkgPyBvID0gby5jb25jYXQocm4oe1xuICAgICAgICAgICAgICAgIGtleTogbiArIFwiW1wiICsgcyArIFwiXVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByW3NdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogYS5nZW9tZXRyeV90eXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBlLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogZS5zdHlsZVNwZWNcbiAgICAgICAgICAgICAgfSkpIDogXCJzdHJpbmdcIiAhPT0gaSAmJiBcIm51bWJlclwiICE9PSBpICYmIFwiYm9vbGVhblwiICE9PSBpICYmIG8ucHVzaChuZXcgUHQobiArIFwiW1wiICsgcyArIFwiXVwiLCByW3NdLCBcInN0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgZm9yICh2YXIgdSA9IDE7IHUgPCByLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgIG8gPSBvLmNvbmNhdCh0KHtcbiAgICAgICAgICAgICAgICBrZXk6IG4gKyBcIltcIiArIHUgKyBcIl1cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogclt1XSxcbiAgICAgICAgICAgICAgICBzdHlsZTogZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IGUuc3R5bGVTcGVjXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaGFzXCI6XG4gICAgICAgICAgY2FzZSBcIiFoYXNcIjpcbiAgICAgICAgICAgIGkgPSBEcihyWzFdKSwgMiAhPT0gci5sZW5ndGggPyBvLnB1c2gobmV3IFB0KG4sIHIsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJyArIHJbMF0gKyAnXCIgb3BlcmF0b3IgbXVzdCBoYXZlIDIgZWxlbWVudHMnKSkgOiBcInN0cmluZ1wiICE9PSBpICYmIG8ucHVzaChuZXcgUHQobiArIFwiWzFdXCIsIHJbMV0sIFwic3RyaW5nIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ3aXRoaW5cIjpcbiAgICAgICAgICAgIGkgPSBEcihyWzFdKSwgMiAhPT0gci5sZW5ndGggPyBvLnB1c2gobmV3IFB0KG4sIHIsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJyArIHJbMF0gKyAnXCIgb3BlcmF0b3IgbXVzdCBoYXZlIDIgZWxlbWVudHMnKSkgOiBcIm9iamVjdFwiICE9PSBpICYmIG8ucHVzaChuZXcgUHQobiArIFwiWzFdXCIsIHJbMV0sIFwib2JqZWN0IGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0odCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geW4odCwgZSkge1xuICAgICAgdmFyIHIgPSB0LmtleSxcbiAgICAgICAgICBuID0gdC5zdHlsZSxcbiAgICAgICAgICBpID0gdC5zdHlsZVNwZWMsXG4gICAgICAgICAgYSA9IHQudmFsdWUsXG4gICAgICAgICAgbyA9IHQub2JqZWN0S2V5LFxuICAgICAgICAgIHMgPSBpW2UgKyBcIl9cIiArIHQubGF5ZXJUeXBlXTtcbiAgICAgIGlmICghcykgcmV0dXJuIFtdO1xuICAgICAgdmFyIHUgPSBvLm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgICAgaWYgKFwicGFpbnRcIiA9PT0gZSAmJiB1ICYmIHNbdVsxXV0gJiYgc1t1WzFdXS50cmFuc2l0aW9uKSByZXR1cm4gQW4oe1xuICAgICAgICBrZXk6IHIsXG4gICAgICAgIHZhbHVlOiBhLFxuICAgICAgICB2YWx1ZVNwZWM6IGkudHJhbnNpdGlvbixcbiAgICAgICAgc3R5bGU6IG4sXG4gICAgICAgIHN0eWxlU3BlYzogaVxuICAgICAgfSk7XG4gICAgICB2YXIgbCxcbiAgICAgICAgICBwID0gdC52YWx1ZVNwZWMgfHwgc1tvXTtcbiAgICAgIGlmICghcCkgcmV0dXJuIFtuZXcgUHQociwgYSwgJ3Vua25vd24gcHJvcGVydHkgXCInICsgbyArICdcIicpXTtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSBEcihhKSAmJiBUcihwKSAmJiAhcC50b2tlbnMgJiYgKGwgPSAvXnsoW159XSspfSQvLmV4ZWMoYSkpKSByZXR1cm4gW25ldyBQdChyLCBhLCAnXCInICsgbyArICdcIiBkb2VzIG5vdCBzdXBwb3J0IGludGVycG9sYXRpb24gc3ludGF4XFxuVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IGB7IFwidHlwZVwiOiBcImlkZW50aXR5XCIsIFwicHJvcGVydHlcIjogJyArIEpTT04uc3RyaW5naWZ5KGxbMV0pICsgXCIgfWAuXCIpXTtcbiAgICAgIHZhciBjID0gW107XG4gICAgICByZXR1cm4gXCJzeW1ib2xcIiA9PT0gdC5sYXllclR5cGUgJiYgKFwidGV4dC1maWVsZFwiID09PSBvICYmIG4gJiYgIW4uZ2x5cGhzICYmIGMucHVzaChuZXcgUHQociwgYSwgJ3VzZSBvZiBcInRleHQtZmllbGRcIiByZXF1aXJlcyBhIHN0eWxlIFwiZ2x5cGhzXCIgcHJvcGVydHknKSksIFwidGV4dC1mb250XCIgPT09IG8gJiYgTHIoVnQoYSkpICYmIFwiaWRlbnRpdHlcIiA9PT0gVHQoYS50eXBlKSAmJiBjLnB1c2gobmV3IFB0KHIsIGEsICdcInRleHQtZm9udFwiIGRvZXMgbm90IHN1cHBvcnQgaWRlbnRpdHkgZnVuY3Rpb25zJykpKSwgYy5jb25jYXQoQW4oe1xuICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgdmFsdWVTcGVjOiBwLFxuICAgICAgICBzdHlsZTogbixcbiAgICAgICAgc3R5bGVTcGVjOiBpLFxuICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJwcm9wZXJ0eVwiLFxuICAgICAgICBwcm9wZXJ0eVR5cGU6IGUsXG4gICAgICAgIHByb3BlcnR5S2V5OiBvXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG4odCkge1xuICAgICAgcmV0dXJuIHluKHQsIFwicGFpbnRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW4odCkge1xuICAgICAgcmV0dXJuIHluKHQsIFwibGF5b3V0XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZuKHQpIHtcbiAgICAgIHZhciBlID0gW10sXG4gICAgICAgICAgciA9IHQudmFsdWUsXG4gICAgICAgICAgbiA9IHQua2V5LFxuICAgICAgICAgIGkgPSB0LnN0eWxlLFxuICAgICAgICAgIGEgPSB0LnN0eWxlU3BlYztcbiAgICAgIHIudHlwZSB8fCByLnJlZiB8fCBlLnB1c2gobmV3IFB0KG4sIHIsICdlaXRoZXIgXCJ0eXBlXCIgb3IgXCJyZWZcIiBpcyByZXF1aXJlZCcpKTtcbiAgICAgIHZhciBvLFxuICAgICAgICAgIHMgPSBUdChyLnR5cGUpLFxuICAgICAgICAgIHUgPSBUdChyLnJlZik7XG4gICAgICBpZiAoci5pZCkgZm9yICh2YXIgbCA9IFR0KHIuaWQpLCBwID0gMDsgcCA8IHQuYXJyYXlJbmRleDsgcCsrKSB7XG4gICAgICAgIHZhciBjID0gaS5sYXllcnNbcF07XG4gICAgICAgIFR0KGMuaWQpID09PSBsICYmIGUucHVzaChuZXcgUHQobiwgci5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIicgKyByLmlkICsgJ1wiLCBwcmV2aW91c2x5IHVzZWQgYXQgbGluZSAnICsgYy5pZC5fX2xpbmVfXykpO1xuICAgICAgfVxuICAgICAgaWYgKFwicmVmXCIgaW4gcikgW1widHlwZVwiLCBcInNvdXJjZVwiLCBcInNvdXJjZS1sYXllclwiLCBcImZpbHRlclwiLCBcImxheW91dFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQgaW4gciAmJiBlLnB1c2gobmV3IFB0KG4sIHJbdF0sICdcIicgKyB0ICsgJ1wiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnMnKSk7XG4gICAgICB9KSwgaS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBUdCh0LmlkKSA9PT0gdSAmJiAobyA9IHQpO1xuICAgICAgfSksIG8gPyBvLnJlZiA/IGUucHVzaChuZXcgUHQobiwgci5yZWYsIFwicmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXJcIikpIDogcyA9IFR0KG8udHlwZSkgOiBlLnB1c2gobmV3IFB0KG4sIHIucmVmLCAncmVmIGxheWVyIFwiJyArIHUgKyAnXCIgbm90IGZvdW5kJykpO2Vsc2UgaWYgKFwiYmFja2dyb3VuZFwiICE9PSBzKSBpZiAoci5zb3VyY2UpIHtcbiAgICAgICAgdmFyIGggPSBpLnNvdXJjZXMgJiYgaS5zb3VyY2VzW3Iuc291cmNlXSxcbiAgICAgICAgICAgIGYgPSBoICYmIFR0KGgudHlwZSk7XG4gICAgICAgIGggPyBcInZlY3RvclwiID09PSBmICYmIFwicmFzdGVyXCIgPT09IHMgPyBlLnB1c2gobmV3IFB0KG4sIHIuc291cmNlLCAnbGF5ZXIgXCInICsgci5pZCArICdcIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2UnKSkgOiBcInJhc3RlclwiID09PSBmICYmIFwicmFzdGVyXCIgIT09IHMgPyBlLnB1c2gobmV3IFB0KG4sIHIuc291cmNlLCAnbGF5ZXIgXCInICsgci5pZCArICdcIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnKSkgOiBcInZlY3RvclwiICE9PSBmIHx8IHJbXCJzb3VyY2UtbGF5ZXJcIl0gPyBcInJhc3Rlci1kZW1cIiA9PT0gZiAmJiBcImhpbGxzaGFkZVwiICE9PSBzID8gZS5wdXNoKG5ldyBQdChuLCByLnNvdXJjZSwgXCJyYXN0ZXItZGVtIHNvdXJjZSBjYW4gb25seSBiZSB1c2VkIHdpdGggbGF5ZXIgdHlwZSAnaGlsbHNoYWRlJy5cIikpIDogXCJsaW5lXCIgIT09IHMgfHwgIXIucGFpbnQgfHwgIXIucGFpbnRbXCJsaW5lLWdyYWRpZW50XCJdIHx8IFwiZ2VvanNvblwiID09PSBmICYmIGgubGluZU1ldHJpY3MgfHwgZS5wdXNoKG5ldyBQdChuLCByLCAnbGF5ZXIgXCInICsgci5pZCArICdcIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggYGxpbmVNZXRyaWNzYCBlbmFibGVkLicpKSA6IGUucHVzaChuZXcgUHQobiwgciwgJ2xheWVyIFwiJyArIHIuaWQgKyAnXCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcIicpKSA6IGUucHVzaChuZXcgUHQobiwgci5zb3VyY2UsICdzb3VyY2UgXCInICsgci5zb3VyY2UgKyAnXCIgbm90IGZvdW5kJykpO1xuICAgICAgfSBlbHNlIGUucHVzaChuZXcgUHQobiwgciwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzb3VyY2VcIicpKTtcbiAgICAgIHJldHVybiBlID0gZS5jb25jYXQoJHIoe1xuICAgICAgICBrZXk6IG4sXG4gICAgICAgIHZhbHVlOiByLFxuICAgICAgICB2YWx1ZVNwZWM6IGEubGF5ZXIsXG4gICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogZnVuY3Rpb24gdHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBBbih7XG4gICAgICAgICAgICAgIGtleTogbiArIFwiLnR5cGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHIudHlwZSxcbiAgICAgICAgICAgICAgdmFsdWVTcGVjOiBhLmxheWVyLnR5cGUsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBvYmplY3Q6IHIsXG4gICAgICAgICAgICAgIG9iamVjdEtleTogXCJ0eXBlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsdGVyOiBmbixcbiAgICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gJHIoe1xuICAgICAgICAgICAgICBsYXllcjogcixcbiAgICAgICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHQudmFsdWUsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiBfKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtbihCdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyVHlwZTogc1xuICAgICAgICAgICAgICAgICAgfSwgdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWludDogZnVuY3Rpb24gcGFpbnQodCkge1xuICAgICAgICAgICAgcmV0dXJuICRyKHtcbiAgICAgICAgICAgICAgbGF5ZXI6IHIsXG4gICAgICAgICAgICAgIGtleTogdC5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB0LnZhbHVlLFxuICAgICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICBcIipcIjogZnVuY3Rpb24gXyh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZG4oQnQoe1xuICAgICAgICAgICAgICAgICAgICBsYXllclR5cGU6IHNcbiAgICAgICAgICAgICAgICAgIH0sIHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGduKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgICByID0gdC5rZXksXG4gICAgICAgICAgbiA9IERyKGUpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IG4gPyBbbmV3IFB0KHIsIGUsIFwic3RyaW5nIGV4cGVjdGVkLCBcIiArIG4gKyBcIiBmb3VuZFwiKV0gOiBbXTtcbiAgICB9XG5cbiAgICB2YXIgeG4gPSB7XG4gICAgICBwcm9tb3RlSWQ6IGZ1bmN0aW9uIHByb21vdGVJZCh0KSB7XG4gICAgICAgIHZhciBlID0gdC5rZXksXG4gICAgICAgICAgICByID0gdC52YWx1ZTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IERyKHIpKSByZXR1cm4gZ24oe1xuICAgICAgICAgIGtleTogZSxcbiAgICAgICAgICB2YWx1ZTogclxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG4gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHIpIHtcbiAgICAgICAgICBuLnB1c2guYXBwbHkobiwgZ24oe1xuICAgICAgICAgICAga2V5OiBlICsgXCIuXCIgKyBpLFxuICAgICAgICAgICAgdmFsdWU6IHJbaV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYm4odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LmtleSxcbiAgICAgICAgICBuID0gdC5zdHlsZVNwZWMsXG4gICAgICAgICAgaSA9IHQuc3R5bGU7XG4gICAgICBpZiAoIWUudHlwZSkgcmV0dXJuIFtuZXcgUHQociwgZSwgJ1widHlwZVwiIGlzIHJlcXVpcmVkJyldO1xuICAgICAgdmFyIGEsXG4gICAgICAgICAgbyA9IFR0KGUudHlwZSk7XG5cbiAgICAgIHN3aXRjaCAobykge1xuICAgICAgICBjYXNlIFwidmVjdG9yXCI6XG4gICAgICAgIGNhc2UgXCJyYXN0ZXJcIjpcbiAgICAgICAgY2FzZSBcInJhc3Rlci1kZW1cIjpcbiAgICAgICAgICByZXR1cm4gJHIoe1xuICAgICAgICAgICAga2V5OiByLFxuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG5bXCJzb3VyY2VfXCIgKyBvLnJlcGxhY2UoXCItXCIsIFwiX1wiKV0sXG4gICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB4blxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgXCJnZW9qc29uXCI6XG4gICAgICAgICAgaWYgKGEgPSAkcih7XG4gICAgICAgICAgICBrZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfZ2VvanNvbixcbiAgICAgICAgICAgIHN0eWxlOiBpLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBuLFxuICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHhuXG4gICAgICAgICAgfSksIGUuY2x1c3RlcikgZm9yICh2YXIgcyBpbiBlLmNsdXN0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGUuY2x1c3RlclByb3BlcnRpZXNbc10sXG4gICAgICAgICAgICAgICAgbCA9IHVbMF0sXG4gICAgICAgICAgICAgICAgcCA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGwgPyBbbCwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBzXV0gOiBsO1xuICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGVuKHtcbiAgICAgICAgICAgICAga2V5OiByICsgXCIuXCIgKyBzICsgXCIubWFwXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiB1WzFdLFxuICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJjbHVzdGVyLW1hcFwiXG4gICAgICAgICAgICB9KSksIGEucHVzaC5hcHBseShhLCBlbih7XG4gICAgICAgICAgICAgIGtleTogciArIFwiLlwiICsgcyArIFwiLnJlZHVjZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogcCxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiY2x1c3Rlci1yZWR1Y2VcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcblxuICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICByZXR1cm4gJHIoe1xuICAgICAgICAgICAga2V5OiByLFxuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX3ZpZGVvLFxuICAgICAgICAgICAgc3R5bGU6IGksXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG5cbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICByZXR1cm4gJHIoe1xuICAgICAgICAgICAga2V5OiByLFxuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX2ltYWdlLFxuICAgICAgICAgICAgc3R5bGU6IGksXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG5cbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwiY2FudmFzXCI6XG4gICAgICAgICAgcmV0dXJuIFtuZXcgUHQociwgbnVsbCwgXCJQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLlwiLCBcInNvdXJjZS5jYW52YXNcIildO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHJuKHtcbiAgICAgICAgICAgIGtleTogciArIFwiLnR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBlLnR5cGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBbXCJ2ZWN0b3JcIiwgXCJyYXN0ZXJcIiwgXCJyYXN0ZXItZGVtXCIsIFwiZ2VvanNvblwiLCBcInZpZGVvXCIsIFwiaW1hZ2VcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogblxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHduKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgICByID0gdC5zdHlsZVNwZWMsXG4gICAgICAgICAgbiA9IHIubGlnaHQsXG4gICAgICAgICAgaSA9IHQuc3R5bGUsXG4gICAgICAgICAgYSA9IFtdLFxuICAgICAgICAgIG8gPSBEcihlKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiBhO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IG8pIHJldHVybiBhLmNvbmNhdChbbmV3IFB0KFwibGlnaHRcIiwgZSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgbyArIFwiIGZvdW5kXCIpXSk7XG5cbiAgICAgIGZvciAodmFyIHMgaW4gZSkge1xuICAgICAgICB2YXIgdSA9IHMubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgICAgIGEgPSBhLmNvbmNhdCh1ICYmIG5bdVsxXV0gJiYgblt1WzFdXS50cmFuc2l0aW9uID8gQW4oe1xuICAgICAgICAgIGtleTogcyxcbiAgICAgICAgICB2YWx1ZTogZVtzXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IHIudHJhbnNpdGlvbixcbiAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHJcbiAgICAgICAgfSkgOiBuW3NdID8gQW4oe1xuICAgICAgICAgIGtleTogcyxcbiAgICAgICAgICB2YWx1ZTogZVtzXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IG5bc10sXG4gICAgICAgICAgc3R5bGU6IGksXG4gICAgICAgICAgc3R5bGVTcGVjOiByXG4gICAgICAgIH0pIDogW25ldyBQdChzLCBlW3NdLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBzICsgJ1wiJyldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIF9uID0ge1xuICAgICAgXCIqXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICBhcnJheTogV3IsXG4gICAgICBib29sZWFuOiBmdW5jdGlvbiBib29sZWFuKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgICAgciA9IHQua2V5LFxuICAgICAgICAgICAgbiA9IERyKGUpO1xuICAgICAgICByZXR1cm4gXCJib29sZWFuXCIgIT09IG4gPyBbbmV3IFB0KHIsIGUsIFwiYm9vbGVhbiBleHBlY3RlZCwgXCIgKyBuICsgXCIgZm91bmRcIildIDogW107XG4gICAgICB9LFxuICAgICAgbnVtYmVyOiBRcixcbiAgICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcih0KSB7XG4gICAgICAgIHZhciBlID0gdC5rZXksXG4gICAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICAgIG4gPSBEcihyKTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IG4gPyBbbmV3IFB0KGUsIHIsIFwiY29sb3IgZXhwZWN0ZWQsIFwiICsgbiArIFwiIGZvdW5kXCIpXSA6IG51bGwgPT09IFF0KHIpID8gW25ldyBQdChlLCByLCAnY29sb3IgZXhwZWN0ZWQsIFwiJyArIHIgKyAnXCIgZm91bmQnKV0gOiBbXTtcbiAgICAgIH0sXG4gICAgICBjb25zdGFudHM6IE10LFxuICAgICAgZW51bTogcm4sXG4gICAgICBmaWx0ZXI6IGZuLFxuICAgICAgZnVuY3Rpb246IHRuLFxuICAgICAgbGF5ZXI6IHZuLFxuICAgICAgb2JqZWN0OiAkcixcbiAgICAgIHNvdXJjZTogYm4sXG4gICAgICBsaWdodDogd24sXG4gICAgICBzdHJpbmc6IGduLFxuICAgICAgZm9ybWF0dGVkOiBmdW5jdGlvbiBmb3JtYXR0ZWQodCkge1xuICAgICAgICByZXR1cm4gMCA9PT0gZ24odCkubGVuZ3RoID8gW10gOiBlbih0KTtcbiAgICAgIH0sXG4gICAgICByZXNvbHZlZEltYWdlOiBmdW5jdGlvbiByZXNvbHZlZEltYWdlKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IGduKHQpLmxlbmd0aCA/IFtdIDogZW4odCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEFuKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgICByID0gdC52YWx1ZVNwZWMsXG4gICAgICAgICAgbiA9IHQuc3R5bGVTcGVjO1xuICAgICAgcmV0dXJuIHIuZXhwcmVzc2lvbiAmJiBMcihUdChlKSkgPyB0bih0KSA6IHIuZXhwcmVzc2lvbiAmJiBHcihWdChlKSkgPyBlbih0KSA6IHIudHlwZSAmJiBfbltyLnR5cGVdID8gX25bci50eXBlXSh0KSA6ICRyKEJ0KHt9LCB0LCB7XG4gICAgICAgIHZhbHVlU3BlYzogci50eXBlID8gbltyLnR5cGVdIDogclxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNuKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgICByID0gdC5rZXksXG4gICAgICAgICAgbiA9IGduKHQpO1xuICAgICAgcmV0dXJuIG4ubGVuZ3RoIHx8ICgtMSA9PT0gZS5pbmRleE9mKFwie2ZvbnRzdGFja31cIikgJiYgbi5wdXNoKG5ldyBQdChyLCBlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpLCAtMSA9PT0gZS5pbmRleE9mKFwie3JhbmdlfVwiKSAmJiBuLnB1c2gobmV3IFB0KHIsIGUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntyYW5nZX1cIiB0b2tlbicpKSksIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga24odCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gRXQpO1xuICAgICAgdmFyIHIgPSBbXTtcbiAgICAgIHJldHVybiByID0gci5jb25jYXQoQW4oe1xuICAgICAgICBrZXk6IFwiXCIsXG4gICAgICAgIHZhbHVlOiB0LFxuICAgICAgICB2YWx1ZVNwZWM6IGUuJHJvb3QsXG4gICAgICAgIHN0eWxlU3BlYzogZSxcbiAgICAgICAgc3R5bGU6IHQsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgZ2x5cGhzOiBTbixcbiAgICAgICAgICBcIipcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKSwgdC5jb25zdGFudHMgJiYgKHIgPSByLmNvbmNhdChNdCh7XG4gICAgICAgIGtleTogXCJjb25zdGFudHNcIixcbiAgICAgICAgdmFsdWU6IHQuY29uc3RhbnRzLFxuICAgICAgICBzdHlsZTogdCxcbiAgICAgICAgc3R5bGVTcGVjOiBlXG4gICAgICB9KSkpLCBJbihyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbih0KSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KHQpLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQubGluZSAtIGUubGluZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHpuKHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBbXSwgciA9IGFyZ3VtZW50cy5sZW5ndGg7IHItLTspIHtcbiAgICAgICAgICBlW3JdID0gYXJndW1lbnRzW3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEluKHQuYXBwbHkodGhpcywgZSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBrbi5zb3VyY2UgPSB6bihibiksIGtuLmxpZ2h0ID0gem4od24pLCBrbi5sYXllciA9IHpuKHZuKSwga24uZmlsdGVyID0gem4oZm4pLCBrbi5wYWludFByb3BlcnR5ID0gem4oZG4pLCBrbi5sYXlvdXRQcm9wZXJ0eSA9IHpuKG1uKTtcbiAgICB2YXIgQ24gPSBrbixcbiAgICAgICAgRW4gPSBDbi5saWdodCxcbiAgICAgICAgUG4gPSBDbi5wYWludFByb3BlcnR5LFxuICAgICAgICBNbiA9IENuLmxheW91dFByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gQm4odCwgZSkge1xuICAgICAgdmFyIHIgPSAhMTtcbiAgICAgIGlmIChlICYmIGUubGVuZ3RoKSBmb3IgKHZhciBuID0gMCwgaSA9IGU7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHQuZmlyZShuZXcgenQobmV3IEVycm9yKGlbbl0ubWVzc2FnZSkpKSwgciA9ICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgdmFyIFRuID0gVm47XG5cbiAgICBmdW5jdGlvbiBWbih0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuY2VsbHMgPSBbXTtcblxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gdDtcbiAgICAgICAgdmFyIGkgPSBuZXcgSW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgICAgdCA9IGlbMF0sIHRoaXMuZCA9IChlID0gaVsxXSkgKyAyICogKHIgPSBpWzJdKTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMuZCAqIHRoaXMuZDsgYSsrKSB7XG4gICAgICAgICAgdmFyIG8gPSBpWzMgKyBhXSxcbiAgICAgICAgICAgICAgcyA9IGlbMyArIGEgKyAxXTtcbiAgICAgICAgICBuLnB1c2gobyA9PT0gcyA/IG51bGwgOiBpLnN1YmFycmF5KG8sIHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1ID0gaVszICsgbi5sZW5ndGggKyAxXTtcbiAgICAgICAgdGhpcy5rZXlzID0gaS5zdWJhcnJheShpWzMgKyBuLmxlbmd0aF0sIHUpLCB0aGlzLmJib3hlcyA9IGkuc3ViYXJyYXkodSksIHRoaXMuaW5zZXJ0ID0gdGhpcy5faW5zZXJ0UmVhZG9ubHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmQgPSBlICsgMiAqIHI7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmQgKiB0aGlzLmQ7IGwrKykge1xuICAgICAgICAgIG4ucHVzaChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleXMgPSBbXSwgdGhpcy5iYm94ZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uID0gZSwgdGhpcy5leHRlbnQgPSB0LCB0aGlzLnBhZGRpbmcgPSByLCB0aGlzLnNjYWxlID0gZSAvIHQsIHRoaXMudWlkID0gMDtcbiAgICAgIHZhciBwID0gciAvIGUgKiB0O1xuICAgICAgdGhpcy5taW4gPSAtcCwgdGhpcy5tYXggPSB0ICsgcDtcbiAgICB9XG5cbiAgICBWbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMuX2ZvckVhY2hDZWxsKGUsIHIsIG4sIGksIHRoaXMuX2luc2VydENlbGwsIHRoaXMudWlkKyspLCB0aGlzLmtleXMucHVzaCh0KSwgdGhpcy5iYm94ZXMucHVzaChlKSwgdGhpcy5iYm94ZXMucHVzaChyKSwgdGhpcy5iYm94ZXMucHVzaChuKSwgdGhpcy5iYm94ZXMucHVzaChpKTtcbiAgICB9LCBWbi5wcm90b3R5cGUuX2luc2VydFJlYWRvbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgaW5zZXJ0IGludG8gYSBHcmlkSW5kZXggY3JlYXRlZCBmcm9tIGFuIEFycmF5QnVmZmVyLlwiO1xuICAgIH0sIFZuLnByb3RvdHlwZS5faW5zZXJ0Q2VsbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLmNlbGxzW2ldLnB1c2goYSk7XG4gICAgfSwgVm4ucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5taW4sXG4gICAgICAgICAgbyA9IHRoaXMubWF4O1xuICAgICAgaWYgKHQgPD0gYSAmJiBlIDw9IGEgJiYgbyA8PSByICYmIG8gPD0gbiAmJiAhaSkgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMua2V5cyk7XG4gICAgICB2YXIgcyA9IFtdO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvckVhY2hDZWxsKHQsIGUsIHIsIG4sIHRoaXMuX3F1ZXJ5Q2VsbCwgcywge30sIGkpLCBzO1xuICAgIH0sIFZuLnByb3RvdHlwZS5fcXVlcnlDZWxsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5jZWxsc1tpXTtcbiAgICAgIGlmIChudWxsICE9PSB1KSBmb3IgKHZhciBsID0gdGhpcy5rZXlzLCBwID0gdGhpcy5iYm94ZXMsIGMgPSAwOyBjIDwgdS5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgaCA9IHVbY107XG5cbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gb1toXSkge1xuICAgICAgICAgIHZhciBmID0gNCAqIGg7XG4gICAgICAgICAgKHMgPyBzKHBbZiArIDBdLCBwW2YgKyAxXSwgcFtmICsgMl0sIHBbZiArIDNdKSA6IHQgPD0gcFtmICsgMl0gJiYgZSA8PSBwW2YgKyAzXSAmJiByID49IHBbZiArIDBdICYmIG4gPj0gcFtmICsgMV0pID8gKG9baF0gPSAhMCwgYS5wdXNoKGxbaF0pKSA6IG9baF0gPSAhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFZuLnByb3RvdHlwZS5fZm9yRWFjaENlbGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgZm9yICh2YXIgdSA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh0KSwgbCA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChlKSwgcCA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChyKSwgYyA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChuKSwgaCA9IHU7IGggPD0gcDsgaCsrKSB7XG4gICAgICAgIGZvciAodmFyIGYgPSBsOyBmIDw9IGM7IGYrKykge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5kICogZiArIGg7XG4gICAgICAgICAgaWYgKCghcyB8fCBzKHRoaXMuX2NvbnZlcnRGcm9tQ2VsbENvb3JkKGgpLCB0aGlzLl9jb252ZXJ0RnJvbUNlbGxDb29yZChmKSwgdGhpcy5fY29udmVydEZyb21DZWxsQ29vcmQoaCArIDEpLCB0aGlzLl9jb252ZXJ0RnJvbUNlbGxDb29yZChmICsgMSkpKSAmJiBpLmNhbGwodGhpcywgdCwgZSwgciwgbiwgeSwgYSwgbywgcykpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFZuLnByb3RvdHlwZS5fY29udmVydEZyb21DZWxsQ29vcmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICh0IC0gdGhpcy5wYWRkaW5nKSAvIHRoaXMuc2NhbGU7XG4gICAgfSwgVm4ucHJvdG90eXBlLl9jb252ZXJ0VG9DZWxsQ29vcmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuZCAtIDEsIE1hdGguZmxvb3IodCAqIHRoaXMuc2NhbGUpICsgdGhpcy5wYWRkaW5nKSk7XG4gICAgfSwgVm4ucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5hcnJheUJ1ZmZlcikgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXI7XG5cbiAgICAgIGZvciAodmFyIHQgPSB0aGlzLmNlbGxzLCBlID0gMyArIHRoaXMuY2VsbHMubGVuZ3RoICsgMSArIDEsIHIgPSAwLCBuID0gMDsgbiA8IHRoaXMuY2VsbHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgciArPSB0aGlzLmNlbGxzW25dLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBuZXcgSW50MzJBcnJheShlICsgciArIHRoaXMua2V5cy5sZW5ndGggKyB0aGlzLmJib3hlcy5sZW5ndGgpO1xuICAgICAgaVswXSA9IHRoaXMuZXh0ZW50LCBpWzFdID0gdGhpcy5uLCBpWzJdID0gdGhpcy5wYWRkaW5nO1xuXG4gICAgICBmb3IgKHZhciBhID0gZSwgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciBzID0gdFtvXTtcbiAgICAgICAgaVszICsgb10gPSBhLCBpLnNldChzLCBhKSwgYSArPSBzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlbMyArIHQubGVuZ3RoXSA9IGEsIGkuc2V0KHRoaXMua2V5cywgYSksIGlbMyArIHQubGVuZ3RoICsgMV0gPSBhICs9IHRoaXMua2V5cy5sZW5ndGgsIGkuc2V0KHRoaXMuYmJveGVzLCBhKSwgYSArPSB0aGlzLmJib3hlcy5sZW5ndGgsIGkuYnVmZmVyO1xuICAgIH07XG4gICAgdmFyIEZuID0gby5JbWFnZURhdGEsXG4gICAgICAgIERuID0gby5JbWFnZUJpdG1hcCxcbiAgICAgICAgTG4gPSB7fTtcblxuICAgIGZ1bmN0aW9uIE9uKHQsIGUsIHIpIHtcbiAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX2NsYXNzUmVnaXN0cnlLZXlcIiwge1xuICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgd3JpdGVhYmxlOiAhMVxuICAgICAgfSksIExuW3RdID0ge1xuICAgICAgICBrbGFzczogZSxcbiAgICAgICAgb21pdDogci5vbWl0IHx8IFtdLFxuICAgICAgICBzaGFsbG93OiByLnNoYWxsb3cgfHwgW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgUm4gaW4gT24oXCJPYmplY3RcIiwgT2JqZWN0KSwgVG4uc2VyaWFsaXplID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC50b0FycmF5QnVmZmVyKCk7XG4gICAgICByZXR1cm4gZSAmJiBlLnB1c2gociksIHtcbiAgICAgICAgYnVmZmVyOiByXG4gICAgICB9O1xuICAgIH0sIFRuLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG4odC5idWZmZXIpO1xuICAgIH0sIE9uKFwiR3JpZFwiLCBUbiksIE9uKFwiQ29sb3JcIiwgdGUpLCBPbihcIkVycm9yXCIsIEVycm9yKSwgT24oXCJSZXNvbHZlZEltYWdlXCIsIGllKSwgT24oXCJTdHlsZVByb3BlcnR5RnVuY3Rpb25cIiwgWXIpLCBPbihcIlN0eWxlRXhwcmVzc2lvblwiLCBLciwge1xuICAgICAgb21pdDogW1wiX2V2YWx1YXRvclwiXVxuICAgIH0pLCBPbihcIlpvb21EZXBlbmRlbnRFeHByZXNzaW9uXCIsIEpyKSwgT24oXCJab29tQ29uc3RhbnRFeHByZXNzaW9uXCIsIFhyKSwgT24oXCJDb21wb3VuZEV4cHJlc3Npb25cIiwgeGUsIHtcbiAgICAgIG9taXQ6IFtcIl9ldmFsdWF0ZVwiXVxuICAgIH0pLCBJcikge1xuICAgICAgSXJbUm5dLl9jbGFzc1JlZ2lzdHJ5S2V5IHx8IE9uKFwiRXhwcmVzc2lvbl9cIiArIFJuLCBJcltSbl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVuKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEFycmF5QnVmZmVyICYmICh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgdC5jb25zdHJ1Y3RvciAmJiBcIkFycmF5QnVmZmVyXCIgPT09IHQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam4odCkge1xuICAgICAgcmV0dXJuIERuICYmIHQgaW5zdGFuY2VvZiBEbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxbih0LCBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0IHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCB8fCB0IGluc3RhbmNlb2YgQm9vbGVhbiB8fCB0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdCBpbnN0YW5jZW9mIERhdGUgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHQ7XG4gICAgICBpZiAoVW4odCkgfHwgam4odCkpIHJldHVybiBlICYmIGUucHVzaCh0KSwgdDtcblxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0KSkge1xuICAgICAgICB2YXIgciA9IHQ7XG4gICAgICAgIHJldHVybiBlICYmIGUucHVzaChyLmJ1ZmZlciksIHI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0IGluc3RhbmNlb2YgRm4pIHJldHVybiBlICYmIGUucHVzaCh0LmRhdGEuYnVmZmVyKSwgdDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgbi5wdXNoKHFuKGFbaV0sIGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICB2YXIgbyA9IHQuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBzID0gby5fY2xhc3NSZWdpc3RyeUtleTtcbiAgICAgICAgaWYgKCFzKSB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgb2JqZWN0IG9mIHVucmVnaXN0ZXJlZCBjbGFzc1wiKTtcbiAgICAgICAgdmFyIHUgPSBvLnNlcmlhbGl6ZSA/IG8uc2VyaWFsaXplKHQsIGUpIDoge307XG5cbiAgICAgICAgaWYgKCFvLnNlcmlhbGl6ZSkge1xuICAgICAgICAgIGZvciAodmFyIGwgaW4gdCkge1xuICAgICAgICAgICAgaWYgKHQuaGFzT3duUHJvcGVydHkobCkgJiYgIShMbltzXS5vbWl0LmluZGV4T2YobCkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0W2xdO1xuICAgICAgICAgICAgICB1W2xdID0gTG5bc10uc2hhbGxvdy5pbmRleE9mKGwpID49IDAgPyBwIDogcW4ocCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdCBpbnN0YW5jZW9mIEVycm9yICYmICh1Lm1lc3NhZ2UgPSB0Lm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHUuJG5hbWUpIHRocm93IG5ldyBFcnJvcihcIiRuYW1lIHByb3BlcnR5IGlzIHJlc2VydmVkIGZvciB3b3JrZXIgc2VyaWFsaXphdGlvbiBsb2dpYy5cIik7XG4gICAgICAgIHJldHVybiBcIk9iamVjdFwiICE9PSBzICYmICh1LiRuYW1lID0gcyksIHU7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBvYmplY3Qgb2YgdHlwZSBcIiArIHR5cGVvZiB0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBObih0KSB7XG4gICAgICBpZiAobnVsbCA9PSB0IHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCB8fCB0IGluc3RhbmNlb2YgQm9vbGVhbiB8fCB0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdCBpbnN0YW5jZW9mIERhdGUgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBVbih0KSB8fCBqbih0KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodCkgfHwgdCBpbnN0YW5jZW9mIEZuKSByZXR1cm4gdDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSByZXR1cm4gdC5tYXAoTm4pO1xuXG4gICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICB2YXIgZSA9IHQuJG5hbWUgfHwgXCJPYmplY3RcIixcbiAgICAgICAgICAgIHIgPSBMbltlXS5rbGFzcztcbiAgICAgICAgaWYgKCFyKSB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBkZXNlcmlhbGl6ZSB1bnJlZ2lzdGVyZWQgY2xhc3MgXCIgKyBlKTtcbiAgICAgICAgaWYgKHIuZGVzZXJpYWxpemUpIHJldHVybiByLmRlc2VyaWFsaXplKHQpO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSBPYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSwgaSA9IDAsIGEgPSBPYmplY3Qua2V5cyh0KTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgbyA9IGFbaV07XG5cbiAgICAgICAgICBpZiAoXCIkbmFtZVwiICE9PSBvKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRbb107XG4gICAgICAgICAgICBuW29dID0gTG5bZV0uc2hhbGxvdy5pbmRleE9mKG8pID49IDAgPyBzIDogTm4ocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGRlc2VyaWFsaXplIG9iamVjdCBvZiB0eXBlIFwiICsgdHlwZW9mIHQpO1xuICAgIH1cblxuICAgIHZhciBLbiA9IGZ1bmN0aW9uIEtuKCkge1xuICAgICAgdGhpcy5maXJzdCA9ICEwO1xuICAgIH07XG5cbiAgICBLbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gTWF0aC5mbG9vcih0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpcnN0ID8gKHRoaXMuZmlyc3QgPSAhMSwgdGhpcy5sYXN0SW50ZWdlclpvb20gPSByLCB0aGlzLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSAwLCB0aGlzLmxhc3Rab29tID0gdCwgdGhpcy5sYXN0Rmxvb3Jab29tID0gciwgITApIDogKHRoaXMubGFzdEZsb29yWm9vbSA+IHIgPyAodGhpcy5sYXN0SW50ZWdlclpvb20gPSByICsgMSwgdGhpcy5sYXN0SW50ZWdlclpvb21UaW1lID0gZSkgOiB0aGlzLmxhc3RGbG9vclpvb20gPCByICYmICh0aGlzLmxhc3RJbnRlZ2VyWm9vbSA9IHIsIHRoaXMubGFzdEludGVnZXJab29tVGltZSA9IGUpLCB0ICE9PSB0aGlzLmxhc3Rab29tICYmICh0aGlzLmxhc3Rab29tID0gdCwgdGhpcy5sYXN0Rmxvb3Jab29tID0gciwgITApKTtcbiAgICB9O1xuXG4gICAgdmFyIEduID0ge1xuICAgICAgXCJMYXRpbi0xIFN1cHBsZW1lbnRcIjogZnVuY3Rpb24gTGF0aW4xU3VwcGxlbWVudCh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyOCAmJiB0IDw9IDI1NTtcbiAgICAgIH0sXG4gICAgICBBcmFiaWM6IGZ1bmN0aW9uIEFyYWJpYyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE1MzYgJiYgdCA8PSAxNzkxO1xuICAgICAgfSxcbiAgICAgIFwiQXJhYmljIFN1cHBsZW1lbnRcIjogZnVuY3Rpb24gQXJhYmljU3VwcGxlbWVudCh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE4NzIgJiYgdCA8PSAxOTE5O1xuICAgICAgfSxcbiAgICAgIFwiQXJhYmljIEV4dGVuZGVkLUFcIjogZnVuY3Rpb24gQXJhYmljRXh0ZW5kZWRBKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMjIwOCAmJiB0IDw9IDIzMDM7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgSmFtb1wiOiBmdW5jdGlvbiBIYW5ndWxKYW1vKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDM1MiAmJiB0IDw9IDQ2MDc7XG4gICAgICB9LFxuICAgICAgXCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXCI6IGZ1bmN0aW9uIFVuaWZpZWRDYW5hZGlhbkFib3JpZ2luYWxTeWxsYWJpY3ModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA1MTIwICYmIHQgPD0gNTc1OTtcbiAgICAgIH0sXG4gICAgICBLaG1lcjogZnVuY3Rpb24gS2htZXIodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2MDE2ICYmIHQgPD0gNjE0MztcbiAgICAgIH0sXG4gICAgICBcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3MgRXh0ZW5kZWRcIjogZnVuY3Rpb24gVW5pZmllZENhbmFkaWFuQWJvcmlnaW5hbFN5bGxhYmljc0V4dGVuZGVkKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjMyMCAmJiB0IDw9IDYzOTk7XG4gICAgICB9LFxuICAgICAgXCJHZW5lcmFsIFB1bmN0dWF0aW9uXCI6IGZ1bmN0aW9uIEdlbmVyYWxQdW5jdHVhdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDgxOTIgJiYgdCA8PSA4MzAzO1xuICAgICAgfSxcbiAgICAgIFwiTGV0dGVybGlrZSBTeW1ib2xzXCI6IGZ1bmN0aW9uIExldHRlcmxpa2VTeW1ib2xzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gODQ0OCAmJiB0IDw9IDg1Mjc7XG4gICAgICB9LFxuICAgICAgXCJOdW1iZXIgRm9ybXNcIjogZnVuY3Rpb24gTnVtYmVyRm9ybXModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA4NTI4ICYmIHQgPD0gODU5MTtcbiAgICAgIH0sXG4gICAgICBcIk1pc2NlbGxhbmVvdXMgVGVjaG5pY2FsXCI6IGZ1bmN0aW9uIE1pc2NlbGxhbmVvdXNUZWNobmljYWwodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA4OTYwICYmIHQgPD0gOTIxNTtcbiAgICAgIH0sXG4gICAgICBcIkNvbnRyb2wgUGljdHVyZXNcIjogZnVuY3Rpb24gQ29udHJvbFBpY3R1cmVzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTIxNiAmJiB0IDw9IDkyNzk7XG4gICAgICB9LFxuICAgICAgXCJPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblwiOiBmdW5jdGlvbiBPcHRpY2FsQ2hhcmFjdGVyUmVjb2duaXRpb24odCkge1xuICAgICAgICByZXR1cm4gdCA+PSA5MjgwICYmIHQgPD0gOTMxMTtcbiAgICAgIH0sXG4gICAgICBcIkVuY2xvc2VkIEFscGhhbnVtZXJpY3NcIjogZnVuY3Rpb24gRW5jbG9zZWRBbHBoYW51bWVyaWNzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTMxMiAmJiB0IDw9IDk0NzE7XG4gICAgICB9LFxuICAgICAgXCJHZW9tZXRyaWMgU2hhcGVzXCI6IGZ1bmN0aW9uIEdlb21ldHJpY1NoYXBlcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDk2MzIgJiYgdCA8PSA5NzI3O1xuICAgICAgfSxcbiAgICAgIFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzXCI6IGZ1bmN0aW9uIE1pc2NlbGxhbmVvdXNTeW1ib2xzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTcyOCAmJiB0IDw9IDk5ODM7XG4gICAgICB9LFxuICAgICAgXCJNaXNjZWxsYW5lb3VzIFN5bWJvbHMgYW5kIEFycm93c1wiOiBmdW5jdGlvbiBNaXNjZWxsYW5lb3VzU3ltYm9sc0FuZEFycm93cyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDExMDA4ICYmIHQgPD0gMTEyNjM7XG4gICAgICB9LFxuICAgICAgXCJDSksgUmFkaWNhbHMgU3VwcGxlbWVudFwiOiBmdW5jdGlvbiBDSktSYWRpY2Fsc1N1cHBsZW1lbnQodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMTkwNCAmJiB0IDw9IDEyMDMxO1xuICAgICAgfSxcbiAgICAgIFwiS2FuZ3hpIFJhZGljYWxzXCI6IGZ1bmN0aW9uIEthbmd4aVJhZGljYWxzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTIwMzIgJiYgdCA8PSAxMjI1NTtcbiAgICAgIH0sXG4gICAgICBcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIjogZnVuY3Rpb24gSWRlb2dyYXBoaWNEZXNjcmlwdGlvbkNoYXJhY3RlcnModCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjI3MiAmJiB0IDw9IDEyMjg3O1xuICAgICAgfSxcbiAgICAgIFwiQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCI6IGZ1bmN0aW9uIENKS1N5bWJvbHNBbmRQdW5jdHVhdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyMjg4ICYmIHQgPD0gMTIzNTE7XG4gICAgICB9LFxuICAgICAgSGlyYWdhbmE6IGZ1bmN0aW9uIEhpcmFnYW5hKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTIzNTIgJiYgdCA8PSAxMjQ0NztcbiAgICAgIH0sXG4gICAgICBLYXRha2FuYTogZnVuY3Rpb24gS2F0YWthbmEodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjQ0OCAmJiB0IDw9IDEyNTQzO1xuICAgICAgfSxcbiAgICAgIEJvcG9tb2ZvOiBmdW5jdGlvbiBCb3BvbW9mbyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNTQ0ICYmIHQgPD0gMTI1OTE7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vXCI6IGZ1bmN0aW9uIEhhbmd1bENvbXBhdGliaWxpdHlKYW1vKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI1OTIgJiYgdCA8PSAxMjY4NztcbiAgICAgIH0sXG4gICAgICBLYW5idW46IGZ1bmN0aW9uIEthbmJ1bih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNjg4ICYmIHQgPD0gMTI3MDM7XG4gICAgICB9LFxuICAgICAgXCJCb3BvbW9mbyBFeHRlbmRlZFwiOiBmdW5jdGlvbiBCb3BvbW9mb0V4dGVuZGVkKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI3MDQgJiYgdCA8PSAxMjczNTtcbiAgICAgIH0sXG4gICAgICBcIkNKSyBTdHJva2VzXCI6IGZ1bmN0aW9uIENKS1N0cm9rZXModCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjczNiAmJiB0IDw9IDEyNzgzO1xuICAgICAgfSxcbiAgICAgIFwiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiOiBmdW5jdGlvbiBLYXRha2FuYVBob25ldGljRXh0ZW5zaW9ucyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNzg0ICYmIHQgPD0gMTI3OTk7XG4gICAgICB9LFxuICAgICAgXCJFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXCI6IGZ1bmN0aW9uIEVuY2xvc2VkQ0pLTGV0dGVyc0FuZE1vbnRocyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyODAwICYmIHQgPD0gMTMwNTU7XG4gICAgICB9LFxuICAgICAgXCJDSksgQ29tcGF0aWJpbGl0eVwiOiBmdW5jdGlvbiBDSktDb21wYXRpYmlsaXR5KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTMwNTYgJiYgdCA8PSAxMzMxMTtcbiAgICAgIH0sXG4gICAgICBcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIjogZnVuY3Rpb24gQ0pLVW5pZmllZElkZW9ncmFwaHNFeHRlbnNpb25BKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTMzMTIgJiYgdCA8PSAxOTkwMztcbiAgICAgIH0sXG4gICAgICBcIllpamluZyBIZXhhZ3JhbSBTeW1ib2xzXCI6IGZ1bmN0aW9uIFlpamluZ0hleGFncmFtU3ltYm9scyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE5OTA0ICYmIHQgPD0gMTk5Njc7XG4gICAgICB9LFxuICAgICAgXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCI6IGZ1bmN0aW9uIENKS1VuaWZpZWRJZGVvZ3JhcGhzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTk5NjggJiYgdCA8PSA0MDk1OTtcbiAgICAgIH0sXG4gICAgICBcIllpIFN5bGxhYmxlc1wiOiBmdW5jdGlvbiBZaVN5bGxhYmxlcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQwOTYwICYmIHQgPD0gNDIxMjc7XG4gICAgICB9LFxuICAgICAgXCJZaSBSYWRpY2Fsc1wiOiBmdW5jdGlvbiBZaVJhZGljYWxzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDIxMjggJiYgdCA8PSA0MjE5MTtcbiAgICAgIH0sXG4gICAgICBcIkhhbmd1bCBKYW1vIEV4dGVuZGVkLUFcIjogZnVuY3Rpb24gSGFuZ3VsSmFtb0V4dGVuZGVkQSh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQzMzYwICYmIHQgPD0gNDMzOTE7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgU3lsbGFibGVzXCI6IGZ1bmN0aW9uIEhhbmd1bFN5bGxhYmxlcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQ0MDMyICYmIHQgPD0gNTUyMTU7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1CXCI6IGZ1bmN0aW9uIEhhbmd1bEphbW9FeHRlbmRlZEIodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA1NTIxNiAmJiB0IDw9IDU1Mjk1O1xuICAgICAgfSxcbiAgICAgIFwiUHJpdmF0ZSBVc2UgQXJlYVwiOiBmdW5jdGlvbiBQcml2YXRlVXNlQXJlYSh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDU3MzQ0ICYmIHQgPD0gNjM3NDM7XG4gICAgICB9LFxuICAgICAgXCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXCI6IGZ1bmN0aW9uIENKS0NvbXBhdGliaWxpdHlJZGVvZ3JhcGhzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjM3NDQgJiYgdCA8PSA2NDI1NTtcbiAgICAgIH0sXG4gICAgICBcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVwiOiBmdW5jdGlvbiBBcmFiaWNQcmVzZW50YXRpb25Gb3Jtc0EodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NDMzNiAmJiB0IDw9IDY1MDIzO1xuICAgICAgfSxcbiAgICAgIFwiVmVydGljYWwgRm9ybXNcIjogZnVuY3Rpb24gVmVydGljYWxGb3Jtcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY1MDQwICYmIHQgPD0gNjUwNTU7XG4gICAgICB9LFxuICAgICAgXCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiOiBmdW5jdGlvbiBDSktDb21wYXRpYmlsaXR5Rm9ybXModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTA3MiAmJiB0IDw9IDY1MTAzO1xuICAgICAgfSxcbiAgICAgIFwiU21hbGwgRm9ybSBWYXJpYW50c1wiOiBmdW5jdGlvbiBTbWFsbEZvcm1WYXJpYW50cyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY1MTA0ICYmIHQgPD0gNjUxMzU7XG4gICAgICB9LFxuICAgICAgXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIjogZnVuY3Rpb24gQXJhYmljUHJlc2VudGF0aW9uRm9ybXNCKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjUxMzYgJiYgdCA8PSA2NTI3OTtcbiAgICAgIH0sXG4gICAgICBcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCI6IGZ1bmN0aW9uIEhhbGZ3aWR0aEFuZEZ1bGx3aWR0aEZvcm1zKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjUyODAgJiYgdCA8PSA2NTUxOTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gWm4odCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICBpZiAoWG4ocltlXS5jaGFyQ29kZUF0KDApKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWG4odCkge1xuICAgICAgcmV0dXJuICEoNzQ2ICE9PSB0ICYmIDc0NyAhPT0gdCAmJiAodCA8IDQzNTIgfHwgIShHbltcIkJvcG9tb2ZvIEV4dGVuZGVkXCJdKHQpIHx8IEduLkJvcG9tb2ZvKHQpIHx8IEduW1wiQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcIl0odCkgJiYgISh0ID49IDY1MDk3ICYmIHQgPD0gNjUxMDMpIHx8IEduW1wiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1wiXSh0KSB8fCBHbltcIkNKSyBDb21wYXRpYmlsaXR5XCJdKHQpIHx8IEduW1wiQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcIl0odCkgfHwgR25bXCJDSksgU3Ryb2tlc1wiXSh0KSB8fCAhKCFHbltcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiXSh0KSB8fCB0ID49IDEyMjk2ICYmIHQgPD0gMTIzMDUgfHwgdCA+PSAxMjMwOCAmJiB0IDw9IDEyMzE5IHx8IDEyMzM2ID09PSB0KSB8fCBHbltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIl0odCkgfHwgR25bXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCJdKHQpIHx8IEduW1wiRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1wiXSh0KSB8fCBHbltcIkhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cIl0odCkgfHwgR25bXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXCJdKHQpIHx8IEduW1wiSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQlwiXSh0KSB8fCBHbltcIkhhbmd1bCBKYW1vXCJdKHQpIHx8IEduW1wiSGFuZ3VsIFN5bGxhYmxlc1wiXSh0KSB8fCBHbi5IaXJhZ2FuYSh0KSB8fCBHbltcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIl0odCkgfHwgR24uS2FuYnVuKHQpIHx8IEduW1wiS2FuZ3hpIFJhZGljYWxzXCJdKHQpIHx8IEduW1wiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiXSh0KSB8fCBHbi5LYXRha2FuYSh0KSAmJiAxMjU0MCAhPT0gdCB8fCAhKCFHbltcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCJdKHQpIHx8IDY1Mjg4ID09PSB0IHx8IDY1Mjg5ID09PSB0IHx8IDY1MjkzID09PSB0IHx8IHQgPj0gNjUzMDYgJiYgdCA8PSA2NTMxMCB8fCA2NTMzOSA9PT0gdCB8fCA2NTM0MSA9PT0gdCB8fCA2NTM0MyA9PT0gdCB8fCB0ID49IDY1MzcxICYmIHQgPD0gNjU1MDMgfHwgNjU1MDcgPT09IHQgfHwgdCA+PSA2NTUxMiAmJiB0IDw9IDY1NTE5KSB8fCAhKCFHbltcIlNtYWxsIEZvcm0gVmFyaWFudHNcIl0odCkgfHwgdCA+PSA2NTExMiAmJiB0IDw9IDY1MTE4IHx8IHQgPj0gNjUxMjMgJiYgdCA8PSA2NTEyNikgfHwgR25bXCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXCJdKHQpIHx8IEduW1wiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljcyBFeHRlbmRlZFwiXSh0KSB8fCBHbltcIlZlcnRpY2FsIEZvcm1zXCJdKHQpIHx8IEduW1wiWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcIl0odCkgfHwgR25bXCJZaSBTeWxsYWJsZXNcIl0odCkgfHwgR25bXCJZaSBSYWRpY2Fsc1wiXSh0KSkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBKbih0KSB7XG4gICAgICByZXR1cm4gIShYbih0KSB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gISEoR25bXCJMYXRpbi0xIFN1cHBsZW1lbnRcIl0odCkgJiYgKDE2NyA9PT0gdCB8fCAxNjkgPT09IHQgfHwgMTc0ID09PSB0IHx8IDE3NyA9PT0gdCB8fCAxODggPT09IHQgfHwgMTg5ID09PSB0IHx8IDE5MCA9PT0gdCB8fCAyMTUgPT09IHQgfHwgMjQ3ID09PSB0KSB8fCBHbltcIkdlbmVyYWwgUHVuY3R1YXRpb25cIl0odCkgJiYgKDgyMTQgPT09IHQgfHwgODIyNCA9PT0gdCB8fCA4MjI1ID09PSB0IHx8IDgyNDAgPT09IHQgfHwgODI0MSA9PT0gdCB8fCA4MjUxID09PSB0IHx8IDgyNTIgPT09IHQgfHwgODI1OCA9PT0gdCB8fCA4MjYzID09PSB0IHx8IDgyNjQgPT09IHQgfHwgODI2NSA9PT0gdCB8fCA4MjczID09PSB0KSB8fCBHbltcIkxldHRlcmxpa2UgU3ltYm9sc1wiXSh0KSB8fCBHbltcIk51bWJlciBGb3Jtc1wiXSh0KSB8fCBHbltcIk1pc2NlbGxhbmVvdXMgVGVjaG5pY2FsXCJdKHQpICYmICh0ID49IDg5NjAgJiYgdCA8PSA4OTY3IHx8IHQgPj0gODk3MiAmJiB0IDw9IDg5OTEgfHwgdCA+PSA4OTk2ICYmIHQgPD0gOWUzIHx8IDkwMDMgPT09IHQgfHwgdCA+PSA5MDg1ICYmIHQgPD0gOTExNCB8fCB0ID49IDkxNTAgJiYgdCA8PSA5MTY1IHx8IDkxNjcgPT09IHQgfHwgdCA+PSA5MTY5ICYmIHQgPD0gOTE3OSB8fCB0ID49IDkxODYgJiYgdCA8PSA5MjE1KSB8fCBHbltcIkNvbnRyb2wgUGljdHVyZXNcIl0odCkgJiYgOTI1MSAhPT0gdCB8fCBHbltcIk9wdGljYWwgQ2hhcmFjdGVyIFJlY29nbml0aW9uXCJdKHQpIHx8IEduW1wiRW5jbG9zZWQgQWxwaGFudW1lcmljc1wiXSh0KSB8fCBHbltcIkdlb21ldHJpYyBTaGFwZXNcIl0odCkgfHwgR25bXCJNaXNjZWxsYW5lb3VzIFN5bWJvbHNcIl0odCkgJiYgISh0ID49IDk3NTQgJiYgdCA8PSA5NzU5KSB8fCBHbltcIk1pc2NlbGxhbmVvdXMgU3ltYm9scyBhbmQgQXJyb3dzXCJdKHQpICYmICh0ID49IDExMDI2ICYmIHQgPD0gMTEwNTUgfHwgdCA+PSAxMTA4OCAmJiB0IDw9IDExMDk3IHx8IHQgPj0gMTExOTIgJiYgdCA8PSAxMTI0MykgfHwgR25bXCJDSksgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cIl0odCkgfHwgR24uS2F0YWthbmEodCkgfHwgR25bXCJQcml2YXRlIFVzZSBBcmVhXCJdKHQpIHx8IEduW1wiQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcIl0odCkgfHwgR25bXCJTbWFsbCBGb3JtIFZhcmlhbnRzXCJdKHQpIHx8IEduW1wiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcIl0odCkgfHwgODczNCA9PT0gdCB8fCA4NzU2ID09PSB0IHx8IDg3NTcgPT09IHQgfHwgdCA+PSA5OTg0ICYmIHQgPD0gMTAwODcgfHwgdCA+PSAxMDEwMiAmJiB0IDw9IDEwMTMxIHx8IDY1NTMyID09PSB0IHx8IDY1NTMzID09PSB0KTtcbiAgICAgIH0odCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhuKHQpIHtcbiAgICAgIHJldHVybiB0ID49IDE0MjQgJiYgdCA8PSAyMzAzIHx8IEduW1wiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXCJdKHQpIHx8IEduW1wiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXCJdKHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFluKHQsIGUpIHtcbiAgICAgIHJldHVybiAhKCFlICYmIEhuKHQpIHx8IHQgPj0gMjMwNCAmJiB0IDw9IDM1ODMgfHwgdCA+PSAzODQwICYmIHQgPD0gNDI1NSB8fCBHbi5LaG1lcih0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJG4odCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICBpZiAoSG4ocltlXS5jaGFyQ29kZUF0KDApKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgdmFyIFduID0gbnVsbCxcbiAgICAgICAgUW4gPSBcInVuYXZhaWxhYmxlXCIsXG4gICAgICAgIHRpID0gbnVsbCxcbiAgICAgICAgZWkgPSBmdW5jdGlvbiBlaSh0KSB7XG4gICAgICB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdC5pbmRleE9mKFwiTmV0d29ya0Vycm9yXCIpID4gLTEgJiYgKFFuID0gXCJlcnJvclwiKSwgV24gJiYgV24odCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJpKCkge1xuICAgICAgbmkuZmlyZShuZXcgSXQoXCJwbHVnaW5TdGF0ZUNoYW5nZVwiLCB7XG4gICAgICAgIHBsdWdpblN0YXR1czogUW4sXG4gICAgICAgIHBsdWdpblVSTDogdGlcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgbmkgPSBuZXcgQ3QoKSxcbiAgICAgICAgaWkgPSBmdW5jdGlvbiBpaSgpIHtcbiAgICAgIHJldHVybiBRbjtcbiAgICB9LFxuICAgICAgICBhaSA9IGZ1bmN0aW9uIGFpKCkge1xuICAgICAgaWYgKFwiZGVmZXJyZWRcIiAhPT0gUW4gfHwgIXRpKSB0aHJvdyBuZXcgRXJyb3IoXCJydGwtdGV4dC1wbHVnaW4gY2Fubm90IGJlIGRvd25sb2FkZWQgdW5sZXNzIGEgcGx1Z2luVVJMIGlzIHNwZWNpZmllZFwiKTtcbiAgICAgIFFuID0gXCJsb2FkaW5nXCIsIHJpKCksIHRpICYmIGJ0KHtcbiAgICAgICAgdXJsOiB0aVxuICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCA/IGVpKHQpIDogKFFuID0gXCJsb2FkZWRcIiwgcmkoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBvaSA9IHtcbiAgICAgIGFwcGx5QXJhYmljU2hhcGluZzogbnVsbCxcbiAgICAgIHByb2Nlc3NCaWRpcmVjdGlvbmFsVGV4dDogbnVsbCxcbiAgICAgIHByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dDogbnVsbCxcbiAgICAgIGlzTG9hZGVkOiBmdW5jdGlvbiBpc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIFwibG9hZGVkXCIgPT09IFFuIHx8IG51bGwgIT0gb2kuYXBwbHlBcmFiaWNTaGFwaW5nO1xuICAgICAgfSxcbiAgICAgIGlzTG9hZGluZzogZnVuY3Rpb24gaXNMb2FkaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJsb2FkaW5nXCIgPT09IFFuO1xuICAgICAgfSxcbiAgICAgIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZSh0KSB7XG4gICAgICAgIFFuID0gdC5wbHVnaW5TdGF0dXMsIHRpID0gdC5wbHVnaW5VUkw7XG4gICAgICB9LFxuICAgICAgaXNQYXJzZWQ6IGZ1bmN0aW9uIGlzUGFyc2VkKCkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPSBvaS5hcHBseUFyYWJpY1NoYXBpbmcgJiYgbnVsbCAhPSBvaS5wcm9jZXNzQmlkaXJlY3Rpb25hbFRleHQgJiYgbnVsbCAhPSBvaS5wcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQ7XG4gICAgICB9LFxuICAgICAgZ2V0UGx1Z2luVVJMOiBmdW5jdGlvbiBnZXRQbHVnaW5VUkwoKSB7XG4gICAgICAgIHJldHVybiB0aTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBzaSA9IGZ1bmN0aW9uIHNpKHQsIGUpIHtcbiAgICAgIHRoaXMuem9vbSA9IHQsIGUgPyAodGhpcy5ub3cgPSBlLm5vdywgdGhpcy5mYWRlRHVyYXRpb24gPSBlLmZhZGVEdXJhdGlvbiwgdGhpcy56b29tSGlzdG9yeSA9IGUuem9vbUhpc3RvcnksIHRoaXMudHJhbnNpdGlvbiA9IGUudHJhbnNpdGlvbikgOiAodGhpcy5ub3cgPSAwLCB0aGlzLmZhZGVEdXJhdGlvbiA9IDAsIHRoaXMuem9vbUhpc3RvcnkgPSBuZXcgS24oKSwgdGhpcy50cmFuc2l0aW9uID0ge30pO1xuICAgIH07XG5cbiAgICBzaS5wcm90b3R5cGUuaXNTdXBwb3J0ZWRTY3JpcHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gdDsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICBpZiAoIVluKG5bcl0uY2hhckNvZGVBdCgwKSwgZSkpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0odCwgb2kuaXNMb2FkZWQoKSk7XG4gICAgfSwgc2kucHJvdG90eXBlLmNyb3NzRmFkaW5nRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuZmFkZUR1cmF0aW9uID8gMSA6IE1hdGgubWluKCh0aGlzLm5vdyAtIHRoaXMuem9vbUhpc3RvcnkubGFzdEludGVnZXJab29tVGltZSkgLyB0aGlzLmZhZGVEdXJhdGlvbiwgMSk7XG4gICAgfSwgc2kucHJvdG90eXBlLmdldENyb3NzZmFkZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuem9vbSxcbiAgICAgICAgICBlID0gdCAtIE1hdGguZmxvb3IodCksXG4gICAgICAgICAgciA9IHRoaXMuY3Jvc3NGYWRpbmdGYWN0b3IoKTtcbiAgICAgIHJldHVybiB0ID4gdGhpcy56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb20gPyB7XG4gICAgICAgIGZyb21TY2FsZTogMixcbiAgICAgICAgdG9TY2FsZTogMSxcbiAgICAgICAgdDogZSArICgxIC0gZSkgKiByXG4gICAgICB9IDoge1xuICAgICAgICBmcm9tU2NhbGU6IC41LFxuICAgICAgICB0b1NjYWxlOiAxLFxuICAgICAgICB0OiAxIC0gKDEgLSByKSAqIGVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB1aSA9IGZ1bmN0aW9uIHVpKHQsIGUpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gZSwgdGhpcy5leHByZXNzaW9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKExyKHQpKSByZXR1cm4gbmV3IFlyKHQsIGUpO1xuXG4gICAgICAgIGlmIChHcih0KSkge1xuICAgICAgICAgIHZhciByID0gSHIodCwgZSk7XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gci5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihyLnZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQua2V5ICsgXCI6IFwiICsgdC5tZXNzYWdlO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgcmV0dXJuIHIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHQ7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIFwiY29sb3JcIiA9PT0gZS50eXBlICYmIChuID0gdGUucGFyc2UodCkpLCB7XG4gICAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0odm9pZCAwID09PSBlID8gdC5zcGVjaWZpY2F0aW9uLmRlZmF1bHQgOiBlLCB0LnNwZWNpZmljYXRpb24pO1xuICAgIH07XG5cbiAgICB1aS5wcm90b3R5cGUuaXNEYXRhRHJpdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwic291cmNlXCIgPT09IHRoaXMuZXhwcmVzc2lvbi5raW5kIHx8IFwiY29tcG9zaXRlXCIgPT09IHRoaXMuZXhwcmVzc2lvbi5raW5kO1xuICAgIH0sIHVpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnBvc3NpYmx5RXZhbHVhdGUodGhpcywgdCwgZSwgcik7XG4gICAgfTtcblxuICAgIHZhciBsaSA9IGZ1bmN0aW9uIGxpKHQpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gbmV3IHVpKHQsIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIGxpLnByb3RvdHlwZS50cmFuc2l0aW9uZWQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIG5ldyBjaSh0aGlzLnByb3BlcnR5LCB0aGlzLnZhbHVlLCBlLCBoKHt9LCB0LnRyYW5zaXRpb24sIHRoaXMudHJhbnNpdGlvbiksIHQubm93KTtcbiAgICB9LCBsaS5wcm90b3R5cGUudW50cmFuc2l0aW9uZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGNpKHRoaXMucHJvcGVydHksIHRoaXMudmFsdWUsIG51bGwsIHt9LCAwKTtcbiAgICB9O1xuXG4gICAgdmFyIHBpID0gZnVuY3Rpb24gcGkodCkge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHQsIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUodC5kZWZhdWx0VHJhbnNpdGlvbmFibGVQcm9wZXJ0eVZhbHVlcyk7XG4gICAgfTtcblxuICAgIHBpLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdyh0aGlzLl92YWx1ZXNbdF0udmFsdWUudmFsdWUpO1xuICAgIH0sIHBpLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLl92YWx1ZXMuaGFzT3duUHJvcGVydHkodCkgfHwgKHRoaXMuX3ZhbHVlc1t0XSA9IG5ldyBsaSh0aGlzLl92YWx1ZXNbdF0ucHJvcGVydHkpKSwgdGhpcy5fdmFsdWVzW3RdLnZhbHVlID0gbmV3IHVpKHRoaXMuX3ZhbHVlc1t0XS5wcm9wZXJ0eSwgbnVsbCA9PT0gZSA/IHZvaWQgMCA6IHcoZSkpO1xuICAgIH0sIHBpLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB3KHRoaXMuX3ZhbHVlc1t0XS50cmFuc2l0aW9uKTtcbiAgICB9LCBwaS5wcm90b3R5cGUuc2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLl92YWx1ZXMuaGFzT3duUHJvcGVydHkodCkgfHwgKHRoaXMuX3ZhbHVlc1t0XSA9IG5ldyBsaSh0aGlzLl92YWx1ZXNbdF0ucHJvcGVydHkpKSwgdGhpcy5fdmFsdWVzW3RdLnRyYW5zaXRpb24gPSB3KGUpIHx8IHZvaWQgMDtcbiAgICB9LCBwaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IHt9LCBlID0gMCwgciA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXSxcbiAgICAgICAgICAgIGkgPSB0aGlzLmdldFZhbHVlKG4pO1xuICAgICAgICB2b2lkIDAgIT09IGkgJiYgKHRbbl0gPSBpKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldFRyYW5zaXRpb24obik7XG4gICAgICAgIHZvaWQgMCAhPT0gYSAmJiAodFtuICsgXCItdHJhbnNpdGlvblwiXSA9IGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBwaS5wcm90b3R5cGUudHJhbnNpdGlvbmVkID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSBuZXcgaGkodGhpcy5fcHJvcGVydGllcyksIG4gPSAwLCBpID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICByLl92YWx1ZXNbYV0gPSB0aGlzLl92YWx1ZXNbYV0udHJhbnNpdGlvbmVkKHQsIGUuX3ZhbHVlc1thXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHBpLnByb3RvdHlwZS51bnRyYW5zaXRpb25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSBuZXcgaGkodGhpcy5fcHJvcGVydGllcyksIGUgPSAwLCByID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0Ll92YWx1ZXNbbl0gPSB0aGlzLl92YWx1ZXNbbl0udW50cmFuc2l0aW9uZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciBjaSA9IGZ1bmN0aW9uIGNpKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gZSwgdGhpcy5iZWdpbiA9IGkgKyBuLmRlbGF5IHx8IDAsIHRoaXMuZW5kID0gdGhpcy5iZWdpbiArIG4uZHVyYXRpb24gfHwgMCwgdC5zcGVjaWZpY2F0aW9uLnRyYW5zaXRpb24gJiYgKG4uZGVsYXkgfHwgbi5kdXJhdGlvbikgJiYgKHRoaXMucHJpb3IgPSByKTtcbiAgICB9O1xuXG4gICAgY2kucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0Lm5vdyB8fCAwLFxuICAgICAgICAgIGkgPSB0aGlzLnZhbHVlLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgciksXG4gICAgICAgICAgYSA9IHRoaXMucHJpb3I7XG5cbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChuID4gdGhpcy5lbmQpIHJldHVybiB0aGlzLnByaW9yID0gbnVsbCwgaTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuaXNEYXRhRHJpdmVuKCkpIHJldHVybiB0aGlzLnByaW9yID0gbnVsbCwgaTtcbiAgICAgICAgaWYgKG4gPCB0aGlzLmJlZ2luKSByZXR1cm4gYS5wb3NzaWJseUV2YWx1YXRlKHQsIGUsIHIpO1xuICAgICAgICB2YXIgbyA9IChuIC0gdGhpcy5iZWdpbikgLyAodGhpcy5lbmQgLSB0aGlzLmJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuaW50ZXJwb2xhdGUoYS5wb3NzaWJseUV2YWx1YXRlKHQsIGUsIHIpLCBpLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgICAgICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgICAgICAgIHZhciBlID0gdCAqIHQsXG4gICAgICAgICAgICAgIHIgPSBlICogdDtcbiAgICAgICAgICByZXR1cm4gNCAqICh0IDwgLjUgPyByIDogMyAqICh0IC0gZSkgKyByIC0gLjc1KTtcbiAgICAgICAgfShvKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICB2YXIgaGkgPSBmdW5jdGlvbiBoaSh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRUcmFuc2l0aW9uaW5nUHJvcGVydHlWYWx1ZXMpO1xuICAgIH07XG5cbiAgICBoaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gbmV3IGRpKHRoaXMuX3Byb3BlcnRpZXMpLCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgbi5fdmFsdWVzW29dID0gdGhpcy5fdmFsdWVzW29dLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH0sIGhpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2VbdF1dLnByaW9yKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuXG4gICAgdmFyIGZpID0gZnVuY3Rpb24gZmkodCkge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHQsIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUodC5kZWZhdWx0UHJvcGVydHlWYWx1ZXMpO1xuICAgIH07XG5cbiAgICBmaS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHcodGhpcy5fdmFsdWVzW3RdLnZhbHVlKTtcbiAgICB9LCBmaS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fdmFsdWVzW3RdID0gbmV3IHVpKHRoaXMuX3ZhbHVlc1t0XS5wcm9wZXJ0eSwgbnVsbCA9PT0gZSA/IHZvaWQgMCA6IHcoZSkpO1xuICAgIH0sIGZpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0ge30sIGUgPSAwLCByID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdLFxuICAgICAgICAgICAgaSA9IHRoaXMuZ2V0VmFsdWUobik7XG4gICAgICAgIHZvaWQgMCAhPT0gaSAmJiAodFtuXSA9IGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBmaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gbmV3IGRpKHRoaXMuX3Byb3BlcnRpZXMpLCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgbi5fdmFsdWVzW29dID0gdGhpcy5fdmFsdWVzW29dLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH07XG5cbiAgICB2YXIgeWkgPSBmdW5jdGlvbiB5aSh0LCBlLCByKSB7XG4gICAgICB0aGlzLnByb3BlcnR5ID0gdCwgdGhpcy52YWx1ZSA9IGUsIHRoaXMucGFyYW1ldGVycyA9IHI7XG4gICAgfTtcblxuICAgIHlpLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiY29uc3RhbnRcIiA9PT0gdGhpcy52YWx1ZS5raW5kO1xuICAgIH0sIHlpLnByb3RvdHlwZS5jb25zdGFudE9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBcImNvbnN0YW50XCIgPT09IHRoaXMudmFsdWUua2luZCA/IHRoaXMudmFsdWUudmFsdWUgOiB0O1xuICAgIH0sIHlpLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5ldmFsdWF0ZSh0aGlzLnZhbHVlLCB0aGlzLnBhcmFtZXRlcnMsIHQsIGUsIHIsIG4pO1xuICAgIH07XG5cbiAgICB2YXIgZGkgPSBmdW5jdGlvbiBkaSh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRQb3NzaWJseUV2YWx1YXRlZFZhbHVlcyk7XG4gICAgfTtcblxuICAgIGRpLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1t0XTtcbiAgICB9O1xuXG4gICAgdmFyIG1pID0gZnVuY3Rpb24gbWkodCkge1xuICAgICAgdGhpcy5zcGVjaWZpY2F0aW9uID0gdDtcbiAgICB9O1xuXG4gICAgbWkucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlKTtcbiAgICB9LCBtaS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBHZVt0aGlzLnNwZWNpZmljYXRpb24udHlwZV07XG4gICAgICByZXR1cm4gbiA/IG4odCwgZSwgcikgOiB0O1xuICAgIH07XG5cbiAgICB2YXIgdmkgPSBmdW5jdGlvbiB2aSh0LCBlKSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0LCB0aGlzLm92ZXJyaWRlcyA9IGU7XG4gICAgfTtcblxuICAgIHZpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBuZXcgeWkodGhpcywgXCJjb25zdGFudFwiID09PSB0LmV4cHJlc3Npb24ua2luZCB8fCBcImNhbWVyYVwiID09PSB0LmV4cHJlc3Npb24ua2luZCA/IHtcbiAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICB2YWx1ZTogdC5leHByZXNzaW9uLmV2YWx1YXRlKGUsIG51bGwsIHt9LCByLCBuKVxuICAgICAgfSA6IHQuZXhwcmVzc2lvbiwgZSk7XG4gICAgfSwgdmkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmIChcImNvbnN0YW50XCIgIT09IHQudmFsdWUua2luZCB8fCBcImNvbnN0YW50XCIgIT09IGUudmFsdWUua2luZCkgcmV0dXJuIHQ7XG4gICAgICBpZiAodm9pZCAwID09PSB0LnZhbHVlLnZhbHVlIHx8IHZvaWQgMCA9PT0gZS52YWx1ZS52YWx1ZSkgcmV0dXJuIG5ldyB5aSh0aGlzLCB7XG4gICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfSwgdC5wYXJhbWV0ZXJzKTtcbiAgICAgIHZhciBuID0gR2VbdGhpcy5zcGVjaWZpY2F0aW9uLnR5cGVdO1xuICAgICAgcmV0dXJuIG4gPyBuZXcgeWkodGhpcywge1xuICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgIHZhbHVlOiBuKHQudmFsdWUudmFsdWUsIGUudmFsdWUudmFsdWUsIHIpXG4gICAgICB9LCB0LnBhcmFtZXRlcnMpIDogdDtcbiAgICB9LCB2aS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgcmV0dXJuIFwiY29uc3RhbnRcIiA9PT0gdC5raW5kID8gdC52YWx1ZSA6IHQuZXZhbHVhdGUoZSwgciwgbiwgaSwgYSk7XG4gICAgfTtcblxuICAgIHZhciBnaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICBpZiAodm9pZCAwID09PSB0LnZhbHVlKSByZXR1cm4gbmV3IHlpKHRoaXMsIHtcbiAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9LCBlKTtcblxuICAgICAgICBpZiAoXCJjb25zdGFudFwiID09PSB0LmV4cHJlc3Npb24ua2luZCkge1xuICAgICAgICAgIHZhciBpID0gdC5leHByZXNzaW9uLmV2YWx1YXRlKGUsIG51bGwsIHt9LCByLCBuKSxcbiAgICAgICAgICAgICAgYSA9IFwicmVzb2x2ZWRJbWFnZVwiID09PSB0LnByb3BlcnR5LnNwZWNpZmljYXRpb24udHlwZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBpID8gaS5uYW1lIDogaSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMuX2NhbGN1bGF0ZShhLCBhLCBhLCBlKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgeWkodGhpcywge1xuICAgICAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICAgICAgdmFsdWU6IG9cbiAgICAgICAgICB9LCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImNhbWVyYVwiID09PSB0LmV4cHJlc3Npb24ua2luZCkge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5fY2FsY3VsYXRlKHQuZXhwcmVzc2lvbi5ldmFsdWF0ZSh7XG4gICAgICAgICAgICB6b29tOiBlLnpvb20gLSAxXG4gICAgICAgICAgfSksIHQuZXhwcmVzc2lvbi5ldmFsdWF0ZSh7XG4gICAgICAgICAgICB6b29tOiBlLnpvb21cbiAgICAgICAgICB9KSwgdC5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IGUuem9vbSArIDFcbiAgICAgICAgICB9KSwgZSk7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IHlpKHRoaXMsIHtcbiAgICAgICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBzXG4gICAgICAgICAgfSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHlpKHRoaXMsIHQuZXhwcmVzc2lvbiwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIGlmIChcInNvdXJjZVwiID09PSB0LmtpbmQpIHtcbiAgICAgICAgICB2YXIgbyA9IHQuZXZhbHVhdGUoZSwgciwgbiwgaSwgYSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZShvLCBvLCBvLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcImNvbXBvc2l0ZVwiID09PSB0LmtpbmQgPyB0aGlzLl9jYWxjdWxhdGUodC5ldmFsdWF0ZSh7XG4gICAgICAgICAgem9vbTogTWF0aC5mbG9vcihlLnpvb20pIC0gMVxuICAgICAgICB9LCByLCBuKSwgdC5ldmFsdWF0ZSh7XG4gICAgICAgICAgem9vbTogTWF0aC5mbG9vcihlLnpvb20pXG4gICAgICAgIH0sIHIsIG4pLCB0LmV2YWx1YXRlKHtcbiAgICAgICAgICB6b29tOiBNYXRoLmZsb29yKGUuem9vbSkgKyAxXG4gICAgICAgIH0sIHIsIG4pLCBlKSA6IHQudmFsdWU7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fY2FsY3VsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgcmV0dXJuIG4uem9vbSA+IG4uem9vbUhpc3RvcnkubGFzdEludGVnZXJab29tID8ge1xuICAgICAgICAgIGZyb206IHQsXG4gICAgICAgICAgdG86IGVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBmcm9tOiByLFxuICAgICAgICAgIHRvOiBlXG4gICAgICAgIH07XG4gICAgICB9LCBlLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSwgZTtcbiAgICB9KHZpKSxcbiAgICAgICAgeGkgPSBmdW5jdGlvbiB4aSh0KSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0O1xuICAgIH07XG5cbiAgICB4aS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBpZiAodm9pZCAwICE9PSB0LnZhbHVlKSB7XG4gICAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHQuZXhwcmVzc2lvbi5raW5kKSB7XG4gICAgICAgICAgdmFyIGkgPSB0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSwgbnVsbCwge30sIHIsIG4pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGUoaSwgaSwgaSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgc2koTWF0aC5mbG9vcihlLnpvb20gLSAxKSwgZSkpLCB0LmV4cHJlc3Npb24uZXZhbHVhdGUobmV3IHNpKE1hdGguZmxvb3IoZS56b29tKSwgZSkpLCB0LmV4cHJlc3Npb24uZXZhbHVhdGUobmV3IHNpKE1hdGguZmxvb3IoZS56b29tICsgMSksIGUpKSwgZSk7XG4gICAgICB9XG4gICAgfSwgeGkucHJvdG90eXBlLl9jYWxjdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG4uem9vbSA+IG4uem9vbUhpc3RvcnkubGFzdEludGVnZXJab29tID8ge1xuICAgICAgICBmcm9tOiB0LFxuICAgICAgICB0bzogZVxuICAgICAgfSA6IHtcbiAgICAgICAgZnJvbTogcixcbiAgICAgICAgdG86IGVcbiAgICAgIH07XG4gICAgfSwgeGkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICB2YXIgYmkgPSBmdW5jdGlvbiBiaSh0KSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0O1xuICAgIH07XG5cbiAgICBiaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gISF0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSwgbnVsbCwge30sIHIsIG4pO1xuICAgIH0sIGJpLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuXG4gICAgdmFyIHdpID0gZnVuY3Rpb24gd2kodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLnByb3BlcnRpZXMgPSB0LCB0aGlzLmRlZmF1bHRQcm9wZXJ0eVZhbHVlcyA9IHt9LCB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uYWJsZVByb3BlcnR5VmFsdWVzID0ge30sIHRoaXMuZGVmYXVsdFRyYW5zaXRpb25pbmdQcm9wZXJ0eVZhbHVlcyA9IHt9LCB0aGlzLmRlZmF1bHRQb3NzaWJseUV2YWx1YXRlZFZhbHVlcyA9IHt9LCB0aGlzLm92ZXJyaWRhYmxlUHJvcGVydGllcyA9IFtdLCB0KSB7XG4gICAgICAgIHZhciByID0gdFtlXTtcbiAgICAgICAgci5zcGVjaWZpY2F0aW9uLm92ZXJyaWRhYmxlICYmIHRoaXMub3ZlcnJpZGFibGVQcm9wZXJ0aWVzLnB1c2goZSk7XG4gICAgICAgIHZhciBuID0gdGhpcy5kZWZhdWx0UHJvcGVydHlWYWx1ZXNbZV0gPSBuZXcgdWkociwgdm9pZCAwKSxcbiAgICAgICAgICAgIGkgPSB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uYWJsZVByb3BlcnR5VmFsdWVzW2VdID0gbmV3IGxpKHIpO1xuICAgICAgICB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uaW5nUHJvcGVydHlWYWx1ZXNbZV0gPSBpLnVudHJhbnNpdGlvbmVkKCksIHRoaXMuZGVmYXVsdFBvc3NpYmx5RXZhbHVhdGVkVmFsdWVzW2VdID0gbi5wb3NzaWJseUV2YWx1YXRlKHt9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT24oXCJEYXRhRHJpdmVuUHJvcGVydHlcIiwgdmkpLCBPbihcIkRhdGFDb25zdGFudFByb3BlcnR5XCIsIG1pKSwgT24oXCJDcm9zc0ZhZGVkRGF0YURyaXZlblByb3BlcnR5XCIsIGdpKSwgT24oXCJDcm9zc0ZhZGVkUHJvcGVydHlcIiwgeGkpLCBPbihcIkNvbG9yUmFtcFByb3BlcnR5XCIsIGJpKTtcblxuICAgIHZhciBfaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgaWYgKHQuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5fZmVhdHVyZUZpbHRlciA9IHtcbiAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5lZWRHZW9tZXRyeTogITFcbiAgICAgICAgfSwgXCJjdXN0b21cIiAhPT0gZS50eXBlICYmICh0aGlzLm1ldGFkYXRhID0gKGUgPSBlKS5tZXRhZGF0YSwgdGhpcy5taW56b29tID0gZS5taW56b29tLCB0aGlzLm1heHpvb20gPSBlLm1heHpvb20sIFwiYmFja2dyb3VuZFwiICE9PSBlLnR5cGUgJiYgKHRoaXMuc291cmNlID0gZS5zb3VyY2UsIHRoaXMuc291cmNlTGF5ZXIgPSBlW1wic291cmNlLWxheWVyXCJdLCB0aGlzLmZpbHRlciA9IGUuZmlsdGVyKSwgci5sYXlvdXQgJiYgKHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0ID0gbmV3IGZpKHIubGF5b3V0KSksIHIucGFpbnQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50ID0gbmV3IHBpKHIucGFpbnQpLCBlLnBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhaW50UHJvcGVydHkobiwgZS5wYWludFtuXSwge1xuICAgICAgICAgICAgICB2YWxpZGF0ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgaW4gZS5sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF5b3V0UHJvcGVydHkoaSwgZS5sYXlvdXRbaV0sIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGU6ICExXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uaW5nUGFpbnQgPSB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50LnVudHJhbnNpdGlvbmVkKCksIHRoaXMucGFpbnQgPSBuZXcgZGkoci5wYWludCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzZmFkZVBhcmFtZXRlcnM7XG4gICAgICB9LCBlLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcInZpc2liaWxpdHlcIiA9PT0gdCA/IHRoaXMudmlzaWJpbGl0eSA6IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0LmdldFZhbHVlKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0TGF5b3V0UHJvcGVydHkgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIG51bGwgIT0gZSAmJiB0aGlzLl92YWxpZGF0ZShNbiwgXCJsYXllcnMuXCIgKyB0aGlzLmlkICsgXCIubGF5b3V0LlwiICsgdCwgdCwgZSwgcikgfHwgKFwidmlzaWJpbGl0eVwiICE9PSB0ID8gdGhpcy5fdW5ldmFsdWF0ZWRMYXlvdXQuc2V0VmFsdWUodCwgZSkgOiB0aGlzLnZpc2liaWxpdHkgPSBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmdldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZyh0LCBcIi10cmFuc2l0aW9uXCIpID8gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5nZXRUcmFuc2l0aW9uKHQuc2xpY2UoMCwgLVwiLXRyYW5zaXRpb25cIi5sZW5ndGgpKSA6IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuZ2V0VmFsdWUodCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXRQYWludFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgbnVsbCAhPSBlICYmIHRoaXMuX3ZhbGlkYXRlKFBuLCBcImxheWVycy5cIiArIHRoaXMuaWQgKyBcIi5wYWludC5cIiArIHQsIHQsIGUsIHIpKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChnKHQsIFwiLXRyYW5zaXRpb25cIikpIHJldHVybiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50LnNldFRyYW5zaXRpb24odC5zbGljZSgwLCAtXCItdHJhbnNpdGlvblwiLmxlbmd0aCksIGUgfHwgdm9pZCAwKSwgITE7XG4gICAgICAgIHZhciBuID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW3RdLFxuICAgICAgICAgICAgaSA9IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIiA9PT0gbi5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uW1wicHJvcGVydHktdHlwZVwiXSxcbiAgICAgICAgICAgIGEgPSBuLnZhbHVlLmlzRGF0YURyaXZlbigpLFxuICAgICAgICAgICAgbyA9IG4udmFsdWU7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuc2V0VmFsdWUodCwgZSksIHRoaXMuX2hhbmRsZVNwZWNpYWxQYWludFByb3BlcnR5VXBkYXRlKHQpO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuX3ZhbHVlc1t0XS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHMuaXNEYXRhRHJpdmVuKCkgfHwgYSB8fCBpIHx8IHRoaXMuX2hhbmRsZU92ZXJyaWRhYmxlUGFpbnRQcm9wZXJ0eVVwZGF0ZSh0LCBvLCBzKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9oYW5kbGVTcGVjaWFsUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7fSwgZS5wcm90b3R5cGUuX2hhbmRsZU92ZXJyaWRhYmxlUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMubWluem9vbSAmJiB0IDwgdGhpcy5taW56b29tKSB8fCAhISh0aGlzLm1heHpvb20gJiYgdCA+PSB0aGlzLm1heHpvb20pIHx8IFwibm9uZVwiID09PSB0aGlzLnZpc2liaWxpdHk7XG4gICAgICB9LCBlLnByb3RvdHlwZS51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludCA9IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQudHJhbnNpdGlvbmVkKHQsIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50Lmhhc1RyYW5zaXRpb24oKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdC5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzICYmICh0aGlzLl9jcm9zc2ZhZGVQYXJhbWV0ZXJzID0gdC5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzKCkpLCB0aGlzLl91bmV2YWx1YXRlZExheW91dCAmJiAodGhpcy5sYXlvdXQgPSB0aGlzLl91bmV2YWx1YXRlZExheW91dC5wb3NzaWJseUV2YWx1YXRlKHQsIHZvaWQgMCwgZSkpLCB0aGlzLnBhaW50ID0gdGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50LnBvc3NpYmx5RXZhbHVhdGUodCwgdm9pZCAwLCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgXCJzb3VyY2UtbGF5ZXJcIjogdGhpcy5zb3VyY2VMYXllcixcbiAgICAgICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICBtaW56b29tOiB0aGlzLm1pbnpvb20sXG4gICAgICAgICAgbWF4em9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgbGF5b3V0OiB0aGlzLl91bmV2YWx1YXRlZExheW91dCAmJiB0aGlzLl91bmV2YWx1YXRlZExheW91dC5zZXJpYWxpemUoKSxcbiAgICAgICAgICBwYWludDogdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludCAmJiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50LnNlcmlhbGl6ZSgpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2liaWxpdHkgJiYgKHQubGF5b3V0ID0gdC5sYXlvdXQgfHwge30sIHQubGF5b3V0LnZpc2liaWxpdHkgPSB0aGlzLnZpc2liaWxpdHkpLCBiKHQsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuICEodm9pZCAwID09PSB0IHx8IFwibGF5b3V0XCIgPT09IGUgJiYgIU9iamVjdC5rZXlzKHQpLmxlbmd0aCB8fCBcInBhaW50XCIgPT09IGUgJiYgIU9iamVjdC5rZXlzKHQpLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgKCFpIHx8ICExICE9PSBpLnZhbGlkYXRlKSAmJiBCbih0aGlzLCB0LmNhbGwoQ24sIHtcbiAgICAgICAgICBrZXk6IGUsXG4gICAgICAgICAgbGF5ZXJUeXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgb2JqZWN0S2V5OiByLFxuICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgIHN0eWxlU3BlYzogRXQsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGdseXBoczogITAsXG4gICAgICAgICAgICBzcHJpdGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5pczNEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5pc1RpbGVDbGlwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5oYXNPZmZzY3JlZW5QYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUuaXNTdGF0ZURlcGVuZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnBhaW50Ll92YWx1ZXMpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMucGFpbnQuZ2V0KHQpO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgeWkgJiYgVHIoZS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uKSAmJiAoXCJzb3VyY2VcIiA9PT0gZS52YWx1ZS5raW5kIHx8IFwiY29tcG9zaXRlXCIgPT09IGUudmFsdWUua2luZCkgJiYgZS52YWx1ZS5pc1N0YXRlRGVwZW5kZW50KSByZXR1cm4gITA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlO1xuICAgIH0oQ3QpLFxuICAgICAgICBBaSA9IHtcbiAgICAgIEludDg6IEludDhBcnJheSxcbiAgICAgIFVpbnQ4OiBVaW50OEFycmF5LFxuICAgICAgSW50MTY6IEludDE2QXJyYXksXG4gICAgICBVaW50MTY6IFVpbnQxNkFycmF5LFxuICAgICAgSW50MzI6IEludDMyQXJyYXksXG4gICAgICBVaW50MzI6IFVpbnQzMkFycmF5LFxuICAgICAgRmxvYXQzMjogRmxvYXQzMkFycmF5XG4gICAgfSxcbiAgICAgICAgU2kgPSBmdW5jdGlvbiBTaSh0LCBlKSB7XG4gICAgICB0aGlzLl9zdHJ1Y3RBcnJheSA9IHQsIHRoaXMuX3BvczEgPSBlICogdGhpcy5zaXplLCB0aGlzLl9wb3MyID0gdGhpcy5fcG9zMSAvIDIsIHRoaXMuX3BvczQgPSB0aGlzLl9wb3MxIC8gNCwgdGhpcy5fcG9zOCA9IHRoaXMuX3BvczEgLyA4O1xuICAgIH0sXG4gICAgICAgIGtpID0gZnVuY3Rpb24ga2koKSB7XG4gICAgICB0aGlzLmlzVHJhbnNmZXJyZWQgPSAhMSwgdGhpcy5jYXBhY2l0eSA9IC0xLCB0aGlzLnJlc2l6ZSgwKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSWkodCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMSk7XG4gICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgbiA9IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZW1iZXJzOiB0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBpID0gQWlbdC50eXBlXS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgICAgICAgYSA9IHIgPSB6aShyLCBNYXRoLm1heChlLCBpKSksXG4gICAgICAgICAgICAgIG8gPSB0LmNvbXBvbmVudHMgfHwgMTtcbiAgICAgICAgICByZXR1cm4gbiA9IE1hdGgubWF4KG4sIGkpLCByICs9IGkgKiBvLCB7XG4gICAgICAgICAgICBuYW1lOiB0Lm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0LnR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBvLFxuICAgICAgICAgICAgb2Zmc2V0OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHNpemU6IHppKHIsIE1hdGgubWF4KG4sIGUpKSxcbiAgICAgICAgYWxpZ25tZW50OiBlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHppKHQsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodCAvIGUpICogZTtcbiAgICB9XG5cbiAgICBraS5zZXJpYWxpemUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHQuX3RyaW0oKSwgZSAmJiAodC5pc1RyYW5zZmVycmVkID0gITAsIGUucHVzaCh0LmFycmF5QnVmZmVyKSksIHtcbiAgICAgICAgbGVuZ3RoOiB0Lmxlbmd0aCxcbiAgICAgICAgYXJyYXlCdWZmZXI6IHQuYXJyYXlCdWZmZXJcbiAgICAgIH07XG4gICAgfSwga2kuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBlLmFycmF5QnVmZmVyID0gdC5hcnJheUJ1ZmZlciwgZS5sZW5ndGggPSB0Lmxlbmd0aCwgZS5jYXBhY2l0eSA9IHQuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAvIGUuYnl0ZXNQZXJFbGVtZW50LCBlLl9yZWZyZXNoVmlld3MoKSwgZTtcbiAgICB9LCBraS5wcm90b3R5cGUuX3RyaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxlbmd0aCAhPT0gdGhpcy5jYXBhY2l0eSAmJiAodGhpcy5jYXBhY2l0eSA9IHRoaXMubGVuZ3RoLCB0aGlzLmFycmF5QnVmZmVyID0gdGhpcy5hcnJheUJ1ZmZlci5zbGljZSgwLCB0aGlzLmxlbmd0aCAqIHRoaXMuYnl0ZXNQZXJFbGVtZW50KSwgdGhpcy5fcmVmcmVzaFZpZXdzKCkpO1xuICAgIH0sIGtpLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9LCBraS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMucmVzZXJ2ZSh0KSwgdGhpcy5sZW5ndGggPSB0O1xuICAgIH0sIGtpLnByb3RvdHlwZS5yZXNlcnZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0ID4gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gTWF0aC5tYXgodCwgTWF0aC5mbG9vcig1ICogdGhpcy5jYXBhY2l0eSksIDEyOCksIHRoaXMuYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5jYXBhY2l0eSAqIHRoaXMuYnl0ZXNQZXJFbGVtZW50KTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnVpbnQ4O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKSwgZSAmJiB0aGlzLnVpbnQ4LnNldChlKTtcbiAgICAgIH1cbiAgICB9LCBraS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9yZWZyZXNoVmlld3MoKSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggY29uY3JldGUgU3RydWN0QXJyYXkgbGF5b3V0XCIpO1xuICAgIH07XG5cbiAgICB2YXIgQ2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHIgKyAxKSwgdGhpcy5lbXBsYWNlKHIsIHQsIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W24gKyAwXSA9IGUsIHRoaXMuaW50MTZbbiArIDFdID0gciwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBDaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpNFwiLCBDaSk7XG5cbiAgICB2YXIgRWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGkgKyAxKSwgdGhpcy5lbXBsYWNlKGksIHQsIGUsIHIsIG4pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gNCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2EgKyAwXSA9IGUsIHRoaXMuaW50MTZbYSArIDFdID0gciwgdGhpcy5pbnQxNlthICsgMl0gPSBuLCB0aGlzLmludDE2W2EgKyAzXSA9IGksIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgRWkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ0aThcIiwgRWkpO1xuXG4gICAgdmFyIFBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShvICsgMSksIHRoaXMuZW1wbGFjZShvLCB0LCBlLCByLCBuLCBpLCBhKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICB2YXIgcyA9IDYgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltzICsgMF0gPSBlLCB0aGlzLmludDE2W3MgKyAxXSA9IHIsIHRoaXMuaW50MTZbcyArIDJdID0gbiwgdGhpcy5pbnQxNltzICsgM10gPSBpLCB0aGlzLmludDE2W3MgKyA0XSA9IGEsIHRoaXMuaW50MTZbcyArIDVdID0gbywgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBQaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTIsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyaTRpMTJcIiwgUGkpO1xuXG4gICAgdmFyIE1pID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShvICsgMSksIHRoaXMuZW1wbGFjZShvLCB0LCBlLCByLCBuLCBpLCBhKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICB2YXIgcyA9IDQgKiB0LFxuICAgICAgICAgICAgdSA9IDggKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltzICsgMF0gPSBlLCB0aGlzLmludDE2W3MgKyAxXSA9IHIsIHRoaXMudWludDhbdSArIDRdID0gbiwgdGhpcy51aW50OFt1ICsgNV0gPSBpLCB0aGlzLnVpbnQ4W3UgKyA2XSA9IGEsIHRoaXMudWludDhbdSArIDddID0gbywgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBNaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpNHViOFwiLCBNaSk7XG5cbiAgICB2YXIgQmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShyICsgMSksIHRoaXMuZW1wbGFjZShyLCB0LCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IDIgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyW24gKyAwXSA9IGUsIHRoaXMuZmxvYXQzMltuICsgMV0gPSByLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KGtpKTtcblxuICAgIEJpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA4LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MmY4XCIsIEJpKTtcblxuICAgIHZhciBUaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShwICsgMSksIHRoaXMuZW1wbGFjZShwLCB0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCkge1xuICAgICAgICB2YXIgYyA9IDEwICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDE2W2MgKyAwXSA9IGUsIHRoaXMudWludDE2W2MgKyAxXSA9IHIsIHRoaXMudWludDE2W2MgKyAyXSA9IG4sIHRoaXMudWludDE2W2MgKyAzXSA9IGksIHRoaXMudWludDE2W2MgKyA0XSA9IGEsIHRoaXMudWludDE2W2MgKyA1XSA9IG8sIHRoaXMudWludDE2W2MgKyA2XSA9IHMsIHRoaXMudWludDE2W2MgKyA3XSA9IHUsIHRoaXMudWludDE2W2MgKyA4XSA9IGwsIHRoaXMudWludDE2W2MgKyA5XSA9IHAsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgVGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDIwLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MTB1aTIwXCIsIFRpKTtcblxuICAgIHZhciBWaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGggKyAxKSwgdGhpcy5lbXBsYWNlKGgsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoKSB7XG4gICAgICAgIHZhciBmID0gMTIgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltmICsgMF0gPSBlLCB0aGlzLmludDE2W2YgKyAxXSA9IHIsIHRoaXMuaW50MTZbZiArIDJdID0gbiwgdGhpcy5pbnQxNltmICsgM10gPSBpLCB0aGlzLnVpbnQxNltmICsgNF0gPSBhLCB0aGlzLnVpbnQxNltmICsgNV0gPSBvLCB0aGlzLnVpbnQxNltmICsgNl0gPSBzLCB0aGlzLnVpbnQxNltmICsgN10gPSB1LCB0aGlzLmludDE2W2YgKyA4XSA9IGwsIHRoaXMuaW50MTZbZiArIDldID0gcCwgdGhpcy5pbnQxNltmICsgMTBdID0gYywgdGhpcy5pbnQxNltmICsgMTFdID0gaCwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBWaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMjQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ0aTR1aTRpMjRcIiwgVmkpO1xuXG4gICAgdmFyIEZpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobiArIDEpLCB0aGlzLmVtcGxhY2UobiwgdCwgZSwgcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSAzICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXQzMltpICsgMF0gPSBlLCB0aGlzLmZsb2F0MzJbaSArIDFdID0gciwgdGhpcy5mbG9hdDMyW2kgKyAyXSA9IG4sIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgRmkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDEyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0M2YxMlwiLCBGaSk7XG5cbiAgICB2YXIgRGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoZSArIDEpLCB0aGlzLmVtcGxhY2UoZSwgdCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyWzEgKiB0ICsgMF0gPSBlLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KGtpKTtcblxuICAgIERpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MXVsNFwiLCBEaSk7XG5cbiAgICB2YXIgTGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSkge1xuICAgICAgICB2YXIgbCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobCArIDEpLCB0aGlzLmVtcGxhY2UobCwgdCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgICAgdmFyIHAgPSAxMCAqIHQsXG4gICAgICAgICAgICBjID0gNSAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3AgKyAwXSA9IGUsIHRoaXMuaW50MTZbcCArIDFdID0gciwgdGhpcy5pbnQxNltwICsgMl0gPSBuLCB0aGlzLmludDE2W3AgKyAzXSA9IGksIHRoaXMuaW50MTZbcCArIDRdID0gYSwgdGhpcy5pbnQxNltwICsgNV0gPSBvLCB0aGlzLnVpbnQzMltjICsgM10gPSBzLCB0aGlzLnVpbnQxNltwICsgOF0gPSB1LCB0aGlzLnVpbnQxNltwICsgOV0gPSBsLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KGtpKTtcblxuICAgIExpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAyMCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDZpMXVsMnVpMjBcIiwgTGkpO1xuXG4gICAgdmFyIE9pID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShvICsgMSksIHRoaXMuZW1wbGFjZShvLCB0LCBlLCByLCBuLCBpLCBhKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICB2YXIgcyA9IDYgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltzICsgMF0gPSBlLCB0aGlzLmludDE2W3MgKyAxXSA9IHIsIHRoaXMuaW50MTZbcyArIDJdID0gbiwgdGhpcy5pbnQxNltzICsgM10gPSBpLCB0aGlzLmludDE2W3MgKyA0XSA9IGEsIHRoaXMuaW50MTZbcyArIDVdID0gbywgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBPaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTIsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyaTJpMmkxMlwiLCBPaSk7XG5cbiAgICB2YXIgUmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGEgKyAxKSwgdGhpcy5lbXBsYWNlKGEsIHQsIGUsIHIsIG4sIGkpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gNCAqIHQsXG4gICAgICAgICAgICBzID0gOCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbbyArIDBdID0gZSwgdGhpcy5mbG9hdDMyW28gKyAxXSA9IHIsIHRoaXMuZmxvYXQzMltvICsgMl0gPSBuLCB0aGlzLmludDE2W3MgKyA2XSA9IGksIHRoaXMuaW50MTZbcyArIDddID0gYSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBSaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTYsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyZjFmMmkxNlwiLCBSaSk7XG5cbiAgICB2YXIgVWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShpICsgMSksIHRoaXMuZW1wbGFjZShpLCB0LCBlLCByLCBuKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB2YXIgYSA9IDEyICogdCxcbiAgICAgICAgICAgIG8gPSAzICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDhbYSArIDBdID0gZSwgdGhpcy51aW50OFthICsgMV0gPSByLCB0aGlzLmZsb2F0MzJbbyArIDFdID0gbiwgdGhpcy5mbG9hdDMyW28gKyAyXSA9IGksIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgVWkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDEyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MnViMmYxMlwiLCBVaSk7XG5cbiAgICB2YXIgamkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobiArIDEpLCB0aGlzLmVtcGxhY2UobiwgdCwgZSwgcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSAzICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDE2W2kgKyAwXSA9IGUsIHRoaXMudWludDE2W2kgKyAxXSA9IHIsIHRoaXMudWludDE2W2kgKyAyXSA9IG4sIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgamkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDYsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQzdWk2XCIsIGppKTtcblxuICAgIHZhciBxaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZSh2ICsgMSksIHRoaXMuZW1wbGFjZSh2LCB0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCwgbSwgdikge1xuICAgICAgICB2YXIgZyA9IDI0ICogdCxcbiAgICAgICAgICAgIHggPSAxMiAqIHQsXG4gICAgICAgICAgICBiID0gNDggKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltnICsgMF0gPSBlLCB0aGlzLmludDE2W2cgKyAxXSA9IHIsIHRoaXMudWludDE2W2cgKyAyXSA9IG4sIHRoaXMudWludDE2W2cgKyAzXSA9IGksIHRoaXMudWludDMyW3ggKyAyXSA9IGEsIHRoaXMudWludDMyW3ggKyAzXSA9IG8sIHRoaXMudWludDMyW3ggKyA0XSA9IHMsIHRoaXMudWludDE2W2cgKyAxMF0gPSB1LCB0aGlzLnVpbnQxNltnICsgMTFdID0gbCwgdGhpcy51aW50MTZbZyArIDEyXSA9IHAsIHRoaXMuZmxvYXQzMlt4ICsgN10gPSBjLCB0aGlzLmZsb2F0MzJbeCArIDhdID0gaCwgdGhpcy51aW50OFtiICsgMzZdID0gZiwgdGhpcy51aW50OFtiICsgMzddID0geSwgdGhpcy51aW50OFtiICsgMzhdID0gZCwgdGhpcy51aW50MzJbeCArIDEwXSA9IG0sIHRoaXMuaW50MTZbZyArIDIyXSA9IHYsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgcWkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDQ4LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MmkydWkzdWwzdWkyZjN1YjF1bDFpNDhcIiwgcWkpO1xuXG4gICAgdmFyIE5pID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0sIHYsIGcsIHgsIGIsIHcsIF8sIEEsIFMsIGssIEksIHopIHtcbiAgICAgICAgdmFyIEMgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKEMgKyAxKSwgdGhpcy5lbXBsYWNlKEMsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0sIHYsIGcsIHgsIGIsIHcsIF8sIEEsIFMsIGssIEksIHopO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2LCBnLCB4LCBiLCB3LCBfLCBBLCBTLCBrLCBJLCB6LCBDKSB7XG4gICAgICAgIHZhciBFID0gMzQgKiB0LFxuICAgICAgICAgICAgUCA9IDE3ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbRSArIDBdID0gZSwgdGhpcy5pbnQxNltFICsgMV0gPSByLCB0aGlzLmludDE2W0UgKyAyXSA9IG4sIHRoaXMuaW50MTZbRSArIDNdID0gaSwgdGhpcy5pbnQxNltFICsgNF0gPSBhLCB0aGlzLmludDE2W0UgKyA1XSA9IG8sIHRoaXMuaW50MTZbRSArIDZdID0gcywgdGhpcy5pbnQxNltFICsgN10gPSB1LCB0aGlzLnVpbnQxNltFICsgOF0gPSBsLCB0aGlzLnVpbnQxNltFICsgOV0gPSBwLCB0aGlzLnVpbnQxNltFICsgMTBdID0gYywgdGhpcy51aW50MTZbRSArIDExXSA9IGgsIHRoaXMudWludDE2W0UgKyAxMl0gPSBmLCB0aGlzLnVpbnQxNltFICsgMTNdID0geSwgdGhpcy51aW50MTZbRSArIDE0XSA9IGQsIHRoaXMudWludDE2W0UgKyAxNV0gPSBtLCB0aGlzLnVpbnQxNltFICsgMTZdID0gdiwgdGhpcy51aW50MTZbRSArIDE3XSA9IGcsIHRoaXMudWludDE2W0UgKyAxOF0gPSB4LCB0aGlzLnVpbnQxNltFICsgMTldID0gYiwgdGhpcy51aW50MTZbRSArIDIwXSA9IHcsIHRoaXMudWludDE2W0UgKyAyMV0gPSBfLCB0aGlzLnVpbnQxNltFICsgMjJdID0gQSwgdGhpcy51aW50MzJbUCArIDEyXSA9IFMsIHRoaXMuZmxvYXQzMltQICsgMTNdID0gaywgdGhpcy5mbG9hdDMyW1AgKyAxNF0gPSBJLCB0aGlzLmZsb2F0MzJbUCArIDE1XSA9IHosIHRoaXMuZmxvYXQzMltQICsgMTZdID0gQywgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBOaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNjgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ4aTE1dWkxdWw0ZjY4XCIsIE5pKTtcblxuICAgIHZhciBLaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGUgKyAxKSwgdGhpcy5lbXBsYWNlKGUsIHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbMSAqIHQgKyAwXSA9IGUsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgS2kucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQxZjRcIiwgS2kpO1xuXG4gICAgdmFyIEdpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShuICsgMSksIHRoaXMuZW1wbGFjZShuLCB0LCBlLCByKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltpICsgMF0gPSBlLCB0aGlzLmludDE2W2kgKyAxXSA9IHIsIHRoaXMuaW50MTZbaSArIDJdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBHaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDNpNlwiLCBHaSk7XG5cbiAgICB2YXIgWmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG4gKyAxKSwgdGhpcy5lbXBsYWNlKG4sIHQsIGUsIHIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gNCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMlsyICogdCArIDBdID0gZSwgdGhpcy51aW50MTZbaSArIDJdID0gciwgdGhpcy51aW50MTZbaSArIDNdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShraSk7XG5cbiAgICBaaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDF1bDJ1aThcIiwgWmkpO1xuXG4gICAgdmFyIFhpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHIgKyAxKSwgdGhpcy5lbXBsYWNlKHIsIHQsIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQxNltuICsgMF0gPSBlLCB0aGlzLnVpbnQxNltuICsgMV0gPSByLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KGtpKTtcblxuICAgIFhpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MnVpNFwiLCBYaSk7XG5cbiAgICB2YXIgSmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoZSArIDEpLCB0aGlzLmVtcGxhY2UoZSwgdCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDE2WzEgKiB0ICsgMF0gPSBlLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KGtpKTtcblxuICAgIEppLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MXVpMlwiLCBKaSk7XG5cbiAgICB2YXIgSGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShpICsgMSksIHRoaXMuZW1wbGFjZShpLCB0LCBlLCByLCBuKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB2YXIgYSA9IDQgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyW2EgKyAwXSA9IGUsIHRoaXMuZmxvYXQzMlthICsgMV0gPSByLCB0aGlzLmZsb2F0MzJbYSArIDJdID0gbiwgdGhpcy5mbG9hdDMyW2EgKyAzXSA9IGksIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oa2kpO1xuXG4gICAgSGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDE2LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0NGYxNlwiLCBIaSk7XG5cbiAgICB2YXIgWWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgYW5jaG9yUG9pbnRYOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JQb2ludFk6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHgxOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB5MToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgeDI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHkyOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBmZWF0dXJlSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZUxheWVySW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGJ1Y2tldEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JQb2ludDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmFuY2hvclBvaW50WC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMF07XG4gICAgICB9LCByLmFuY2hvclBvaW50WS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMV07XG4gICAgICB9LCByLngxLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAyXTtcbiAgICAgIH0sIHIueTEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDNdO1xuICAgICAgfSwgci54Mi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgNF07XG4gICAgICB9LCByLnkyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA1XTtcbiAgICAgIH0sIHIuZmVhdHVyZUluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgM107XG4gICAgICB9LCByLnNvdXJjZUxheWVySW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA4XTtcbiAgICAgIH0sIHIuYnVja2V0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA5XTtcbiAgICAgIH0sIHIuYW5jaG9yUG9pbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGkodGhpcy5hbmNob3JQb2ludFgsIHRoaXMuYW5jaG9yUG9pbnRZKTtcbiAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgZTtcbiAgICB9KFNpKTtcblxuICAgIFlpLnByb3RvdHlwZS5zaXplID0gMjA7XG5cbiAgICB2YXIgJGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IFlpKHRoaXMsIHQpO1xuICAgICAgfSwgZTtcbiAgICB9KExpKTtcblxuICAgIE9uKFwiQ29sbGlzaW9uQm94QXJyYXlcIiwgJGkpO1xuXG4gICAgdmFyIFdpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlO1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIGFuY2hvclg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclk6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGdseXBoU3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtR2x5cGhzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUxlbmd0aDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2VnbWVudDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbG93ZXJTaXplOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB1cHBlclNpemU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVPZmZzZXRYOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsaW5lT2Zmc2V0WToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGluZ01vZGU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlZE9yaWVudGF0aW9uOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBoaWRkZW46IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzVGlsZUlEOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBhc3NvY2lhdGVkSWNvbkluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHIuYW5jaG9yWC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMF07XG4gICAgICB9LCByLmFuY2hvclkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDFdO1xuICAgICAgfSwgci5nbHlwaFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAyXTtcbiAgICAgIH0sIHIubnVtR2x5cGhzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCByLnZlcnRleFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAyXTtcbiAgICAgIH0sIHIubGluZVN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAzXTtcbiAgICAgIH0sIHIubGluZUxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDRdO1xuICAgICAgfSwgci5zZWdtZW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTBdO1xuICAgICAgfSwgci5sb3dlclNpemUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxMV07XG4gICAgICB9LCByLnVwcGVyU2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDEyXTtcbiAgICAgIH0sIHIubGluZU9mZnNldFguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgN107XG4gICAgICB9LCByLmxpbmVPZmZzZXRZLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmZsb2F0MzJbdGhpcy5fcG9zNCArIDhdO1xuICAgICAgfSwgci53cml0aW5nTW9kZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50OFt0aGlzLl9wb3MxICsgMzZdO1xuICAgICAgfSwgci5wbGFjZWRPcmllbnRhdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50OFt0aGlzLl9wb3MxICsgMzddO1xuICAgICAgfSwgci5wbGFjZWRPcmllbnRhdGlvbi5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zdHJ1Y3RBcnJheS51aW50OFt0aGlzLl9wb3MxICsgMzddID0gdDtcbiAgICAgIH0sIHIuaGlkZGVuLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzOF07XG4gICAgICB9LCByLmhpZGRlbi5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zdHJ1Y3RBcnJheS51aW50OFt0aGlzLl9wb3MxICsgMzhdID0gdDtcbiAgICAgIH0sIHIuY3Jvc3NUaWxlSUQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAxMF07XG4gICAgICB9LCByLmNyb3NzVGlsZUlELnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgMTBdID0gdDtcbiAgICAgIH0sIHIuYXNzb2NpYXRlZEljb25JbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMjJdO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBlO1xuICAgIH0oU2kpO1xuXG4gICAgV2kucHJvdG90eXBlLnNpemUgPSA0ODtcblxuICAgIHZhciBRaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2kodGhpcywgdCk7XG4gICAgICB9LCBlO1xuICAgIH0ocWkpO1xuXG4gICAgT24oXCJQbGFjZWRTeW1ib2xBcnJheVwiLCBRaSk7XG5cbiAgICB2YXIgdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgYW5jaG9yWDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYW5jaG9yWToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlZEljb25TeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGtleToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dEJveFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRCb3hFbmRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxUZXh0Qm94U3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxUZXh0Qm94RW5kSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGljb25Cb3hTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBpY29uQm94RW5kSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsSWNvbkJveFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsSWNvbkJveEVuZEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBmZWF0dXJlSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG51bUhvcml6b250YWxHbHlwaFZlcnRpY2VzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBudW1WZXJ0aWNhbEdseXBoVmVydGljZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG51bUljb25WZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtVmVydGljYWxJY29uVmVydGljZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHVzZVJ1bnRpbWVDb2xsaXNpb25DaXJjbGVzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBjcm9zc1RpbGVJRDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dEJveFNjYWxlOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0T2Zmc2V0MDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dE9mZnNldDE6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxpc2lvbkNpcmNsZURpYW1ldGVyOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHIuYW5jaG9yWC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMF07XG4gICAgICB9LCByLmFuY2hvclkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDFdO1xuICAgICAgfSwgci5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMl07XG4gICAgICB9LCByLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCByLmxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDRdO1xuICAgICAgfSwgci52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgNV07XG4gICAgICB9LCByLnBsYWNlZEljb25TeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgNl07XG4gICAgICB9LCByLnZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA3XTtcbiAgICAgIH0sIHIua2V5LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgOF07XG4gICAgICB9LCByLnRleHRCb3hTdGFydEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgOV07XG4gICAgICB9LCByLnRleHRCb3hFbmRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDEwXTtcbiAgICAgIH0sIHIudmVydGljYWxUZXh0Qm94U3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDExXTtcbiAgICAgIH0sIHIudmVydGljYWxUZXh0Qm94RW5kSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxMl07XG4gICAgICB9LCByLmljb25Cb3hTdGFydEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTNdO1xuICAgICAgfSwgci5pY29uQm94RW5kSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxNF07XG4gICAgICB9LCByLnZlcnRpY2FsSWNvbkJveFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxNV07XG4gICAgICB9LCByLnZlcnRpY2FsSWNvbkJveEVuZEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTZdO1xuICAgICAgfSwgci5mZWF0dXJlSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxN107XG4gICAgICB9LCByLm51bUhvcml6b250YWxHbHlwaFZlcnRpY2VzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMThdO1xuICAgICAgfSwgci5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxOV07XG4gICAgICB9LCByLm51bUljb25WZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDIwXTtcbiAgICAgIH0sIHIubnVtVmVydGljYWxJY29uVmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAyMV07XG4gICAgICB9LCByLnVzZVJ1bnRpbWVDb2xsaXNpb25DaXJjbGVzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMjJdO1xuICAgICAgfSwgci5jcm9zc1RpbGVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDEyXTtcbiAgICAgIH0sIHIuY3Jvc3NUaWxlSUQuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAxMl0gPSB0O1xuICAgICAgfSwgci50ZXh0Qm94U2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgMTNdO1xuICAgICAgfSwgci50ZXh0T2Zmc2V0MC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyAxNF07XG4gICAgICB9LCByLnRleHRPZmZzZXQxLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmZsb2F0MzJbdGhpcy5fcG9zNCArIDE1XTtcbiAgICAgIH0sIHIuY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgMTZdO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBlO1xuICAgIH0oU2kpO1xuXG4gICAgdGEucHJvdG90eXBlLnNpemUgPSA2ODtcblxuICAgIHZhciBlYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGEodGhpcywgdCk7XG4gICAgICB9LCBlO1xuICAgIH0oTmkpO1xuXG4gICAgT24oXCJTeW1ib2xJbnN0YW5jZUFycmF5XCIsIGVhKTtcblxuICAgIHZhciByYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldG9mZnNldFggPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyWzEgKiB0ICsgMF07XG4gICAgICB9LCBlO1xuICAgIH0oS2kpO1xuXG4gICAgT24oXCJHbHlwaE9mZnNldEFycmF5XCIsIHJhKTtcblxuICAgIHZhciBuYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldHggPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNlszICogdCArIDBdO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZ2V0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2WzMgKiB0ICsgMV07XG4gICAgICB9LCBlLnByb3RvdHlwZS5nZXR0aWxlVW5pdERpc3RhbmNlRnJvbUFuY2hvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2WzMgKiB0ICsgMl07XG4gICAgICB9LCBlO1xuICAgIH0oR2kpO1xuXG4gICAgT24oXCJTeW1ib2xMaW5lVmVydGV4QXJyYXlcIiwgbmEpO1xuXG4gICAgdmFyIGlhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlO1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIGZlYXR1cmVJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlTGF5ZXJJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYnVja2V0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5mZWF0dXJlSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAwXTtcbiAgICAgIH0sIHIuc291cmNlTGF5ZXJJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDJdO1xuICAgICAgfSwgci5idWNrZXRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDNdO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBlO1xuICAgIH0oU2kpO1xuXG4gICAgaWEucHJvdG90eXBlLnNpemUgPSA4O1xuXG4gICAgdmFyIGFhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpYSh0aGlzLCB0KTtcbiAgICAgIH0sIGU7XG4gICAgfShaaSk7XG5cbiAgICBPbihcIkZlYXR1cmVJbmRleEFycmF5XCIsIGFhKTtcblxuICAgIHZhciBvYSA9IElpKFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICAgIHNhID0gZnVuY3Rpb24gc2EodCkge1xuICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gW10pLCB0aGlzLnNlZ21lbnRzID0gdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdWEodCwgZSkge1xuICAgICAgcmV0dXJuIDI1NiAqICh0ID0gcChNYXRoLmZsb29yKHQpLCAwLCAyNTUpKSArIHAoTWF0aC5mbG9vcihlKSwgMCwgMjU1KTtcbiAgICB9XG5cbiAgICBzYS5wcm90b3R5cGUucHJlcGFyZVNlZ21lbnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0aGlzLnNlZ21lbnRzW3RoaXMuc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gdCA+IHNhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIICYmIEEoXCJNYXggdmVydGljZXMgcGVyIHNlZ21lbnQgaXMgXCIgKyBzYS5NQVhfVkVSVEVYX0FSUkFZX0xFTkdUSCArIFwiOiBidWNrZXQgcmVxdWVzdGVkIFwiICsgdCksICghaSB8fCBpLnZlcnRleExlbmd0aCArIHQgPiBzYS5NQVhfVkVSVEVYX0FSUkFZX0xFTkdUSCB8fCBpLnNvcnRLZXkgIT09IG4pICYmIChpID0ge1xuICAgICAgICB2ZXJ0ZXhPZmZzZXQ6IGUubGVuZ3RoLFxuICAgICAgICBwcmltaXRpdmVPZmZzZXQ6IHIubGVuZ3RoLFxuICAgICAgICB2ZXJ0ZXhMZW5ndGg6IDAsXG4gICAgICAgIHByaW1pdGl2ZUxlbmd0aDogMFxuICAgICAgfSwgdm9pZCAwICE9PSBuICYmIChpLnNvcnRLZXkgPSBuKSwgdGhpcy5zZWdtZW50cy5wdXNoKGkpKSwgaTtcbiAgICB9LCBzYS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHM7XG4gICAgfSwgc2EucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMCwgZSA9IHRoaXMuc2VnbWVudHM7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgIHZhciByID0gZVt0XTtcblxuICAgICAgICBmb3IgKHZhciBuIGluIHIudmFvcykge1xuICAgICAgICAgIHIudmFvc1tuXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBzYS5zaW1wbGVTZWdtZW50ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBuZXcgc2EoW3tcbiAgICAgICAgdmVydGV4T2Zmc2V0OiB0LFxuICAgICAgICBwcmltaXRpdmVPZmZzZXQ6IGUsXG4gICAgICAgIHZlcnRleExlbmd0aDogcixcbiAgICAgICAgcHJpbWl0aXZlTGVuZ3RoOiBuLFxuICAgICAgICB2YW9zOiB7fSxcbiAgICAgICAgc29ydEtleTogMFxuICAgICAgfV0pO1xuICAgIH0sIHNhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIID0gTWF0aC5wb3coMiwgMTYpIC0gMSwgT24oXCJTZWdtZW50VmVjdG9yXCIsIHNhKTtcbiAgICB2YXIgbGEgPSBJaShbe1xuICAgICAgbmFtZTogXCJhX3BhdHRlcm5fZnJvbVwiLFxuICAgICAgY29tcG9uZW50czogNCxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfcGF0dGVybl90b1wiLFxuICAgICAgY29tcG9uZW50czogNCxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfcGl4ZWxfcmF0aW9fZnJvbVwiLFxuICAgICAgY29tcG9uZW50czogMSxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfcGl4ZWxfcmF0aW9fdG9cIixcbiAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICB0eXBlOiBcIlVpbnQxNlwiXG4gICAgfV0pLFxuICAgICAgICBwYSA9IGUoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByLCBuLCBpLCBhLCBvLCBzLCB1LCBsO1xuXG4gICAgICAgIGZvciAobiA9IHQubGVuZ3RoIC0gKHIgPSAzICYgdC5sZW5ndGgpLCBpID0gZSwgbyA9IDM0MzI5MTgzNTMsIHMgPSA0NjE4NDU5MDcsIGwgPSAwOyBsIDwgbjspIHtcbiAgICAgICAgICB1ID0gMjU1ICYgdC5jaGFyQ29kZUF0KGwpIHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2wpKSA8PCA4IHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2wpKSA8PCAxNiB8ICgyNTUgJiB0LmNoYXJDb2RlQXQoKytsKSkgPDwgMjQsICsrbCwgaSA9IDI3NDkyICsgKDY1NTM1ICYgKGEgPSA1ICogKDY1NTM1ICYgKGkgPSAoaSBePSB1ID0gKDY1NTM1ICYgKHUgPSAodSA9ICg2NTUzNSAmIHUpICogbyArICgoKHUgPj4+IDE2KSAqIG8gJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTUgfCB1ID4+PiAxNykpICogcyArICgoKHUgPj4+IDE2KSAqIHMgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTMgfCBpID4+PiAxOSkpICsgKCg1ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1KSkgKyAoKDU4OTY0ICsgKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHUgPSAwLCByKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdSBePSAoMjU1ICYgdC5jaGFyQ29kZUF0KGwgKyAyKSkgPDwgMTY7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB1IF49ICgyNTUgJiB0LmNoYXJDb2RlQXQobCArIDEpKSA8PCA4O1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaSBePSB1ID0gKDY1NTM1ICYgKHUgPSAodSA9ICg2NTUzNSAmICh1IF49IDI1NSAmIHQuY2hhckNvZGVBdChsKSkpICogbyArICgoKHUgPj4+IDE2KSAqIG8gJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTUgfCB1ID4+PiAxNykpICogcyArICgoKHUgPj4+IDE2KSAqIHMgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpIF49IHQubGVuZ3RoLCBpID0gMjI0NjgyMjUwNyAqICg2NTUzNSAmIChpIF49IGkgPj4+IDE2KSkgKyAoKDIyNDY4MjI1MDcgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTUsIGkgPSAzMjY2NDg5OTA5ICogKDY1NTM1ICYgKGkgXj0gaSA+Pj4gMTMpKSArICgoMzI2NjQ4OTkwOSAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSwgKGkgXj0gaSA+Pj4gMTYpID4+PiAwO1xuICAgICAgfTtcbiAgICB9KSxcbiAgICAgICAgY2EgPSBlKGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByLCBuID0gdC5sZW5ndGgsIGkgPSBlIF4gbiwgYSA9IDA7IG4gPj0gNDspIHtcbiAgICAgICAgICByID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIChyID0gMjU1ICYgdC5jaGFyQ29kZUF0KGEpIHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2EpKSA8PCA4IHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2EpKSA8PCAxNiB8ICgyNTUgJiB0LmNoYXJDb2RlQXQoKythKSkgPDwgMjQpKSArICgoMTU0MDQ4MzQ3NyAqIChyID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpLCBpID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIGkpICsgKCgxNTQwNDgzNDc3ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgXiAociA9IDE1NDA0ODM0NzcgKiAoNjU1MzUgJiAociBePSByID4+PiAyNCkpICsgKCgxNTQwNDgzNDc3ICogKHIgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikpLCBuIC09IDQsICsrYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGkgXj0gKDI1NSAmIHQuY2hhckNvZGVBdChhICsgMikpIDw8IDE2O1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaSBePSAoMjU1ICYgdC5jaGFyQ29kZUF0KGEgKyAxKSkgPDwgODtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGkgPSAxNTQwNDgzNDc3ICogKDY1NTM1ICYgKGkgXj0gMjU1ICYgdC5jaGFyQ29kZUF0KGEpKSkgKyAoKDE1NDA0ODM0NzcgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIChpIF49IGkgPj4+IDEzKSkgKyAoKDE1NDA0ODM0NzcgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgKGkgXj0gaSA+Pj4gMTUpID4+PiAwO1xuICAgICAgfTtcbiAgICB9KSxcbiAgICAgICAgaGEgPSBwYSxcbiAgICAgICAgZmEgPSBjYTtcbiAgICBoYS5tdXJtdXIzID0gcGEsIGhhLm11cm11cjIgPSBmYTtcblxuICAgIHZhciB5YSA9IGZ1bmN0aW9uIHlhKCkge1xuICAgICAgdGhpcy5pZHMgPSBbXSwgdGhpcy5wb3NpdGlvbnMgPSBbXSwgdGhpcy5pbmRleGVkID0gITE7XG4gICAgfTtcblxuICAgIHlhLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5pZHMucHVzaChtYSh0KSksIHRoaXMucG9zaXRpb25zLnB1c2goZSwgciwgbik7XG4gICAgfSwgeWEucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gbWEodCksIHIgPSAwLCBuID0gdGhpcy5pZHMubGVuZ3RoIC0gMTsgciA8IG47KSB7XG4gICAgICAgIHZhciBpID0gciArIG4gPj4gMTtcbiAgICAgICAgdGhpcy5pZHNbaV0gPj0gZSA/IG4gPSBpIDogciA9IGkgKyAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBhID0gW107IHRoaXMuaWRzW3JdID09PSBlOykge1xuICAgICAgICBhLnB1c2goe1xuICAgICAgICAgIGluZGV4OiB0aGlzLnBvc2l0aW9uc1szICogcl0sXG4gICAgICAgICAgc3RhcnQ6IHRoaXMucG9zaXRpb25zWzMgKiByICsgMV0sXG4gICAgICAgICAgZW5kOiB0aGlzLnBvc2l0aW9uc1szICogciArIDJdXG4gICAgICAgIH0pLCByKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH0sIHlhLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBGbG9hdDY0QXJyYXkodC5pZHMpLFxuICAgICAgICAgIG4gPSBuZXcgVWludDMyQXJyYXkodC5wb3NpdGlvbnMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHQoZSwgciwgbiwgaSkge1xuICAgICAgICBmb3IgKDsgbiA8IGk7KSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IGVbbiArIGkgPj4gMV0sIG8gPSBuIC0gMSwgcyA9IGkgKyAxOzspIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgbysrO1xuICAgICAgICAgICAgfSB3aGlsZSAoZVtvXSA8IGEpO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGVbc10gPiBhKTtcblxuICAgICAgICAgICAgaWYgKG8gPj0gcykgYnJlYWs7XG4gICAgICAgICAgICB2YShlLCBvLCBzKSwgdmEociwgMyAqIG8sIDMgKiBzKSwgdmEociwgMyAqIG8gKyAxLCAzICogcyArIDEpLCB2YShyLCAzICogbyArIDIsIDMgKiBzICsgMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcyAtIG4gPCBpIC0gcyA/ICh0KGUsIHIsIG4sIHMpLCBuID0gcyArIDEpIDogKHQoZSwgciwgcyArIDEsIGkpLCBpID0gcyk7XG4gICAgICAgIH1cbiAgICAgIH0ociwgbiwgMCwgci5sZW5ndGggLSAxKSwgZSAmJiBlLnB1c2goci5idWZmZXIsIG4uYnVmZmVyKSwge1xuICAgICAgICBpZHM6IHIsXG4gICAgICAgIHBvc2l0aW9uczogblxuICAgICAgfTtcbiAgICB9LCB5YS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyB5YSgpO1xuICAgICAgcmV0dXJuIGUuaWRzID0gdC5pZHMsIGUucG9zaXRpb25zID0gdC5wb3NpdGlvbnMsIGUuaW5kZXhlZCA9ICEwLCBlO1xuICAgIH07XG4gICAgdmFyIGRhID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIGZ1bmN0aW9uIG1hKHQpIHtcbiAgICAgIHZhciBlID0gK3Q7XG4gICAgICByZXR1cm4gIWlzTmFOKGUpICYmIGUgPD0gZGEgPyBlIDogaGEoU3RyaW5nKHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRbZV07XG4gICAgICB0W2VdID0gdFtyXSwgdFtyXSA9IG47XG4gICAgfVxuXG4gICAgT24oXCJGZWF0dXJlUG9zaXRpb25NYXBcIiwgeWEpO1xuXG4gICAgdmFyIGdhID0gZnVuY3Rpb24gZ2EodCwgZSkge1xuICAgICAgdGhpcy5nbCA9IHQuZ2wsIHRoaXMubG9jYXRpb24gPSBlO1xuICAgIH0sXG4gICAgICAgIHhhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCAhPT0gdCAmJiAodGhpcy5jdXJyZW50ID0gdCwgdGhpcy5nbC51bmlmb3JtMWkodGhpcy5sb2NhdGlvbiwgdCkpO1xuICAgICAgfSwgZTtcbiAgICB9KGdhKSxcbiAgICAgICAgYmEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5jdXJyZW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ICE9PSB0ICYmICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLmxvY2F0aW9uLCB0KSk7XG4gICAgICB9LCBlO1xuICAgIH0oZ2EpLFxuICAgICAgICB3YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRbMF0gPT09IHRoaXMuY3VycmVudFswXSAmJiB0WzFdID09PSB0aGlzLmN1cnJlbnRbMV0gfHwgKHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybTJmKHRoaXMubG9jYXRpb24sIHRbMF0sIHRbMV0pKTtcbiAgICAgIH0sIGU7XG4gICAgfShnYSksXG4gICAgICAgIF9hID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IFswLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdFswXSA9PT0gdGhpcy5jdXJyZW50WzBdICYmIHRbMV0gPT09IHRoaXMuY3VycmVudFsxXSAmJiB0WzJdID09PSB0aGlzLmN1cnJlbnRbMl0gfHwgKHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybTNmKHRoaXMubG9jYXRpb24sIHRbMF0sIHRbMV0sIHRbMl0pKTtcbiAgICAgIH0sIGU7XG4gICAgfShnYSksXG4gICAgICAgIEFhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdFswXSA9PT0gdGhpcy5jdXJyZW50WzBdICYmIHRbMV0gPT09IHRoaXMuY3VycmVudFsxXSAmJiB0WzJdID09PSB0aGlzLmN1cnJlbnRbMl0gJiYgdFszXSA9PT0gdGhpcy5jdXJyZW50WzNdIHx8ICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm00Zih0aGlzLmxvY2F0aW9uLCB0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKSk7XG4gICAgICB9LCBlO1xuICAgIH0oZ2EpLFxuICAgICAgICBTYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSB0ZS50cmFuc3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5yID09PSB0aGlzLmN1cnJlbnQuciAmJiB0LmcgPT09IHRoaXMuY3VycmVudC5nICYmIHQuYiA9PT0gdGhpcy5jdXJyZW50LmIgJiYgdC5hID09PSB0aGlzLmN1cnJlbnQuYSB8fCAodGhpcy5jdXJyZW50ID0gdCwgdGhpcy5nbC51bmlmb3JtNGYodGhpcy5sb2NhdGlvbiwgdC5yLCB0LmcsIHQuYiwgdC5hKSk7XG4gICAgICB9LCBlO1xuICAgIH0oZ2EpLFxuICAgICAgICBrYSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpLFxuICAgICAgICBJYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSBrYTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRbMTJdICE9PSB0aGlzLmN1cnJlbnRbMTJdIHx8IHRbMF0gIT09IHRoaXMuY3VycmVudFswXSkgcmV0dXJuIHRoaXMuY3VycmVudCA9IHQsIHZvaWQgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMubG9jYXRpb24sICExLCB0KTtcblxuICAgICAgICBmb3IgKHZhciBlID0gMTsgZSA8IDE2OyBlKyspIHtcbiAgICAgICAgICBpZiAodFtlXSAhPT0gdGhpcy5jdXJyZW50W2VdKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5sb2NhdGlvbiwgITEsIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oZ2EpO1xuXG4gICAgZnVuY3Rpb24gemEodCkge1xuICAgICAgcmV0dXJuIFt1YSgyNTUgKiB0LnIsIDI1NSAqIHQuZyksIHVhKDI1NSAqIHQuYiwgMjU1ICogdC5hKV07XG4gICAgfVxuXG4gICAgdmFyIENhID0gZnVuY3Rpb24gQ2EodCwgZSwgcikge1xuICAgICAgdGhpcy52YWx1ZSA9IHQsIHRoaXMudW5pZm9ybU5hbWVzID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidV9cIiArIHQ7XG4gICAgICB9KSwgdGhpcy50eXBlID0gcjtcbiAgICB9O1xuXG4gICAgQ2EucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdC5zZXQoci5jb25zdGFudE9yKHRoaXMudmFsdWUpKTtcbiAgICB9LCBDYS5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gXCJjb2xvclwiID09PSB0aGlzLnR5cGUgPyBuZXcgU2EodCwgZSkgOiBuZXcgYmEodCwgZSk7XG4gICAgfTtcblxuICAgIHZhciBFYSA9IGZ1bmN0aW9uIEVhKHQsIGUpIHtcbiAgICAgIHRoaXMudW5pZm9ybU5hbWVzID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidV9cIiArIHQ7XG4gICAgICB9KSwgdGhpcy5wYXR0ZXJuRnJvbSA9IG51bGwsIHRoaXMucGF0dGVyblRvID0gbnVsbCwgdGhpcy5waXhlbFJhdGlvRnJvbSA9IDEsIHRoaXMucGl4ZWxSYXRpb1RvID0gMTtcbiAgICB9O1xuXG4gICAgRWEucHJvdG90eXBlLnNldENvbnN0YW50UGF0dGVyblBvc2l0aW9ucyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnBpeGVsUmF0aW9Gcm9tID0gZS5waXhlbFJhdGlvLCB0aGlzLnBpeGVsUmF0aW9UbyA9IHQucGl4ZWxSYXRpbywgdGhpcy5wYXR0ZXJuRnJvbSA9IGUudGxiciwgdGhpcy5wYXR0ZXJuVG8gPSB0LnRsYnI7XG4gICAgfSwgRWEucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBcInVfcGF0dGVybl90b1wiID09PSBuID8gdGhpcy5wYXR0ZXJuVG8gOiBcInVfcGF0dGVybl9mcm9tXCIgPT09IG4gPyB0aGlzLnBhdHRlcm5Gcm9tIDogXCJ1X3BpeGVsX3JhdGlvX3RvXCIgPT09IG4gPyB0aGlzLnBpeGVsUmF0aW9UbyA6IFwidV9waXhlbF9yYXRpb19mcm9tXCIgPT09IG4gPyB0aGlzLnBpeGVsUmF0aW9Gcm9tIDogbnVsbDtcbiAgICAgIGkgJiYgdC5zZXQoaSk7XG4gICAgfSwgRWEucHJvdG90eXBlLmdldEJpbmRpbmcgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIFwidV9wYXR0ZXJuXCIgPT09IHIuc3Vic3RyKDAsIDkpID8gbmV3IEFhKHQsIGUpIDogbmV3IGJhKHQsIGUpO1xuICAgIH07XG5cbiAgICB2YXIgUGEgPSBmdW5jdGlvbiBQYSh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSB0LCB0aGlzLnR5cGUgPSByLCB0aGlzLm1heFZhbHVlID0gMCwgdGhpcy5wYWludFZlcnRleEF0dHJpYnV0ZXMgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiYV9cIiArIHQsXG4gICAgICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICAgICAgY29tcG9uZW50czogXCJjb2xvclwiID09PSByID8gMiA6IDEsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICB9KSwgdGhpcy5wYWludFZlcnRleEFycmF5ID0gbmV3IG4oKTtcbiAgICB9O1xuXG4gICAgUGEucHJvdG90eXBlLnBvcHVsYXRlUGFpbnRBcnJheSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5sZW5ndGgsXG4gICAgICAgICAgbyA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgc2koMCksIGUsIHt9LCBuLCBbXSwgaSk7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkucmVzaXplKHQpLCB0aGlzLl9zZXRQYWludFZhbHVlKGEsIHQsIG8pO1xuICAgIH0sIFBhLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgem9vbTogMFxuICAgICAgfSwgciwgbik7XG5cbiAgICAgIHRoaXMuX3NldFBhaW50VmFsdWUodCwgZSwgaSk7XG4gICAgfSwgUGEucHJvdG90eXBlLl9zZXRQYWludFZhbHVlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmIChcImNvbG9yXCIgPT09IHRoaXMudHlwZSkgZm9yICh2YXIgbiA9IHphKHIpLCBpID0gdDsgaSA8IGU7IGkrKykge1xuICAgICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShpLCBuWzBdLCBuWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGEgPSB0OyBhIDwgZTsgYSsrKSB7XG4gICAgICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5LmVtcGxhY2UoYSwgcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5tYXhWYWx1ZSwgTWF0aC5hYnMocikpO1xuICAgICAgfVxuICAgIH0sIFBhLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5ICYmIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5hcnJheUJ1ZmZlciAmJiAodGhpcy5wYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLnBhaW50VmVydGV4QnVmZmVyLmJ1ZmZlciA/IHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YSh0aGlzLnBhaW50VmVydGV4QXJyYXkpIDogdGhpcy5wYWludFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMucGFpbnRWZXJ0ZXhBcnJheSwgdGhpcy5wYWludFZlcnRleEF0dHJpYnV0ZXMsIHRoaXMuZXhwcmVzc2lvbi5pc1N0YXRlRGVwZW5kZW50KSk7XG4gICAgfSwgUGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICB2YXIgTWEgPSBmdW5jdGlvbiBNYSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSB0LCB0aGlzLnVuaWZvcm1OYW1lcyA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcInVfXCIgKyB0ICsgXCJfdFwiO1xuICAgICAgfSksIHRoaXMudHlwZSA9IHIsIHRoaXMudXNlSW50ZWdlclpvb20gPSBuLCB0aGlzLnpvb20gPSBpLCB0aGlzLm1heFZhbHVlID0gMCwgdGhpcy5wYWludFZlcnRleEF0dHJpYnV0ZXMgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiYV9cIiArIHQsXG4gICAgICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICAgICAgY29tcG9uZW50czogXCJjb2xvclwiID09PSByID8gNCA6IDIsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICB9KSwgdGhpcy5wYWludFZlcnRleEFycmF5ID0gbmV3IGEoKTtcbiAgICB9O1xuXG4gICAgTWEucHJvdG90eXBlLnBvcHVsYXRlUGFpbnRBcnJheSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgc2kodGhpcy56b29tKSwgZSwge30sIG4sIFtdLCBpKSxcbiAgICAgICAgICBvID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyBzaSh0aGlzLnpvb20gKyAxKSwgZSwge30sIG4sIFtdLCBpKSxcbiAgICAgICAgICBzID0gdGhpcy5wYWludFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5yZXNpemUodCksIHRoaXMuX3NldFBhaW50VmFsdWUocywgdCwgYSwgbyk7XG4gICAgfSwgTWEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXkgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICB6b29tOiB0aGlzLnpvb21cbiAgICAgIH0sIHIsIG4pLFxuICAgICAgICAgIGEgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICB6b29tOiB0aGlzLnpvb20gKyAxXG4gICAgICB9LCByLCBuKTtcblxuICAgICAgdGhpcy5fc2V0UGFpbnRWYWx1ZSh0LCBlLCBpLCBhKTtcbiAgICB9LCBNYS5wcm90b3R5cGUuX3NldFBhaW50VmFsdWUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgaWYgKFwiY29sb3JcIiA9PT0gdGhpcy50eXBlKSBmb3IgKHZhciBpID0gemEociksIGEgPSB6YShuKSwgbyA9IHQ7IG8gPCBlOyBvKyspIHtcbiAgICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5LmVtcGxhY2UobywgaVswXSwgaVsxXSwgYVswXSwgYVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBzID0gdDsgcyA8IGU7IHMrKykge1xuICAgICAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5lbXBsYWNlKHMsIHIsIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMubWF4VmFsdWUsIE1hdGguYWJzKHIpLCBNYXRoLmFicyhuKSk7XG4gICAgICB9XG4gICAgfSwgTWEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy5wYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmICh0aGlzLnBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIuYnVmZmVyID8gdGhpcy5wYWludFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMucGFpbnRWZXJ0ZXhBcnJheSkgOiB0aGlzLnBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5wYWludFZlcnRleEFycmF5LCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpKTtcbiAgICB9LCBNYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5wYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfSwgTWEucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLnVzZUludGVnZXJab29tID8gTWF0aC5mbG9vcihlLnpvb20pIDogZS56b29tLFxuICAgICAgICAgIG4gPSBwKHRoaXMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0aW9uRmFjdG9yKHIsIHRoaXMuem9vbSwgdGhpcy56b29tICsgMSksIDAsIDEpO1xuICAgICAgdC5zZXQobik7XG4gICAgfSwgTWEucHJvdG90eXBlLmdldEJpbmRpbmcgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIG5ldyBiYSh0LCBlKTtcbiAgICB9O1xuXG4gICAgdmFyIEJhID0gZnVuY3Rpb24gQmEodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gdCwgdGhpcy50eXBlID0gZSwgdGhpcy51c2VJbnRlZ2VyWm9vbSA9IHIsIHRoaXMuem9vbSA9IG4sIHRoaXMubGF5ZXJJZCA9IGEsIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheSA9IG5ldyBpKCksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkgPSBuZXcgaSgpO1xuICAgIH07XG5cbiAgICBCYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICAgIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheS5yZXNpemUodCksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkucmVzaXplKHQpLCB0aGlzLl9zZXRQYWludFZhbHVlcyhuLCB0LCBlLnBhdHRlcm5zICYmIGUucGF0dGVybnNbdGhpcy5sYXllcklkXSwgcik7XG4gICAgfSwgQmEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy5fc2V0UGFpbnRWYWx1ZXModCwgZSwgci5wYXR0ZXJucyAmJiByLnBhdHRlcm5zW3RoaXMubGF5ZXJJZF0sIGkpO1xuICAgIH0sIEJhLnByb3RvdHlwZS5fc2V0UGFpbnRWYWx1ZXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgaWYgKG4gJiYgcikge1xuICAgICAgICB2YXIgaSA9IG5bci5taW5dLFxuICAgICAgICAgICAgYSA9IG5bci5taWRdLFxuICAgICAgICAgICAgbyA9IG5bci5tYXhdO1xuICAgICAgICBpZiAoaSAmJiBhICYmIG8pIGZvciAodmFyIHMgPSB0OyBzIDwgZTsgcysrKSB7XG4gICAgICAgICAgdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5LmVtcGxhY2UocywgYS50bFswXSwgYS50bFsxXSwgYS5iclswXSwgYS5iclsxXSwgaS50bFswXSwgaS50bFsxXSwgaS5iclswXSwgaS5iclsxXSwgYS5waXhlbFJhdGlvLCBpLnBpeGVsUmF0aW8pLCB0aGlzLnpvb21PdXRQYWludFZlcnRleEFycmF5LmVtcGxhY2UocywgYS50bFswXSwgYS50bFsxXSwgYS5iclswXSwgYS5iclsxXSwgby50bFswXSwgby50bFsxXSwgby5iclswXSwgby5iclsxXSwgYS5waXhlbFJhdGlvLCBvLnBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgQmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheS5hcnJheUJ1ZmZlciAmJiAodGhpcy56b29tSW5QYWludFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheSwgbGEubWVtYmVycywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpLCB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXksIGxhLm1lbWJlcnMsIHRoaXMuZXhwcmVzc2lvbi5pc1N0YXRlRGVwZW5kZW50KSk7XG4gICAgfSwgQmEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy56b29tSW5QYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHZhciBUYSA9IGZ1bmN0aW9uIFRhKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuYmluZGVycyA9IHt9LCB0aGlzLl9idWZmZXJzID0gW107XG4gICAgICB2YXIgbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHQucGFpbnQuX3ZhbHVlcykge1xuICAgICAgICBpZiAocihpKSkge1xuICAgICAgICAgIHZhciBhID0gdC5wYWludC5nZXQoaSk7XG5cbiAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIHlpICYmIFRyKGEucHJvcGVydHkuc3BlY2lmaWNhdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBvID0gRmEoaSwgdC50eXBlKSxcbiAgICAgICAgICAgICAgICBzID0gYS52YWx1ZSxcbiAgICAgICAgICAgICAgICB1ID0gYS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgbCA9IGEucHJvcGVydHkudXNlSW50ZWdlclpvb20sXG4gICAgICAgICAgICAgICAgcCA9IGEucHJvcGVydHkuc3BlY2lmaWNhdGlvbltcInByb3BlcnR5LXR5cGVcIl0sXG4gICAgICAgICAgICAgICAgYyA9IFwiY3Jvc3MtZmFkZWRcIiA9PT0gcCB8fCBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCIgPT09IHA7XG4gICAgICAgICAgICBpZiAoXCJjb25zdGFudFwiID09PSBzLmtpbmQpIHRoaXMuYmluZGVyc1tpXSA9IGMgPyBuZXcgRWEocy52YWx1ZSwgbykgOiBuZXcgQ2Eocy52YWx1ZSwgbywgdSksIG4ucHVzaChcIi91X1wiICsgaSk7ZWxzZSBpZiAoXCJzb3VyY2VcIiA9PT0gcy5raW5kIHx8IGMpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBEYShpLCB1LCBcInNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5iaW5kZXJzW2ldID0gYyA/IG5ldyBCYShzLCB1LCBsLCBlLCBoLCB0LmlkKSA6IG5ldyBQYShzLCBvLCB1LCBoKSwgbi5wdXNoKFwiL2FfXCIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBmID0gRGEoaSwgdSwgXCJjb21wb3NpdGVcIik7XG4gICAgICAgICAgICAgIHRoaXMuYmluZGVyc1tpXSA9IG5ldyBNYShzLCBvLCB1LCBsLCBlLCBmKSwgbi5wdXNoKFwiL3pfXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZUtleSA9IG4uc29ydCgpLmpvaW4oXCJcIik7XG4gICAgfTtcblxuICAgIFRhLnByb3RvdHlwZS5nZXRNYXhWYWx1ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuYmluZGVyc1t0XTtcbiAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUGEgfHwgZSBpbnN0YW5jZW9mIE1hID8gZS5tYXhWYWx1ZSA6IDA7XG4gICAgfSwgVGEucHJvdG90eXBlLnBvcHVsYXRlUGFpbnRBcnJheXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmJpbmRlcnNbYV07XG4gICAgICAgIChvIGluc3RhbmNlb2YgUGEgfHwgbyBpbnN0YW5jZW9mIE1hIHx8IG8gaW5zdGFuY2VvZiBCYSkgJiYgby5wb3B1bGF0ZVBhaW50QXJyYXkodCwgZSwgciwgbiwgaSk7XG4gICAgICB9XG4gICAgfSwgVGEucHJvdG90eXBlLnNldENvbnN0YW50UGF0dGVyblBvc2l0aW9ucyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgbiA9IHRoaXMuYmluZGVyc1tyXTtcbiAgICAgICAgbiBpbnN0YW5jZW9mIEVhICYmIG4uc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKHQsIGUpO1xuICAgICAgfVxuICAgIH0sIFRhLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5cyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9ICExO1xuXG4gICAgICBmb3IgKHZhciBvIGluIHQpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIHUgPSBlLmdldFBvc2l0aW9ucyhvKTsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgICB2YXIgbCA9IHVbc10sXG4gICAgICAgICAgICAgIHAgPSByLmZlYXR1cmUobC5pbmRleCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmJpbmRlcnNbY107XG5cbiAgICAgICAgICAgIGlmICgoaCBpbnN0YW5jZW9mIFBhIHx8IGggaW5zdGFuY2VvZiBNYSB8fCBoIGluc3RhbmNlb2YgQmEpICYmICEwID09PSBoLmV4cHJlc3Npb24uaXNTdGF0ZURlcGVuZGVudCkge1xuICAgICAgICAgICAgICB2YXIgZiA9IG4ucGFpbnQuZ2V0KGMpO1xuICAgICAgICAgICAgICBoLmV4cHJlc3Npb24gPSBmLnZhbHVlLCBoLnVwZGF0ZVBhaW50QXJyYXkobC5zdGFydCwgbC5lbmQsIHAsIHRbb10sIGkpLCBhID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFRhLnByb3RvdHlwZS5kZWZpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJpbmRlcnNbZV07XG4gICAgICAgIChyIGluc3RhbmNlb2YgQ2EgfHwgciBpbnN0YW5jZW9mIEVhKSAmJiB0LnB1c2guYXBwbHkodCwgci51bmlmb3JtTmFtZXMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiI2RlZmluZSBIQVNfVU5JRk9STV9cIiArIHQ7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSwgVGEucHJvdG90eXBlLmdldEJpbmRlckF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQYSB8fCByIGluc3RhbmNlb2YgTWEpIGZvciAodmFyIG4gPSAwOyBuIDwgci5wYWludFZlcnRleEF0dHJpYnV0ZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICB0LnB1c2goci5wYWludFZlcnRleEF0dHJpYnV0ZXNbbl0ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEJhKSBmb3IgKHZhciBpID0gMDsgaSA8IGxhLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0LnB1c2gobGEubWVtYmVyc1tpXS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBUYS5wcm90b3R5cGUuZ2V0QmluZGVyVW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBDYSB8fCByIGluc3RhbmNlb2YgRWEgfHwgciBpbnN0YW5jZW9mIE1hKSBmb3IgKHZhciBuID0gMCwgaSA9IHIudW5pZm9ybU5hbWVzOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIHQucHVzaChpW25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBUYS5wcm90b3R5cGUuZ2V0UGFpbnRWZXJ0ZXhCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnM7XG4gICAgfSwgVGEucHJvdG90eXBlLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gW107XG5cbiAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5iaW5kZXJzW25dO1xuICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIENhIHx8IGkgaW5zdGFuY2VvZiBFYSB8fCBpIGluc3RhbmNlb2YgTWEpIGZvciAodmFyIGEgPSAwLCBvID0gaS51bmlmb3JtTmFtZXM7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgdmFyIHMgPSBvW2FdO1xuXG4gICAgICAgICAgaWYgKGVbc10pIHtcbiAgICAgICAgICAgIHZhciB1ID0gaS5nZXRCaW5kaW5nKHQsIGVbc10sIHMpO1xuICAgICAgICAgICAgci5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogcyxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IG4sXG4gICAgICAgICAgICAgIGJpbmRpbmc6IHVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBUYS5wcm90b3R5cGUuc2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGEgPSBlOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IGFbaV0sXG4gICAgICAgICAgICBzID0gby5uYW1lLFxuICAgICAgICAgICAgdSA9IG8ucHJvcGVydHk7XG4gICAgICAgIHRoaXMuYmluZGVyc1t1XS5zZXRVbmlmb3JtKG8uYmluZGluZywgbiwgci5nZXQodSksIHMpO1xuICAgICAgfVxuICAgIH0sIFRhLnByb3RvdHlwZS51cGRhdGVQYWludEJ1ZmZlcnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLl9idWZmZXJzID0gW10sIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcblxuICAgICAgICBpZiAodCAmJiByIGluc3RhbmNlb2YgQmEpIHtcbiAgICAgICAgICB2YXIgbiA9IDIgPT09IHQuZnJvbVNjYWxlID8gci56b29tSW5QYWludFZlcnRleEJ1ZmZlciA6IHIuem9vbU91dFBhaW50VmVydGV4QnVmZmVyO1xuICAgICAgICAgIG4gJiYgdGhpcy5fYnVmZmVycy5wdXNoKG4pO1xuICAgICAgICB9IGVsc2UgKHIgaW5zdGFuY2VvZiBQYSB8fCByIGluc3RhbmNlb2YgTWEpICYmIHIucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5fYnVmZmVycy5wdXNoKHIucGFpbnRWZXJ0ZXhCdWZmZXIpO1xuICAgICAgfVxuICAgIH0sIFRhLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJpbmRlcnNbZV07XG4gICAgICAgIChyIGluc3RhbmNlb2YgUGEgfHwgciBpbnN0YW5jZW9mIE1hIHx8IHIgaW5zdGFuY2VvZiBCYSkgJiYgci51cGxvYWQodCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUGFpbnRCdWZmZXJzKCk7XG4gICAgfSwgVGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0IGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYmluZGVyc1t0XTtcbiAgICAgICAgKGUgaW5zdGFuY2VvZiBQYSB8fCBlIGluc3RhbmNlb2YgTWEgfHwgZSBpbnN0YW5jZW9mIEJhKSAmJiBlLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFZhID0gZnVuY3Rpb24gVmEodCwgZSwgcikge1xuICAgICAgdm9pZCAwID09PSByICYmIChyID0gZnVuY3Rpb24gcigpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zID0ge307XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9uc1thLmlkXSA9IG5ldyBUYShhLCBlLCByKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWVkc1VwbG9hZCA9ICExLCB0aGlzLl9mZWF0dXJlTWFwID0gbmV3IHlhKCksIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZhKHQsIGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IFtcIm9wYWNpdHlcIl0sXG4gICAgICAgIFwiaWNvbi1vcGFjaXR5XCI6IFtcIm9wYWNpdHlcIl0sXG4gICAgICAgIFwidGV4dC1jb2xvclwiOiBbXCJmaWxsX2NvbG9yXCJdLFxuICAgICAgICBcImljb24tY29sb3JcIjogW1wiZmlsbF9jb2xvclwiXSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjogW1wiaGFsb19jb2xvclwiXSxcbiAgICAgICAgXCJpY29uLWhhbG8tY29sb3JcIjogW1wiaGFsb19jb2xvclwiXSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiBbXCJoYWxvX2JsdXJcIl0sXG4gICAgICAgIFwiaWNvbi1oYWxvLWJsdXJcIjogW1wiaGFsb19ibHVyXCJdLFxuICAgICAgICBcInRleHQtaGFsby13aWR0aFwiOiBbXCJoYWxvX3dpZHRoXCJdLFxuICAgICAgICBcImljb24taGFsby13aWR0aFwiOiBbXCJoYWxvX3dpZHRoXCJdLFxuICAgICAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IFtcImdhcHdpZHRoXCJdLFxuICAgICAgICBcImxpbmUtcGF0dGVyblwiOiBbXCJwYXR0ZXJuX3RvXCIsIFwicGF0dGVybl9mcm9tXCIsIFwicGl4ZWxfcmF0aW9fdG9cIiwgXCJwaXhlbF9yYXRpb19mcm9tXCJdLFxuICAgICAgICBcImZpbGwtcGF0dGVyblwiOiBbXCJwYXR0ZXJuX3RvXCIsIFwicGF0dGVybl9mcm9tXCIsIFwicGl4ZWxfcmF0aW9fdG9cIiwgXCJwaXhlbF9yYXRpb19mcm9tXCJdLFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjogW1wicGF0dGVybl90b1wiLCBcInBhdHRlcm5fZnJvbVwiLCBcInBpeGVsX3JhdGlvX3RvXCIsIFwicGl4ZWxfcmF0aW9fZnJvbVwiXVxuICAgICAgfVt0XSB8fCBbdC5yZXBsYWNlKGUgKyBcIi1cIiwgXCJcIikucmVwbGFjZSgvLS9nLCBcIl9cIildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERhKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0ge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHNvdXJjZTogQmksXG4gICAgICAgICAgY29tcG9zaXRlOiBIaVxuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICBzb3VyY2U6IEtpLFxuICAgICAgICAgIGNvbXBvc2l0ZTogQmlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICAgICBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgICAgICAgICBzb3VyY2U6IFRpLFxuICAgICAgICAgICAgY29tcG9zaXRlOiBUaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgc291cmNlOiBUaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZTogVGlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiOiB7XG4gICAgICAgICAgICBzb3VyY2U6IFRpLFxuICAgICAgICAgICAgY29tcG9zaXRlOiBUaVxuICAgICAgICAgIH1cbiAgICAgICAgfVt0XTtcbiAgICAgIH0odCk7XG5cbiAgICAgIHJldHVybiBpICYmIGlbcl0gfHwgbltlXVtyXTtcbiAgICB9XG5cbiAgICBWYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5cyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBmb3IgKHZhciBvIGluIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW29dLnBvcHVsYXRlUGFpbnRBcnJheXModCwgZSwgbiwgaSwgYSk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgMCAhPT0gZS5pZCAmJiB0aGlzLl9mZWF0dXJlTWFwLmFkZChlLmlkLCByLCB0aGlzLl9idWZmZXJPZmZzZXQsIHQpLCB0aGlzLl9idWZmZXJPZmZzZXQgPSB0LCB0aGlzLm5lZWRzVXBsb2FkID0gITA7XG4gICAgfSwgVmEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhID0gcjsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICB0aGlzLm5lZWRzVXBsb2FkID0gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnNbby5pZF0udXBkYXRlUGFpbnRBcnJheXModCwgdGhpcy5fZmVhdHVyZU1hcCwgZSwgbywgbikgfHwgdGhpcy5uZWVkc1VwbG9hZDtcbiAgICAgIH1cbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9uc1t0XTtcbiAgICB9LCBWYS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzVXBsb2FkKSB7XG4gICAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9uc1tlXS51cGxvYWQodCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5lZWRzVXBsb2FkID0gITE7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0IGluIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW3RdLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9LCBPbihcIkNvbnN0YW50QmluZGVyXCIsIENhKSwgT24oXCJDcm9zc0ZhZGVkQ29uc3RhbnRCaW5kZXJcIiwgRWEpLCBPbihcIlNvdXJjZUV4cHJlc3Npb25CaW5kZXJcIiwgUGEpLCBPbihcIkNyb3NzRmFkZWRDb21wb3NpdGVCaW5kZXJcIiwgQmEpLCBPbihcIkNvbXBvc2l0ZUV4cHJlc3Npb25CaW5kZXJcIiwgTWEpLCBPbihcIlByb2dyYW1Db25maWd1cmF0aW9uXCIsIFRhLCB7XG4gICAgICBvbWl0OiBbXCJfYnVmZmVyc1wiXVxuICAgIH0pLCBPbihcIlByb2dyYW1Db25maWd1cmF0aW9uU2V0XCIsIFZhKTtcbiAgICB2YXIgTGEgPSBNYXRoLnBvdygyLCAxNCkgLSAxLFxuICAgICAgICBPYSA9IC1MYSAtIDE7XG5cbiAgICBmdW5jdGlvbiBSYSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gODE5MiAvIHQuZXh0ZW50LCByID0gdC5sb2FkR2VvbWV0cnkoKSwgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSByW25dLCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICB2YXIgbyA9IGlbYV0sXG4gICAgICAgICAgICAgIHMgPSBNYXRoLnJvdW5kKG8ueCAqIGUpLFxuICAgICAgICAgICAgICB1ID0gTWF0aC5yb3VuZChvLnkgKiBlKTtcbiAgICAgICAgICBvLnggPSBwKHMsIE9hLCBMYSksIG8ueSA9IHAodSwgT2EsIExhKSwgKHMgPCBvLnggfHwgcyA+IG8ueCArIDEgfHwgdSA8IG8ueSB8fCB1ID4gby55ICsgMSkgJiYgQShcIkdlb21ldHJ5IGV4Y2VlZHMgYWxsb3dlZCBleHRlbnQsIHJlZHVjZSB5b3VyIHZlY3RvciB0aWxlIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVhKHQsIGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHQudHlwZSxcbiAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgIHByb3BlcnRpZXM6IHQucHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IGUgPyBSYSh0KSA6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGphKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHQuZW1wbGFjZUJhY2soMiAqIGUgKyAobiArIDEpIC8gMiwgMiAqIHIgKyAoaSArIDEpIC8gMik7XG4gICAgfVxuXG4gICAgdmFyIHFhID0gZnVuY3Rpb24gcWEodCkge1xuICAgICAgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLmluZGV4ID0gdC5pbmRleCwgdGhpcy5oYXNQYXR0ZXJuID0gITEsIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgQ2koKSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IGppKCksIHRoaXMuc2VnbWVudHMgPSBuZXcgc2EoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgVmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcklkcyA9IHRoaXMubGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1N0YXRlRGVwZW5kZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTmEodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGlmIChXYShlLCB0W3JdKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKFdhKHQsIGVbbl0pKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIVhhKHQsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEthKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiAhIVdhKHQsIGUpIHx8ICEhSGEoZSwgdCwgcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR2EodCwgZSkge1xuICAgICAgaWYgKDEgPT09IHQubGVuZ3RoKSByZXR1cm4gJGEoZSwgdFswXSk7XG5cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICBmb3IgKHZhciBuID0gZVtyXSwgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKFdhKHQsIG5baV0pKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGlmICgkYShlLCB0W2FdKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgaWYgKFhhKHQsIGVbb10pKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBaYSh0LCBlLCByKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChYYSh0LCBlKSkgcmV0dXJuICEwO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgIGlmIChIYShlW25dLCB0LCByKSkgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoSGEodFtpXSwgZSwgcikpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFhhKHQsIGUpIHtcbiAgICAgIGlmICgwID09PSB0Lmxlbmd0aCB8fCAwID09PSBlLmxlbmd0aCkgcmV0dXJuICExO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSB0W3JdLCBpID0gdFtyICsgMV0sIGEgPSAwOyBhIDwgZS5sZW5ndGggLSAxOyBhKyspIHtcbiAgICAgICAgICBpZiAoSmEobiwgaSwgZVthXSwgZVthICsgMV0pKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEphKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBTKHQsIHIsIG4pICE9PSBTKGUsIHIsIG4pICYmIFModCwgZSwgcikgIT09IFModCwgZSwgbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSGEodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSByICogcjtcbiAgICAgIGlmICgxID09PSBlLmxlbmd0aCkgcmV0dXJuIHQuZGlzdFNxcihlWzBdKSA8IG47XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoWWEodCwgZVtpIC0gMV0sIGVbaV0pIDwgbikgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWWEodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlLmRpc3RTcXIocik7XG4gICAgICBpZiAoMCA9PT0gbikgcmV0dXJuIHQuZGlzdFNxcihlKTtcbiAgICAgIHZhciBpID0gKCh0LnggLSBlLngpICogKHIueCAtIGUueCkgKyAodC55IC0gZS55KSAqIChyLnkgLSBlLnkpKSAvIG47XG4gICAgICByZXR1cm4gdC5kaXN0U3FyKGkgPCAwID8gZSA6IGkgPiAxID8gciA6IHIuc3ViKGUpLl9tdWx0KGkpLl9hZGQoZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRhKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIsIG4sIGksIGEgPSAhMSwgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gKHIgPSB0W29dKS5sZW5ndGggLSAxOyBzIDwgci5sZW5ndGg7IHUgPSBzKyspIHtcbiAgICAgICAgICAobiA9IHJbc10pLnkgPiBlLnkgIT0gKGkgPSByW3VdKS55ID4gZS55ICYmIGUueCA8IChpLnggLSBuLngpICogKGUueSAtIG4ueSkgLyAoaS55IC0gbi55KSArIG4ueCAmJiAoYSA9ICFhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXYSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gITEsIG4gPSAwLCBpID0gdC5sZW5ndGggLSAxOyBuIDwgdC5sZW5ndGg7IGkgPSBuKyspIHtcbiAgICAgICAgdmFyIGEgPSB0W25dLFxuICAgICAgICAgICAgbyA9IHRbaV07XG4gICAgICAgIGEueSA+IGUueSAhPSBvLnkgPiBlLnkgJiYgZS54IDwgKG8ueCAtIGEueCkgKiAoZS55IC0gYS55KSAvIChvLnkgLSBhLnkpICsgYS54ICYmIChyID0gIXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBRYSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHJbMF0sXG4gICAgICAgICAgaSA9IHJbMl07XG4gICAgICBpZiAodC54IDwgbi54ICYmIGUueCA8IG4ueCB8fCB0LnggPiBpLnggJiYgZS54ID4gaS54IHx8IHQueSA8IG4ueSAmJiBlLnkgPCBuLnkgfHwgdC55ID4gaS55ICYmIGUueSA+IGkueSkgcmV0dXJuICExO1xuICAgICAgdmFyIGEgPSBTKHQsIGUsIHJbMF0pO1xuICAgICAgcmV0dXJuIGEgIT09IFModCwgZSwgclsxXSkgfHwgYSAhPT0gUyh0LCBlLCByWzJdKSB8fCBhICE9PSBTKHQsIGUsIHJbM10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZS5wYWludC5nZXQodCkudmFsdWU7XG4gICAgICByZXR1cm4gXCJjb25zdGFudFwiID09PSBuLmtpbmQgPyBuLnZhbHVlIDogci5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KGUuaWQpLmdldE1heFZhbHVlKHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVvKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodFswXSAqIHRbMF0gKyB0WzFdICogdFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm8odCwgZSwgciwgbiwgYSkge1xuICAgICAgaWYgKCFlWzBdICYmICFlWzFdKSByZXR1cm4gdDtcblxuICAgICAgdmFyIG8gPSBpLmNvbnZlcnQoZSkuX211bHQoYSk7XG5cbiAgICAgIFwidmlld3BvcnRcIiA9PT0gciAmJiBvLl9yb3RhdGUoLW4pO1xuXG4gICAgICBmb3IgKHZhciBzID0gW10sIHUgPSAwOyB1IDwgdC5sZW5ndGg7IHUrKykge1xuICAgICAgICBzLnB1c2godFt1XS5zdWIobykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBxYS5wcm90b3R5cGUucG9wdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0aGlzLmxheWVyc1swXSxcbiAgICAgICAgICBpID0gW10sXG4gICAgICAgICAgYSA9IG51bGw7XG4gICAgICBcImNpcmNsZVwiID09PSBuLnR5cGUgJiYgKGEgPSBuLmxheW91dC5nZXQoXCJjaXJjbGUtc29ydC1rZXlcIikpO1xuXG4gICAgICBmb3IgKHZhciBvID0gMCwgcyA9IHQ7IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgIHZhciB1ID0gc1tvXSxcbiAgICAgICAgICAgIGwgPSB1LmZlYXR1cmUsXG4gICAgICAgICAgICBwID0gdS5pZCxcbiAgICAgICAgICAgIGMgPSB1LmluZGV4LFxuICAgICAgICAgICAgaCA9IHUuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICAgIGYgPSB0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5uZWVkR2VvbWV0cnksXG4gICAgICAgICAgICB5ID0gVWEobCwgZik7XG5cbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLmZpbHRlcihuZXcgc2kodGhpcy56b29tKSwgeSwgcikpIHtcbiAgICAgICAgICB2YXIgZCA9IGEgPyBhLmV2YWx1YXRlKHksIHt9LCByKSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgIGlkOiBwLFxuICAgICAgICAgICAgcHJvcGVydGllczogbC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdHlwZTogbC50eXBlLFxuICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogaCxcbiAgICAgICAgICAgIGluZGV4OiBjLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IGYgPyB5Lmdlb21ldHJ5IDogUmEobCksXG4gICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICBzb3J0S2V5OiBkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYSAmJiBpLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciB2ID0gMCwgZyA9IGk7IHYgPCBnLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgIHZhciB4ID0gZ1t2XSxcbiAgICAgICAgICAgIGIgPSB4Lmdlb21ldHJ5LFxuICAgICAgICAgICAgdyA9IHguaW5kZXgsXG4gICAgICAgICAgICBfID0geC5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgQSA9IHRbd10uZmVhdHVyZTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKHgsIGIsIHcsIHIpLCBlLmZlYXR1cmVJbmRleC5pbnNlcnQoQSwgYiwgdywgXywgdGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgfSwgcWEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLmxlbmd0aCAmJiB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGRhdGVQYWludEFycmF5cyh0LCBlLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLCByKTtcbiAgICB9LCBxYS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICB9LCBxYS5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZDtcbiAgICB9LCBxYS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudXBsb2FkZWQgfHwgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgb2EpLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkpKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBsb2FkKHQpLCB0aGlzLnVwbG9hZGVkID0gITA7XG4gICAgfSwgcWEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZGVzdHJveSgpLCB0aGlzLnNlZ21lbnRzLmRlc3Ryb3koKSk7XG4gICAgfSwgcWEucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGEgPSBlOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IGFbaV07IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgICBsID0gdS54LFxuICAgICAgICAgICAgICBwID0gdS55O1xuXG4gICAgICAgICAgaWYgKCEobCA8IDAgfHwgbCA+PSA4MTkyIHx8IHAgPCAwIHx8IHAgPj0gODE5MikpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCg0LCB0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmluZGV4QXJyYXksIHQuc29ydEtleSksXG4gICAgICAgICAgICAgICAgaCA9IGMudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgamEodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgbCwgcCwgLTEsIC0xKSwgamEodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgbCwgcCwgMSwgLTEpLCBqYSh0aGlzLmxheW91dFZlcnRleEFycmF5LCBsLCBwLCAxLCAxKSwgamEodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgbCwgcCwgLTEsIDEpLCB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaCwgaCArIDEsIGggKyAyKSwgdGhpcy5pbmRleEFycmF5LmVtcGxhY2VCYWNrKGgsIGggKyAzLCBoICsgMiksIGMudmVydGV4TGVuZ3RoICs9IDQsIGMucHJpbWl0aXZlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnBvcHVsYXRlUGFpbnRBcnJheXModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGgsIHQsIHIsIHt9LCBuKTtcbiAgICB9LCBPbihcIkNpcmNsZUJ1Y2tldFwiLCBxYSwge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCJdXG4gICAgfSk7XG4gICAgdmFyIG5vID0gbmV3IHdpKHtcbiAgICAgIFwiY2lyY2xlLXNvcnQta2V5XCI6IG5ldyB2aShFdC5sYXlvdXRfY2lyY2xlW1wiY2lyY2xlLXNvcnQta2V5XCJdKVxuICAgIH0pLFxuICAgICAgICBpbyA9IHtcbiAgICAgIHBhaW50OiBuZXcgd2koe1xuICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogbmV3IHZpKEV0LnBhaW50X2NpcmNsZVtcImNpcmNsZS1yYWRpdXNcIl0pLFxuICAgICAgICBcImNpcmNsZS1jb2xvclwiOiBuZXcgdmkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLWNvbG9yXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtYmx1clwiOiBuZXcgdmkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLWJsdXJcIl0pLFxuICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IG5ldyB2aShFdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtb3BhY2l0eVwiXSksXG4gICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiBuZXcgbWkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IG1pKEV0LnBhaW50X2NpcmNsZVtcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjogbmV3IG1pKEV0LnBhaW50X2NpcmNsZVtcImNpcmNsZS1waXRjaC1zY2FsZVwiXSksXG4gICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiBuZXcgbWkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiXSksXG4gICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiBuZXcgdmkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXN0cm9rZS13aWR0aFwiXSksXG4gICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiBuZXcgdmkoRXQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXN0cm9rZS1jb2xvclwiXSksXG4gICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IG5ldyB2aShFdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIl0pXG4gICAgICB9KSxcbiAgICAgIGxheW91dDogbm9cbiAgICB9LFxuICAgICAgICBhbyA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEZsb2F0MzJBcnJheSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuXG4gICAgZnVuY3Rpb24gb28odCkge1xuICAgICAgcmV0dXJuIHRbMF0gPSAxLCB0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwLCB0WzRdID0gMCwgdFs1XSA9IDEsIHRbNl0gPSAwLCB0WzddID0gMCwgdFs4XSA9IDAsIHRbOV0gPSAwLCB0WzEwXSA9IDEsIHRbMTFdID0gMCwgdFsxMl0gPSAwLCB0WzEzXSA9IDAsIHRbMTRdID0gMCwgdFsxNV0gPSAxLCB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgICBpID0gZVsxXSxcbiAgICAgICAgICBhID0gZVsyXSxcbiAgICAgICAgICBvID0gZVszXSxcbiAgICAgICAgICBzID0gZVs0XSxcbiAgICAgICAgICB1ID0gZVs1XSxcbiAgICAgICAgICBsID0gZVs2XSxcbiAgICAgICAgICBwID0gZVs3XSxcbiAgICAgICAgICBjID0gZVs4XSxcbiAgICAgICAgICBoID0gZVs5XSxcbiAgICAgICAgICBmID0gZVsxMF0sXG4gICAgICAgICAgeSA9IGVbMTFdLFxuICAgICAgICAgIGQgPSBlWzEyXSxcbiAgICAgICAgICBtID0gZVsxM10sXG4gICAgICAgICAgdiA9IGVbMTRdLFxuICAgICAgICAgIGcgPSBlWzE1XSxcbiAgICAgICAgICB4ID0gclswXSxcbiAgICAgICAgICBiID0gclsxXSxcbiAgICAgICAgICB3ID0gclsyXSxcbiAgICAgICAgICBfID0gclszXTtcbiAgICAgIHJldHVybiB0WzBdID0geCAqIG4gKyBiICogcyArIHcgKiBjICsgXyAqIGQsIHRbMV0gPSB4ICogaSArIGIgKiB1ICsgdyAqIGggKyBfICogbSwgdFsyXSA9IHggKiBhICsgYiAqIGwgKyB3ICogZiArIF8gKiB2LCB0WzNdID0geCAqIG8gKyBiICogcCArIHcgKiB5ICsgXyAqIGcsIHRbNF0gPSAoeCA9IHJbNF0pICogbiArIChiID0gcls1XSkgKiBzICsgKHcgPSByWzZdKSAqIGMgKyAoXyA9IHJbN10pICogZCwgdFs1XSA9IHggKiBpICsgYiAqIHUgKyB3ICogaCArIF8gKiBtLCB0WzZdID0geCAqIGEgKyBiICogbCArIHcgKiBmICsgXyAqIHYsIHRbN10gPSB4ICogbyArIGIgKiBwICsgdyAqIHkgKyBfICogZywgdFs4XSA9ICh4ID0gcls4XSkgKiBuICsgKGIgPSByWzldKSAqIHMgKyAodyA9IHJbMTBdKSAqIGMgKyAoXyA9IHJbMTFdKSAqIGQsIHRbOV0gPSB4ICogaSArIGIgKiB1ICsgdyAqIGggKyBfICogbSwgdFsxMF0gPSB4ICogYSArIGIgKiBsICsgdyAqIGYgKyBfICogdiwgdFsxMV0gPSB4ICogbyArIGIgKiBwICsgdyAqIHkgKyBfICogZywgdFsxMl0gPSAoeCA9IHJbMTJdKSAqIG4gKyAoYiA9IHJbMTNdKSAqIHMgKyAodyA9IHJbMTRdKSAqIGMgKyAoXyA9IHJbMTVdKSAqIGQsIHRbMTNdID0geCAqIGkgKyBiICogdSArIHcgKiBoICsgXyAqIG0sIHRbMTRdID0geCAqIGEgKyBiICogbCArIHcgKiBmICsgXyAqIHYsIHRbMTVdID0geCAqIG8gKyBiICogcCArIHcgKiB5ICsgXyAqIGcsIHQ7XG4gICAgfVxuXG4gICAgTWF0aC5oeXBvdCB8fCAoTWF0aC5oeXBvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMsIGUgPSAwLCByID0gYXJndW1lbnRzLmxlbmd0aDsgci0tOykge1xuICAgICAgICBlICs9IHRbcl0gKiB0W3JdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGUpO1xuICAgIH0pO1xuICAgIHZhciB1byxcbiAgICAgICAgbG8gPSBzbztcblxuICAgIGZ1bmN0aW9uIHBvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgICBpID0gZVsxXSxcbiAgICAgICAgICBhID0gZVsyXSxcbiAgICAgICAgICBvID0gZVszXTtcbiAgICAgIHJldHVybiB0WzBdID0gclswXSAqIG4gKyByWzRdICogaSArIHJbOF0gKiBhICsgclsxMl0gKiBvLCB0WzFdID0gclsxXSAqIG4gKyByWzVdICogaSArIHJbOV0gKiBhICsgclsxM10gKiBvLCB0WzJdID0gclsyXSAqIG4gKyByWzZdICogaSArIHJbMTBdICogYSArIHJbMTRdICogbywgdFszXSA9IHJbM10gKiBuICsgcls3XSAqIGkgKyByWzExXSAqIGEgKyByWzE1XSAqIG8sIHQ7XG4gICAgfVxuXG4gICAgdW8gPSBuZXcgYW8oMyksIGFvICE9IEZsb2F0MzJBcnJheSAmJiAodW9bMF0gPSAwLCB1b1sxXSA9IDAsIHVvWzJdID0gMCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gbmV3IGFvKDQpO1xuICAgICAgYW8gIT0gRmxvYXQzMkFycmF5ICYmICh0WzBdID0gMCwgdFsxXSA9IDAsIHRbMl0gPSAwLCB0WzNdID0gMCk7XG4gICAgfSgpO1xuICAgIHZhciBjbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBhbygyKTtcbiAgICAgIGFvICE9IEZsb2F0MzJBcnJheSAmJiAodFswXSA9IDAsIHRbMV0gPSAwKTtcbiAgICB9KCksIGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIGlvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuY3JlYXRlQnVja2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxYSh0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5UmFkaXVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0O1xuICAgICAgICByZXR1cm4gdG8oXCJjaXJjbGUtcmFkaXVzXCIsIHRoaXMsIGUpICsgdG8oXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCIsIHRoaXMsIGUpICsgZW8odGhpcy5wYWludC5nZXQoXCJjaXJjbGUtdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgICBmb3IgKHZhciB1ID0gcm8odCwgdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtdHJhbnNsYXRlXCIpLCB0aGlzLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCIpLCBhLmFuZ2xlLCBvKSwgbCA9IHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXJhZGl1c1wiKS5ldmFsdWF0ZShlLCByKSArIHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiKS5ldmFsdWF0ZShlLCByKSwgcCA9IFwibWFwXCIgPT09IHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiKSwgYyA9IHAgPyB1IDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBobyh0LCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSh1LCBzKSwgaCA9IHAgPyBsICogbyA6IGwsIGYgPSAwLCB5ID0gbjsgZiA8IHkubGVuZ3RoOyBmICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBkID0gMCwgbSA9IHlbZl07IGQgPCBtLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IG1bZF0sXG4gICAgICAgICAgICAgICAgZyA9IHAgPyB2IDogaG8odiwgcyksXG4gICAgICAgICAgICAgICAgeCA9IGgsXG4gICAgICAgICAgICAgICAgYiA9IHBvKFtdLCBbdi54LCB2LnksIDAsIDFdLCBzKTtcbiAgICAgICAgICAgIGlmIChcInZpZXdwb3J0XCIgPT09IHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLXNjYWxlXCIpICYmIFwibWFwXCIgPT09IHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiKSA/IHggKj0gYlszXSAvIGEuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSA6IFwibWFwXCIgPT09IHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLXNjYWxlXCIpICYmIFwidmlld3BvcnRcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpICYmICh4ICo9IGEuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSAvIGJbM10pLCBLYShjLCBnLCB4KSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGU7XG4gICAgfShfaSkpO1xuXG4gICAgZnVuY3Rpb24gaG8odCwgZSkge1xuICAgICAgdmFyIHIgPSBwbyhbXSwgW3QueCwgdC55LCAwLCAxXSwgZSk7XG4gICAgICByZXR1cm4gbmV3IGkoclswXSAvIHJbM10sIHJbMV0gLyByWzNdKTtcbiAgICB9XG5cbiAgICB2YXIgZm8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgIH0ocWEpO1xuXG4gICAgZnVuY3Rpb24geW8odCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBlLndpZHRoLFxuICAgICAgICAgIGEgPSBlLmhlaWdodDtcblxuICAgICAgaWYgKG4pIHtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgbiA9IG5ldyBVaW50OEFycmF5KG4uYnVmZmVyKTtlbHNlIGlmIChuLmxlbmd0aCAhPT0gaSAqIGEgKiByKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pc21hdGNoZWQgaW1hZ2Ugc2l6ZVwiKTtcbiAgICAgIH0gZWxzZSBuID0gbmV3IFVpbnQ4QXJyYXkoaSAqIGEgKiByKTtcblxuICAgICAgcmV0dXJuIHQud2lkdGggPSBpLCB0LmhlaWdodCA9IGEsIHQuZGF0YSA9IG4sIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlLndpZHRoLFxuICAgICAgICAgIGkgPSBlLmhlaWdodDtcblxuICAgICAgaWYgKG4gIT09IHQud2lkdGggfHwgaSAhPT0gdC5oZWlnaHQpIHtcbiAgICAgICAgdmFyIGEgPSB5byh7fSwge1xuICAgICAgICAgIHdpZHRoOiBuLFxuICAgICAgICAgIGhlaWdodDogaVxuICAgICAgICB9LCByKTtcbiAgICAgICAgdm8odCwgYSwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5taW4odC53aWR0aCwgbiksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbih0LmhlaWdodCwgaSlcbiAgICAgICAgfSwgciksIHQud2lkdGggPSBuLCB0LmhlaWdodCA9IGksIHQuZGF0YSA9IGEuZGF0YTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2byh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBpZiAoMCA9PT0gaS53aWR0aCB8fCAwID09PSBpLmhlaWdodCkgcmV0dXJuIGU7XG4gICAgICBpZiAoaS53aWR0aCA+IHQud2lkdGggfHwgaS5oZWlnaHQgPiB0LmhlaWdodCB8fCByLnggPiB0LndpZHRoIC0gaS53aWR0aCB8fCByLnkgPiB0LmhlaWdodCAtIGkuaGVpZ2h0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBzb3VyY2UgY29vcmRpbmF0ZXMgZm9yIGltYWdlIGNvcHlcIik7XG4gICAgICBpZiAoaS53aWR0aCA+IGUud2lkdGggfHwgaS5oZWlnaHQgPiBlLmhlaWdodCB8fCBuLnggPiBlLndpZHRoIC0gaS53aWR0aCB8fCBuLnkgPiBlLmhlaWdodCAtIGkuaGVpZ2h0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBkZXN0aW5hdGlvbiBjb29yZGluYXRlcyBmb3IgaW1hZ2UgY29weVwiKTtcblxuICAgICAgZm9yICh2YXIgbyA9IHQuZGF0YSwgcyA9IGUuZGF0YSwgdSA9IDA7IHUgPCBpLmhlaWdodDsgdSsrKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSAoKHIueSArIHUpICogdC53aWR0aCArIHIueCkgKiBhLCBwID0gKChuLnkgKyB1KSAqIGUud2lkdGggKyBuLngpICogYSwgYyA9IDA7IGMgPCBpLndpZHRoICogYTsgYysrKSB7XG4gICAgICAgICAgc1twICsgY10gPSBvW2wgKyBjXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBPbihcIkhlYXRtYXBCdWNrZXRcIiwgZm8sIHtcbiAgICAgIG9taXQ6IFtcImxheWVyc1wiXVxuICAgIH0pO1xuXG4gICAgdmFyIGdvID0gZnVuY3Rpb24gZ28odCwgZSkge1xuICAgICAgeW8odGhpcywgdCwgMSwgZSk7XG4gICAgfTtcblxuICAgIGdvLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgbW8odGhpcywgdCwgMSk7XG4gICAgfSwgZ28ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBnbyh7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9LCBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgICB9LCBnby5jb3B5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZvKHQsIGUsIHIsIG4sIGksIDEpO1xuICAgIH07XG5cbiAgICB2YXIgeG8gPSBmdW5jdGlvbiB4byh0LCBlKSB7XG4gICAgICB5byh0aGlzLCB0LCA0LCBlKTtcbiAgICB9O1xuXG4gICAgeG8ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBtbyh0aGlzLCB0LCA0KTtcbiAgICB9LCB4by5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBlID8gdGhpcy5kYXRhLnNldCh0KSA6IHRoaXMuZGF0YSA9IHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSA/IG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSA6IHQ7XG4gICAgfSwgeG8ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB4byh7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9LCBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgICB9LCB4by5jb3B5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZvKHQsIGUsIHIsIG4sIGksIDQpO1xuICAgIH0sIE9uKFwiQWxwaGFJbWFnZVwiLCBnbyksIE9uKFwiUkdCQUltYWdlXCIsIHhvKTtcbiAgICB2YXIgYm8gPSB7XG4gICAgICBwYWludDogbmV3IHdpKHtcbiAgICAgICAgXCJoZWF0bWFwLXJhZGl1c1wiOiBuZXcgdmkoRXQucGFpbnRfaGVhdG1hcFtcImhlYXRtYXAtcmFkaXVzXCJdKSxcbiAgICAgICAgXCJoZWF0bWFwLXdlaWdodFwiOiBuZXcgdmkoRXQucGFpbnRfaGVhdG1hcFtcImhlYXRtYXAtd2VpZ2h0XCJdKSxcbiAgICAgICAgXCJoZWF0bWFwLWludGVuc2l0eVwiOiBuZXcgbWkoRXQucGFpbnRfaGVhdG1hcFtcImhlYXRtYXAtaW50ZW5zaXR5XCJdKSxcbiAgICAgICAgXCJoZWF0bWFwLWNvbG9yXCI6IG5ldyBiaShFdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1jb2xvclwiXSksXG4gICAgICAgIFwiaGVhdG1hcC1vcGFjaXR5XCI6IG5ldyBtaShFdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1vcGFjaXR5XCJdKVxuICAgICAgfSlcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd28odCkge1xuICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgICByID0gdC5yZXNvbHV0aW9uIHx8IDI1NixcbiAgICAgICAgICBuID0gdC5jbGlwcyA/IHQuY2xpcHMubGVuZ3RoIDogMSxcbiAgICAgICAgICBpID0gdC5pbWFnZSB8fCBuZXcgeG8oe1xuICAgICAgICB3aWR0aDogcixcbiAgICAgICAgaGVpZ2h0OiBuXG4gICAgICB9KSxcbiAgICAgICAgICBhID0gZnVuY3Rpb24gYShyLCBuLCBfYTIpIHtcbiAgICAgICAgZVt0LmV2YWx1YXRpb25LZXldID0gX2EyO1xuICAgICAgICB2YXIgbyA9IHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlKTtcbiAgICAgICAgaS5kYXRhW3IgKyBuICsgMF0gPSBNYXRoLmZsb29yKDI1NSAqIG8uciAvIG8uYSksIGkuZGF0YVtyICsgbiArIDFdID0gTWF0aC5mbG9vcigyNTUgKiBvLmcgLyBvLmEpLCBpLmRhdGFbciArIG4gKyAyXSA9IE1hdGguZmxvb3IoMjU1ICogby5iIC8gby5hKSwgaS5kYXRhW3IgKyBuICsgM10gPSBNYXRoLmZsb29yKDI1NSAqIG8uYSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodC5jbGlwcykgZm9yICh2YXIgbyA9IDAsIHMgPSAwOyBvIDwgbjsgKytvLCBzICs9IDQgKiByKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSAwLCBsID0gMDsgdSA8IHI7IHUrKywgbCArPSA0KSB7XG4gICAgICAgICAgdmFyIHAgPSB1IC8gKHIgLSAxKSxcbiAgICAgICAgICAgICAgYyA9IHQuY2xpcHNbb107XG4gICAgICAgICAgYShzLCBsLCBjLnN0YXJ0ICogKDEgLSBwKSArIGMuZW5kICogcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKHZhciBoID0gMCwgZiA9IDA7IGggPCByOyBoKyssIGYgKz0gNCkge1xuICAgICAgICBhKDAsIGYsIGggLyAociAtIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHZhciBfbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIGJvKSwgdGhpcy5fdXBkYXRlQ29sb3JSYW1wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgZm8odCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5faGFuZGxlU3BlY2lhbFBhaW50UHJvcGVydHlVcGRhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBcImhlYXRtYXAtY29sb3JcIiA9PT0gdCAmJiB0aGlzLl91cGRhdGVDb2xvclJhbXAoKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl91cGRhdGVDb2xvclJhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JSYW1wID0gd28oe1xuICAgICAgICAgIGV4cHJlc3Npb246IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuX3ZhbHVlc1tcImhlYXRtYXAtY29sb3JcIl0udmFsdWUuZXhwcmVzc2lvbixcbiAgICAgICAgICBldmFsdWF0aW9uS2V5OiBcImhlYXRtYXBEZW5zaXR5XCIsXG4gICAgICAgICAgaW1hZ2U6IHRoaXMuY29sb3JSYW1wXG4gICAgICAgIH0pLCB0aGlzLmNvbG9yUmFtcFRleHR1cmUgPSBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhlYXRtYXBGYm8gJiYgKHRoaXMuaGVhdG1hcEZiby5kZXN0cm95KCksIHRoaXMuaGVhdG1hcEZibyA9IG51bGwpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuaGFzT2Zmc2NyZWVuUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgIT09IHRoaXMucGFpbnQuZ2V0KFwiaGVhdG1hcC1vcGFjaXR5XCIpICYmIFwibm9uZVwiICE9PSB0aGlzLnZpc2liaWxpdHk7XG4gICAgICB9LCBlO1xuICAgIH0oX2kpLFxuICAgICAgICBBbyA9IHtcbiAgICAgIHBhaW50OiBuZXcgd2koe1xuICAgICAgICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCI6IG5ldyBtaShFdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiXSksXG4gICAgICAgIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JcIjogbmV3IG1pKEV0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCJdKSxcbiAgICAgICAgXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IG5ldyBtaShFdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCJdKSxcbiAgICAgICAgXCJoaWxsc2hhZGUtc2hhZG93LWNvbG9yXCI6IG5ldyBtaShFdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtc2hhZG93LWNvbG9yXCJdKSxcbiAgICAgICAgXCJoaWxsc2hhZGUtaGlnaGxpZ2h0LWNvbG9yXCI6IG5ldyBtaShFdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtaGlnaGxpZ2h0LWNvbG9yXCJdKSxcbiAgICAgICAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IG5ldyBtaShFdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCJdKVxuICAgICAgfSlcbiAgICB9LFxuICAgICAgICBTbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIEFvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuaGFzT2Zmc2NyZWVuUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgIT09IHRoaXMucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiKSAmJiBcIm5vbmVcIiAhPT0gdGhpcy52aXNpYmlsaXR5O1xuICAgICAgfSwgZTtcbiAgICB9KF9pKSxcbiAgICAgICAga28gPSBJaShbe1xuICAgICAgbmFtZTogXCJhX3Bvc1wiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgIH1dLCA0KS5tZW1iZXJzLFxuICAgICAgICBJbyA9IENvLFxuICAgICAgICB6byA9IENvO1xuXG4gICAgZnVuY3Rpb24gQ28odCwgZSwgcikge1xuICAgICAgciA9IHIgfHwgMjtcbiAgICAgIHZhciBuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgYSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHAgPSBlICYmIGUubGVuZ3RoLFxuICAgICAgICAgIGMgPSBwID8gZVswXSAqIHIgOiB0Lmxlbmd0aCxcbiAgICAgICAgICBoID0gRW8odCwgMCwgYywgciwgITApLFxuICAgICAgICAgIGYgPSBbXTtcbiAgICAgIGlmICghaCB8fCBoLm5leHQgPT09IGgucHJldikgcmV0dXJuIGY7XG5cbiAgICAgIGlmIChwICYmIChoID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIHMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBhID0gZS5sZW5ndGg7IGkgPCBhOyBpKyspIHtcbiAgICAgICAgICAobyA9IEVvKHQsIGVbaV0gKiBuLCBpIDwgYSAtIDEgPyBlW2kgKyAxXSAqIG4gOiB0Lmxlbmd0aCwgbiwgITEpKSA9PT0gby5uZXh0ICYmIChvLnN0ZWluZXIgPSAhMCksIHMucHVzaChVbyhvKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHMuc29ydChEbyksIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIExvKHNbaV0sIHIpLCByID0gUG8ociwgci5uZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSh0LCBlLCBoLCByKSksIHQubGVuZ3RoID4gODAgKiByKSB7XG4gICAgICAgIG4gPSBhID0gdFswXSwgaSA9IG8gPSB0WzFdO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSByOyB5IDwgYzsgeSArPSByKSB7XG4gICAgICAgICAgKHMgPSB0W3ldKSA8IG4gJiYgKG4gPSBzKSwgKHUgPSB0W3kgKyAxXSkgPCBpICYmIChpID0gdSksIHMgPiBhICYmIChhID0gcyksIHUgPiBvICYmIChvID0gdSk7XG4gICAgICAgIH1cblxuICAgICAgICBsID0gMCAhPT0gKGwgPSBNYXRoLm1heChhIC0gbiwgbyAtIGkpKSA/IDEgLyBsIDogMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1vKGgsIGYsIHIsIG4sIGksIGwpLCBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVvKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhLCBvO1xuICAgICAgaWYgKGkgPT09IFFvKHQsIGUsIHIsIG4pID4gMCkgZm9yIChhID0gZTsgYSA8IHI7IGEgKz0gbikge1xuICAgICAgICBvID0gWW8oYSwgdFthXSwgdFthICsgMV0sIG8pO1xuICAgICAgfSBlbHNlIGZvciAoYSA9IHIgLSBuOyBhID49IGU7IGEgLT0gbikge1xuICAgICAgICBvID0gWW8oYSwgdFthXSwgdFthICsgMV0sIG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG8gJiYgS28obywgby5uZXh0KSAmJiAoJG8obyksIG8gPSBvLm5leHQpLCBvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvKHQsIGUpIHtcbiAgICAgIGlmICghdCkgcmV0dXJuIHQ7XG4gICAgICBlIHx8IChlID0gdCk7XG4gICAgICB2YXIgcixcbiAgICAgICAgICBuID0gdDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAociA9ICExLCBuLnN0ZWluZXIgfHwgIUtvKG4sIG4ubmV4dCkgJiYgMCAhPT0gTm8obi5wcmV2LCBuLCBuLm5leHQpKSBuID0gbi5uZXh0O2Vsc2Uge1xuICAgICAgICAgIGlmICgkbyhuKSwgKG4gPSBlID0gbi5wcmV2KSA9PT0gbi5uZXh0KSBicmVhaztcbiAgICAgICAgICByID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHIgfHwgbiAhPT0gZSk7XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE1vKHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgICFvICYmIGEgJiYgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICB2YXIgaSA9IHQ7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBudWxsID09PSBpLnogJiYgKGkueiA9IFJvKGkueCwgaS55LCBlLCByLCBuKSksIGkucHJldlogPSBpLnByZXYsIGkubmV4dFogPSBpLm5leHQsIGkgPSBpLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAoaSAhPT0gdCk7XG5cbiAgICAgICAgICBpLnByZXZaLm5leHRaID0gbnVsbCwgaS5wcmV2WiA9IG51bGwsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICB1LFxuICAgICAgICAgICAgICAgIGwgPSAxO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGZvciAociA9IHQsIHQgPSBudWxsLCBhID0gbnVsbCwgbyA9IDA7IHI7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChvKyssIG4gPSByLCBzID0gMCwgZSA9IDA7IGUgPCBsICYmIChzKyssIG4gPSBuLm5leHRaKTsgZSsrKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh1ID0gbDsgcyA+IDAgfHwgdSA+IDAgJiYgbjspIHtcbiAgICAgICAgICAgICAgICAgIDAgIT09IHMgJiYgKDAgPT09IHUgfHwgIW4gfHwgci56IDw9IG4ueikgPyAoaSA9IHIsIHIgPSByLm5leHRaLCBzLS0pIDogKGkgPSBuLCBuID0gbi5uZXh0WiwgdS0tKSwgYSA/IGEubmV4dFogPSBpIDogdCA9IGksIGkucHJldlogPSBhLCBhID0gaTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByID0gbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGEubmV4dFogPSBudWxsLCBsICo9IDI7XG4gICAgICAgICAgICB9IHdoaWxlIChvID4gMSk7XG4gICAgICAgICAgfShpKTtcbiAgICAgICAgfSh0LCBuLCBpLCBhKTtcblxuICAgICAgICBmb3IgKHZhciBzLCB1LCBsID0gdDsgdC5wcmV2ICE9PSB0Lm5leHQ7KSB7XG4gICAgICAgICAgaWYgKHMgPSB0LnByZXYsIHUgPSB0Lm5leHQsIGEgPyBUbyh0LCBuLCBpLCBhKSA6IEJvKHQpKSBlLnB1c2gocy5pIC8gciksIGUucHVzaCh0LmkgLyByKSwgZS5wdXNoKHUuaSAvIHIpLCAkbyh0KSwgdCA9IHUubmV4dCwgbCA9IHUubmV4dDtlbHNlIGlmICgodCA9IHUpID09PSBsKSB7XG4gICAgICAgICAgICBvID8gMSA9PT0gbyA/IE1vKHQgPSBWbyhQbyh0KSwgZSwgciksIGUsIHIsIG4sIGksIGEsIDIpIDogMiA9PT0gbyAmJiBGbyh0LCBlLCByLCBuLCBpLCBhKSA6IE1vKFBvKHQpLCBlLCByLCBuLCBpLCBhLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJvKHQpIHtcbiAgICAgIHZhciBlID0gdC5wcmV2LFxuICAgICAgICAgIHIgPSB0LFxuICAgICAgICAgIG4gPSB0Lm5leHQ7XG4gICAgICBpZiAoTm8oZSwgciwgbikgPj0gMCkgcmV0dXJuICExO1xuXG4gICAgICBmb3IgKHZhciBpID0gdC5uZXh0Lm5leHQ7IGkgIT09IHQucHJldjspIHtcbiAgICAgICAgaWYgKGpvKGUueCwgZS55LCByLngsIHIueSwgbi54LCBuLnksIGkueCwgaS55KSAmJiBObyhpLnByZXYsIGksIGkubmV4dCkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICBpID0gaS5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVG8odCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0LnByZXYsXG4gICAgICAgICAgYSA9IHQsXG4gICAgICAgICAgbyA9IHQubmV4dDtcbiAgICAgIGlmIChObyhpLCBhLCBvKSA+PSAwKSByZXR1cm4gITE7XG5cbiAgICAgIGZvciAodmFyIHMgPSBpLnggPiBhLnggPyBpLnggPiBvLnggPyBpLnggOiBvLnggOiBhLnggPiBvLnggPyBhLnggOiBvLngsIHUgPSBpLnkgPiBhLnkgPyBpLnkgPiBvLnkgPyBpLnkgOiBvLnkgOiBhLnkgPiBvLnkgPyBhLnkgOiBvLnksIGwgPSBSbyhpLnggPCBhLnggPyBpLnggPCBvLnggPyBpLnggOiBvLnggOiBhLnggPCBvLnggPyBhLnggOiBvLngsIGkueSA8IGEueSA/IGkueSA8IG8ueSA/IGkueSA6IG8ueSA6IGEueSA8IG8ueSA/IGEueSA6IG8ueSwgZSwgciwgbiksIHAgPSBSbyhzLCB1LCBlLCByLCBuKSwgYyA9IHQucHJldlosIGggPSB0Lm5leHRaOyBjICYmIGMueiA+PSBsICYmIGggJiYgaC56IDw9IHA7KSB7XG4gICAgICAgIGlmIChjICE9PSB0LnByZXYgJiYgYyAhPT0gdC5uZXh0ICYmIGpvKGkueCwgaS55LCBhLngsIGEueSwgby54LCBvLnksIGMueCwgYy55KSAmJiBObyhjLnByZXYsIGMsIGMubmV4dCkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoYyA9IGMucHJldlosIGggIT09IHQucHJldiAmJiBoICE9PSB0Lm5leHQgJiYgam8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgaC54LCBoLnkpICYmIE5vKGgucHJldiwgaCwgaC5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGggPSBoLm5leHRaO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgYyAmJiBjLnogPj0gbDspIHtcbiAgICAgICAgaWYgKGMgIT09IHQucHJldiAmJiBjICE9PSB0Lm5leHQgJiYgam8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgYy54LCBjLnkpICYmIE5vKGMucHJldiwgYywgYy5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGMgPSBjLnByZXZaO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaCAmJiBoLnogPD0gcDspIHtcbiAgICAgICAgaWYgKGggIT09IHQucHJldiAmJiBoICE9PSB0Lm5leHQgJiYgam8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgaC54LCBoLnkpICYmIE5vKGgucHJldiwgaCwgaC5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGggPSBoLm5leHRaO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVm8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBpID0gbi5wcmV2LFxuICAgICAgICAgICAgYSA9IG4ubmV4dC5uZXh0O1xuICAgICAgICAhS28oaSwgYSkgJiYgR28oaSwgbiwgbi5uZXh0LCBhKSAmJiBKbyhpLCBhKSAmJiBKbyhhLCBpKSAmJiAoZS5wdXNoKGkuaSAvIHIpLCBlLnB1c2gobi5pIC8gciksIGUucHVzaChhLmkgLyByKSwgJG8obiksICRvKG4ubmV4dCksIG4gPSB0ID0gYSksIG4gPSBuLm5leHQ7XG4gICAgICB9IHdoaWxlIChuICE9PSB0KTtcblxuICAgICAgcmV0dXJuIFBvKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZvKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHZhciBvID0gdDtcblxuICAgICAgZG8ge1xuICAgICAgICBmb3IgKHZhciBzID0gby5uZXh0Lm5leHQ7IHMgIT09IG8ucHJldjspIHtcbiAgICAgICAgICBpZiAoby5pICE9PSBzLmkgJiYgcW8obywgcykpIHtcbiAgICAgICAgICAgIHZhciB1ID0gSG8obywgcyk7XG4gICAgICAgICAgICByZXR1cm4gbyA9IFBvKG8sIG8ubmV4dCksIHUgPSBQbyh1LCB1Lm5leHQpLCBNbyhvLCBlLCByLCBuLCBpLCBhKSwgdm9pZCBNbyh1LCBlLCByLCBuLCBpLCBhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzID0gcy5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbyA9IG8ubmV4dDtcbiAgICAgIH0gd2hpbGUgKG8gIT09IHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERvKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnggLSBlLng7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG8odCwgZSkge1xuICAgICAgaWYgKGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgcixcbiAgICAgICAgICAgIG4gPSBlLFxuICAgICAgICAgICAgaSA9IHQueCxcbiAgICAgICAgICAgIGEgPSB0LnksXG4gICAgICAgICAgICBvID0gLTEgLyAwO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoYSA8PSBuLnkgJiYgYSA+PSBuLm5leHQueSAmJiBuLm5leHQueSAhPT0gbi55KSB7XG4gICAgICAgICAgICB2YXIgcyA9IG4ueCArIChhIC0gbi55KSAqIChuLm5leHQueCAtIG4ueCkgLyAobi5uZXh0LnkgLSBuLnkpO1xuXG4gICAgICAgICAgICBpZiAocyA8PSBpICYmIHMgPiBvKSB7XG4gICAgICAgICAgICAgIGlmIChvID0gcywgcyA9PT0gaSkge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBuLnkpIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBuLm5leHQueSkgcmV0dXJuIG4ubmV4dDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIgPSBuLnggPCBuLm5leHQueCA/IG4gOiBuLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbiA9IG4ubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobiAhPT0gZSk7XG5cbiAgICAgICAgaWYgKCFyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGkgPT09IG8pIHJldHVybiByO1xuICAgICAgICB2YXIgdSxcbiAgICAgICAgICAgIGwgPSByLFxuICAgICAgICAgICAgcCA9IHIueCxcbiAgICAgICAgICAgIGMgPSByLnksXG4gICAgICAgICAgICBoID0gMSAvIDA7XG4gICAgICAgIG4gPSByO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpID49IG4ueCAmJiBuLnggPj0gcCAmJiBpICE9PSBuLnggJiYgam8oYSA8IGMgPyBpIDogbywgYSwgcCwgYywgYSA8IGMgPyBvIDogaSwgYSwgbi54LCBuLnkpICYmICh1ID0gTWF0aC5hYnMoYSAtIG4ueSkgLyAoaSAtIG4ueCksIEpvKG4sIHQpICYmICh1IDwgaCB8fCB1ID09PSBoICYmIChuLnggPiByLnggfHwgbi54ID09PSByLnggJiYgT28ociwgbikpKSAmJiAociA9IG4sIGggPSB1KSksIG4gPSBuLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKG4gIT09IGwpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSh0LCBlKSkge1xuICAgICAgICB2YXIgciA9IEhvKGUsIHQpO1xuICAgICAgICBQbyhlLCBlLm5leHQpLCBQbyhyLCByLm5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIE9vKHQsIGUpIHtcbiAgICAgIHJldHVybiBObyh0LnByZXYsIHQsIGUucHJldikgPCAwICYmIE5vKGUubmV4dCwgdCwgdC5uZXh0KSA8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUm8odCwgZSwgciwgbiwgaSkge1xuICAgICAgcmV0dXJuICh0ID0gMTQzMTY1NTc2NSAmICgodCA9IDg1ODk5MzQ1OSAmICgodCA9IDI1MjY0NTEzNSAmICgodCA9IDE2NzExOTM1ICYgKCh0ID0gMzI3NjcgKiAodCAtIHIpICogaSkgfCB0IDw8IDgpKSB8IHQgPDwgNCkpIHwgdCA8PCAyKSkgfCB0IDw8IDEpKSB8IChlID0gMTQzMTY1NTc2NSAmICgoZSA9IDg1ODk5MzQ1OSAmICgoZSA9IDI1MjY0NTEzNSAmICgoZSA9IDE2NzExOTM1ICYgKChlID0gMzI3NjcgKiAoZSAtIG4pICogaSkgfCBlIDw8IDgpKSB8IGUgPDwgNCkpIHwgZSA8PCAyKSkgfCBlIDw8IDEpKSA8PCAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVvKHQpIHtcbiAgICAgIHZhciBlID0gdCxcbiAgICAgICAgICByID0gdDtcblxuICAgICAgZG8ge1xuICAgICAgICAoZS54IDwgci54IHx8IGUueCA9PT0gci54ICYmIGUueSA8IHIueSkgJiYgKHIgPSBlKSwgZSA9IGUubmV4dDtcbiAgICAgIH0gd2hpbGUgKGUgIT09IHQpO1xuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqbyh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICByZXR1cm4gKGkgLSBvKSAqIChlIC0gcykgLSAodCAtIG8pICogKGEgLSBzKSA+PSAwICYmICh0IC0gbykgKiAobiAtIHMpIC0gKHIgLSBvKSAqIChlIC0gcykgPj0gMCAmJiAociAtIG8pICogKGEgLSBzKSAtIChpIC0gbykgKiAobiAtIHMpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcW8odCwgZSkge1xuICAgICAgcmV0dXJuIHQubmV4dC5pICE9PSBlLmkgJiYgdC5wcmV2LmkgIT09IGUuaSAmJiAhZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoci5pICE9PSB0LmkgJiYgci5uZXh0LmkgIT09IHQuaSAmJiByLmkgIT09IGUuaSAmJiByLm5leHQuaSAhPT0gZS5pICYmIEdvKHIsIHIubmV4dCwgdCwgZSkpIHJldHVybiAhMDtcbiAgICAgICAgICByID0gci5uZXh0O1xuICAgICAgICB9IHdoaWxlIChyICE9PSB0KTtcblxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9KHQsIGUpICYmIChKbyh0LCBlKSAmJiBKbyhlLCB0KSAmJiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHQsXG4gICAgICAgICAgICBuID0gITEsXG4gICAgICAgICAgICBpID0gKHQueCArIGUueCkgLyAyLFxuICAgICAgICAgICAgYSA9ICh0LnkgKyBlLnkpIC8gMjtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgci55ID4gYSAhPSByLm5leHQueSA+IGEgJiYgci5uZXh0LnkgIT09IHIueSAmJiBpIDwgKHIubmV4dC54IC0gci54KSAqIChhIC0gci55KSAvIChyLm5leHQueSAtIHIueSkgKyByLnggJiYgKG4gPSAhbiksIHIgPSByLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHIgIT09IHQpO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSh0LCBlKSAmJiAoTm8odC5wcmV2LCB0LCBlLnByZXYpIHx8IE5vKHQsIGUucHJldiwgZSkpIHx8IEtvKHQsIGUpICYmIE5vKHQucHJldiwgdCwgdC5uZXh0KSA+IDAgJiYgTm8oZS5wcmV2LCBlLCBlLm5leHQpID4gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTm8odCwgZSwgcikge1xuICAgICAgcmV0dXJuIChlLnkgLSB0LnkpICogKHIueCAtIGUueCkgLSAoZS54IC0gdC54KSAqIChyLnkgLSBlLnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtvKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnggPT09IGUueCAmJiB0LnkgPT09IGUueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IFhvKE5vKHQsIGUsIHIpKSxcbiAgICAgICAgICBhID0gWG8oTm8odCwgZSwgbikpLFxuICAgICAgICAgIG8gPSBYbyhObyhyLCBuLCB0KSksXG4gICAgICAgICAgcyA9IFhvKE5vKHIsIG4sIGUpKTtcbiAgICAgIHJldHVybiBpICE9PSBhICYmIG8gIT09IHMgfHwgISgwICE9PSBpIHx8ICFabyh0LCByLCBlKSkgfHwgISgwICE9PSBhIHx8ICFabyh0LCBuLCBlKSkgfHwgISgwICE9PSBvIHx8ICFabyhyLCB0LCBuKSkgfHwgISgwICE9PSBzIHx8ICFabyhyLCBlLCBuKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWm8odCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUueCA8PSBNYXRoLm1heCh0LngsIHIueCkgJiYgZS54ID49IE1hdGgubWluKHQueCwgci54KSAmJiBlLnkgPD0gTWF0aC5tYXgodC55LCByLnkpICYmIGUueSA+PSBNYXRoLm1pbih0LnksIHIueSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWG8odCkge1xuICAgICAgcmV0dXJuIHQgPiAwID8gMSA6IHQgPCAwID8gLTEgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEpvKHQsIGUpIHtcbiAgICAgIHJldHVybiBObyh0LnByZXYsIHQsIHQubmV4dCkgPCAwID8gTm8odCwgZSwgdC5uZXh0KSA+PSAwICYmIE5vKHQsIHQucHJldiwgZSkgPj0gMCA6IE5vKHQsIGUsIHQucHJldikgPCAwIHx8IE5vKHQsIHQubmV4dCwgZSkgPCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhvKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IFdvKHQuaSwgdC54LCB0LnkpLFxuICAgICAgICAgIG4gPSBuZXcgV28oZS5pLCBlLngsIGUueSksXG4gICAgICAgICAgaSA9IHQubmV4dCxcbiAgICAgICAgICBhID0gZS5wcmV2O1xuICAgICAgcmV0dXJuIHQubmV4dCA9IGUsIGUucHJldiA9IHQsIHIubmV4dCA9IGksIGkucHJldiA9IHIsIG4ubmV4dCA9IHIsIHIucHJldiA9IG4sIGEubmV4dCA9IG4sIG4ucHJldiA9IGEsIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWW8odCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBuZXcgV28odCwgZSwgcik7XG4gICAgICByZXR1cm4gbiA/IChpLm5leHQgPSBuLm5leHQsIGkucHJldiA9IG4sIG4ubmV4dC5wcmV2ID0gaSwgbi5uZXh0ID0gaSkgOiAoaS5wcmV2ID0gaSwgaS5uZXh0ID0gaSksIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJG8odCkge1xuICAgICAgdC5uZXh0LnByZXYgPSB0LnByZXYsIHQucHJldi5uZXh0ID0gdC5uZXh0LCB0LnByZXZaICYmICh0LnByZXZaLm5leHRaID0gdC5uZXh0WiksIHQubmV4dFogJiYgKHQubmV4dFoucHJldlogPSB0LnByZXZaKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXbyh0LCBlLCByKSB7XG4gICAgICB0aGlzLmkgPSB0LCB0aGlzLnggPSBlLCB0aGlzLnkgPSByLCB0aGlzLnByZXYgPSBudWxsLCB0aGlzLm5leHQgPSBudWxsLCB0aGlzLnogPSBudWxsLCB0aGlzLnByZXZaID0gbnVsbCwgdGhpcy5uZXh0WiA9IG51bGwsIHRoaXMuc3RlaW5lciA9ICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFFvKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhID0gZSwgbyA9IHIgLSBuOyBhIDwgcjsgYSArPSBuKSB7XG4gICAgICAgIGkgKz0gKHRbb10gLSB0W2FdKSAqICh0W2EgKyAxXSArIHRbbyArIDFdKSwgbyA9IGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRzKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICFmdW5jdGlvbiB0KGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgZm9yICg7IGkgPiBuOykge1xuICAgICAgICAgIGlmIChpIC0gbiA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG8gPSBpIC0gbiArIDEsXG4gICAgICAgICAgICAgICAgcyA9IHIgLSBuICsgMSxcbiAgICAgICAgICAgICAgICB1ID0gTWF0aC5sb2cobyksXG4gICAgICAgICAgICAgICAgbCA9IC41ICogTWF0aC5leHAoMiAqIHUgLyAzKSxcbiAgICAgICAgICAgICAgICBwID0gLjUgKiBNYXRoLnNxcnQodSAqIGwgKiAobyAtIGwpIC8gbykgKiAocyAtIG8gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB0KGUsIHIsIE1hdGgubWF4KG4sIE1hdGguZmxvb3IociAtIHMgKiBsIC8gbyArIHApKSwgTWF0aC5taW4oaSwgTWF0aC5mbG9vcihyICsgKG8gLSBzKSAqIGwgLyBvICsgcCkpLCBhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYyA9IGVbcl0sXG4gICAgICAgICAgICAgIGggPSBuLFxuICAgICAgICAgICAgICBmID0gaTtcblxuICAgICAgICAgIGZvciAoZXMoZSwgbiwgciksIGEoZVtpXSwgYykgPiAwICYmIGVzKGUsIG4sIGkpOyBoIDwgZjspIHtcbiAgICAgICAgICAgIGZvciAoZXMoZSwgaCwgZiksIGgrKywgZi0tOyBhKGVbaF0sIGMpIDwgMDspIHtcbiAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKDsgYShlW2ZdLCBjKSA+IDA7KSB7XG4gICAgICAgICAgICAgIGYtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAwID09PSBhKGVbbl0sIGMpID8gZXMoZSwgbiwgZikgOiBlcyhlLCArK2YsIGkpLCBmIDw9IHIgJiYgKG4gPSBmICsgMSksIHIgPD0gZiAmJiAoaSA9IGYgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSh0LCBlLCByIHx8IDAsIG4gfHwgdC5sZW5ndGggLSAxLCBpIHx8IHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcyh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRbZV07XG4gICAgICB0W2VdID0gdFtyXSwgdFtyXSA9IG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnModCwgZSkge1xuICAgICAgcmV0dXJuIHQgPCBlID8gLTEgOiB0ID4gZSA/IDEgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5zKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC5sZW5ndGg7XG4gICAgICBpZiAociA8PSAxKSByZXR1cm4gW3RdO1xuXG4gICAgICBmb3IgKHZhciBuLCBpLCBhID0gW10sIG8gPSAwOyBvIDwgcjsgbysrKSB7XG4gICAgICAgIHZhciBzID0gayh0W29dKTtcbiAgICAgICAgMCAhPT0gcyAmJiAodFtvXS5hcmVhID0gTWF0aC5hYnMocyksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHMgPCAwKSwgaSA9PT0gcyA8IDAgPyAobiAmJiBhLnB1c2gobiksIG4gPSBbdFtvXV0pIDogbi5wdXNoKHRbb10pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gJiYgYS5wdXNoKG4pLCBlID4gMSkgZm9yICh2YXIgdSA9IDA7IHUgPCBhLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIGFbdV0ubGVuZ3RoIDw9IGUgfHwgKHRzKGFbdV0sIGUsIDEsIGFbdV0ubGVuZ3RoIC0gMSwgaXMpLCBhW3VdID0gYVt1XS5zbGljZSgwLCBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpcyh0LCBlKSB7XG4gICAgICByZXR1cm4gZS5hcmVhIC0gdC5hcmVhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSByLnBhdHRlcm5EZXBlbmRlbmNpZXMsIGkgPSAhMSwgYSA9IDAsIG8gPSBlOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICB2YXIgcyA9IG9bYV0ucGFpbnQuZ2V0KHQgKyBcIi1wYXR0ZXJuXCIpO1xuICAgICAgICBzLmlzQ29uc3RhbnQoKSB8fCAoaSA9ICEwKTtcbiAgICAgICAgdmFyIHUgPSBzLmNvbnN0YW50T3IobnVsbCk7XG4gICAgICAgIHUgJiYgKGkgPSAhMCwgblt1LnRvXSA9ICEwLCBuW3UuZnJvbV0gPSAhMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9zKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSBpLnBhdHRlcm5EZXBlbmRlbmNpZXMsIG8gPSAwLCBzID0gZTsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgbCA9IHUucGFpbnQuZ2V0KHQgKyBcIi1wYXR0ZXJuXCIpLnZhbHVlO1xuXG4gICAgICAgIGlmIChcImNvbnN0YW50XCIgIT09IGwua2luZCkge1xuICAgICAgICAgIHZhciBwID0gbC5ldmFsdWF0ZSh7XG4gICAgICAgICAgICB6b29tOiBuIC0gMVxuICAgICAgICAgIH0sIHIsIHt9LCBpLmF2YWlsYWJsZUltYWdlcyksXG4gICAgICAgICAgICAgIGMgPSBsLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IG5cbiAgICAgICAgICB9LCByLCB7fSwgaS5hdmFpbGFibGVJbWFnZXMpLFxuICAgICAgICAgICAgICBoID0gbC5ldmFsdWF0ZSh7XG4gICAgICAgICAgICB6b29tOiBuICsgMVxuICAgICAgICAgIH0sIHIsIHt9LCBpLmF2YWlsYWJsZUltYWdlcyk7XG4gICAgICAgICAgYyA9IGMgJiYgYy5uYW1lID8gYy5uYW1lIDogYywgaCA9IGggJiYgaC5uYW1lID8gaC5uYW1lIDogaCwgYVtwID0gcCAmJiBwLm5hbWUgPyBwLm5hbWUgOiBwXSA9ICEwLCBhW2NdID0gITAsIGFbaF0gPSAhMCwgci5wYXR0ZXJuc1t1LmlkXSA9IHtcbiAgICAgICAgICAgIG1pbjogcCxcbiAgICAgICAgICAgIG1pZDogYyxcbiAgICAgICAgICAgIG1heDogaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgQ28uZGV2aWF0aW9uID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gZSAmJiBlLmxlbmd0aCxcbiAgICAgICAgICBhID0gTWF0aC5hYnMoUW8odCwgMCwgaSA/IGVbMF0gKiByIDogdC5sZW5ndGgsIHIpKTtcbiAgICAgIGlmIChpKSBmb3IgKHZhciBvID0gMCwgcyA9IGUubGVuZ3RoOyBvIDwgczsgbysrKSB7XG4gICAgICAgIGEgLT0gTWF0aC5hYnMoUW8odCwgZVtvXSAqIHIsIG8gPCBzIC0gMSA/IGVbbyArIDFdICogciA6IHQubGVuZ3RoLCByKSk7XG4gICAgICB9XG4gICAgICB2YXIgdSA9IDA7XG5cbiAgICAgIGZvciAobyA9IDA7IG8gPCBuLmxlbmd0aDsgbyArPSAzKSB7XG4gICAgICAgIHZhciBsID0gbltvXSAqIHIsXG4gICAgICAgICAgICBwID0gbltvICsgMV0gKiByLFxuICAgICAgICAgICAgYyA9IG5bbyArIDJdICogcjtcbiAgICAgICAgdSArPSBNYXRoLmFicygodFtsXSAtIHRbY10pICogKHRbcCArIDFdIC0gdFtsICsgMV0pIC0gKHRbbF0gLSB0W3BdKSAqICh0W2MgKyAxXSAtIHRbbCArIDFdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwID09PSBhICYmIDAgPT09IHUgPyAwIDogTWF0aC5hYnMoKHUgLSBhKSAvIGEpO1xuICAgIH0sIENvLmZsYXR0ZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRbMF1bMF0ubGVuZ3RoLCByID0ge1xuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIGhvbGVzOiBbXSxcbiAgICAgICAgZGltZW5zaW9uczogZVxuICAgICAgfSwgbiA9IDAsIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRbaV0ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGU7IG8rKykge1xuICAgICAgICAgICAgci52ZXJ0aWNlcy5wdXNoKHRbaV1bYV1bb10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGkgPiAwICYmIHIuaG9sZXMucHVzaChuICs9IHRbaSAtIDFdLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIElvLmRlZmF1bHQgPSB6bztcblxuICAgIHZhciBzcyA9IGZ1bmN0aW9uIHNzKHQpIHtcbiAgICAgIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLnBhdHRlcm5GZWF0dXJlcyA9IFtdLCB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IENpKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBqaSgpLCB0aGlzLmluZGV4QXJyYXkyID0gbmV3IFhpKCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zID0gbmV3IFZhKHQubGF5ZXJzLCB0Lnpvb20pLCB0aGlzLnNlZ21lbnRzID0gbmV3IHNhKCksIHRoaXMuc2VnbWVudHMyID0gbmV3IHNhKCksIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcklkcyA9IHRoaXMubGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1N0YXRlRGVwZW5kZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc3MucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuaGFzUGF0dGVybiA9IGFzKFwiZmlsbFwiLCB0aGlzLmxheWVycywgZSk7XG5cbiAgICAgIGZvciAodmFyIG4gPSB0aGlzLmxheWVyc1swXS5sYXlvdXQuZ2V0KFwiZmlsbC1zb3J0LWtleVwiKSwgaSA9IFtdLCBhID0gMCwgbyA9IHQ7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gb1thXSxcbiAgICAgICAgICAgIHUgPSBzLmZlYXR1cmUsXG4gICAgICAgICAgICBsID0gcy5pZCxcbiAgICAgICAgICAgIHAgPSBzLmluZGV4LFxuICAgICAgICAgICAgYyA9IHMuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICAgIGggPSB0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5uZWVkR2VvbWV0cnksXG4gICAgICAgICAgICBmID0gVWEodSwgaCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLmZpbHRlcihuZXcgc2kodGhpcy56b29tKSwgZiwgcikpIHtcbiAgICAgICAgICB2YXIgeSA9IG4gPyBuLmV2YWx1YXRlKGYsIHt9LCByLCBlLmF2YWlsYWJsZUltYWdlcykgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGQgPSB7XG4gICAgICAgICAgICBpZDogbCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHUucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IHUudHlwZSxcbiAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IGMsXG4gICAgICAgICAgICBpbmRleDogcCxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBoID8gZi5nZW9tZXRyeSA6IFJhKHUpLFxuICAgICAgICAgICAgcGF0dGVybnM6IHt9LFxuICAgICAgICAgICAgc29ydEtleTogeVxuICAgICAgICAgIH07XG4gICAgICAgICAgaS5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gJiYgaS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgbSA9IDAsIHYgPSBpOyBtIDwgdi5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgZyA9IHZbbV0sXG4gICAgICAgICAgICB4ID0gZy5nZW9tZXRyeSxcbiAgICAgICAgICAgIGIgPSBnLmluZGV4LFxuICAgICAgICAgICAgdyA9IGcuc291cmNlTGF5ZXJJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5oYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIF8gPSBvcyhcImZpbGxcIiwgdGhpcy5sYXllcnMsIGcsIHRoaXMuem9vbSwgZSk7XG5cbiAgICAgICAgICB0aGlzLnBhdHRlcm5GZWF0dXJlcy5wdXNoKF8pO1xuICAgICAgICB9IGVsc2UgdGhpcy5hZGRGZWF0dXJlKGcsIHgsIGIsIHIsIHt9KTtcblxuICAgICAgICBlLmZlYXR1cmVJbmRleC5pbnNlcnQodFtiXS5mZWF0dXJlLCB4LCBiLCB3LCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9LCBzcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMubGVuZ3RoICYmIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwZGF0ZVBhaW50QXJyYXlzKHQsIGUsIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMsIHIpO1xuICAgIH0sIHNzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMucGF0dGVybkZlYXR1cmVzOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZShhLCBhLmdlb21ldHJ5LCBhLmluZGV4LCBlLCByKTtcbiAgICAgIH1cbiAgICB9LCBzcy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICB9LCBzcy5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZDtcbiAgICB9LCBzcy5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudXBsb2FkZWQgfHwgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwga28pLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkpLCB0aGlzLmluZGV4QnVmZmVyMiA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5MikpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGxvYWQodCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCBzcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyMi5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMyLmRlc3Ryb3koKSk7XG4gICAgfSwgc3MucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZm9yICh2YXIgYSA9IDAsIG8gPSBucyhlLCA1MDApOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBzID0gb1thXSwgdSA9IDAsIGwgPSAwLCBwID0gczsgbCA8IHAubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICB1ICs9IHBbbF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQodSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgdGhpcy5pbmRleEFycmF5KSwgaCA9IGMudmVydGV4TGVuZ3RoLCBmID0gW10sIHkgPSBbXSwgZCA9IDAsIG0gPSBzOyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIHZhciB2ID0gbVtkXTtcblxuICAgICAgICAgIGlmICgwICE9PSB2Lmxlbmd0aCkge1xuICAgICAgICAgICAgdiAhPT0gc1swXSAmJiB5LnB1c2goZi5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5zZWdtZW50czIucHJlcGFyZVNlZ21lbnQodi5sZW5ndGgsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheTIpLFxuICAgICAgICAgICAgICAgIHggPSBnLnZlcnRleExlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkuZW1wbGFjZUJhY2sodlswXS54LCB2WzBdLnkpLCB0aGlzLmluZGV4QXJyYXkyLmVtcGxhY2VCYWNrKHggKyB2Lmxlbmd0aCAtIDEsIHgpLCBmLnB1c2godlswXS54KSwgZi5wdXNoKHZbMF0ueSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAxOyBiIDwgdi5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5LmVtcGxhY2VCYWNrKHZbYl0ueCwgdltiXS55KSwgdGhpcy5pbmRleEFycmF5Mi5lbXBsYWNlQmFjayh4ICsgYiAtIDEsIHggKyBiKSwgZi5wdXNoKHZbYl0ueCksIGYucHVzaCh2W2JdLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnLnZlcnRleExlbmd0aCArPSB2Lmxlbmd0aCwgZy5wcmltaXRpdmVMZW5ndGggKz0gdi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IElvKGYsIHkpLCBfID0gMDsgXyA8IHcubGVuZ3RoOyBfICs9IDMpIHtcbiAgICAgICAgICB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaCArIHdbX10sIGggKyB3W18gKyAxXSwgaCArIHdbXyArIDJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMudmVydGV4TGVuZ3RoICs9IHUsIGMucHJpbWl0aXZlTGVuZ3RoICs9IHcubGVuZ3RoIC8gMztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyh0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCwgdCwgciwgaSwgbik7XG4gICAgfSwgT24oXCJGaWxsQnVja2V0XCIsIHNzLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIiwgXCJwYXR0ZXJuRmVhdHVyZXNcIl1cbiAgICB9KTtcblxuICAgIHZhciB1cyA9IG5ldyB3aSh7XG4gICAgICBcImZpbGwtc29ydC1rZXlcIjogbmV3IHZpKEV0LmxheW91dF9maWxsW1wiZmlsbC1zb3J0LWtleVwiXSlcbiAgICB9KSxcbiAgICAgICAgbHMgPSB7XG4gICAgICBwYWludDogbmV3IHdpKHtcbiAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiBuZXcgbWkoRXQucGFpbnRfZmlsbFtcImZpbGwtYW50aWFsaWFzXCJdKSxcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogbmV3IHZpKEV0LnBhaW50X2ZpbGxbXCJmaWxsLW9wYWNpdHlcIl0pLFxuICAgICAgICBcImZpbGwtY29sb3JcIjogbmV3IHZpKEV0LnBhaW50X2ZpbGxbXCJmaWxsLWNvbG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjogbmV3IHZpKEV0LnBhaW50X2ZpbGxbXCJmaWxsLW91dGxpbmUtY29sb3JcIl0pLFxuICAgICAgICBcImZpbGwtdHJhbnNsYXRlXCI6IG5ldyBtaShFdC5wYWludF9maWxsW1wiZmlsbC10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgbWkoRXQucGFpbnRfZmlsbFtcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgIFwiZmlsbC1wYXR0ZXJuXCI6IG5ldyBnaShFdC5wYWludF9maWxsW1wiZmlsbC1wYXR0ZXJuXCJdKVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IHVzXG4gICAgfSxcbiAgICAgICAgcHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgdC5wcm90b3R5cGUucmVjYWxjdWxhdGUuY2FsbCh0aGlzLCBlLCByKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnBhaW50Ll92YWx1ZXNbXCJmaWxsLW91dGxpbmUtY29sb3JcIl07XG4gICAgICAgIFwiY29uc3RhbnRcIiA9PT0gbi52YWx1ZS5raW5kICYmIHZvaWQgMCA9PT0gbi52YWx1ZS52YWx1ZSAmJiAodGhpcy5wYWludC5fdmFsdWVzW1wiZmlsbC1vdXRsaW5lLWNvbG9yXCJdID0gdGhpcy5wYWludC5fdmFsdWVzW1wiZmlsbC1jb2xvclwiXSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IHNzKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbyh0aGlzLnBhaW50LmdldChcImZpbGwtdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICByZXR1cm4gR2Eocm8odCwgdGhpcy5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZVwiKSwgdGhpcy5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIiksIGEuYW5nbGUsIG8pLCBuKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzVGlsZUNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGU7XG4gICAgfShfaSksXG4gICAgICAgIGNzID0gSWkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfbm9ybWFsX2VkXCIsXG4gICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICAgIGhzID0gZnM7XG5cbiAgICBmdW5jdGlvbiBmcyh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fSwgdGhpcy5leHRlbnQgPSByLCB0aGlzLnR5cGUgPSAwLCB0aGlzLl9wYmYgPSB0LCB0aGlzLl9nZW9tZXRyeSA9IC0xLCB0aGlzLl9rZXlzID0gbiwgdGhpcy5fdmFsdWVzID0gaSwgdC5yZWFkRmllbGRzKHlzLCB0aGlzLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5cyh0LCBlLCByKSB7XG4gICAgICAxID09IHQgPyBlLmlkID0gci5yZWFkVmFyaW50KCkgOiAyID09IHQgPyBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gdC5yZWFkVmFyaW50KCkgKyB0LnBvczsgdC5wb3MgPCByOykge1xuICAgICAgICAgIHZhciBuID0gZS5fa2V5c1t0LnJlYWRWYXJpbnQoKV0sXG4gICAgICAgICAgICAgIGkgPSBlLl92YWx1ZXNbdC5yZWFkVmFyaW50KCldO1xuXG4gICAgICAgICAgZS5wcm9wZXJ0aWVzW25dID0gaTtcbiAgICAgICAgfVxuICAgICAgfShyLCBlKSA6IDMgPT0gdCA/IGUudHlwZSA9IHIucmVhZFZhcmludCgpIDogNCA9PSB0ICYmIChlLl9nZW9tZXRyeSA9IHIucG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcyh0KSB7XG4gICAgICBmb3IgKHZhciBlLCByLCBuID0gMCwgaSA9IDAsIGEgPSB0Lmxlbmd0aCwgbyA9IGEgLSAxOyBpIDwgYTsgbyA9IGkrKykge1xuICAgICAgICBuICs9ICgociA9IHRbb10pLnggLSAoZSA9IHRbaV0pLngpICogKGUueSArIHIueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZzLnR5cGVzID0gW1wiVW5rbm93blwiLCBcIlBvaW50XCIsIFwiTGluZVN0cmluZ1wiLCBcIlBvbHlnb25cIl0sIGZzLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3BiZjtcbiAgICAgIHQucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICAgIGZvciAodmFyIGUsIHIgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCBuID0gMSwgYSA9IDAsIG8gPSAwLCBzID0gMCwgdSA9IFtdOyB0LnBvcyA8IHI7KSB7XG4gICAgICAgIGlmIChhIDw9IDApIHtcbiAgICAgICAgICB2YXIgbCA9IHQucmVhZFZhcmludCgpO1xuICAgICAgICAgIG4gPSA3ICYgbCwgYSA9IGwgPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLS0sIDEgPT09IG4gfHwgMiA9PT0gbikgbyArPSB0LnJlYWRTVmFyaW50KCksIHMgKz0gdC5yZWFkU1ZhcmludCgpLCAxID09PSBuICYmIChlICYmIHUucHVzaChlKSwgZSA9IFtdKSwgZS5wdXNoKG5ldyBpKG8sIHMpKTtlbHNlIHtcbiAgICAgICAgICBpZiAoNyAhPT0gbikgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjb21tYW5kIFwiICsgbik7XG4gICAgICAgICAgZSAmJiBlLnB1c2goZVswXS5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiB1LnB1c2goZSksIHU7XG4gICAgfSwgZnMucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3BiZjtcbiAgICAgIHQucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICAgIGZvciAodmFyIGUgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCByID0gMSwgbiA9IDAsIGkgPSAwLCBhID0gMCwgbyA9IDEgLyAwLCBzID0gLTEgLyAwLCB1ID0gMSAvIDAsIGwgPSAtMSAvIDA7IHQucG9zIDwgZTspIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHZhciBwID0gdC5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgciA9IDcgJiBwLCBuID0gcCA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4tLSwgMSA9PT0gciB8fCAyID09PSByKSAoaSArPSB0LnJlYWRTVmFyaW50KCkpIDwgbyAmJiAobyA9IGkpLCBpID4gcyAmJiAocyA9IGkpLCAoYSArPSB0LnJlYWRTVmFyaW50KCkpIDwgdSAmJiAodSA9IGEpLCBhID4gbCAmJiAobCA9IGEpO2Vsc2UgaWYgKDcgIT09IHIpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gY29tbWFuZCBcIiArIHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW28sIHUsIHMsIGxdO1xuICAgIH0sIGZzLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBhID0gdGhpcy5leHRlbnQgKiBNYXRoLnBvdygyLCByKSxcbiAgICAgICAgICBvID0gdGhpcy5leHRlbnQgKiB0LFxuICAgICAgICAgIHMgPSB0aGlzLmV4dGVudCAqIGUsXG4gICAgICAgICAgdSA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgICAgbCA9IGZzLnR5cGVzW3RoaXMudHlwZV07XG5cbiAgICAgIGZ1bmN0aW9uIHAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgciA9IHRbZV07XG4gICAgICAgICAgdFtlXSA9IFszNjAgKiAoci54ICsgbykgLyBhIC0gMTgwLCAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKCgxODAgLSAzNjAgKiAoci55ICsgcykgLyBhKSAqIE1hdGguUEkgLyAxODApKSAtIDkwXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdmFyIGMgPSBbXTtcblxuICAgICAgICAgIGZvciAobiA9IDA7IG4gPCB1Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjW25dID0gdVtuXVswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwKHUgPSBjKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHAodVtuXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZvciAodSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGUgPD0gMSkgcmV0dXJuIFt0XTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciwgbiwgaSA9IFtdLCBhID0gMDsgYSA8IGU7IGErKykge1xuICAgICAgICAgICAgICB2YXIgbyA9IGRzKHRbYV0pO1xuICAgICAgICAgICAgICAwICE9PSBvICYmICh2b2lkIDAgPT09IG4gJiYgKG4gPSBvIDwgMCksIG4gPT09IG8gPCAwID8gKHIgJiYgaS5wdXNoKHIpLCByID0gW3RbYV1dKSA6IHIucHVzaCh0W2FdKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByICYmIGkucHVzaChyKSwgaTtcbiAgICAgICAgICB9KHUpLCBuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB1W25dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHAodVtuXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIDEgPT09IHUubGVuZ3RoID8gdSA9IHVbMF0gOiBsID0gXCJNdWx0aVwiICsgbDtcbiAgICAgIHZhciBoID0ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiBsLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB1XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBcImlkXCIgaW4gdGhpcyAmJiAoaC5pZCA9IHRoaXMuaWQpLCBoO1xuICAgIH07XG4gICAgdmFyIG1zID0gdnM7XG5cbiAgICBmdW5jdGlvbiB2cyh0LCBlKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSAxLCB0aGlzLm5hbWUgPSBudWxsLCB0aGlzLmV4dGVudCA9IDQwOTYsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5fcGJmID0gdCwgdGhpcy5fa2V5cyA9IFtdLCB0aGlzLl92YWx1ZXMgPSBbXSwgdGhpcy5fZmVhdHVyZXMgPSBbXSwgdC5yZWFkRmllbGRzKGdzLCB0aGlzLCBlKSwgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3ModCwgZSwgcikge1xuICAgICAgMTUgPT09IHQgPyBlLnZlcnNpb24gPSByLnJlYWRWYXJpbnQoKSA6IDEgPT09IHQgPyBlLm5hbWUgPSByLnJlYWRTdHJpbmcoKSA6IDUgPT09IHQgPyBlLmV4dGVudCA9IHIucmVhZFZhcmludCgpIDogMiA9PT0gdCA/IGUuX2ZlYXR1cmVzLnB1c2goci5wb3MpIDogMyA9PT0gdCA/IGUuX2tleXMucHVzaChyLnJlYWRTdHJpbmcoKSkgOiA0ID09PSB0ICYmIGUuX3ZhbHVlcy5wdXNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBudWxsLCByID0gdC5yZWFkVmFyaW50KCkgKyB0LnBvczsgdC5wb3MgPCByOykge1xuICAgICAgICAgIHZhciBuID0gdC5yZWFkVmFyaW50KCkgPj4gMztcbiAgICAgICAgICBlID0gMSA9PT0gbiA/IHQucmVhZFN0cmluZygpIDogMiA9PT0gbiA/IHQucmVhZEZsb2F0KCkgOiAzID09PSBuID8gdC5yZWFkRG91YmxlKCkgOiA0ID09PSBuID8gdC5yZWFkVmFyaW50NjQoKSA6IDUgPT09IG4gPyB0LnJlYWRWYXJpbnQoKSA6IDYgPT09IG4gPyB0LnJlYWRTVmFyaW50KCkgOiA3ID09PSBuID8gdC5yZWFkQm9vbGVhbigpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geHModCwgZSwgcikge1xuICAgICAgaWYgKDMgPT09IHQpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgbXMociwgci5yZWFkVmFyaW50KCkgKyByLnBvcyk7XG4gICAgICAgIG4ubGVuZ3RoICYmIChlW24ubmFtZV0gPSBuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2cy5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCA8IDAgfHwgdCA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1t0XTtcblxuICAgICAgdmFyIGUgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcblxuICAgICAgcmV0dXJuIG5ldyBocyh0aGlzLl9wYmYsIGUsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH07XG5cbiAgICB2YXIgYnMgPSB7XG4gICAgICBWZWN0b3JUaWxlOiBmdW5jdGlvbiBWZWN0b3JUaWxlKHQsIGUpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSB0LnJlYWRGaWVsZHMoeHMsIHt9LCBlKTtcbiAgICAgIH0sXG4gICAgICBWZWN0b3JUaWxlRmVhdHVyZTogaHMsXG4gICAgICBWZWN0b3JUaWxlTGF5ZXI6IG1zXG4gICAgfSxcbiAgICAgICAgd3MgPSBicy5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyxcbiAgICAgICAgX3MgPSBNYXRoLnBvdygyLCAxMyk7XG5cbiAgICBmdW5jdGlvbiBBcyh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKGUsIHIsIDIgKiBNYXRoLmZsb29yKG4gKiBfcykgKyBvLCBpICogX3MgKiAyLCBhICogX3MgKiAyLCBNYXRoLnJvdW5kKHMpKTtcbiAgICB9XG5cbiAgICB2YXIgU3MgPSBmdW5jdGlvbiBTcyh0KSB7XG4gICAgICB0aGlzLnpvb20gPSB0Lnpvb20sIHRoaXMub3ZlcnNjYWxpbmcgPSB0Lm92ZXJzY2FsaW5nLCB0aGlzLmxheWVycyA9IHQubGF5ZXJzLCB0aGlzLmxheWVySWRzID0gdGhpcy5sYXllcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSksIHRoaXMuaW5kZXggPSB0LmluZGV4LCB0aGlzLmhhc1BhdHRlcm4gPSAhMSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBQaSgpLCB0aGlzLmluZGV4QXJyYXkgPSBuZXcgamkoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgVmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc2VnbWVudHMgPSBuZXcgc2EoKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBrcyh0LCBlKSB7XG4gICAgICByZXR1cm4gdC54ID09PSBlLnggJiYgKHQueCA8IDAgfHwgdC54ID4gODE5MikgfHwgdC55ID09PSBlLnkgJiYgKHQueSA8IDAgfHwgdC55ID4gODE5Mik7XG4gICAgfVxuXG4gICAgU3MucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXMgPSBbXSwgdGhpcy5oYXNQYXR0ZXJuID0gYXMoXCJmaWxsLWV4dHJ1c2lvblwiLCB0aGlzLmxheWVycywgZSk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dLFxuICAgICAgICAgICAgbyA9IGEuZmVhdHVyZSxcbiAgICAgICAgICAgIHMgPSBhLmlkLFxuICAgICAgICAgICAgdSA9IGEuaW5kZXgsXG4gICAgICAgICAgICBsID0gYS5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgcCA9IHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLm5lZWRHZW9tZXRyeSxcbiAgICAgICAgICAgIGMgPSBVYShvLCBwKTtcblxuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyBzaSh0aGlzLnpvb20pLCBjLCByKSkge1xuICAgICAgICAgIHZhciBoID0ge1xuICAgICAgICAgICAgaWQ6IHMsXG4gICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiBsLFxuICAgICAgICAgICAgaW5kZXg6IHUsXG4gICAgICAgICAgICBnZW9tZXRyeTogcCA/IGMuZ2VvbWV0cnkgOiBSYShvKSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG8ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgICAgICAgIHBhdHRlcm5zOiB7fVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5oYXNQYXR0ZXJuID8gdGhpcy5mZWF0dXJlcy5wdXNoKG9zKFwiZmlsbC1leHRydXNpb25cIiwgdGhpcy5sYXllcnMsIGgsIHRoaXMuem9vbSwgZSkpIDogdGhpcy5hZGRGZWF0dXJlKGgsIGguZ2VvbWV0cnksIHUsIHIsIHt9KSwgZS5mZWF0dXJlSW5kZXguaW5zZXJ0KG8sIGguZ2VvbWV0cnksIHUsIGwsIHRoaXMuaW5kZXgsICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFNzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMuZmVhdHVyZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGEsIGEuZ2VvbWV0cnksIGEuaW5kZXgsIGUsIHIpO1xuICAgICAgfVxuICAgIH0sIFNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwgU3MucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwgU3MucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwgU3MucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVwbG9hZGVkIHx8ICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGNzKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIFNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCkpO1xuICAgIH0sIFNzLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gbnMoZSwgNTAwKTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IG9bYV0sIHUgPSAwLCBsID0gMCwgcCA9IHM7IGwgPCBwLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgICAgdSArPSBwW2xdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSksIGggPSAwLCBmID0gczsgaCA8IGYubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICB2YXIgeSA9IGZbaF07XG4gICAgICAgICAgaWYgKDAgIT09IHkubGVuZ3RoICYmICEoKEIgPSB5KS5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueCA8IDA7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueCA+IDgxOTI7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueSA8IDA7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueSA+IDgxOTI7XG4gICAgICAgICAgfSkpKSBmb3IgKHZhciBkID0gMCwgbSA9IDA7IG0gPCB5Lmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHlbbV07XG5cbiAgICAgICAgICAgIGlmIChtID49IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGcgPSB5W20gLSAxXTtcblxuICAgICAgICAgICAgICBpZiAoIWtzKHYsIGcpKSB7XG4gICAgICAgICAgICAgICAgYy52ZXJ0ZXhMZW5ndGggKyA0ID4gc2EuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgKGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSB2LnN1YihnKS5fcGVycCgpLl91bml0KCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBnLmRpc3Qodik7XG5cbiAgICAgICAgICAgICAgICBkICsgYiA+IDMyNzY4ICYmIChkID0gMCksIEFzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMCwgZCksIEFzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMSwgZCksIEFzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGcueCwgZy55LCB4LngsIHgueSwgMCwgMCwgZCArPSBiKSwgQXModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgZy54LCBnLnksIHgueCwgeC55LCAwLCAxLCBkKTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGMudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayh3LCB3ICsgMiwgdyArIDEpLCB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2sodyArIDEsIHcgKyAyLCB3ICsgMyksIGMudmVydGV4TGVuZ3RoICs9IDQsIGMucHJpbWl0aXZlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYy52ZXJ0ZXhMZW5ndGggKyB1ID4gc2EuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgKGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KHUsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSkpLCBcIlBvbHlnb25cIiA9PT0gd3NbdC50eXBlXSkge1xuICAgICAgICAgIGZvciAodmFyIF8gPSBbXSwgQSA9IFtdLCBTID0gYy52ZXJ0ZXhMZW5ndGgsIGsgPSAwLCBJID0gczsgayA8IEkubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB6ID0gSVtrXTtcblxuICAgICAgICAgICAgaWYgKDAgIT09IHoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHogIT09IHNbMF0gJiYgQS5wdXNoKF8ubGVuZ3RoIC8gMik7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgQyA9IDA7IEMgPCB6Lmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIEUgPSB6W0NdO1xuICAgICAgICAgICAgICAgIEFzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIEUueCwgRS55LCAwLCAwLCAxLCAxLCAwKSwgXy5wdXNoKEUueCksIF8ucHVzaChFLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgUCA9IElvKF8sIEEpLCBNID0gMDsgTSA8IFAubGVuZ3RoOyBNICs9IDMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhTICsgUFtNXSwgUyArIFBbTSArIDJdLCBTICsgUFtNICsgMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMucHJpbWl0aXZlTGVuZ3RoICs9IFAubGVuZ3RoIC8gMywgYy52ZXJ0ZXhMZW5ndGggKz0gdTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgQjtcbiAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnBvcHVsYXRlUGFpbnRBcnJheXModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGgsIHQsIHIsIGksIG4pO1xuICAgIH0sIE9uKFwiRmlsbEV4dHJ1c2lvbkJ1Y2tldFwiLCBTcywge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCIsIFwiZmVhdHVyZXNcIl1cbiAgICB9KTtcblxuICAgIHZhciBJcyA9IHtcbiAgICAgIHBhaW50OiBuZXcgd2koe1xuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIjogbmV3IG1pKEV0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiBuZXcgdmkoRXRbXCJwYWludF9maWxsLWV4dHJ1c2lvblwiXVtcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIjogbmV3IG1pKEV0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IG1pKEV0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IG5ldyBnaShFdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXSksXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IG5ldyB2aShFdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24taGVpZ2h0XCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IG5ldyB2aShFdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tYmFzZVwiXSksXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjogbmV3IG1pKEV0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiXSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAgICAgenMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBJcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ModCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVvKHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcywgdSkge1xuICAgICAgICB2YXIgbCA9IHJvKHQsIHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCIpLCB0aGlzLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIiksIG8uYW5nbGUsIHMpLFxuICAgICAgICAgICAgcCA9IHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCIpLmV2YWx1YXRlKGUsIHIpLFxuICAgICAgICAgICAgYyA9IHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tYmFzZVwiKS5ldmFsdWF0ZShlLCByKSxcbiAgICAgICAgICAgIGggPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IDAsIHMgPSB0OyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgICAgIGwgPSBbdS54LCB1LnksIDAsIDFdO1xuICAgICAgICAgICAgcG8obCwgbCwgZSksIGEucHVzaChuZXcgaShsWzBdIC8gbFszXSwgbFsxXSAvIGxbM10pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfShsLCB1KSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IFtdLCBzID0gbls4XSAqIGUsIHUgPSBuWzldICogZSwgbCA9IG5bMTBdICogZSwgcCA9IG5bMTFdICogZSwgYyA9IG5bOF0gKiByLCBoID0gbls5XSAqIHIsIGYgPSBuWzEwXSAqIHIsIHkgPSBuWzExXSAqIHIsIGQgPSAwLCBtID0gdDsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBbXSwgZyA9IFtdLCB4ID0gMCwgYiA9IG1bZF07IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gYlt4XSxcbiAgICAgICAgICAgICAgICAgIF8gPSB3LngsXG4gICAgICAgICAgICAgICAgICBBID0gdy55LFxuICAgICAgICAgICAgICAgICAgUyA9IG5bMF0gKiBfICsgbls0XSAqIEEgKyBuWzEyXSxcbiAgICAgICAgICAgICAgICAgIGsgPSBuWzFdICogXyArIG5bNV0gKiBBICsgblsxM10sXG4gICAgICAgICAgICAgICAgICBJID0gblsyXSAqIF8gKyBuWzZdICogQSArIG5bMTRdLFxuICAgICAgICAgICAgICAgICAgeiA9IG5bM10gKiBfICsgbls3XSAqIEEgKyBuWzE1XSxcbiAgICAgICAgICAgICAgICAgIEMgPSBJICsgbCxcbiAgICAgICAgICAgICAgICAgIEUgPSB6ICsgcCxcbiAgICAgICAgICAgICAgICAgIFAgPSBTICsgYyxcbiAgICAgICAgICAgICAgICAgIE0gPSBrICsgaCxcbiAgICAgICAgICAgICAgICAgIEIgPSBJICsgZixcbiAgICAgICAgICAgICAgICAgIFQgPSB6ICsgeSxcbiAgICAgICAgICAgICAgICAgIFYgPSBuZXcgaSgoUyArIHMpIC8gRSwgKGsgKyB1KSAvIEUpO1xuICAgICAgICAgICAgICBWLnogPSBDIC8gRSwgdi5wdXNoKFYpO1xuICAgICAgICAgICAgICB2YXIgRiA9IG5ldyBpKFAgLyBULCBNIC8gVCk7XG4gICAgICAgICAgICAgIEYueiA9IEIgLyBULCBnLnB1c2goRik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEucHVzaCh2KSwgby5wdXNoKGcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbYSwgb107XG4gICAgICAgIH0obiwgYywgcCwgdSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgdmFyIG4gPSAxIC8gMDtcbiAgICAgICAgICBHYShyLCBlKSAmJiAobiA9IEVzKHIsIGVbMF0pKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGVbaV0sIG8gPSB0W2ldLCBzID0gMDsgcyA8IGEubGVuZ3RoIC0gMTsgcysrKSB7XG4gICAgICAgICAgICAgIHZhciB1ID0gYVtzXSxcbiAgICAgICAgICAgICAgICAgIGwgPSBbdSwgYVtzICsgMV0sIG9bcyArIDFdLCBvW3NdLCB1XTtcbiAgICAgICAgICAgICAgTmEociwgbCkgJiYgKG4gPSBNYXRoLm1pbihuLCBFcyhyLCBsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuICE9PSAxIC8gMCAmJiBuO1xuICAgICAgICB9KGZbMF0sIGZbMV0sIGgpO1xuICAgICAgfSwgZTtcbiAgICB9KF9pKTtcblxuICAgIGZ1bmN0aW9uIENzKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnggKiBlLnggKyB0LnkgKiBlLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRXModCwgZSkge1xuICAgICAgaWYgKDEgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIHIsIG4gPSAwLCBpID0gZVtuKytdOyAhciB8fCBpLmVxdWFscyhyKTspIHtcbiAgICAgICAgICBpZiAoIShyID0gZVtuKytdKSkgcmV0dXJuIDEgLyAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgdmFyIGEgPSBlW25dLFxuICAgICAgICAgICAgICBvID0gdFswXSxcbiAgICAgICAgICAgICAgcyA9IHIuc3ViKGkpLFxuICAgICAgICAgICAgICB1ID0gYS5zdWIoaSksXG4gICAgICAgICAgICAgIGwgPSBvLnN1YihpKSxcbiAgICAgICAgICAgICAgcCA9IENzKHMsIHMpLFxuICAgICAgICAgICAgICBjID0gQ3MocywgdSksXG4gICAgICAgICAgICAgIGggPSBDcyh1LCB1KSxcbiAgICAgICAgICAgICAgZiA9IENzKGwsIHMpLFxuICAgICAgICAgICAgICB5ID0gQ3MobCwgdSksXG4gICAgICAgICAgICAgIGQgPSBwICogaCAtIGMgKiBjLFxuICAgICAgICAgICAgICBtID0gKGggKiBmIC0gYyAqIHkpIC8gZCxcbiAgICAgICAgICAgICAgdiA9IChwICogeSAtIGMgKiBmKSAvIGQsXG4gICAgICAgICAgICAgIGcgPSBpLnogKiAoMSAtIG0gLSB2KSArIHIueiAqIG0gKyBhLnogKiB2O1xuICAgICAgICAgIGlmIChpc0Zpbml0ZShnKSkgcmV0dXJuIGc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMSAvIDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHggPSAxIC8gMCwgYiA9IDAsIHcgPSBlOyBiIDwgdy5sZW5ndGg7IGIgKz0gMSkge1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgd1tiXS56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgdmFyIFBzID0gSWkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3Nfbm9ybWFsXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX2RhdGFcIixcbiAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICB0eXBlOiBcIlVpbnQ4XCJcbiAgICB9XSwgNCkubWVtYmVycyxcbiAgICAgICAgTXMgPSBJaShbe1xuICAgICAgbmFtZTogXCJhX3V2X3hcIixcbiAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9zcGxpdF9pbmRleFwiLFxuICAgICAgY29tcG9uZW50czogMSxcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgfV0pLm1lbWJlcnMsXG4gICAgICAgIEJzID0gYnMuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICAgIFRzID0gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIDM3LjUpLFxuICAgICAgICBWcyA9IE1hdGgucG93KDIsIDE0KSAvIC41LFxuICAgICAgICBGcyA9IGZ1bmN0aW9uIEZzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcbiAgICAgIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLnBhdHRlcm5GZWF0dXJlcyA9IFtdLCB0aGlzLmxpbmVDbGlwc0FycmF5ID0gW10sIHRoaXMuZ3JhZGllbnRzID0ge30sIHRoaXMubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZS5ncmFkaWVudHNbdC5pZF0gPSB7fTtcbiAgICAgIH0pLCB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IE1pKCksIHRoaXMubGF5b3V0VmVydGV4QXJyYXkyID0gbmV3IEJpKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBqaSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IG5ldyBWYSh0LmxheWVycywgdC56b29tKSwgdGhpcy5zZWdtZW50cyA9IG5ldyBzYSgpLCB0aGlzLm1heExpbmVMZW5ndGggPSAwLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJJZHMgPSB0aGlzLmxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaXNTdGF0ZURlcGVuZGVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIEZzLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLmhhc1BhdHRlcm4gPSBhcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIGUpO1xuXG4gICAgICBmb3IgKHZhciBuID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LmdldChcImxpbmUtc29ydC1rZXlcIiksIGkgPSBbXSwgYSA9IDAsIG8gPSB0OyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICB2YXIgcyA9IG9bYV0sXG4gICAgICAgICAgICB1ID0gcy5mZWF0dXJlLFxuICAgICAgICAgICAgbCA9IHMuaWQsXG4gICAgICAgICAgICBwID0gcy5pbmRleCxcbiAgICAgICAgICAgIGMgPSBzLnNvdXJjZUxheWVySW5kZXgsXG4gICAgICAgICAgICBoID0gdGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIubmVlZEdlb21ldHJ5LFxuICAgICAgICAgICAgZiA9IFVhKHUsIGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5maWx0ZXIobmV3IHNpKHRoaXMuem9vbSksIGYsIHIpKSB7XG4gICAgICAgICAgdmFyIHkgPSBuID8gbi5ldmFsdWF0ZShmLCB7fSwgcikgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGQgPSB7XG4gICAgICAgICAgICBpZDogbCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHUucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IHUudHlwZSxcbiAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IGMsXG4gICAgICAgICAgICBpbmRleDogcCxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBoID8gZi5nZW9tZXRyeSA6IFJhKHUpLFxuICAgICAgICAgICAgcGF0dGVybnM6IHt9LFxuICAgICAgICAgICAgc29ydEtleTogeVxuICAgICAgICAgIH07XG4gICAgICAgICAgaS5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gJiYgaS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgbSA9IDAsIHYgPSBpOyBtIDwgdi5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgZyA9IHZbbV0sXG4gICAgICAgICAgICB4ID0gZy5nZW9tZXRyeSxcbiAgICAgICAgICAgIGIgPSBnLmluZGV4LFxuICAgICAgICAgICAgdyA9IGcuc291cmNlTGF5ZXJJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5oYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIF8gPSBvcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIGcsIHRoaXMuem9vbSwgZSk7XG5cbiAgICAgICAgICB0aGlzLnBhdHRlcm5GZWF0dXJlcy5wdXNoKF8pO1xuICAgICAgICB9IGVsc2UgdGhpcy5hZGRGZWF0dXJlKGcsIHgsIGIsIHIsIHt9KTtcblxuICAgICAgICBlLmZlYXR1cmVJbmRleC5pbnNlcnQodFtiXS5mZWF0dXJlLCB4LCBiLCB3LCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9LCBGcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMubGVuZ3RoICYmIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwZGF0ZVBhaW50QXJyYXlzKHQsIGUsIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMsIHIpO1xuICAgIH0sIEZzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMucGF0dGVybkZlYXR1cmVzOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZShhLCBhLmdlb21ldHJ5LCBhLmluZGV4LCBlLCByKTtcbiAgICAgIH1cbiAgICB9LCBGcy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICB9LCBGcy5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZDtcbiAgICB9LCBGcy5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudXBsb2FkZWQgfHwgKDAgIT09IHRoaXMubGF5b3V0VmVydGV4QXJyYXkyLmxlbmd0aCAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheTIsIE1zKSksIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgUHMpLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkpKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBsb2FkKHQpLCB0aGlzLnVwbG9hZGVkID0gITA7XG4gICAgfSwgRnMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZGVzdHJveSgpLCB0aGlzLnNlZ21lbnRzLmRlc3Ryb3koKSk7XG4gICAgfSwgRnMucHJvdG90eXBlLmxpbmVGZWF0dXJlQ2xpcHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQucHJvcGVydGllcyAmJiB0LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJtYXBib3hfY2xpcF9zdGFydFwiKSAmJiB0LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJtYXBib3hfY2xpcF9lbmRcIikpIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiArdC5wcm9wZXJ0aWVzLm1hcGJveF9jbGlwX3N0YXJ0LFxuICAgICAgICBlbmQ6ICt0LnByb3BlcnRpZXMubWFwYm94X2NsaXBfZW5kXG4gICAgICB9O1xuICAgIH0sIEZzLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgIG8gPSBhLmdldChcImxpbmUtam9pblwiKS5ldmFsdWF0ZSh0LCB7fSksXG4gICAgICAgICAgcyA9IGEuZ2V0KFwibGluZS1jYXBcIiksXG4gICAgICAgICAgdSA9IGEuZ2V0KFwibGluZS1taXRlci1saW1pdFwiKSxcbiAgICAgICAgICBsID0gYS5nZXQoXCJsaW5lLXJvdW5kLWxpbWl0XCIpO1xuICAgICAgdGhpcy5saW5lQ2xpcHMgPSB0aGlzLmxpbmVGZWF0dXJlQ2xpcHModCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwLCBjID0gZTsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lKGNbcF0sIHQsIG8sIHMsIHUsIGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5wb3B1bGF0ZVBhaW50QXJyYXlzKHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoLCB0LCByLCBpLCBuKTtcbiAgICB9LCBGcy5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBpZiAodGhpcy5kaXN0YW5jZSA9IDAsIHRoaXMuc2NhbGVkRGlzdGFuY2UgPSAwLCB0aGlzLnRvdGFsRGlzdGFuY2UgPSAwLCB0aGlzLmxpbmVDbGlwcykge1xuICAgICAgICB0aGlzLmxpbmVDbGlwc0FycmF5LnB1c2godGhpcy5saW5lQ2xpcHMpO1xuXG4gICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdC5sZW5ndGggLSAxOyBvKyspIHtcbiAgICAgICAgICB0aGlzLnRvdGFsRGlzdGFuY2UgKz0gdFtvXS5kaXN0KHRbbyArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGVkRGlzdGFuY2UoKSwgdGhpcy5tYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5tYXhMaW5lTGVuZ3RoLCB0aGlzLnRvdGFsRGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBzID0gXCJQb2x5Z29uXCIgPT09IEJzW2UudHlwZV0sIHUgPSB0Lmxlbmd0aDsgdSA+PSAyICYmIHRbdSAtIDFdLmVxdWFscyh0W3UgLSAyXSk7KSB7XG4gICAgICAgIHUtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB1IC0gMSAmJiB0W2xdLmVxdWFscyh0W2wgKyAxXSk7KSB7XG4gICAgICAgIGwrKztcbiAgICAgIH1cblxuICAgICAgaWYgKCEodSA8IChzID8gMyA6IDIpKSkge1xuICAgICAgICBcImJldmVsXCIgPT09IHIgJiYgKGkgPSAxLjA1KTtcbiAgICAgICAgdmFyIHAsXG4gICAgICAgICAgICBjID0gdGhpcy5vdmVyc2NhbGluZyA8PSAxNiA/IDEyMjg4MCAvICg1MTIgKiB0aGlzLm92ZXJzY2FsaW5nKSA6IDAsXG4gICAgICAgICAgICBoID0gdGhpcy5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCgxMCAqIHUsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSksXG4gICAgICAgICAgICBmID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGQgPSB2b2lkIDAsXG4gICAgICAgICAgICBtID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xLCBzICYmIChtID0gdFtsXS5zdWIocCA9IHRbdSAtIDJdKS5fdW5pdCgpLl9wZXJwKCkpO1xuXG4gICAgICAgIGZvciAodmFyIHYgPSBsOyB2IDwgdTsgdisrKSB7XG4gICAgICAgICAgaWYgKCEoeSA9IHYgPT09IHUgLSAxID8gcyA/IHRbbCArIDFdIDogdm9pZCAwIDogdFt2ICsgMV0pIHx8ICF0W3ZdLmVxdWFscyh5KSkge1xuICAgICAgICAgICAgbSAmJiAoZCA9IG0pLCBwICYmIChmID0gcCksIHAgPSB0W3ZdLCBtID0geSA/IHkuc3ViKHApLl91bml0KCkuX3BlcnAoKSA6IGQ7XG4gICAgICAgICAgICB2YXIgZyA9IChkID0gZCB8fCBtKS5hZGQobSk7XG4gICAgICAgICAgICAwID09PSBnLnggJiYgMCA9PT0gZy55IHx8IGcuX3VuaXQoKTtcblxuICAgICAgICAgICAgdmFyIHggPSBkLnggKiBtLnggKyBkLnkgKiBtLnksXG4gICAgICAgICAgICAgICAgYiA9IGcueCAqIG0ueCArIGcueSAqIG0ueSxcbiAgICAgICAgICAgICAgICB3ID0gMCAhPT0gYiA/IDEgLyBiIDogMSAvIDAsXG4gICAgICAgICAgICAgICAgXyA9IDIgKiBNYXRoLnNxcnQoMiAtIDIgKiBiKSxcbiAgICAgICAgICAgICAgICBBID0gYiA8IFRzICYmIGYgJiYgeSxcbiAgICAgICAgICAgICAgICBTID0gZC54ICogbS55IC0gZC55ICogbS54ID4gMDtcblxuICAgICAgICAgICAgaWYgKEEgJiYgdiA+IGwpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBwLmRpc3QoZik7XG5cbiAgICAgICAgICAgICAgaWYgKGsgPiAyICogYykge1xuICAgICAgICAgICAgICAgIHZhciBJID0gcC5zdWIocC5zdWIoZikuX211bHQoYyAvIGspLl9yb3VuZCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3RhbmNlKGYsIEkpLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoSSwgZCwgMCwgMCwgaCksIGYgPSBJO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB6ID0gZiAmJiB5LFxuICAgICAgICAgICAgICAgIEMgPSB6ID8gciA6IHMgPyBcImJ1dHRcIiA6IG47XG4gICAgICAgICAgICBpZiAoeiAmJiBcInJvdW5kXCIgPT09IEMgJiYgKHcgPCBhID8gQyA9IFwibWl0ZXJcIiA6IHcgPD0gMiAmJiAoQyA9IFwiZmFrZXJvdW5kXCIpKSwgXCJtaXRlclwiID09PSBDICYmIHcgPiBpICYmIChDID0gXCJiZXZlbFwiKSwgXCJiZXZlbFwiID09PSBDICYmICh3ID4gMiAmJiAoQyA9IFwiZmxpcGJldmVsXCIpLCB3IDwgaSAmJiAoQyA9IFwibWl0ZXJcIikpLCBmICYmIHRoaXMudXBkYXRlRGlzdGFuY2UoZiwgcCksIFwibWl0ZXJcIiA9PT0gQykgZy5fbXVsdCh3KSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcsIDAsIDAsIGgpO2Vsc2UgaWYgKFwiZmxpcGJldmVsXCIgPT09IEMpIHtcbiAgICAgICAgICAgICAgaWYgKHcgPiAxMDApIGcgPSBtLm11bHQoLTEpO2Vsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBFID0gdyAqIGQuYWRkKG0pLm1hZygpIC8gZC5zdWIobSkubWFnKCk7XG5cbiAgICAgICAgICAgICAgICBnLl9wZXJwKCkuX211bHQoRSAqIChTID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcsIDAsIDAsIGgpLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZy5tdWx0KC0xKSwgMCwgMCwgaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiYmV2ZWxcIiA9PT0gQyB8fCBcImZha2Vyb3VuZFwiID09PSBDKSB7XG4gICAgICAgICAgICAgIHZhciBQID0gLU1hdGguc3FydCh3ICogdyAtIDEpLFxuICAgICAgICAgICAgICAgICAgTSA9IFMgPyBQIDogMCxcbiAgICAgICAgICAgICAgICAgIEIgPSBTID8gMCA6IFA7XG4gICAgICAgICAgICAgIGlmIChmICYmIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBkLCBNLCBCLCBoKSwgXCJmYWtlcm91bmRcIiA9PT0gQykgZm9yICh2YXIgVCA9IE1hdGgucm91bmQoMTgwICogXyAvIE1hdGguUEkgLyAyMCksIFYgPSAxOyBWIDwgVDsgVisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIEYgPSBWIC8gVDtcblxuICAgICAgICAgICAgICAgIGlmICguNSAhPT0gRikge1xuICAgICAgICAgICAgICAgICAgdmFyIEQgPSBGIC0gLjU7XG4gICAgICAgICAgICAgICAgICBGICs9IEYgKiBEICogKEYgLSAxKSAqICgoMS4wOTA0ICsgeCAqICh4ICogKDMuNTU2NDUgLSAxLjQzNTE5ICogeCkgLSAzLjI0NTIpKSAqIEQgKiBEICsgKC44NDgwMTMgKyB4ICogKC4yMTU2MzggKiB4IC0gMS4wNjAyMSkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgTCA9IG0uc3ViKGQpLl9tdWx0KEYpLl9hZGQoZCkuX3VuaXQoKS5fbXVsdChTID8gLTEgOiAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFsZlZlcnRleChwLCBMLngsIEwueSwgITEsIFMsIDAsIGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHkgJiYgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIG0sIC1NLCAtQiwgaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiYnV0dFwiID09PSBDKSB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZywgMCwgMCwgaCk7ZWxzZSBpZiAoXCJzcXVhcmVcIiA9PT0gQykge1xuICAgICAgICAgICAgICB2YXIgTyA9IGYgPyAxIDogLTE7XG4gICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBnLCBPLCBPLCBoKTtcbiAgICAgICAgICAgIH0gZWxzZSBcInJvdW5kXCIgPT09IEMgJiYgKGYgJiYgKHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBkLCAwLCAwLCBoKSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGQsIDEsIDEsIGgsICEwKSksIHkgJiYgKHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBtLCAtMSwgLTEsIGgsICEwKSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIG0sIDAsIDAsIGgpKSk7XG5cbiAgICAgICAgICAgIGlmIChBICYmIHYgPCB1IC0gMSkge1xuICAgICAgICAgICAgICB2YXIgUiA9IHAuZGlzdCh5KTtcblxuICAgICAgICAgICAgICBpZiAoUiA+IDIgKiBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIFUgPSBwLmFkZCh5LnN1YihwKS5fbXVsdChjIC8gUikuX3JvdW5kKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzdGFuY2UocCwgVSksIHRoaXMuYWRkQ3VycmVudFZlcnRleChVLCBtLCAwLCAwLCBoKSwgcCA9IFU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBGcy5wcm90b3R5cGUuYWRkQ3VycmVudFZlcnRleCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMSk7XG4gICAgICB2YXIgbyA9IGUueSAqIG4gLSBlLngsXG4gICAgICAgICAgcyA9IC1lLnkgLSBlLnggKiBuO1xuICAgICAgdGhpcy5hZGRIYWxmVmVydGV4KHQsIGUueCArIGUueSAqIHIsIGUueSAtIGUueCAqIHIsIGEsICExLCByLCBpKSwgdGhpcy5hZGRIYWxmVmVydGV4KHQsIG8sIHMsIGEsICEwLCAtbiwgaSksIHRoaXMuZGlzdGFuY2UgPiBWcyAvIDIgJiYgMCA9PT0gdGhpcy50b3RhbERpc3RhbmNlICYmICh0aGlzLmRpc3RhbmNlID0gMCwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHQsIGUsIHIsIG4sIGksIGEpKTtcbiAgICB9LCBGcy5wcm90b3R5cGUuYWRkSGFsZlZlcnRleCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICB2YXIgcyA9IC41ICogKHRoaXMubGluZUNsaXBzID8gdGhpcy5zY2FsZWREaXN0YW5jZSAqIChWcyAtIDEpIDogdGhpcy5zY2FsZWREaXN0YW5jZSk7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5LmVtcGxhY2VCYWNrKCh0LnggPDwgMSkgKyAobiA/IDEgOiAwKSwgKHQueSA8PCAxKSArIChpID8gMSA6IDApLCBNYXRoLnJvdW5kKDYzICogZSkgKyAxMjgsIE1hdGgucm91bmQoNjMgKiByKSArIDEyOCwgMSArICgwID09PSBhID8gMCA6IGEgPCAwID8gLTEgOiAxKSB8ICg2MyAmIHMpIDw8IDIsIHMgPj4gNiksIHRoaXMubGluZUNsaXBzICYmIHRoaXMubGF5b3V0VmVydGV4QXJyYXkyLmVtcGxhY2VCYWNrKCh0aGlzLnNjYWxlZERpc3RhbmNlIC0gdGhpcy5saW5lQ2xpcHMuc3RhcnQpIC8gKHRoaXMubGluZUNsaXBzLmVuZCAtIHRoaXMubGluZUNsaXBzLnN0YXJ0KSwgdGhpcy5saW5lQ2xpcHNBcnJheS5sZW5ndGgpO1xuICAgICAgdmFyIHUgPSBvLnZlcnRleExlbmd0aCsrO1xuICAgICAgdGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCAmJiAodGhpcy5pbmRleEFycmF5LmVtcGxhY2VCYWNrKHRoaXMuZTEsIHRoaXMuZTIsIHUpLCBvLnByaW1pdGl2ZUxlbmd0aCsrKSwgaSA/IHRoaXMuZTIgPSB1IDogdGhpcy5lMSA9IHU7XG4gICAgfSwgRnMucHJvdG90eXBlLnVwZGF0ZVNjYWxlZERpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zY2FsZWREaXN0YW5jZSA9IHRoaXMubGluZUNsaXBzID8gdGhpcy5saW5lQ2xpcHMuc3RhcnQgKyAodGhpcy5saW5lQ2xpcHMuZW5kIC0gdGhpcy5saW5lQ2xpcHMuc3RhcnQpICogdGhpcy5kaXN0YW5jZSAvIHRoaXMudG90YWxEaXN0YW5jZSA6IHRoaXMuZGlzdGFuY2U7XG4gICAgfSwgRnMucHJvdG90eXBlLnVwZGF0ZURpc3RhbmNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuZGlzdGFuY2UgKz0gdC5kaXN0KGUpLCB0aGlzLnVwZGF0ZVNjYWxlZERpc3RhbmNlKCk7XG4gICAgfSwgT24oXCJMaW5lQnVja2V0XCIsIEZzLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIiwgXCJwYXR0ZXJuRmVhdHVyZXNcIl1cbiAgICB9KTtcbiAgICB2YXIgRHMgPSBuZXcgd2koe1xuICAgICAgXCJsaW5lLWNhcFwiOiBuZXcgbWkoRXQubGF5b3V0X2xpbmVbXCJsaW5lLWNhcFwiXSksXG4gICAgICBcImxpbmUtam9pblwiOiBuZXcgdmkoRXQubGF5b3V0X2xpbmVbXCJsaW5lLWpvaW5cIl0pLFxuICAgICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IG5ldyBtaShFdC5sYXlvdXRfbGluZVtcImxpbmUtbWl0ZXItbGltaXRcIl0pLFxuICAgICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IG5ldyBtaShFdC5sYXlvdXRfbGluZVtcImxpbmUtcm91bmQtbGltaXRcIl0pLFxuICAgICAgXCJsaW5lLXNvcnQta2V5XCI6IG5ldyB2aShFdC5sYXlvdXRfbGluZVtcImxpbmUtc29ydC1rZXlcIl0pXG4gICAgfSksXG4gICAgICAgIExzID0ge1xuICAgICAgcGFpbnQ6IG5ldyB3aSh7XG4gICAgICAgIFwibGluZS1vcGFjaXR5XCI6IG5ldyB2aShFdC5wYWludF9saW5lW1wibGluZS1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJsaW5lLWNvbG9yXCI6IG5ldyB2aShFdC5wYWludF9saW5lW1wibGluZS1jb2xvclwiXSksXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIjogbmV3IG1pKEV0LnBhaW50X2xpbmVbXCJsaW5lLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgIFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IG5ldyBtaShFdC5wYWludF9saW5lW1wibGluZS10cmFuc2xhdGUtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJsaW5lLXdpZHRoXCI6IG5ldyB2aShFdC5wYWludF9saW5lW1wibGluZS13aWR0aFwiXSksXG4gICAgICAgIFwibGluZS1nYXAtd2lkdGhcIjogbmV3IHZpKEV0LnBhaW50X2xpbmVbXCJsaW5lLWdhcC13aWR0aFwiXSksXG4gICAgICAgIFwibGluZS1vZmZzZXRcIjogbmV3IHZpKEV0LnBhaW50X2xpbmVbXCJsaW5lLW9mZnNldFwiXSksXG4gICAgICAgIFwibGluZS1ibHVyXCI6IG5ldyB2aShFdC5wYWludF9saW5lW1wibGluZS1ibHVyXCJdKSxcbiAgICAgICAgXCJsaW5lLWRhc2hhcnJheVwiOiBuZXcgeGkoRXQucGFpbnRfbGluZVtcImxpbmUtZGFzaGFycmF5XCJdKSxcbiAgICAgICAgXCJsaW5lLXBhdHRlcm5cIjogbmV3IGdpKEV0LnBhaW50X2xpbmVbXCJsaW5lLXBhdHRlcm5cIl0pLFxuICAgICAgICBcImxpbmUtZ3JhZGllbnRcIjogbmV3IGJpKEV0LnBhaW50X2xpbmVbXCJsaW5lLWdyYWRpZW50XCJdKVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IERzXG4gICAgfSxcbiAgICAgICAgT3MgPSBuZXcgKGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICByZXR1cm4gciA9IG5ldyBzaShNYXRoLmZsb29yKHIuem9vbSksIHtcbiAgICAgICAgICBub3c6IHIubm93LFxuICAgICAgICAgIGZhZGVEdXJhdGlvbjogci5mYWRlRHVyYXRpb24sXG4gICAgICAgICAgem9vbUhpc3Rvcnk6IHIuem9vbUhpc3RvcnksXG4gICAgICAgICAgdHJhbnNpdGlvbjogci50cmFuc2l0aW9uXG4gICAgICAgIH0pLCB0LnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlLmNhbGwodGhpcywgZSwgcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChlLCByLCBuLCBpKSB7XG4gICAgICAgIHJldHVybiByID0gaCh7fSwgciwge1xuICAgICAgICAgIHpvb206IE1hdGguZmxvb3Ioci56b29tKVxuICAgICAgICB9KSwgdC5wcm90b3R5cGUuZXZhbHVhdGUuY2FsbCh0aGlzLCBlLCByLCBuLCBpKTtcbiAgICAgIH0sIGU7XG4gICAgfSh2aSkpKExzLnBhaW50LnByb3BlcnRpZXNbXCJsaW5lLXdpZHRoXCJdLnNwZWNpZmljYXRpb24pO1xuICAgIE9zLnVzZUludGVnZXJab29tID0gITA7XG5cbiAgICB2YXIgUnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBMcyksIHRoaXMuZ3JhZGllbnRWZXJzaW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2hhbmRsZVNwZWNpYWxQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgXCJsaW5lLWdyYWRpZW50XCIgPT09IHQgJiYgKHRoaXMuc3RlcEludGVycG9sYW50ID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW1wibGluZS1ncmFkaWVudFwiXS52YWx1ZS5leHByZXNzaW9uLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbiBpbnN0YW5jZW9mIE5lLCB0aGlzLmdyYWRpZW50VmVyc2lvbiA9ICh0aGlzLmdyYWRpZW50VmVyc2lvbiArIDEpICUgcyk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5ncmFkaWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50Ll92YWx1ZXNbXCJsaW5lLWdyYWRpZW50XCJdLnZhbHVlLmV4cHJlc3Npb247XG4gICAgICB9LCBlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIHQucHJvdG90eXBlLnJlY2FsY3VsYXRlLmNhbGwodGhpcywgZSwgciksIHRoaXMucGFpbnQuX3ZhbHVlc1tcImxpbmUtZmxvb3J3aWR0aFwiXSA9IE9zLnBvc3NpYmx5RXZhbHVhdGUodGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50Ll92YWx1ZXNbXCJsaW5lLXdpZHRoXCJdLnZhbHVlLCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnModCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdCxcbiAgICAgICAgICAgIHIgPSBVcyh0byhcImxpbmUtd2lkdGhcIiwgdGhpcywgZSksIHRvKFwibGluZS1nYXAtd2lkdGhcIiwgdGhpcywgZSkpLFxuICAgICAgICAgICAgbiA9IHRvKFwibGluZS1vZmZzZXRcIiwgdGhpcywgZSk7XG4gICAgICAgIHJldHVybiByIC8gMiArIE1hdGguYWJzKG4pICsgZW8odGhpcy5wYWludC5nZXQoXCJsaW5lLXRyYW5zbGF0ZVwiKSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeUludGVyc2VjdHNGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGEsIG8sIHMpIHtcbiAgICAgICAgdmFyIHUgPSBybyh0LCB0aGlzLnBhaW50LmdldChcImxpbmUtdHJhbnNsYXRlXCIpLCB0aGlzLnBhaW50LmdldChcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiKSwgby5hbmdsZSwgcyksXG4gICAgICAgICAgICBsID0gcyAvIDIgKiBVcyh0aGlzLnBhaW50LmdldChcImxpbmUtd2lkdGhcIikuZXZhbHVhdGUoZSwgciksIHRoaXMucGFpbnQuZ2V0KFwibGluZS1nYXAtd2lkdGhcIikuZXZhbHVhdGUoZSwgcikpLFxuICAgICAgICAgICAgcCA9IHRoaXMucGFpbnQuZ2V0KFwibGluZS1vZmZzZXRcIikuZXZhbHVhdGUoZSwgcik7XG4gICAgICAgIHJldHVybiBwICYmIChuID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gW10sIG4gPSBuZXcgaSgwLCAwKSwgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvID0gdFthXSwgcyA9IFtdLCB1ID0gMDsgdSA8IG8ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBvW3VdLFxuICAgICAgICAgICAgICAgICAgcCA9IG9bdSArIDFdLFxuICAgICAgICAgICAgICAgICAgYyA9IDAgPT09IHUgPyBuIDogbC5zdWIob1t1IC0gMV0pLl91bml0KCkuX3BlcnAoKSxcbiAgICAgICAgICAgICAgICAgIGggPSB1ID09PSBvLmxlbmd0aCAtIDEgPyBuIDogcC5zdWIobCkuX3VuaXQoKS5fcGVycCgpLFxuICAgICAgICAgICAgICAgICAgZiA9IGMuX2FkZChoKS5fdW5pdCgpO1xuXG4gICAgICAgICAgICAgIGYuX211bHQoMSAvIChmLnggKiBoLnggKyBmLnkgKiBoLnkpKSwgcy5wdXNoKGYuX211bHQoZSkuX2FkZChsKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucHVzaChzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfShuLCBwICogcykpLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIGkgPSBlW25dO1xuICAgICAgICAgICAgaWYgKHQubGVuZ3RoID49IDMpIGZvciAodmFyIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICBpZiAoV2EodCwgaVthXSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChaYSh0LCBpLCByKSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSh1LCBuLCBsKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzVGlsZUNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGU7XG4gICAgfShfaSk7XG5cbiAgICBmdW5jdGlvbiBVcyh0LCBlKSB7XG4gICAgICByZXR1cm4gZSA+IDAgPyBlICsgMiAqIHQgOiB0O1xuICAgIH1cblxuICAgIHZhciBqcyA9IElpKFt7XG4gICAgICBuYW1lOiBcImFfcG9zX29mZnNldFwiLFxuICAgICAgY29tcG9uZW50czogNCxcbiAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9kYXRhXCIsXG4gICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9waXhlbG9mZnNldFwiLFxuICAgICAgY29tcG9uZW50czogNCxcbiAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgIH1dLCA0KSxcbiAgICAgICAgcXMgPSBJaShbe1xuICAgICAgbmFtZTogXCJhX3Byb2plY3RlZF9wb3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDMsXG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIlxuICAgIH1dLCA0KSxcbiAgICAgICAgTnMgPSAoSWkoW3tcbiAgICAgIG5hbWU6IFwiYV9mYWRlX29wYWNpdHlcIixcbiAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICB0eXBlOiBcIlVpbnQzMlwiXG4gICAgfV0sIDQpLCBJaShbe1xuICAgICAgbmFtZTogXCJhX3BsYWNlZFwiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiVWludDhcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9zaGlmdFwiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgfV0pKSxcbiAgICAgICAgS3MgPSAoSWkoW3tcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYW5jaG9yUG9pbnRYXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvclBvaW50WVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ4MVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ5MVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ4MlwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ5MlwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwiZmVhdHVyZUluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJzb3VyY2VMYXllckluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJidWNrZXRJbmRleFwiXG4gICAgfV0pLCBJaShbe1xuICAgICAgbmFtZTogXCJhX3Bvc1wiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9hbmNob3JfcG9zXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX2V4dHJ1ZGVcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9XSwgNCkpLFxuICAgICAgICBHcyA9IElpKFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfcmFkaXVzXCIsXG4gICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfZmxhZ3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9XSwgNCk7XG5cbiAgICBmdW5jdGlvbiBacyh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdC5zZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQudGV4dCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgdmFyIG4gPSBlLmxheW91dC5nZXQoXCJ0ZXh0LXRyYW5zZm9ybVwiKS5ldmFsdWF0ZShyLCB7fSk7XG4gICAgICAgICAgcmV0dXJuIFwidXBwZXJjYXNlXCIgPT09IG4gPyB0ID0gdC50b0xvY2FsZVVwcGVyQ2FzZSgpIDogXCJsb3dlcmNhc2VcIiA9PT0gbiAmJiAodCA9IHQudG9Mb2NhbGVMb3dlckNhc2UoKSksIG9pLmFwcGx5QXJhYmljU2hhcGluZyAmJiAodCA9IG9pLmFwcGx5QXJhYmljU2hhcGluZyh0KSksIHQ7XG4gICAgICAgIH0odC50ZXh0LCBlLCByKTtcbiAgICAgIH0pLCB0O1xuICAgIH1cblxuICAgIElpKFt7XG4gICAgICBuYW1lOiBcInRyaWFuZ2xlXCIsXG4gICAgICBjb21wb25lbnRzOiAzLFxuICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgIH1dKSwgSWkoW3tcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYW5jaG9yWFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhbmNob3JZXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJnbHlwaFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcIm51bUdseXBoc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwidmVydGV4U3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwibGluZVN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcImxpbmVMZW5ndGhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInNlZ21lbnRcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImxvd2VyU2l6ZVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidXBwZXJTaXplXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIG5hbWU6IFwibGluZU9mZnNldFhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgbmFtZTogXCJsaW5lT2Zmc2V0WVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50OFwiLFxuICAgICAgbmFtZTogXCJ3cml0aW5nTW9kZVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50OFwiLFxuICAgICAgbmFtZTogXCJwbGFjZWRPcmllbnRhdGlvblwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50OFwiLFxuICAgICAgbmFtZTogXCJoaWRkZW5cIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcImNyb3NzVGlsZUlEXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFzc29jaWF0ZWRJY29uSW5kZXhcIlxuICAgIH1dKSwgSWkoW3tcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYW5jaG9yWFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhbmNob3JZXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInJpZ2h0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJsZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInBsYWNlZEljb25TeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbFBsYWNlZEljb25TeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwia2V5XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ0ZXh0Qm94U3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidGV4dEJveEVuZEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbFRleHRCb3hFbmRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwiaWNvbkJveFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImljb25Cb3hFbmRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxJY29uQm94U3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxJY29uQm94RW5kSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImZlYXR1cmVJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcIm51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibnVtSWNvblZlcnRpY2VzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJudW1WZXJ0aWNhbEljb25WZXJ0aWNlc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcImNyb3NzVGlsZUlEXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIG5hbWU6IFwidGV4dEJveFNjYWxlXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICBuYW1lOiBcInRleHRPZmZzZXRcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgbmFtZTogXCJjb2xsaXNpb25DaXJjbGVEaWFtZXRlclwiXG4gICAgfV0pLCBJaShbe1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBuYW1lOiBcIm9mZnNldFhcIlxuICAgIH1dKSwgSWkoW3tcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ5XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yXCJcbiAgICB9XSk7XG5cbiAgICB2YXIgWHMgPSB7XG4gICAgICBcIiFcIjogXCLvuJVcIixcbiAgICAgIFwiI1wiOiBcIu+8g1wiLFxuICAgICAgJDogXCLvvIRcIixcbiAgICAgIFwiJVwiOiBcIu+8hVwiLFxuICAgICAgXCImXCI6IFwi77yGXCIsXG4gICAgICBcIihcIjogXCLvuLVcIixcbiAgICAgIFwiKVwiOiBcIu+4tlwiLFxuICAgICAgXCIqXCI6IFwi77yKXCIsXG4gICAgICBcIitcIjogXCLvvItcIixcbiAgICAgIFwiLFwiOiBcIu+4kFwiLFxuICAgICAgXCItXCI6IFwi77iyXCIsXG4gICAgICBcIi5cIjogXCLjg7tcIixcbiAgICAgIFwiL1wiOiBcIu+8j1wiLFxuICAgICAgXCI6XCI6IFwi77iTXCIsXG4gICAgICBcIjtcIjogXCLvuJRcIixcbiAgICAgIFwiPFwiOiBcIu+4v1wiLFxuICAgICAgXCI9XCI6IFwi77ydXCIsXG4gICAgICBcIj5cIjogXCLvuYBcIixcbiAgICAgIFwiP1wiOiBcIu+4llwiLFxuICAgICAgXCJAXCI6IFwi77ygXCIsXG4gICAgICBcIltcIjogXCLvuYdcIixcbiAgICAgIFwiXFxcXFwiOiBcIu+8vFwiLFxuICAgICAgXCJdXCI6IFwi77mIXCIsXG4gICAgICBcIl5cIjogXCLvvL5cIixcbiAgICAgIF86IFwi77izXCIsXG4gICAgICBcImBcIjogXCLvvYBcIixcbiAgICAgIFwie1wiOiBcIu+4t1wiLFxuICAgICAgXCJ8XCI6IFwi4oCVXCIsXG4gICAgICBcIn1cIjogXCLvuLhcIixcbiAgICAgIFwiflwiOiBcIu+9nlwiLFxuICAgICAgXCLColwiOiBcIu+/oFwiLFxuICAgICAgXCLCo1wiOiBcIu+/oVwiLFxuICAgICAgXCLCpVwiOiBcIu+/pVwiLFxuICAgICAgXCLCplwiOiBcIu+/pFwiLFxuICAgICAgXCLCrFwiOiBcIu+/olwiLFxuICAgICAgXCLCr1wiOiBcIu+/o1wiLFxuICAgICAgXCLigJNcIjogXCLvuLJcIixcbiAgICAgIFwi4oCUXCI6IFwi77ixXCIsXG4gICAgICBcIuKAmFwiOiBcIu+5g1wiLFxuICAgICAgXCLigJlcIjogXCLvuYRcIixcbiAgICAgIFwi4oCcXCI6IFwi77mBXCIsXG4gICAgICBcIuKAnVwiOiBcIu+5glwiLFxuICAgICAgXCLigKZcIjogXCLvuJlcIixcbiAgICAgIFwi4oCnXCI6IFwi44O7XCIsXG4gICAgICBcIuKCqVwiOiBcIu+/plwiLFxuICAgICAgXCLjgIFcIjogXCLvuJFcIixcbiAgICAgIFwi44CCXCI6IFwi77iSXCIsXG4gICAgICBcIuOAiFwiOiBcIu+4v1wiLFxuICAgICAgXCLjgIlcIjogXCLvuYBcIixcbiAgICAgIFwi44CKXCI6IFwi77i9XCIsXG4gICAgICBcIuOAi1wiOiBcIu+4vlwiLFxuICAgICAgXCLjgIxcIjogXCLvuYFcIixcbiAgICAgIFwi44CNXCI6IFwi77mCXCIsXG4gICAgICBcIuOAjlwiOiBcIu+5g1wiLFxuICAgICAgXCLjgI9cIjogXCLvuYRcIixcbiAgICAgIFwi44CQXCI6IFwi77i7XCIsXG4gICAgICBcIuOAkVwiOiBcIu+4vFwiLFxuICAgICAgXCLjgJRcIjogXCLvuLlcIixcbiAgICAgIFwi44CVXCI6IFwi77i6XCIsXG4gICAgICBcIuOAllwiOiBcIu+4l1wiLFxuICAgICAgXCLjgJdcIjogXCLvuJhcIixcbiAgICAgIFwi77yBXCI6IFwi77iVXCIsXG4gICAgICBcIu+8iFwiOiBcIu+4tVwiLFxuICAgICAgXCLvvIlcIjogXCLvuLZcIixcbiAgICAgIFwi77yMXCI6IFwi77iQXCIsXG4gICAgICBcIu+8jVwiOiBcIu+4slwiLFxuICAgICAgXCLvvI5cIjogXCLjg7tcIixcbiAgICAgIFwi77yaXCI6IFwi77iTXCIsXG4gICAgICBcIu+8m1wiOiBcIu+4lFwiLFxuICAgICAgXCLvvJxcIjogXCLvuL9cIixcbiAgICAgIFwi77yeXCI6IFwi77mAXCIsXG4gICAgICBcIu+8n1wiOiBcIu+4llwiLFxuICAgICAgXCLvvLtcIjogXCLvuYdcIixcbiAgICAgIFwi77y9XCI6IFwi77mIXCIsXG4gICAgICBcIu+8v1wiOiBcIu+4s1wiLFxuICAgICAgXCLvvZtcIjogXCLvuLdcIixcbiAgICAgIFwi772cXCI6IFwi4oCVXCIsXG4gICAgICBcIu+9nVwiOiBcIu+4uFwiLFxuICAgICAgXCLvvZ9cIjogXCLvuLVcIixcbiAgICAgIFwi772gXCI6IFwi77i2XCIsXG4gICAgICBcIu+9oVwiOiBcIu+4klwiLFxuICAgICAgXCLvvaJcIjogXCLvuYFcIixcbiAgICAgIFwi772jXCI6IFwi77mCXCJcbiAgICB9LFxuICAgICAgICBKcyA9IGZ1bmN0aW9uIEpzKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgcyA9IDggKiBpIC0gbiAtIDEsXG4gICAgICAgICAgdSA9ICgxIDw8IHMpIC0gMSxcbiAgICAgICAgICBsID0gdSA+PiAxLFxuICAgICAgICAgIHAgPSAtNyxcbiAgICAgICAgICBjID0gciA/IGkgLSAxIDogMCxcbiAgICAgICAgICBoID0gciA/IC0xIDogMSxcbiAgICAgICAgICBmID0gdFtlICsgY107XG5cbiAgICAgIGZvciAoYyArPSBoLCBhID0gZiAmICgxIDw8IC1wKSAtIDEsIGYgPj49IC1wLCBwICs9IHM7IHAgPiAwOyBhID0gMjU2ICogYSArIHRbZSArIGNdLCBjICs9IGgsIHAgLT0gOCkge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIGZvciAobyA9IGEgJiAoMSA8PCAtcCkgLSAxLCBhID4+PSAtcCwgcCArPSBuOyBwID4gMDsgbyA9IDI1NiAqIG8gKyB0W2UgKyBjXSwgYyArPSBoLCBwIC09IDgpIHtcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICBpZiAoMCA9PT0gYSkgYSA9IDEgLSBsO2Vsc2Uge1xuICAgICAgICBpZiAoYSA9PT0gdSkgcmV0dXJuIG8gPyBOYU4gOiAxIC8gMCAqIChmID8gLTEgOiAxKTtcbiAgICAgICAgbyArPSBNYXRoLnBvdygyLCBuKSwgYSAtPSBsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChmID8gLTEgOiAxKSAqIG8gKiBNYXRoLnBvdygyLCBhIC0gbik7XG4gICAgfSxcbiAgICAgICAgSHMgPSBmdW5jdGlvbiBIcyh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB2YXIgbyxcbiAgICAgICAgICBzLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCA9IDggKiBhIC0gaSAtIDEsXG4gICAgICAgICAgcCA9ICgxIDw8IGwpIC0gMSxcbiAgICAgICAgICBjID0gcCA+PiAxLFxuICAgICAgICAgIGggPSAyMyA9PT0gaSA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCxcbiAgICAgICAgICBmID0gbiA/IDAgOiBhIC0gMSxcbiAgICAgICAgICB5ID0gbiA/IDEgOiAtMSxcbiAgICAgICAgICBkID0gZSA8IDAgfHwgMCA9PT0gZSAmJiAxIC8gZSA8IDAgPyAxIDogMDtcblxuICAgICAgZm9yIChlID0gTWF0aC5hYnMoZSksIGlzTmFOKGUpIHx8IGUgPT09IDEgLyAwID8gKHMgPSBpc05hTihlKSA/IDEgOiAwLCBvID0gcCkgOiAobyA9IE1hdGguZmxvb3IoTWF0aC5sb2coZSkgLyBNYXRoLkxOMiksIGUgKiAodSA9IE1hdGgucG93KDIsIC1vKSkgPCAxICYmIChvLS0sIHUgKj0gMiksIChlICs9IG8gKyBjID49IDEgPyBoIC8gdSA6IGggKiBNYXRoLnBvdygyLCAxIC0gYykpICogdSA+PSAyICYmIChvKyssIHUgLz0gMiksIG8gKyBjID49IHAgPyAocyA9IDAsIG8gPSBwKSA6IG8gKyBjID49IDEgPyAocyA9IChlICogdSAtIDEpICogTWF0aC5wb3coMiwgaSksIG8gKz0gYykgOiAocyA9IGUgKiBNYXRoLnBvdygyLCBjIC0gMSkgKiBNYXRoLnBvdygyLCBpKSwgbyA9IDApKTsgaSA+PSA4OyB0W3IgKyBmXSA9IDI1NSAmIHMsIGYgKz0geSwgcyAvPSAyNTYsIGkgLT0gOCkge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIGZvciAobyA9IG8gPDwgaSB8IHMsIGwgKz0gaTsgbCA+IDA7IHRbciArIGZdID0gMjU1ICYgbywgZiArPSB5LCBvIC89IDI1NiwgbCAtPSA4KSB7XG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgdFtyICsgZiAtIHldIHw9IDEyOCAqIGQ7XG4gICAgfSxcbiAgICAgICAgWXMgPSAkcztcblxuICAgIGZ1bmN0aW9uICRzKHQpIHtcbiAgICAgIHRoaXMuYnVmID0gQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh0KSA/IHQgOiBuZXcgVWludDhBcnJheSh0IHx8IDApLCB0aGlzLnBvcyA9IDAsIHRoaXMudHlwZSA9IDAsIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xuICAgIH1cblxuICAgICRzLlZhcmludCA9IDAsICRzLkZpeGVkNjQgPSAxLCAkcy5CeXRlcyA9IDIsICRzLkZpeGVkMzIgPSA1O1xuICAgIHZhciBXcyA9IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFRleHREZWNvZGVyID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik7XG5cbiAgICBmdW5jdGlvbiBRcyh0KSB7XG4gICAgICByZXR1cm4gdC50eXBlID09PSAkcy5CeXRlcyA/IHQucmVhZFZhcmludCgpICsgdC5wb3MgOiB0LnBvcyArIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHUodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHIgPyA0Mjk0OTY3Mjk2ICogZSArICh0ID4+PiAwKSA6IDQyOTQ5NjcyOTYgKiAoZSA+Pj4gMCkgKyAodCA+Pj4gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXUodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlIDw9IDE2MzgzID8gMSA6IGUgPD0gMjA5NzE1MSA/IDIgOiBlIDw9IDI2ODQzNTQ1NSA/IDMgOiBNYXRoLmZsb29yKE1hdGgubG9nKGUpIC8gKDcgKiBNYXRoLkxOMikpO1xuICAgICAgci5yZWFsbG9jKG4pO1xuXG4gICAgICBmb3IgKHZhciBpID0gci5wb3MgLSAxOyBpID49IHQ7IGktLSkge1xuICAgICAgICByLmJ1ZltpICsgbl0gPSByLmJ1ZltpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZVZhcmludCh0W3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBudSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZVNWYXJpbnQodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVGbG9hdCh0W3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZURvdWJsZSh0W3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvdSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZUJvb2xlYW4odFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3UodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVGaXhlZDMyKHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLndyaXRlU0ZpeGVkMzIodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbHUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVGaXhlZDY0KHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLndyaXRlU0ZpeGVkNjQodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3UodCwgZSkge1xuICAgICAgcmV0dXJuICh0W2VdIHwgdFtlICsgMV0gPDwgOCB8IHRbZSArIDJdIDw8IDE2KSArIDE2Nzc3MjE2ICogdFtlICsgM107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHUodCwgZSwgcikge1xuICAgICAgdFtyXSA9IGUsIHRbciArIDFdID0gZSA+Pj4gOCwgdFtyICsgMl0gPSBlID4+PiAxNiwgdFtyICsgM10gPSBlID4+PiAyNDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmdSh0LCBlKSB7XG4gICAgICByZXR1cm4gKHRbZV0gfCB0W2UgKyAxXSA8PCA4IHwgdFtlICsgMl0gPDwgMTYpICsgKHRbZSArIDNdIDw8IDI0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5dSh0LCBlLCByKSB7XG4gICAgICAxID09PSB0ICYmIHIucmVhZE1lc3NhZ2UoZHUsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1KHQsIGUsIHIpIHtcbiAgICAgIGlmICgzID09PSB0KSB7XG4gICAgICAgIHZhciBuID0gci5yZWFkTWVzc2FnZShtdSwge30pLFxuICAgICAgICAgICAgaSA9IG4ud2lkdGgsXG4gICAgICAgICAgICBhID0gbi5oZWlnaHQsXG4gICAgICAgICAgICBvID0gbi5sZWZ0LFxuICAgICAgICAgICAgcyA9IG4udG9wLFxuICAgICAgICAgICAgdSA9IG4uYWR2YW5jZTtcbiAgICAgICAgZS5wdXNoKHtcbiAgICAgICAgICBpZDogbi5pZCxcbiAgICAgICAgICBiaXRtYXA6IG5ldyBnbyh7XG4gICAgICAgICAgICB3aWR0aDogaSArIDYsXG4gICAgICAgICAgICBoZWlnaHQ6IGEgKyA2XG4gICAgICAgICAgfSwgbi5iaXRtYXApLFxuICAgICAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgICAgIHdpZHRoOiBpLFxuICAgICAgICAgICAgaGVpZ2h0OiBhLFxuICAgICAgICAgICAgbGVmdDogbyxcbiAgICAgICAgICAgIHRvcDogcyxcbiAgICAgICAgICAgIGFkdmFuY2U6IHVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11KHQsIGUsIHIpIHtcbiAgICAgIDEgPT09IHQgPyBlLmlkID0gci5yZWFkVmFyaW50KCkgOiAyID09PSB0ID8gZS5iaXRtYXAgPSByLnJlYWRCeXRlcygpIDogMyA9PT0gdCA/IGUud2lkdGggPSByLnJlYWRWYXJpbnQoKSA6IDQgPT09IHQgPyBlLmhlaWdodCA9IHIucmVhZFZhcmludCgpIDogNSA9PT0gdCA/IGUubGVmdCA9IHIucmVhZFNWYXJpbnQoKSA6IDYgPT09IHQgPyBlLnRvcCA9IHIucmVhZFNWYXJpbnQoKSA6IDcgPT09IHQgJiYgKGUuYWR2YW5jZSA9IHIucmVhZFZhcmludCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2dSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IDAsIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICBlICs9IGEudyAqIGEuaCwgciA9IE1hdGgubWF4KHIsIGEudyk7XG4gICAgICB9XG5cbiAgICAgIHQuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5oIC0gdC5oO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIG8gPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiBNYXRoLm1heChNYXRoLmNlaWwoTWF0aC5zcXJ0KGUgLyAuOTUpKSwgciksXG4gICAgICAgIGg6IDEgLyAwXG4gICAgICB9XSwgcyA9IDAsIHUgPSAwLCBsID0gMCwgcCA9IHQ7IGwgPCBwLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSBwW2xdLCBoID0gby5sZW5ndGggLSAxOyBoID49IDA7IGgtLSkge1xuICAgICAgICAgIHZhciBmID0gb1toXTtcblxuICAgICAgICAgIGlmICghKGMudyA+IGYudyB8fCBjLmggPiBmLmgpKSB7XG4gICAgICAgICAgICBpZiAoYy54ID0gZi54LCBjLnkgPSBmLnksIHUgPSBNYXRoLm1heCh1LCBjLnkgKyBjLmgpLCBzID0gTWF0aC5tYXgocywgYy54ICsgYy53KSwgYy53ID09PSBmLncgJiYgYy5oID09PSBmLmgpIHtcbiAgICAgICAgICAgICAgdmFyIHkgPSBvLnBvcCgpO1xuICAgICAgICAgICAgICBoIDwgby5sZW5ndGggJiYgKG9baF0gPSB5KTtcbiAgICAgICAgICAgIH0gZWxzZSBjLmggPT09IGYuaCA/IChmLnggKz0gYy53LCBmLncgLT0gYy53KSA6IGMudyA9PT0gZi53ID8gKGYueSArPSBjLmgsIGYuaCAtPSBjLmgpIDogKG8ucHVzaCh7XG4gICAgICAgICAgICAgIHg6IGYueCArIGMudyxcbiAgICAgICAgICAgICAgeTogZi55LFxuICAgICAgICAgICAgICB3OiBmLncgLSBjLncsXG4gICAgICAgICAgICAgIGg6IGMuaFxuICAgICAgICAgICAgfSksIGYueSArPSBjLmgsIGYuaCAtPSBjLmgpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogcyxcbiAgICAgICAgaDogdSxcbiAgICAgICAgZmlsbDogZSAvIChzICogdSkgfHwgMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAkcy5wcm90b3R5cGUgPSB7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgICB9LFxuICAgICAgcmVhZEZpZWxkczogZnVuY3Rpb24gcmVhZEZpZWxkcyh0LCBlLCByKSB7XG4gICAgICAgIGZvciAociA9IHIgfHwgdGhpcy5sZW5ndGg7IHRoaXMucG9zIDwgcjspIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgICBpID0gbiA+PiAzLFxuICAgICAgICAgICAgICBhID0gdGhpcy5wb3M7XG4gICAgICAgICAgdGhpcy50eXBlID0gNyAmIG4sIHQoaSwgZSwgdGhpcyksIHRoaXMucG9zID09PSBhICYmIHRoaXMuc2tpcChuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbiByZWFkTWVzc2FnZSh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWVsZHModCwgZSwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgICB9LFxuICAgICAgcmVhZEZpeGVkMzI6IGZ1bmN0aW9uIHJlYWRGaXhlZDMyKCkge1xuICAgICAgICB2YXIgdCA9IGN1KHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA0LCB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24gcmVhZFNGaXhlZDMyKCkge1xuICAgICAgICB2YXIgdCA9IGZ1KHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA0LCB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRGaXhlZDY0OiBmdW5jdGlvbiByZWFkRml4ZWQ2NCgpIHtcbiAgICAgICAgdmFyIHQgPSBjdSh0aGlzLmJ1ZiwgdGhpcy5wb3MpICsgNDI5NDk2NzI5NiAqIGN1KHRoaXMuYnVmLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRTRml4ZWQ2NCgpIHtcbiAgICAgICAgdmFyIHQgPSBjdSh0aGlzLmJ1ZiwgdGhpcy5wb3MpICsgNDI5NDk2NzI5NiAqIGZ1KHRoaXMuYnVmLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uIHJlYWRGbG9hdCgpIHtcbiAgICAgICAgdmFyIHQgPSBKcyh0aGlzLmJ1ZiwgdGhpcy5wb3MsICEwLCAyMywgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA0LCB0O1xuICAgICAgfSxcbiAgICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uIHJlYWREb3VibGUoKSB7XG4gICAgICAgIHZhciB0ID0gSnModGhpcy5idWYsIHRoaXMucG9zLCAhMCwgNTIsIDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkVmFyaW50OiBmdW5jdGlvbiByZWFkVmFyaW50KHQpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgbiA9IHRoaXMuYnVmO1xuICAgICAgICByZXR1cm4gZSA9IDEyNyAmIChyID0gblt0aGlzLnBvcysrXSksIHIgPCAxMjggPyBlIDogKGUgfD0gKDEyNyAmIChyID0gblt0aGlzLnBvcysrXSkpIDw8IDcsIHIgPCAxMjggPyBlIDogKGUgfD0gKDEyNyAmIChyID0gblt0aGlzLnBvcysrXSkpIDw8IDE0LCByIDwgMTI4ID8gZSA6IChlIHw9ICgxMjcgJiAociA9IG5bdGhpcy5wb3MrK10pKSA8PCAyMSwgciA8IDEyOCA/IGUgOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHZhciBuLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBhID0gci5idWY7XG4gICAgICAgICAgaWYgKG4gPSAoMTEyICYgKGkgPSBhW3IucG9zKytdKSkgPj4gNCwgaSA8IDEyOCkgcmV0dXJuIHR1KHQsIG4sIGUpO1xuICAgICAgICAgIGlmIChuIHw9ICgxMjcgJiAoaSA9IGFbci5wb3MrK10pKSA8PCAzLCBpIDwgMTI4KSByZXR1cm4gdHUodCwgbiwgZSk7XG4gICAgICAgICAgaWYgKG4gfD0gKDEyNyAmIChpID0gYVtyLnBvcysrXSkpIDw8IDEwLCBpIDwgMTI4KSByZXR1cm4gdHUodCwgbiwgZSk7XG4gICAgICAgICAgaWYgKG4gfD0gKDEyNyAmIChpID0gYVtyLnBvcysrXSkpIDw8IDE3LCBpIDwgMTI4KSByZXR1cm4gdHUodCwgbiwgZSk7XG4gICAgICAgICAgaWYgKG4gfD0gKDEyNyAmIChpID0gYVtyLnBvcysrXSkpIDw8IDI0LCBpIDwgMTI4KSByZXR1cm4gdHUodCwgbiwgZSk7XG4gICAgICAgICAgaWYgKG4gfD0gKDEgJiAoaSA9IGFbci5wb3MrK10pKSA8PCAzMSwgaSA8IDEyOCkgcmV0dXJuIHR1KHQsIG4sIGUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzXCIpO1xuICAgICAgICB9KGUgfD0gKDE1ICYgKHIgPSBuW3RoaXMucG9zXSkpIDw8IDI4LCB0LCB0aGlzKSkpKTtcbiAgICAgIH0sXG4gICAgICByZWFkVmFyaW50NjQ6IGZ1bmN0aW9uIHJlYWRWYXJpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFZhcmludCghMCk7XG4gICAgICB9LFxuICAgICAgcmVhZFNWYXJpbnQ6IGZ1bmN0aW9uIHJlYWRTVmFyaW50KCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgICAgICByZXR1cm4gdCAlIDIgPT0gMSA/ICh0ICsgMSkgLyAtMiA6IHQgLyAyO1xuICAgICAgfSxcbiAgICAgIHJlYWRCb29sZWFuOiBmdW5jdGlvbiByZWFkQm9vbGVhbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgfSxcbiAgICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID0gdCwgdCAtIGUgPj0gMTIgJiYgV3MgPyBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiBXcy5kZWNvZGUodC5zdWJhcnJheShlLCByKSk7XG4gICAgICAgIH0odGhpcy5idWYsIGUsIHQpIDogZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gXCJcIiwgaSA9IGU7IGkgPCByOykge1xuICAgICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgIHUgPSB0W2ldLFxuICAgICAgICAgICAgICAgIGwgPSBudWxsLFxuICAgICAgICAgICAgICAgIHAgPSB1ID4gMjM5ID8gNCA6IHUgPiAyMjMgPyAzIDogdSA+IDE5MSA/IDIgOiAxO1xuICAgICAgICAgICAgaWYgKGkgKyBwID4gcikgYnJlYWs7XG4gICAgICAgICAgICAxID09PSBwID8gdSA8IDEyOCAmJiAobCA9IHUpIDogMiA9PT0gcCA/IDEyOCA9PSAoMTkyICYgKGEgPSB0W2kgKyAxXSkpICYmIChsID0gKDMxICYgdSkgPDwgNiB8IDYzICYgYSkgPD0gMTI3ICYmIChsID0gbnVsbCkgOiAzID09PSBwID8gKG8gPSB0W2kgKyAyXSwgMTI4ID09ICgxOTIgJiAoYSA9IHRbaSArIDFdKSkgJiYgMTI4ID09ICgxOTIgJiBvKSAmJiAoKGwgPSAoMTUgJiB1KSA8PCAxMiB8ICg2MyAmIGEpIDw8IDYgfCA2MyAmIG8pIDw9IDIwNDcgfHwgbCA+PSA1NTI5NiAmJiBsIDw9IDU3MzQzKSAmJiAobCA9IG51bGwpKSA6IDQgPT09IHAgJiYgKG8gPSB0W2kgKyAyXSwgcyA9IHRbaSArIDNdLCAxMjggPT0gKDE5MiAmIChhID0gdFtpICsgMV0pKSAmJiAxMjggPT0gKDE5MiAmIG8pICYmIDEyOCA9PSAoMTkyICYgcykgJiYgKChsID0gKDE1ICYgdSkgPDwgMTggfCAoNjMgJiBhKSA8PCAxMiB8ICg2MyAmIG8pIDw8IDYgfCA2MyAmIHMpIDw9IDY1NTM1IHx8IGwgPj0gMTExNDExMikgJiYgKGwgPSBudWxsKSksIG51bGwgPT09IGwgPyAobCA9IDY1NTMzLCBwID0gMSkgOiBsID4gNjU1MzUgJiYgKGwgLT0gNjU1MzYsIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsID4+PiAxMCAmIDEwMjMgfCA1NTI5NiksIGwgPSA1NjMyMCB8IDEwMjMgJiBsKSwgbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGwpLCBpICs9IHA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0odGhpcy5idWYsIGUsIHQpO1xuICAgICAgfSxcbiAgICAgIHJlYWRCeXRlczogZnVuY3Rpb24gcmVhZEJ5dGVzKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBlID0gdGhpcy5idWYuc3ViYXJyYXkodGhpcy5wb3MsIHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPSB0LCBlO1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uIHJlYWRQYWNrZWRWYXJpbnQodCwgZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAkcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRWYXJpbnQoZSkpO1xuICAgICAgICB2YXIgciA9IFFzKHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgcjspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkVmFyaW50KGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRTVmFyaW50OiBmdW5jdGlvbiByZWFkUGFja2VkU1ZhcmludCh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICRzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZFNWYXJpbnQoKSk7XG4gICAgICAgIHZhciBlID0gUXModGhpcyk7XG5cbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykge1xuICAgICAgICAgIHQucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uIHJlYWRQYWNrZWRCb29sZWFuKHQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJHMuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkQm9vbGVhbigpKTtcbiAgICAgICAgdmFyIGUgPSBRcyh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uIHJlYWRQYWNrZWRGbG9hdCh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICRzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEZsb2F0KCkpO1xuICAgICAgICB2YXIgZSA9IFFzKHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbiByZWFkUGFja2VkRG91YmxlKHQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJHMuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkRG91YmxlKCkpO1xuICAgICAgICB2YXIgZSA9IFFzKHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkRG91YmxlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uIHJlYWRQYWNrZWRGaXhlZDMyKHQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJHMuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkRml4ZWQzMigpKTtcbiAgICAgICAgdmFyIGUgPSBRcyh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uIHJlYWRQYWNrZWRTRml4ZWQzMih0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICRzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZFNGaXhlZDMyKCkpO1xuICAgICAgICB2YXIgZSA9IFFzKHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24gcmVhZFBhY2tlZEZpeGVkNjQodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAkcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICB2YXIgZSA9IFFzKHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24gcmVhZFBhY2tlZFNGaXhlZDY0KHQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJHMuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkU0ZpeGVkNjQoKSk7XG4gICAgICAgIHZhciBlID0gUXModGhpcyk7XG5cbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykge1xuICAgICAgICAgIHQucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHNraXA6IGZ1bmN0aW9uIHNraXAodCkge1xuICAgICAgICB2YXIgZSA9IDcgJiB0O1xuICAgICAgICBpZiAoZSA9PT0gJHMuVmFyaW50KSBmb3IgKDsgdGhpcy5idWZbdGhpcy5wb3MrK10gPiAxMjc7KSB7XG4gICAgICAgICAgO1xuICAgICAgICB9IGVsc2UgaWYgKGUgPT09ICRzLkJ5dGVzKSB0aGlzLnBvcyA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3M7ZWxzZSBpZiAoZSA9PT0gJHMuRml4ZWQzMikgdGhpcy5wb3MgKz0gNDtlbHNlIHtcbiAgICAgICAgICBpZiAoZSAhPT0gJHMuRml4ZWQ2NCkgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZCB0eXBlOiBcIiArIGUpO1xuICAgICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZVRhZzogZnVuY3Rpb24gd3JpdGVUYWcodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHQgPDwgMyB8IGUpO1xuICAgICAgfSxcbiAgICAgIHJlYWxsb2M6IGZ1bmN0aW9uIHJlYWxsb2ModCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5sZW5ndGggfHwgMTY7IGUgPCB0aGlzLnBvcyArIHQ7KSB7XG4gICAgICAgICAgZSAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUgIT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHIgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICAgICAgICByLnNldCh0aGlzLmJ1ZiksIHRoaXMuYnVmID0gciwgdGhpcy5sZW5ndGggPSBlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IHRoaXMucG9zLCB0aGlzLnBvcyA9IDAsIHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uIHdyaXRlRml4ZWQzMih0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KSwgaHUodGhpcy5idWYsIHQsIHRoaXMucG9zKSwgdGhpcy5wb3MgKz0gNDtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbiB3cml0ZVNGaXhlZDMyKHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpLCBodSh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSA0O1xuICAgICAgfSxcbiAgICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24gd3JpdGVGaXhlZDY0KHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpLCBodSh0aGlzLmJ1ZiwgLTEgJiB0LCB0aGlzLnBvcyksIGh1KHRoaXMuYnVmLCBNYXRoLmZsb29yKHQgKiAoMSAvIDQyOTQ5NjcyOTYpKSwgdGhpcy5wb3MgKyA0KSwgdGhpcy5wb3MgKz0gODtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNGaXhlZDY0OiBmdW5jdGlvbiB3cml0ZVNGaXhlZDY0KHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpLCBodSh0aGlzLmJ1ZiwgLTEgJiB0LCB0aGlzLnBvcyksIGh1KHRoaXMuYnVmLCBNYXRoLmZsb29yKHQgKiAoMSAvIDQyOTQ5NjcyOTYpKSwgdGhpcy5wb3MgKyA0KSwgdGhpcy5wb3MgKz0gODtcbiAgICAgIH0sXG4gICAgICB3cml0ZVZhcmludDogZnVuY3Rpb24gd3JpdGVWYXJpbnQodCkge1xuICAgICAgICAodCA9ICt0IHx8IDApID4gMjY4NDM1NDU1IHx8IHQgPCAwID8gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciwgbjtcbiAgICAgICAgICBpZiAodCA+PSAwID8gKHIgPSB0ICUgNDI5NDk2NzI5NiB8IDAsIG4gPSB0IC8gNDI5NDk2NzI5NiB8IDApIDogKG4gPSB+KC10IC8gNDI5NDk2NzI5NiksIDQyOTQ5NjcyOTUgXiAociA9IH4oLXQgJSA0Mjk0OTY3Mjk2KSkgPyByID0gciArIDEgfCAwIDogKHIgPSAwLCBuID0gbiArIDEgfCAwKSksIHQgPj0gMHgxMDAwMDAwMDAwMDAwMDAwMCB8fCB0IDwgLTB4MTAwMDAwMDAwMDAwMDAwMDApIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIHZhcmludCBkb2Vzbid0IGZpdCBpbnRvIDEwIGJ5dGVzXCIpO1xuICAgICAgICAgIGUucmVhbGxvYygxMCksIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgICByLmJ1ZltyLnBvcysrXSA9IDEyNyAmIHQgfCAxMjgsIHQgPj4+PSA3LCByLmJ1ZltyLnBvcysrXSA9IDEyNyAmIHQgfCAxMjgsIHQgPj4+PSA3LCByLmJ1ZltyLnBvcysrXSA9IDEyNyAmIHQgfCAxMjgsIHQgPj4+PSA3LCByLmJ1ZltyLnBvcysrXSA9IDEyNyAmIHQgfCAxMjgsIHIuYnVmW3IucG9zXSA9IDEyNyAmICh0ID4+Pj0gNyk7XG4gICAgICAgICAgfShyLCAwLCBlKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciByID0gKDcgJiB0KSA8PCA0O1xuICAgICAgICAgICAgZS5idWZbZS5wb3MrK10gfD0gciB8ICgodCA+Pj49IDMpID8gMTI4IDogMCksIHQgJiYgKGUuYnVmW2UucG9zKytdID0gMTI3ICYgdCB8ICgodCA+Pj49IDcpID8gMTI4IDogMCksIHQgJiYgKGUuYnVmW2UucG9zKytdID0gMTI3ICYgdCB8ICgodCA+Pj49IDcpID8gMTI4IDogMCksIHQgJiYgKGUuYnVmW2UucG9zKytdID0gMTI3ICYgdCB8ICgodCA+Pj49IDcpID8gMTI4IDogMCksIHQgJiYgKGUuYnVmW2UucG9zKytdID0gMTI3ICYgdCB8ICgodCA+Pj49IDcpID8gMTI4IDogMCksIHQgJiYgKGUuYnVmW2UucG9zKytdID0gMTI3ICYgdCkpKSkpO1xuICAgICAgICAgIH0obiwgZSk7XG4gICAgICAgIH0odCwgdGhpcykgOiAodGhpcy5yZWFsbG9jKDQpLCB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDEyNyAmIHQgfCAodCA+IDEyNyA/IDEyOCA6IDApLCB0IDw9IDEyNyB8fCAodGhpcy5idWZbdGhpcy5wb3MrK10gPSAxMjcgJiAodCA+Pj49IDcpIHwgKHQgPiAxMjcgPyAxMjggOiAwKSwgdCA8PSAxMjcgfHwgKHRoaXMuYnVmW3RoaXMucG9zKytdID0gMTI3ICYgKHQgPj4+PSA3KSB8ICh0ID4gMTI3ID8gMTI4IDogMCksIHQgPD0gMTI3IHx8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHQgPj4+IDcgJiAxMjcpKSkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24gd3JpdGVTVmFyaW50KHQpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh0IDwgMCA/IDIgKiAtdCAtIDEgOiAyICogdCk7XG4gICAgICB9LFxuICAgICAgd3JpdGVCb29sZWFuOiBmdW5jdGlvbiB3cml0ZUJvb2xlYW4odCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odCkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbiB3cml0ZVN0cmluZyh0KSB7XG4gICAgICAgIHQgPSBTdHJpbmcodCksIHRoaXMucmVhbGxvYyg0ICogdC5sZW5ndGgpLCB0aGlzLnBvcysrO1xuICAgICAgICB2YXIgZSA9IHRoaXMucG9zO1xuXG4gICAgICAgIHRoaXMucG9zID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBuLCBpLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGlmICgobiA9IGUuY2hhckNvZGVBdChhKSkgPiA1NTI5NSAmJiBuIDwgNTczNDQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgbiA+IDU2MzE5IHx8IGEgKyAxID09PSBlLmxlbmd0aCA/ICh0W3IrK10gPSAyMzksIHRbcisrXSA9IDE5MSwgdFtyKytdID0gMTg5KSA6IGkgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG4gPCA1NjMyMCkge1xuICAgICAgICAgICAgICAgIHRbcisrXSA9IDIzOSwgdFtyKytdID0gMTkxLCB0W3IrK10gPSAxODksIGkgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbiA9IGkgLSA1NTI5NiA8PCAxMCB8IG4gLSA1NjMyMCB8IDY1NTM2LCBpID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpICYmICh0W3IrK10gPSAyMzksIHRbcisrXSA9IDE5MSwgdFtyKytdID0gMTg5LCBpID0gbnVsbCk7XG5cbiAgICAgICAgICAgIG4gPCAxMjggPyB0W3IrK10gPSBuIDogKG4gPCAyMDQ4ID8gdFtyKytdID0gbiA+PiA2IHwgMTkyIDogKG4gPCA2NTUzNiA/IHRbcisrXSA9IG4gPj4gMTIgfCAyMjQgOiAodFtyKytdID0gbiA+PiAxOCB8IDI0MCwgdFtyKytdID0gbiA+PiAxMiAmIDYzIHwgMTI4KSwgdFtyKytdID0gbiA+PiA2ICYgNjMgfCAxMjgpLCB0W3IrK10gPSA2MyAmIG4gfCAxMjgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KHRoaXMuYnVmLCB0LCB0aGlzLnBvcyk7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnBvcyAtIGU7XG4gICAgICAgIHIgPj0gMTI4ICYmIGV1KGUsIHIsIHRoaXMpLCB0aGlzLnBvcyA9IGUgLSAxLCB0aGlzLndyaXRlVmFyaW50KHIpLCB0aGlzLnBvcyArPSByO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRmxvYXQ6IGZ1bmN0aW9uIHdyaXRlRmxvYXQodCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCksIEhzKHRoaXMuYnVmLCB0LCB0aGlzLnBvcywgITAsIDIzLCA0KSwgdGhpcy5wb3MgKz0gNDtcbiAgICAgIH0sXG4gICAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24gd3JpdGVEb3VibGUodCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCksIEhzKHRoaXMuYnVmLCB0LCB0aGlzLnBvcywgITAsIDUyLCA4KSwgdGhpcy5wb3MgKz0gODtcbiAgICAgIH0sXG4gICAgICB3cml0ZUJ5dGVzOiBmdW5jdGlvbiB3cml0ZUJ5dGVzKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChlKSwgdGhpcy5yZWFsbG9jKGUpO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZTsgcisrKSB7XG4gICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB0W3JdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGVSYXdNZXNzYWdlOiBmdW5jdGlvbiB3cml0ZVJhd01lc3NhZ2UodCwgZSkge1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICB2YXIgciA9IHRoaXMucG9zO1xuICAgICAgICB0KGUsIHRoaXMpO1xuICAgICAgICB2YXIgbiA9IHRoaXMucG9zIC0gcjtcbiAgICAgICAgbiA+PSAxMjggJiYgZXUociwgbiwgdGhpcyksIHRoaXMucG9zID0gciAtIDEsIHRoaXMud3JpdGVWYXJpbnQobiksIHRoaXMucG9zICs9IG47XG4gICAgICB9LFxuICAgICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbiB3cml0ZU1lc3NhZ2UodCwgZSwgcikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsICRzLkJ5dGVzKSwgdGhpcy53cml0ZVJhd01lc3NhZ2UoZSwgcik7XG4gICAgICB9LFxuICAgICAgd3JpdGVQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uIHdyaXRlUGFja2VkVmFyaW50KHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgcnUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkU1ZhcmludDogZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgbnUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkQm9vbGVhbjogZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgb3UsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRmxvYXQ6IGZ1bmN0aW9uIHdyaXRlUGFja2VkRmxvYXQodCwgZSkge1xuICAgICAgICBlLmxlbmd0aCAmJiB0aGlzLndyaXRlTWVzc2FnZSh0LCBpdSwgZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVQYWNrZWREb3VibGU6IGZ1bmN0aW9uIHdyaXRlUGFja2VkRG91YmxlKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgYXUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRml4ZWQzMjogZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgc3UsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkMzIodCwgZSkge1xuICAgICAgICBlLmxlbmd0aCAmJiB0aGlzLndyaXRlTWVzc2FnZSh0LCB1dSwgZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkNjQodCwgZSkge1xuICAgICAgICBlLmxlbmd0aCAmJiB0aGlzLndyaXRlTWVzc2FnZSh0LCBsdSwgZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NCh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIHB1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgJHMuQnl0ZXMpLCB0aGlzLndyaXRlQnl0ZXMoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uIHdyaXRlRml4ZWQzMkZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCAkcy5GaXhlZDMyKSwgdGhpcy53cml0ZUZpeGVkMzIoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbiB3cml0ZVNGaXhlZDMyRmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsICRzLkZpeGVkMzIpLCB0aGlzLndyaXRlU0ZpeGVkMzIoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uIHdyaXRlRml4ZWQ2NEZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCAkcy5GaXhlZDY0KSwgdGhpcy53cml0ZUZpeGVkNjQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbiB3cml0ZVNGaXhlZDY0RmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsICRzLkZpeGVkNjQpLCB0aGlzLndyaXRlU0ZpeGVkNjQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVWYXJpbnRGaWVsZDogZnVuY3Rpb24gd3JpdGVWYXJpbnRGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgJHMuVmFyaW50KSwgdGhpcy53cml0ZVZhcmludChlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNWYXJpbnRGaWVsZDogZnVuY3Rpb24gd3JpdGVTVmFyaW50RmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsICRzLlZhcmludCksIHRoaXMud3JpdGVTVmFyaW50KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uIHdyaXRlU3RyaW5nRmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsICRzLkJ5dGVzKSwgdGhpcy53cml0ZVN0cmluZyhlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uIHdyaXRlRmxvYXRGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgJHMuRml4ZWQzMiksIHRoaXMud3JpdGVGbG9hdChlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZURvdWJsZUZpZWxkOiBmdW5jdGlvbiB3cml0ZURvdWJsZUZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCAkcy5GaXhlZDY0KSwgdGhpcy53cml0ZURvdWJsZShlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUJvb2xlYW5GaWVsZDogZnVuY3Rpb24gd3JpdGVCb29sZWFuRmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50RmllbGQodCwgQm9vbGVhbihlKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBndSA9IGZ1bmN0aW9uIGd1KHQsIGUpIHtcbiAgICAgIHZhciByID0gZS5waXhlbFJhdGlvLFxuICAgICAgICAgIG4gPSBlLnZlcnNpb24sXG4gICAgICAgICAgaSA9IGUuc3RyZXRjaFgsXG4gICAgICAgICAgYSA9IGUuc3RyZXRjaFksXG4gICAgICAgICAgbyA9IGUuY29udGVudDtcbiAgICAgIHRoaXMucGFkZGVkUmVjdCA9IHQsIHRoaXMucGl4ZWxSYXRpbyA9IHIsIHRoaXMuc3RyZXRjaFggPSBpLCB0aGlzLnN0cmV0Y2hZID0gYSwgdGhpcy5jb250ZW50ID0gbywgdGhpcy52ZXJzaW9uID0gbjtcbiAgICB9LFxuICAgICAgICB4dSA9IHtcbiAgICAgIHRsOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBicjoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgdGxicjoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgZGlzcGxheVNpemU6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfVxuICAgIH07XG5cbiAgICB4dS50bC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3RoaXMucGFkZGVkUmVjdC54ICsgMSwgdGhpcy5wYWRkZWRSZWN0LnkgKyAxXTtcbiAgICB9LCB4dS5ici5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3RoaXMucGFkZGVkUmVjdC54ICsgdGhpcy5wYWRkZWRSZWN0LncgLSAxLCB0aGlzLnBhZGRlZFJlY3QueSArIHRoaXMucGFkZGVkUmVjdC5oIC0gMV07XG4gICAgfSwgeHUudGxici5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50bC5jb25jYXQodGhpcy5icik7XG4gICAgfSwgeHUuZGlzcGxheVNpemUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsodGhpcy5wYWRkZWRSZWN0LncgLSAyKSAvIHRoaXMucGl4ZWxSYXRpbywgKHRoaXMucGFkZGVkUmVjdC5oIC0gMikgLyB0aGlzLnBpeGVsUmF0aW9dO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGd1LnByb3RvdHlwZSwgeHUpO1xuXG4gICAgdmFyIGJ1ID0gZnVuY3Rpb24gYnUodCwgZSkge1xuICAgICAgdmFyIHIgPSB7fSxcbiAgICAgICAgICBuID0ge307XG4gICAgICB0aGlzLmhhdmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgIHZhciBpID0gW107XG4gICAgICB0aGlzLmFkZEltYWdlcyh0LCByLCBpKSwgdGhpcy5hZGRJbWFnZXMoZSwgbiwgaSk7XG4gICAgICB2YXIgYSA9IHZ1KGkpLFxuICAgICAgICAgIG8gPSBuZXcgeG8oe1xuICAgICAgICB3aWR0aDogYS53IHx8IDEsXG4gICAgICAgIGhlaWdodDogYS5oIHx8IDFcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBzIGluIHQpIHtcbiAgICAgICAgdmFyIHUgPSB0W3NdLFxuICAgICAgICAgICAgbCA9IHJbc10ucGFkZGVkUmVjdDtcbiAgICAgICAgeG8uY29weSh1LmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGwueCArIDEsXG4gICAgICAgICAgeTogbC55ICsgMVxuICAgICAgICB9LCB1LmRhdGEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBwIGluIGUpIHtcbiAgICAgICAgdmFyIGMgPSBlW3BdLFxuICAgICAgICAgICAgaCA9IG5bcF0ucGFkZGVkUmVjdCxcbiAgICAgICAgICAgIGYgPSBoLnggKyAxLFxuICAgICAgICAgICAgeSA9IGgueSArIDEsXG4gICAgICAgICAgICBkID0gYy5kYXRhLndpZHRoLFxuICAgICAgICAgICAgbSA9IGMuZGF0YS5oZWlnaHQ7XG4gICAgICAgIHhvLmNvcHkoYy5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBmLFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSwgYy5kYXRhKSwgeG8uY29weShjLmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IG0gLSAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBmLFxuICAgICAgICAgIHk6IHkgLSAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogZCxcbiAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfSksIHhvLmNvcHkoYy5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBmLFxuICAgICAgICAgIHk6IHkgKyBtXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogZCxcbiAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfSksIHhvLmNvcHkoYy5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogZCAtIDEsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogZiAtIDEsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9LCB7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiBtXG4gICAgICAgIH0pLCB4by5jb3B5KGMuZGF0YSwgbywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogZiArIGQsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9LCB7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiBtXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltYWdlID0gbywgdGhpcy5pY29uUG9zaXRpb25zID0gciwgdGhpcy5wYXR0ZXJuUG9zaXRpb25zID0gbjtcbiAgICB9O1xuXG4gICAgYnUucHJvdG90eXBlLmFkZEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuIGluIHQpIHtcbiAgICAgICAgdmFyIGkgPSB0W25dLFxuICAgICAgICAgICAgYSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdzogaS5kYXRhLndpZHRoICsgMixcbiAgICAgICAgICBoOiBpLmRhdGEuaGVpZ2h0ICsgMlxuICAgICAgICB9O1xuICAgICAgICByLnB1c2goYSksIGVbbl0gPSBuZXcgZ3UoYSwgaSksIGkuaGFzUmVuZGVyQ2FsbGJhY2sgJiYgdGhpcy5oYXZlUmVuZGVyQ2FsbGJhY2tzLnB1c2gobik7XG4gICAgICB9XG4gICAgfSwgYnUucHJvdG90eXBlLnBhdGNoVXBkYXRlZEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByIGluIHQuZGlzcGF0Y2hSZW5kZXJDYWxsYmFja3ModGhpcy5oYXZlUmVuZGVyQ2FsbGJhY2tzKSwgdC51cGRhdGVkSW1hZ2VzKSB7XG4gICAgICAgIHRoaXMucGF0Y2hVcGRhdGVkSW1hZ2UodGhpcy5pY29uUG9zaXRpb25zW3JdLCB0LmdldEltYWdlKHIpLCBlKSwgdGhpcy5wYXRjaFVwZGF0ZWRJbWFnZSh0aGlzLnBhdHRlcm5Qb3NpdGlvbnNbcl0sIHQuZ2V0SW1hZ2UociksIGUpO1xuICAgICAgfVxuICAgIH0sIGJ1LnByb3RvdHlwZS5wYXRjaFVwZGF0ZWRJbWFnZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAodCAmJiBlICYmIHQudmVyc2lvbiAhPT0gZS52ZXJzaW9uKSB7XG4gICAgICAgIHQudmVyc2lvbiA9IGUudmVyc2lvbjtcbiAgICAgICAgdmFyIG4gPSB0LnRsO1xuICAgICAgICByLnVwZGF0ZShlLmRhdGEsIHZvaWQgMCwge1xuICAgICAgICAgIHg6IG5bMF0sXG4gICAgICAgICAgeTogblsxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBPbihcIkltYWdlUG9zaXRpb25cIiwgZ3UpLCBPbihcIkltYWdlQXRsYXNcIiwgYnUpO1xuXG4gICAgdmFyIHd1ID0ge1xuICAgICAgaG9yaXpvbnRhbDogMSxcbiAgICAgIHZlcnRpY2FsOiAyLFxuICAgICAgaG9yaXpvbnRhbE9ubHk6IDNcbiAgICB9LFxuICAgICAgICBfdSA9IGZ1bmN0aW9uIF91KCkge1xuICAgICAgdGhpcy5zY2FsZSA9IDEsIHRoaXMuZm9udFN0YWNrID0gXCJcIiwgdGhpcy5pbWFnZU5hbWUgPSBudWxsO1xuICAgIH07XG5cbiAgICBfdS5mb3JUZXh0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IF91KCk7XG4gICAgICByZXR1cm4gci5zY2FsZSA9IHQgfHwgMSwgci5mb250U3RhY2sgPSBlLCByO1xuICAgIH0sIF91LmZvckltYWdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IF91KCk7XG4gICAgICByZXR1cm4gZS5pbWFnZU5hbWUgPSB0LCBlO1xuICAgIH07XG5cbiAgICB2YXIgQXUgPSBmdW5jdGlvbiBBdSgpIHtcbiAgICAgIHRoaXMudGV4dCA9IFwiXCIsIHRoaXMuc2VjdGlvbkluZGV4ID0gW10sIHRoaXMuc2VjdGlvbnMgPSBbXSwgdGhpcy5pbWFnZVNlY3Rpb25JRCA9IG51bGw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFN1KHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQpIHtcbiAgICAgIHZhciBtLFxuICAgICAgICAgIHYgPSBBdS5mcm9tRmVhdHVyZSh0LCBpKTtcbiAgICAgIGMgPT09IHd1LnZlcnRpY2FsICYmIHYudmVydGljYWxpemVQdW5jdHVhdGlvbigpO1xuICAgICAgdmFyIGcgPSBvaS5wcm9jZXNzQmlkaXJlY3Rpb25hbFRleHQsXG4gICAgICAgICAgeCA9IG9pLnByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dDtcblxuICAgICAgaWYgKGcgJiYgMSA9PT0gdi5zZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgbSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGIgPSAwLCB3ID0gZyh2LnRvU3RyaW5nKCksIE11KHYsIGwsIGEsIGUsIG4sIGYsIHkpKTsgYiA8IHcubGVuZ3RoOyBiICs9IDEpIHtcbiAgICAgICAgICB2YXIgXyA9IHdbYl0sXG4gICAgICAgICAgICAgIEEgPSBuZXcgQXUoKTtcbiAgICAgICAgICBBLnRleHQgPSBfLCBBLnNlY3Rpb25zID0gdi5zZWN0aW9ucztcblxuICAgICAgICAgIGZvciAodmFyIFMgPSAwOyBTIDwgXy5sZW5ndGg7IFMrKykge1xuICAgICAgICAgICAgQS5zZWN0aW9uSW5kZXgucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtLnB1c2goQSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeCkge1xuICAgICAgICBtID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDAsIEkgPSB4KHYudGV4dCwgdi5zZWN0aW9uSW5kZXgsIE11KHYsIGwsIGEsIGUsIG4sIGYsIHkpKTsgayA8IEkubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICB2YXIgeiA9IElba10sXG4gICAgICAgICAgICAgIEMgPSBuZXcgQXUoKTtcbiAgICAgICAgICBDLnRleHQgPSB6WzBdLCBDLnNlY3Rpb25JbmRleCA9IHpbMV0sIEMuc2VjdGlvbnMgPSB2LnNlY3Rpb25zLCBtLnB1c2goQyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBtID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IFtdLCBuID0gdC50ZXh0LCBpID0gMCwgYSA9IDAsIG8gPSBlOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgIHZhciBzID0gb1thXTtcbiAgICAgICAgICByLnB1c2godC5zdWJzdHJpbmcoaSwgcykpLCBpID0gcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpIDwgbi5sZW5ndGggJiYgci5wdXNoKHQuc3Vic3RyaW5nKGksIG4ubGVuZ3RoKSksIHI7XG4gICAgICB9KHYsIE11KHYsIGwsIGEsIGUsIG4sIGYsIHkpKTtcblxuICAgICAgdmFyIEUgPSBbXSxcbiAgICAgICAgICBQID0ge1xuICAgICAgICBwb3NpdGlvbmVkTGluZXM6IEUsXG4gICAgICAgIHRleHQ6IHYudG9TdHJpbmcoKSxcbiAgICAgICAgdG9wOiBwWzFdLFxuICAgICAgICBib3R0b206IHBbMV0sXG4gICAgICAgIGxlZnQ6IHBbMF0sXG4gICAgICAgIHJpZ2h0OiBwWzBdLFxuICAgICAgICB3cml0aW5nTW9kZTogYyxcbiAgICAgICAgaWNvbnNJblRleHQ6ICExLFxuICAgICAgICB2ZXJ0aWNhbGl6YWJsZTogITFcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IDAsIGYgPSAtMTcsIHkgPSAwLCBkID0gMCwgbSA9IFwicmlnaHRcIiA9PT0gcyA/IDEgOiBcImxlZnRcIiA9PT0gcyA/IDAgOiAuNSwgdiA9IDAsIGcgPSAwLCB4ID0gaTsgZyA8IHgubGVuZ3RoOyBnICs9IDEpIHtcbiAgICAgICAgICB2YXIgYiA9IHhbZ107XG4gICAgICAgICAgYi50cmltKCk7XG5cbiAgICAgICAgICB2YXIgdyA9IGIuZ2V0TWF4U2NhbGUoKSxcbiAgICAgICAgICAgICAgXyA9IDI0ICogKHcgLSAxKSxcbiAgICAgICAgICAgICAgQSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHM6IFtdLFxuICAgICAgICAgICAgbGluZU9mZnNldDogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0LnBvc2l0aW9uZWRMaW5lc1t2XSA9IEE7XG4gICAgICAgICAgdmFyIFMgPSBBLnBvc2l0aW9uZWRHbHlwaHMsXG4gICAgICAgICAgICAgIGsgPSAwO1xuXG4gICAgICAgICAgaWYgKGIubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgYi5sZW5ndGgoKTsgSSsrKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gYi5nZXRTZWN0aW9uKEkpLFxuICAgICAgICAgICAgICAgICAgQyA9IGIuZ2V0U2VjdGlvbkluZGV4KEkpLFxuICAgICAgICAgICAgICAgICAgRSA9IGIuZ2V0Q2hhckNvZGUoSSksXG4gICAgICAgICAgICAgICAgICBQID0gMCxcbiAgICAgICAgICAgICAgICAgIE0gPSBudWxsLFxuICAgICAgICAgICAgICAgICAgQiA9IG51bGwsXG4gICAgICAgICAgICAgICAgICBUID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgIFYgPSAyNCxcbiAgICAgICAgICAgICAgICAgIEYgPSAhKHUgPT09IHd1Lmhvcml6b250YWwgfHwgIXAgJiYgIVhuKEUpIHx8IHAgJiYgKGt1W0VdIHx8IChLID0gRSwgR24uQXJhYmljKEspIHx8IEduW1wiQXJhYmljIFN1cHBsZW1lbnRcIl0oSykgfHwgR25bXCJBcmFiaWMgRXh0ZW5kZWQtQVwiXShLKSB8fCBHbltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVwiXShLKSB8fCBHbltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlwiXShLKSkpKTtcblxuICAgICAgICAgICAgICBpZiAoei5pbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IG5bei5pbWFnZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghRCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgVCA9IHouaW1hZ2VOYW1lLCB0Lmljb25zSW5UZXh0ID0gdC5pY29uc0luVGV4dCB8fCAhMCwgQiA9IEQucGFkZGVkUmVjdDtcbiAgICAgICAgICAgICAgICB2YXIgTCA9IEQuZGlzcGxheVNpemU7XG4gICAgICAgICAgICAgICAgei5zY2FsZSA9IDI0ICogei5zY2FsZSAvIGMsIFAgPSBfICsgKDI0IC0gTFsxXSAqIHouc2NhbGUpLCBWID0gKE0gPSB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogTFswXSxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogTFsxXSxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICB0b3A6IC0zLFxuICAgICAgICAgICAgICAgICAgYWR2YW5jZTogRiA/IExbMV0gOiBMWzBdXG4gICAgICAgICAgICAgICAgfSkuYWR2YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgTyA9IEYgPyBMWzBdICogei5zY2FsZSAtIDI0ICogdyA6IExbMV0gKiB6LnNjYWxlIC0gMjQgKiB3O1xuICAgICAgICAgICAgICAgIE8gPiAwICYmIE8gPiBrICYmIChrID0gTyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFIgPSByW3ouZm9udFN0YWNrXSxcbiAgICAgICAgICAgICAgICAgICAgVSA9IFIgJiYgUltFXTtcbiAgICAgICAgICAgICAgICBpZiAoVSAmJiBVLnJlY3QpIEIgPSBVLnJlY3QsIE0gPSBVLm1ldHJpY3M7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaiA9IGVbei5mb250U3RhY2tdLFxuICAgICAgICAgICAgICAgICAgICAgIHEgPSBqICYmIGpbRV07XG4gICAgICAgICAgICAgICAgICBpZiAoIXEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgTSA9IHEubWV0cmljcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUCA9IDI0ICogKHcgLSB6LnNjYWxlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIEYgPyAodC52ZXJ0aWNhbGl6YWJsZSA9ICEwLCBTLnB1c2goe1xuICAgICAgICAgICAgICAgIGdseXBoOiBFLFxuICAgICAgICAgICAgICAgIGltYWdlTmFtZTogVCxcbiAgICAgICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgICAgIHk6IGYgKyBQLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBGLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6LnNjYWxlLFxuICAgICAgICAgICAgICAgIGZvbnRTdGFjazogei5mb250U3RhY2ssXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiBDLFxuICAgICAgICAgICAgICAgIG1ldHJpY3M6IE0sXG4gICAgICAgICAgICAgICAgcmVjdDogQlxuICAgICAgICAgICAgICB9KSwgaCArPSBWICogei5zY2FsZSArIGwpIDogKFMucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2x5cGg6IEUsXG4gICAgICAgICAgICAgICAgaW1hZ2VOYW1lOiBULFxuICAgICAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICAgICAgeTogZiArIFAsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IEYsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHouc2NhbGUsXG4gICAgICAgICAgICAgICAgZm9udFN0YWNrOiB6LmZvbnRTdGFjayxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXg6IEMsXG4gICAgICAgICAgICAgICAgbWV0cmljczogTSxcbiAgICAgICAgICAgICAgICByZWN0OiBCXG4gICAgICAgICAgICAgIH0pLCBoICs9IE0uYWR2YW5jZSAqIHouc2NhbGUgKyBsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgMCAhPT0gUy5sZW5ndGggJiYgKHkgPSBNYXRoLm1heChoIC0gbCwgeSksIFR1KFMsIDAsIFMubGVuZ3RoIC0gMSwgbSwgaykpLCBoID0gMDtcbiAgICAgICAgICAgIHZhciBOID0gYSAqIHcgKyBrO1xuICAgICAgICAgICAgQS5saW5lT2Zmc2V0ID0gTWF0aC5tYXgoaywgXyksIGYgKz0gTiwgZCA9IE1hdGgubWF4KE4sIGQpLCArK3Y7XG4gICAgICAgICAgfSBlbHNlIGYgKz0gYSwgKyt2O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEssXG4gICAgICAgICAgICBHID0gZiAtIC0xNyxcbiAgICAgICAgICAgIFogPSBCdShvKSxcbiAgICAgICAgICAgIFggPSBaLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgICAgIEogPSBaLnZlcnRpY2FsQWxpZ247XG4gICAgICAgIChmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSkge1xuICAgICAgICAgIHZhciBsLFxuICAgICAgICAgICAgICBwID0gKGUgLSByKSAqIGk7XG4gICAgICAgICAgbCA9IGEgIT09IG8gPyAtcyAqIG4gLSAtMTcgOiAoLW4gKiB1ICsgLjUpICogbztcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBoID0gdDsgYyA8IGgubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSAwLCB5ID0gaFtjXS5wb3NpdGlvbmVkR2x5cGhzOyBmIDwgeS5sZW5ndGg7IGYgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgZCA9IHlbZl07XG4gICAgICAgICAgICAgIGQueCArPSBwLCBkLnkgKz0gbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKHQucG9zaXRpb25lZExpbmVzLCBtLCBYLCBKLCB5LCBkLCBhLCBHLCBpLmxlbmd0aCksIHQudG9wICs9IC1KICogRywgdC5ib3R0b20gPSB0LnRvcCArIEcsIHQubGVmdCArPSAtWCAqIHksIHQucmlnaHQgPSB0LmxlZnQgKyB5O1xuICAgICAgfShQLCBlLCByLCBuLCBtLCBvLCBzLCB1LCBjLCBsLCBoLCBkKSwgIWZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICBpZiAoMCAhPT0gcltlXS5wb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfShFKSAmJiBQO1xuICAgIH1cblxuICAgIEF1LmZyb21GZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSBuZXcgQXUoKSwgbiA9IDA7IG4gPCB0LnNlY3Rpb25zLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBpID0gdC5zZWN0aW9uc1tuXTtcbiAgICAgICAgaS5pbWFnZSA/IHIuYWRkSW1hZ2VTZWN0aW9uKGkpIDogci5hZGRUZXh0U2VjdGlvbihpLCBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgQXUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH0sIEF1LnByb3RvdHlwZS5nZXRTZWN0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25zW3RoaXMuc2VjdGlvbkluZGV4W3RdXTtcbiAgICB9LCBBdS5wcm90b3R5cGUuZ2V0U2VjdGlvbkluZGV4ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25JbmRleFt0XTtcbiAgICB9LCBBdS5wcm90b3R5cGUuZ2V0Q2hhckNvZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5jaGFyQ29kZUF0KHQpO1xuICAgIH0sIEF1LnByb3RvdHlwZS52ZXJ0aWNhbGl6ZVB1bmN0dWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IFwiXCIsIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICAgIHZhciBuID0gdC5jaGFyQ29kZUF0KHIgKyAxKSB8fCBudWxsLFxuICAgICAgICAgICAgICBpID0gdC5jaGFyQ29kZUF0KHIgLSAxKSB8fCBudWxsO1xuICAgICAgICAgIGUgKz0gbiAmJiBKbihuKSAmJiAhWHNbdFtyICsgMV1dIHx8IGkgJiYgSm4oaSkgJiYgIVhzW3RbciAtIDFdXSB8fCAhWHNbdFtyXV0gPyB0W3JdIDogWHNbdFtyXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0odGhpcy50ZXh0KTtcbiAgICB9LCBBdS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gMDsgZSA8IHRoaXMudGV4dC5sZW5ndGggJiYga3VbdGhpcy50ZXh0LmNoYXJDb2RlQXQoZSldOyBlKyspIHtcbiAgICAgICAgdCsrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciByID0gdGhpcy50ZXh0Lmxlbmd0aCwgbiA9IHRoaXMudGV4dC5sZW5ndGggLSAxOyBuID49IDAgJiYgbiA+PSB0ICYmIGt1W3RoaXMudGV4dC5jaGFyQ29kZUF0KG4pXTsgbi0tKSB7XG4gICAgICAgIHItLTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZyh0LCByKSwgdGhpcy5zZWN0aW9uSW5kZXggPSB0aGlzLnNlY3Rpb25JbmRleC5zbGljZSh0LCByKTtcbiAgICB9LCBBdS5wcm90b3R5cGUuc3Vic3RyaW5nID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IEF1KCk7XG4gICAgICByZXR1cm4gci50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZyh0LCBlKSwgci5zZWN0aW9uSW5kZXggPSB0aGlzLnNlY3Rpb25JbmRleC5zbGljZSh0LCBlKSwgci5zZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMsIHI7XG4gICAgfSwgQXUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9LCBBdS5wcm90b3R5cGUuZ2V0TWF4U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9uSW5kZXgucmVkdWNlKGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChlLCB0LnNlY3Rpb25zW3JdLnNjYWxlKTtcbiAgICAgIH0sIDApO1xuICAgIH0sIEF1LnByb3RvdHlwZS5hZGRUZXh0U2VjdGlvbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnRleHQgKz0gdC50ZXh0LCB0aGlzLnNlY3Rpb25zLnB1c2goX3UuZm9yVGV4dCh0LnNjYWxlLCB0LmZvbnRTdGFjayB8fCBlKSk7XG5cbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLnNlY3Rpb25zLmxlbmd0aCAtIDEsIG4gPSAwOyBuIDwgdC50ZXh0Lmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbkluZGV4LnB1c2gocik7XG4gICAgICB9XG4gICAgfSwgQXUucHJvdG90eXBlLmFkZEltYWdlU2VjdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuaW1hZ2UgPyB0LmltYWdlLm5hbWUgOiBcIlwiO1xuXG4gICAgICBpZiAoMCAhPT0gZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldE5leHRJbWFnZVNlY3Rpb25DaGFyQ29kZSgpO1xuICAgICAgICByID8gKHRoaXMudGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHIpLCB0aGlzLnNlY3Rpb25zLnB1c2goX3UuZm9ySW1hZ2UoZSkpLCB0aGlzLnNlY3Rpb25JbmRleC5wdXNoKHRoaXMuc2VjdGlvbnMubGVuZ3RoIC0gMSkpIDogQShcIlJlYWNoZWQgbWF4aW11bSBudW1iZXIgb2YgaW1hZ2VzIDY0MDFcIik7XG4gICAgICB9IGVsc2UgQShcIkNhbid0IGFkZCBGb3JtYXR0ZWRTZWN0aW9uIHdpdGggYW4gZW1wdHkgaW1hZ2UuXCIpO1xuICAgIH0sIEF1LnByb3RvdHlwZS5nZXROZXh0SW1hZ2VTZWN0aW9uQ2hhckNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZVNlY3Rpb25JRCA/IHRoaXMuaW1hZ2VTZWN0aW9uSUQgPj0gNjM3NDMgPyBudWxsIDogKyt0aGlzLmltYWdlU2VjdGlvbklEIDogKHRoaXMuaW1hZ2VTZWN0aW9uSUQgPSA1NzM0NCwgdGhpcy5pbWFnZVNlY3Rpb25JRCk7XG4gICAgfTtcbiAgICB2YXIga3UgPSB7XG4gICAgICA5OiAhMCxcbiAgICAgIDEwOiAhMCxcbiAgICAgIDExOiAhMCxcbiAgICAgIDEyOiAhMCxcbiAgICAgIDEzOiAhMCxcbiAgICAgIDMyOiAhMFxuICAgIH0sXG4gICAgICAgIEl1ID0ge307XG5cbiAgICBmdW5jdGlvbiB6dSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBpZiAoZS5pbWFnZU5hbWUpIHtcbiAgICAgICAgdmFyIG8gPSBuW2UuaW1hZ2VOYW1lXTtcbiAgICAgICAgcmV0dXJuIG8gPyBvLmRpc3BsYXlTaXplWzBdICogZS5zY2FsZSAqIDI0IC8gYSArIGkgOiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcyA9IHJbZS5mb250U3RhY2tdLFxuICAgICAgICAgIHUgPSBzICYmIHNbdF07XG4gICAgICByZXR1cm4gdSA/IHUubWV0cmljcy5hZHZhbmNlICogZS5zY2FsZSArIGkgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEN1KHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gTWF0aC5wb3codCAtIGUsIDIpO1xuICAgICAgcmV0dXJuIG4gPyB0IDwgZSA/IGkgLyAyIDogMiAqIGkgOiBpICsgTWF0aC5hYnMocikgKiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEV1KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHJldHVybiAxMCA9PT0gdCAmJiAobiAtPSAxZTQpLCByICYmIChuICs9IDE1MCksIDQwICE9PSB0ICYmIDY1Mjg4ICE9PSB0IHx8IChuICs9IDUwKSwgNDEgIT09IGUgJiYgNjUyODkgIT09IGUgfHwgKG4gKz0gNTApLCBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFB1KHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGZvciAodmFyIG8gPSBudWxsLCBzID0gQ3UoZSwgciwgaSwgYSksIHUgPSAwLCBsID0gbjsgdSA8IGwubGVuZ3RoOyB1ICs9IDEpIHtcbiAgICAgICAgdmFyIHAgPSBsW3VdLFxuICAgICAgICAgICAgYyA9IEN1KGUgLSBwLngsIHIsIGksIGEpICsgcC5iYWRuZXNzO1xuICAgICAgICBjIDw9IHMgJiYgKG8gPSBwLCBzID0gYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiB0LFxuICAgICAgICB4OiBlLFxuICAgICAgICBwcmlvckJyZWFrOiBvLFxuICAgICAgICBiYWRuZXNzOiBzXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE11KHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgIGlmIChcInBvaW50XCIgIT09IGEpIHJldHVybiBbXTtcbiAgICAgIGlmICghdCkgcmV0dXJuIFtdO1xuXG4gICAgICBmb3IgKHZhciBzLCB1ID0gW10sIGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IDA7IHMgPCB0Lmxlbmd0aCgpOyBzKyspIHtcbiAgICAgICAgICB2YXIgdSA9IHQuZ2V0U2VjdGlvbihzKTtcbiAgICAgICAgICBvICs9IHp1KHQuZ2V0Q2hhckNvZGUocyksIHUsIG4sIGksIGUsIGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG8gLyBNYXRoLm1heCgxLCBNYXRoLmNlaWwobyAvIHIpKTtcbiAgICAgIH0odCwgZSwgciwgbiwgaSwgbyksIHAgPSB0LnRleHQuaW5kZXhPZihcIuKAi1wiKSA+PSAwLCBjID0gMCwgaCA9IDA7IGggPCB0Lmxlbmd0aCgpOyBoKyspIHtcbiAgICAgICAgdmFyIGYgPSB0LmdldFNlY3Rpb24oaCksXG4gICAgICAgICAgICB5ID0gdC5nZXRDaGFyQ29kZShoKTtcblxuICAgICAgICBpZiAoa3VbeV0gfHwgKGMgKz0genUoeSwgZiwgbiwgaSwgZSwgbykpLCBoIDwgdC5sZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgICB2YXIgZCA9ICEoKHMgPSB5KSA8IDExOTA0IHx8ICEoR25bXCJCb3BvbW9mbyBFeHRlbmRlZFwiXShzKSB8fCBHbi5Cb3BvbW9mbyhzKSB8fCBHbltcIkNKSyBDb21wYXRpYmlsaXR5IEZvcm1zXCJdKHMpIHx8IEduW1wiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1wiXShzKSB8fCBHbltcIkNKSyBDb21wYXRpYmlsaXR5XCJdKHMpIHx8IEduW1wiQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcIl0ocykgfHwgR25bXCJDSksgU3Ryb2tlc1wiXShzKSB8fCBHbltcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiXShzKSB8fCBHbltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIl0ocykgfHwgR25bXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCJdKHMpIHx8IEduW1wiRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1wiXShzKSB8fCBHbltcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCJdKHMpIHx8IEduLkhpcmFnYW5hKHMpIHx8IEduW1wiSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1wiXShzKSB8fCBHbltcIkthbmd4aSBSYWRpY2Fsc1wiXShzKSB8fCBHbltcIkthdGFrYW5hIFBob25ldGljIEV4dGVuc2lvbnNcIl0ocykgfHwgR24uS2F0YWthbmEocykgfHwgR25bXCJWZXJ0aWNhbCBGb3Jtc1wiXShzKSB8fCBHbltcIllpIFJhZGljYWxzXCJdKHMpIHx8IEduW1wiWWkgU3lsbGFibGVzXCJdKHMpKSk7XG4gICAgICAgICAgKEl1W3ldIHx8IGQgfHwgZi5pbWFnZU5hbWUpICYmIHUucHVzaChQdShoICsgMSwgYywgbCwgdSwgRXUoeSwgdC5nZXRDaGFyQ29kZShoICsgMSksIGQgJiYgcCksICExKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICByZXR1cm4gZSA/IHQoZS5wcmlvckJyZWFrKS5jb25jYXQoZS5pbmRleCkgOiBbXTtcbiAgICAgIH0oUHUodC5sZW5ndGgoKSwgYywgbCwgdSwgMCwgITApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCdSh0KSB7XG4gICAgICB2YXIgZSA9IC41LFxuICAgICAgICAgIHIgPSAuNTtcblxuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgICBlID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgciA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgICAgIHIgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBob3Jpem9udGFsQWxpZ246IGUsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IHJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHUodCwgZSwgciwgbiwgaSkge1xuICAgICAgaWYgKG4gfHwgaSkgZm9yICh2YXIgYSA9IHRbcl0sIG8gPSAodFtyXS54ICsgYS5tZXRyaWNzLmFkdmFuY2UgKiBhLnNjYWxlKSAqIG4sIHMgPSBlOyBzIDw9IHI7IHMrKykge1xuICAgICAgICB0W3NdLnggLT0gbywgdFtzXS55ICs9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnUodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdmFyIG8sXG4gICAgICAgICAgcyA9IHQuaW1hZ2U7XG5cbiAgICAgIGlmIChzLmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHUgPSBzLmNvbnRlbnQsXG4gICAgICAgICAgICBsID0gcy5waXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIG8gPSBbdVswXSAvIGwsIHVbMV0gLyBsLCBzLmRpc3BsYXlTaXplWzBdIC0gdVsyXSAvIGwsIHMuZGlzcGxheVNpemVbMV0gLSB1WzNdIC8gbF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIHkgPSBlLmxlZnQgKiBhLFxuICAgICAgICAgIGQgPSBlLnJpZ2h0ICogYTtcbiAgICAgIFwid2lkdGhcIiA9PT0gciB8fCBcImJvdGhcIiA9PT0gciA/IChmID0gaVswXSArIHkgLSBuWzNdLCBjID0gaVswXSArIGQgKyBuWzFdKSA6IGMgPSAoZiA9IGlbMF0gKyAoeSArIGQgLSBzLmRpc3BsYXlTaXplWzBdKSAvIDIpICsgcy5kaXNwbGF5U2l6ZVswXTtcbiAgICAgIHZhciBtID0gZS50b3AgKiBhLFxuICAgICAgICAgIHYgPSBlLmJvdHRvbSAqIGE7XG4gICAgICByZXR1cm4gXCJoZWlnaHRcIiA9PT0gciB8fCBcImJvdGhcIiA9PT0gciA/IChwID0gaVsxXSArIG0gLSBuWzBdLCBoID0gaVsxXSArIHYgKyBuWzJdKSA6IGggPSAocCA9IGlbMV0gKyAobSArIHYgLSBzLmRpc3BsYXlTaXplWzFdKSAvIDIpICsgcy5kaXNwbGF5U2l6ZVsxXSwge1xuICAgICAgICBpbWFnZTogcyxcbiAgICAgICAgdG9wOiBwLFxuICAgICAgICByaWdodDogYyxcbiAgICAgICAgYm90dG9tOiBoLFxuICAgICAgICBsZWZ0OiBmLFxuICAgICAgICBjb2xsaXNpb25QYWRkaW5nOiBvXG4gICAgICB9O1xuICAgIH1cblxuICAgIEl1WzEwXSA9ICEwLCBJdVszMl0gPSAhMCwgSXVbMzhdID0gITAsIEl1WzQwXSA9ICEwLCBJdVs0MV0gPSAhMCwgSXVbNDNdID0gITAsIEl1WzQ1XSA9ICEwLCBJdVs0N10gPSAhMCwgSXVbMTczXSA9ICEwLCBJdVsxODNdID0gITAsIEl1WzgyMDNdID0gITAsIEl1WzgyMDhdID0gITAsIEl1WzgyMTFdID0gITAsIEl1WzgyMzFdID0gITA7XG5cbiAgICB2YXIgRnUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByLCBuLCBpKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5hbmdsZSA9IG4sIHZvaWQgMCAhPT0gaSAmJiAodGhpcy5zZWdtZW50ID0gaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGUodGhpcy54LCB0aGlzLnksIHRoaXMuYW5nbGUsIHRoaXMuc2VnbWVudCk7XG4gICAgICB9LCBlO1xuICAgIH0oaSk7XG5cbiAgICBmdW5jdGlvbiBEdSh0LCBlKSB7XG4gICAgICB2YXIgciA9IGUuZXhwcmVzc2lvbjtcbiAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHIua2luZCkgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICBsYXlvdXRTaXplOiByLmV2YWx1YXRlKG5ldyBzaSh0ICsgMSkpXG4gICAgICB9O1xuICAgICAgaWYgKFwic291cmNlXCIgPT09IHIua2luZCkgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJzb3VyY2VcIlxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgbiA9IHIuem9vbVN0b3BzLCBpID0gci5pbnRlcnBvbGF0aW9uVHlwZSwgYSA9IDA7IGEgPCBuLmxlbmd0aCAmJiBuW2FdIDw9IHQ7KSB7XG4gICAgICAgIGErKztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbyA9IGEgPSBNYXRoLm1heCgwLCBhIC0gMSk7IG8gPCBuLmxlbmd0aCAmJiBuW29dIDwgdCArIDE7KSB7XG4gICAgICAgIG8rKztcbiAgICAgIH1cblxuICAgICAgbyA9IE1hdGgubWluKG4ubGVuZ3RoIC0gMSwgbyk7XG4gICAgICB2YXIgcyA9IG5bYV0sXG4gICAgICAgICAgdSA9IG5bb107XG4gICAgICByZXR1cm4gXCJjb21wb3NpdGVcIiA9PT0gci5raW5kID8ge1xuICAgICAgICBraW5kOiBcImNvbXBvc2l0ZVwiLFxuICAgICAgICBtaW5ab29tOiBzLFxuICAgICAgICBtYXhab29tOiB1LFxuICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogaVxuICAgICAgfSA6IHtcbiAgICAgICAga2luZDogXCJjYW1lcmFcIixcbiAgICAgICAgbWluWm9vbTogcyxcbiAgICAgICAgbWF4Wm9vbTogdSxcbiAgICAgICAgbWluU2l6ZTogci5ldmFsdWF0ZShuZXcgc2kocykpLFxuICAgICAgICBtYXhTaXplOiByLmV2YWx1YXRlKG5ldyBzaSh1KSksXG4gICAgICAgIGludGVycG9sYXRpb25UeXBlOiBpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEx1KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZS51U2l6ZSxcbiAgICAgICAgICBpID0gci5sb3dlclNpemU7XG4gICAgICByZXR1cm4gXCJzb3VyY2VcIiA9PT0gdC5raW5kID8gaSAvIDEyOCA6IFwiY29tcG9zaXRlXCIgPT09IHQua2luZCA/IEtlKGkgLyAxMjgsIHIudXBwZXJTaXplIC8gMTI4LCBlLnVTaXplVCkgOiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE91KHQsIGUpIHtcbiAgICAgIHZhciByID0gMCxcbiAgICAgICAgICBuID0gMDtcbiAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHQua2luZCkgbiA9IHQubGF5b3V0U2l6ZTtlbHNlIGlmIChcInNvdXJjZVwiICE9PSB0LmtpbmQpIHtcbiAgICAgICAgdmFyIGkgPSB0LmludGVycG9sYXRpb25UeXBlLFxuICAgICAgICAgICAgYSA9IGkgPyBwKGFyLmludGVycG9sYXRpb25GYWN0b3IoaSwgZSwgdC5taW5ab29tLCB0Lm1heFpvb20pLCAwLCAxKSA6IDA7XG4gICAgICAgIFwiY2FtZXJhXCIgPT09IHQua2luZCA/IG4gPSBLZSh0Lm1pblNpemUsIHQubWF4U2l6ZSwgYSkgOiByID0gYTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVTaXplVDogcixcbiAgICAgICAgdVNpemU6IG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgT24oXCJBbmNob3JcIiwgRnUpO1xuICAgIHZhciBSdSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgZ2V0U2l6ZURhdGE6IER1LFxuICAgICAgZXZhbHVhdGVTaXplRm9yRmVhdHVyZTogTHUsXG4gICAgICBldmFsdWF0ZVNpemVGb3Jab29tOiBPdSxcbiAgICAgIFNJWkVfUEFDS19GQUNUT1I6IDEyOFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gVXUodCwgZSwgciwgbiwgaSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZS5zZWdtZW50KSByZXR1cm4gITA7XG5cbiAgICAgIGZvciAodmFyIGEgPSBlLCBvID0gZS5zZWdtZW50ICsgMSwgcyA9IDA7IHMgPiAtciAvIDI7KSB7XG4gICAgICAgIGlmICgtLW8gPCAwKSByZXR1cm4gITE7XG4gICAgICAgIHMgLT0gdFtvXS5kaXN0KGEpLCBhID0gdFtvXTtcbiAgICAgIH1cblxuICAgICAgcyArPSB0W29dLmRpc3QodFtvICsgMV0pLCBvKys7XG5cbiAgICAgIGZvciAodmFyIHUgPSBbXSwgbCA9IDA7IHMgPCByIC8gMjspIHtcbiAgICAgICAgdmFyIHAgPSB0W29dLFxuICAgICAgICAgICAgYyA9IHRbbyArIDFdO1xuICAgICAgICBpZiAoIWMpIHJldHVybiAhMTtcbiAgICAgICAgdmFyIGggPSB0W28gLSAxXS5hbmdsZVRvKHApIC0gcC5hbmdsZVRvKGMpO1xuXG4gICAgICAgIGZvciAoaCA9IE1hdGguYWJzKChoICsgMyAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSAtIE1hdGguUEkpLCB1LnB1c2goe1xuICAgICAgICAgIGRpc3RhbmNlOiBzLFxuICAgICAgICAgIGFuZ2xlRGVsdGE6IGhcbiAgICAgICAgfSksIGwgKz0gaDsgcyAtIHVbMF0uZGlzdGFuY2UgPiBuOykge1xuICAgICAgICAgIGwgLT0gdS5zaGlmdCgpLmFuZ2xlRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobCA+IGkpIHJldHVybiAhMTtcbiAgICAgICAgbysrLCBzICs9IHAuZGlzdChjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGp1KHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgcisrKSB7XG4gICAgICAgIGUgKz0gdFtyXS5kaXN0KHRbciArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXUodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHQgPyAuNiAqIGUgKiByIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOdSh0LCBlKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodCA/IHQucmlnaHQgLSB0LmxlZnQgOiAwLCBlID8gZS5yaWdodCAtIGUubGVmdCA6IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEt1KHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGZvciAodmFyIG8gPSBxdShyLCBpLCBhKSwgcyA9IE51KHIsIG4pICogYSwgdSA9IDAsIGwgPSBqdSh0KSAvIDIsIHAgPSAwOyBwIDwgdC5sZW5ndGggLSAxOyBwKyspIHtcbiAgICAgICAgdmFyIGMgPSB0W3BdLFxuICAgICAgICAgICAgaCA9IHRbcCArIDFdLFxuICAgICAgICAgICAgZiA9IGMuZGlzdChoKTtcblxuICAgICAgICBpZiAodSArIGYgPiBsKSB7XG4gICAgICAgICAgdmFyIHkgPSAobCAtIHUpIC8gZixcbiAgICAgICAgICAgICAgZCA9IEtlKGMueCwgaC54LCB5KSxcbiAgICAgICAgICAgICAgbSA9IEtlKGMueSwgaC55LCB5KSxcbiAgICAgICAgICAgICAgdiA9IG5ldyBGdShkLCBtLCBoLmFuZ2xlVG8oYyksIHApO1xuICAgICAgICAgIHJldHVybiB2Ll9yb3VuZCgpLCAhbyB8fCBVdSh0LCB2LCBzLCBvLCBlKSA/IHYgOiB2b2lkIDA7XG4gICAgICAgIH1cblxuICAgICAgICB1ICs9IGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR3UodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSkge1xuICAgICAgdmFyIGwgPSBxdShuLCBhLCBvKSxcbiAgICAgICAgICBwID0gTnUobiwgaSksXG4gICAgICAgICAgYyA9IHAgKiBvLFxuICAgICAgICAgIGggPSAwID09PSB0WzBdLnggfHwgdFswXS54ID09PSB1IHx8IDAgPT09IHRbMF0ueSB8fCB0WzBdLnkgPT09IHU7XG4gICAgICByZXR1cm4gZSAtIGMgPCBlIC8gNCAmJiAoZSA9IGMgKyBlIC8gNCksIGZ1bmN0aW9uIHQoZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCkge1xuICAgICAgICBmb3IgKHZhciBwID0gbyAvIDIsIGMgPSBqdShlKSwgaCA9IDAsIGYgPSByIC0gbiwgeSA9IFtdLCBkID0gMDsgZCA8IGUubGVuZ3RoIC0gMTsgZCsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgbSA9IGVbZF0sIHYgPSBlW2QgKyAxXSwgZyA9IG0uZGlzdCh2KSwgeCA9IHYuYW5nbGVUbyhtKTsgZiArIG4gPCBoICsgZzspIHtcbiAgICAgICAgICAgIHZhciBiID0gKChmICs9IG4pIC0gaCkgLyBnLFxuICAgICAgICAgICAgICAgIHcgPSBLZShtLngsIHYueCwgYiksXG4gICAgICAgICAgICAgICAgXyA9IEtlKG0ueSwgdi55LCBiKTtcblxuICAgICAgICAgICAgaWYgKHcgPj0gMCAmJiB3IDwgbCAmJiBfID49IDAgJiYgXyA8IGwgJiYgZiAtIHAgPj0gMCAmJiBmICsgcCA8PSBjKSB7XG4gICAgICAgICAgICAgIHZhciBBID0gbmV3IEZ1KHcsIF8sIHgsIGQpO1xuICAgICAgICAgICAgICBBLl9yb3VuZCgpLCBpICYmICFVdShlLCBBLCBvLCBpLCBhKSB8fCB5LnB1c2goQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaCArPSBnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHUgfHwgeS5sZW5ndGggfHwgcyB8fCAoeSA9IHQoZSwgaCAvIDIsIG4sIGksIGEsIG8sIHMsICEwLCBsKSksIHk7XG4gICAgICB9KHQsIGggPyBlIC8gMiAqIHMgJSBlIDogKHAgLyAyICsgMiAqIGEpICogbyAqIHMgJSBlLCBlLCBsLCByLCBjLCBoLCAhMSwgdSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWnUodCwgZSwgciwgbiwgYSkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IHRbc10sIGwgPSB2b2lkIDAsIHAgPSAwOyBwIDwgdS5sZW5ndGggLSAxOyBwKyspIHtcbiAgICAgICAgICB2YXIgYyA9IHVbcF0sXG4gICAgICAgICAgICAgIGggPSB1W3AgKyAxXTtcbiAgICAgICAgICBjLnggPCBlICYmIGgueCA8IGUgfHwgKGMueCA8IGUgPyBjID0gbmV3IGkoZSwgYy55ICsgKGUgLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkgOiBoLnggPCBlICYmIChoID0gbmV3IGkoZSwgYy55ICsgKGUgLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkpLCBjLnkgPCByICYmIGgueSA8IHIgfHwgKGMueSA8IHIgPyBjID0gbmV3IGkoYy54ICsgKHIgLSBjLnkpIC8gKGgueSAtIGMueSkgKiAoaC54IC0gYy54KSwgcikuX3JvdW5kKCkgOiBoLnkgPCByICYmIChoID0gbmV3IGkoYy54ICsgKHIgLSBjLnkpIC8gKGgueSAtIGMueSkgKiAoaC54IC0gYy54KSwgcikuX3JvdW5kKCkpLCBjLnggPj0gbiAmJiBoLnggPj0gbiB8fCAoYy54ID49IG4gPyBjID0gbmV3IGkobiwgYy55ICsgKG4gLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkgOiBoLnggPj0gbiAmJiAoaCA9IG5ldyBpKG4sIGMueSArIChuIC0gYy54KSAvIChoLnggLSBjLngpICogKGgueSAtIGMueSkpLl9yb3VuZCgpKSwgYy55ID49IGEgJiYgaC55ID49IGEgfHwgKGMueSA+PSBhID8gYyA9IG5ldyBpKGMueCArIChhIC0gYy55KSAvIChoLnkgLSBjLnkpICogKGgueCAtIGMueCksIGEpLl9yb3VuZCgpIDogaC55ID49IGEgJiYgKGggPSBuZXcgaShjLnggKyAoYSAtIGMueSkgLyAoaC55IC0gYy55KSAqIChoLnggLSBjLngpLCBhKS5fcm91bmQoKSksIGwgJiYgYy5lcXVhbHMobFtsLmxlbmd0aCAtIDFdKSB8fCBvLnB1c2gobCA9IFtjXSksIGwucHVzaChoKSkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWHUodCwgZSwgciwgbikge1xuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgICBvID0gdC5pbWFnZSxcbiAgICAgICAgICBzID0gby5waXhlbFJhdGlvLFxuICAgICAgICAgIHUgPSBvLnBhZGRlZFJlY3QudyAtIDIsXG4gICAgICAgICAgbCA9IG8ucGFkZGVkUmVjdC5oIC0gMixcbiAgICAgICAgICBwID0gdC5yaWdodCAtIHQubGVmdCxcbiAgICAgICAgICBjID0gdC5ib3R0b20gLSB0LnRvcCxcbiAgICAgICAgICBoID0gby5zdHJldGNoWCB8fCBbWzAsIHVdXSxcbiAgICAgICAgICBmID0gby5zdHJldGNoWSB8fCBbWzAsIGxdXSxcbiAgICAgICAgICB5ID0gZnVuY3Rpb24geSh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0ICsgZVsxXSAtIGVbMF07XG4gICAgICB9LFxuICAgICAgICAgIGQgPSBoLnJlZHVjZSh5LCAwKSxcbiAgICAgICAgICBtID0gZi5yZWR1Y2UoeSwgMCksXG4gICAgICAgICAgdiA9IHUgLSBkLFxuICAgICAgICAgIGcgPSBsIC0gbSxcbiAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICBiID0gZCxcbiAgICAgICAgICB3ID0gMCxcbiAgICAgICAgICBfID0gbSxcbiAgICAgICAgICBBID0gMCxcbiAgICAgICAgICBTID0gdixcbiAgICAgICAgICBrID0gMCxcbiAgICAgICAgICBJID0gZztcblxuICAgICAgaWYgKG8uY29udGVudCAmJiBuKSB7XG4gICAgICAgIHZhciB6ID0gby5jb250ZW50O1xuICAgICAgICB4ID0gSnUoaCwgMCwgelswXSksIHcgPSBKdShmLCAwLCB6WzFdKSwgYiA9IEp1KGgsIHpbMF0sIHpbMl0pLCBfID0gSnUoZiwgelsxXSwgelszXSksIEEgPSB6WzBdIC0geCwgayA9IHpbMV0gLSB3LCBTID0gelsyXSAtIHpbMF0gLSBiLCBJID0gelszXSAtIHpbMV0gLSBfO1xuICAgICAgfVxuXG4gICAgICB2YXIgQyA9IGZ1bmN0aW9uIEMobiwgYSwgdSwgbCkge1xuICAgICAgICB2YXIgaCA9IFl1KG4uc3RyZXRjaCAtIHgsIGIsIHAsIHQubGVmdCksXG4gICAgICAgICAgICBmID0gJHUobi5maXhlZCAtIEEsIFMsIG4uc3RyZXRjaCwgZCksXG4gICAgICAgICAgICB5ID0gWXUoYS5zdHJldGNoIC0gdywgXywgYywgdC50b3ApLFxuICAgICAgICAgICAgdiA9ICR1KGEuZml4ZWQgLSBrLCBJLCBhLnN0cmV0Y2gsIG0pLFxuICAgICAgICAgICAgZyA9IFl1KHUuc3RyZXRjaCAtIHgsIGIsIHAsIHQubGVmdCksXG4gICAgICAgICAgICB6ID0gJHUodS5maXhlZCAtIEEsIFMsIHUuc3RyZXRjaCwgZCksXG4gICAgICAgICAgICBDID0gWXUobC5zdHJldGNoIC0gdywgXywgYywgdC50b3ApLFxuICAgICAgICAgICAgRSA9ICR1KGwuZml4ZWQgLSBrLCBJLCBsLnN0cmV0Y2gsIG0pLFxuICAgICAgICAgICAgUCA9IG5ldyBpKGgsIHkpLFxuICAgICAgICAgICAgTSA9IG5ldyBpKGcsIHkpLFxuICAgICAgICAgICAgQiA9IG5ldyBpKGcsIEMpLFxuICAgICAgICAgICAgVCA9IG5ldyBpKGgsIEMpLFxuICAgICAgICAgICAgViA9IG5ldyBpKGYgLyBzLCB2IC8gcyksXG4gICAgICAgICAgICBGID0gbmV3IGkoeiAvIHMsIEUgLyBzKSxcbiAgICAgICAgICAgIEQgPSBlICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICBpZiAoRCkge1xuICAgICAgICAgIHZhciBMID0gTWF0aC5zaW4oRCksXG4gICAgICAgICAgICAgIE8gPSBNYXRoLmNvcyhEKSxcbiAgICAgICAgICAgICAgUiA9IFtPLCAtTCwgTCwgT107XG4gICAgICAgICAgUC5fbWF0TXVsdChSKSwgTS5fbWF0TXVsdChSKSwgVC5fbWF0TXVsdChSKSwgQi5fbWF0TXVsdChSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBVID0gbi5zdHJldGNoICsgbi5maXhlZCxcbiAgICAgICAgICAgIGogPSBhLnN0cmV0Y2ggKyBhLmZpeGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRsOiBQLFxuICAgICAgICAgIHRyOiBNLFxuICAgICAgICAgIGJsOiBULFxuICAgICAgICAgIGJyOiBCLFxuICAgICAgICAgIHRleDoge1xuICAgICAgICAgICAgeDogby5wYWRkZWRSZWN0LnggKyAxICsgVSxcbiAgICAgICAgICAgIHk6IG8ucGFkZGVkUmVjdC55ICsgMSArIGosXG4gICAgICAgICAgICB3OiB1LnN0cmV0Y2ggKyB1LmZpeGVkIC0gVSxcbiAgICAgICAgICAgIGg6IGwuc3RyZXRjaCArIGwuZml4ZWQgLSBqXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0aW5nTW9kZTogdm9pZCAwLFxuICAgICAgICAgIGdseXBoT2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgc2VjdGlvbkluZGV4OiAwLFxuICAgICAgICAgIHBpeGVsT2Zmc2V0VEw6IFYsXG4gICAgICAgICAgcGl4ZWxPZmZzZXRCUjogRixcbiAgICAgICAgICBtaW5Gb250U2NhbGVYOiBTIC8gcyAvIHAsXG4gICAgICAgICAgbWluRm9udFNjYWxlWTogSSAvIHMgLyBjLFxuICAgICAgICAgIGlzU0RGOiByXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBpZiAobiAmJiAoby5zdHJldGNoWCB8fCBvLnN0cmV0Y2hZKSkgZm9yICh2YXIgRSA9IEh1KGgsIHYsIGQpLCBQID0gSHUoZiwgZywgbSksIE0gPSAwOyBNIDwgRS5sZW5ndGggLSAxOyBNKyspIHtcbiAgICAgICAgZm9yICh2YXIgQiA9IEVbTV0sIFQgPSBFW00gKyAxXSwgViA9IDA7IFYgPCBQLmxlbmd0aCAtIDE7IFYrKykge1xuICAgICAgICAgIGEucHVzaChDKEIsIFBbVl0sIFQsIFBbViArIDFdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBhLnB1c2goQyh7XG4gICAgICAgIGZpeGVkOiAwLFxuICAgICAgICBzdHJldGNoOiAtMVxuICAgICAgfSwge1xuICAgICAgICBmaXhlZDogMCxcbiAgICAgICAgc3RyZXRjaDogLTFcbiAgICAgIH0sIHtcbiAgICAgICAgZml4ZWQ6IDAsXG4gICAgICAgIHN0cmV0Y2g6IHUgKyAxXG4gICAgICB9LCB7XG4gICAgICAgIGZpeGVkOiAwLFxuICAgICAgICBzdHJldGNoOiBsICsgMVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSnUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSAwLCBhID0gdDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICBuICs9IE1hdGgubWF4KGUsIE1hdGgubWluKHIsIG9bMV0pKSAtIE1hdGgubWF4KGUsIE1hdGgubWluKHIsIG9bMF0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSHUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IFt7XG4gICAgICAgIGZpeGVkOiAtMSxcbiAgICAgICAgc3RyZXRjaDogMFxuICAgICAgfV0sIGkgPSAwLCBhID0gdDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldLFxuICAgICAgICAgICAgcyA9IG9bMF0sXG4gICAgICAgICAgICB1ID0gb1sxXSxcbiAgICAgICAgICAgIGwgPSBuW24ubGVuZ3RoIC0gMV07XG4gICAgICAgIG4ucHVzaCh7XG4gICAgICAgICAgZml4ZWQ6IHMgLSBsLnN0cmV0Y2gsXG4gICAgICAgICAgc3RyZXRjaDogbC5zdHJldGNoXG4gICAgICAgIH0pLCBuLnB1c2goe1xuICAgICAgICAgIGZpeGVkOiBzIC0gbC5zdHJldGNoLFxuICAgICAgICAgIHN0cmV0Y2g6IGwuc3RyZXRjaCArICh1IC0gcylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuLnB1c2goe1xuICAgICAgICBmaXhlZDogZSArIDEsXG4gICAgICAgIHN0cmV0Y2g6IHJcbiAgICAgIH0pLCBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFl1KHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0IC8gZSAqIHIgKyBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICR1KHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0IC0gZSAqIHIgLyBuO1xuICAgIH1cblxuICAgIHZhciBXdSA9IGZ1bmN0aW9uIFd1KHQsIGUsIHIsIG4sIGEsIG8sIHMsIHUsIGwsIHApIHtcbiAgICAgIGlmICh0aGlzLmJveFN0YXJ0SW5kZXggPSB0Lmxlbmd0aCwgbCkge1xuICAgICAgICB2YXIgYyA9IG8udG9wLFxuICAgICAgICAgICAgaCA9IG8uYm90dG9tLFxuICAgICAgICAgICAgZiA9IG8uY29sbGlzaW9uUGFkZGluZztcbiAgICAgICAgZiAmJiAoYyAtPSBmWzFdLCBoICs9IGZbM10pO1xuICAgICAgICB2YXIgeSA9IGggLSBjO1xuICAgICAgICB5ID4gMCAmJiAoeSA9IE1hdGgubWF4KDEwLCB5KSwgdGhpcy5jaXJjbGVEaWFtZXRlciA9IHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBvLnRvcCAqIHMgLSB1LFxuICAgICAgICAgICAgbSA9IG8uYm90dG9tICogcyArIHUsXG4gICAgICAgICAgICB2ID0gby5sZWZ0ICogcyAtIHUsXG4gICAgICAgICAgICBnID0gby5yaWdodCAqIHMgKyB1LFxuICAgICAgICAgICAgeCA9IG8uY29sbGlzaW9uUGFkZGluZztcblxuICAgICAgICBpZiAoeCAmJiAodiAtPSB4WzBdICogcywgZCAtPSB4WzFdICogcywgZyArPSB4WzJdICogcywgbSArPSB4WzNdICogcyksIHApIHtcbiAgICAgICAgICB2YXIgYiA9IG5ldyBpKHYsIGQpLFxuICAgICAgICAgICAgICB3ID0gbmV3IGkoZywgZCksXG4gICAgICAgICAgICAgIF8gPSBuZXcgaSh2LCBtKSxcbiAgICAgICAgICAgICAgQSA9IG5ldyBpKGcsIG0pLFxuICAgICAgICAgICAgICBTID0gcCAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgICBiLl9yb3RhdGUoUyksIHcuX3JvdGF0ZShTKSwgXy5fcm90YXRlKFMpLCBBLl9yb3RhdGUoUyksIHYgPSBNYXRoLm1pbihiLngsIHcueCwgXy54LCBBLngpLCBnID0gTWF0aC5tYXgoYi54LCB3LngsIF8ueCwgQS54KSwgZCA9IE1hdGgubWluKGIueSwgdy55LCBfLnksIEEueSksIG0gPSBNYXRoLm1heChiLnksIHcueSwgXy55LCBBLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5lbXBsYWNlQmFjayhlLngsIGUueSwgdiwgZCwgZywgbSwgciwgbiwgYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm94RW5kSW5kZXggPSB0Lmxlbmd0aDtcbiAgICB9LFxuICAgICAgICBRdSA9IGZ1bmN0aW9uIFF1KHQsIGUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQgJiYgKHQgPSBbXSksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRsKSwgdGhpcy5kYXRhID0gdCwgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoLCB0aGlzLmNvbXBhcmUgPSBlLCB0aGlzLmxlbmd0aCA+IDApIGZvciAodmFyIHIgPSAodGhpcy5sZW5ndGggPj4gMSkgLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICB0aGlzLl9kb3duKHIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0bCh0LCBlKSB7XG4gICAgICByZXR1cm4gdCA8IGUgPyAtMSA6IHQgPiBlID8gMSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWwodCwgZSwgcikge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMSksIHZvaWQgMCA9PT0gciAmJiAociA9ICExKTtcblxuICAgICAgZm9yICh2YXIgbiA9IDEgLyAwLCBhID0gMSAvIDAsIG8gPSAtMSAvIDAsIHMgPSAtMSAvIDAsIHUgPSB0WzBdLCBsID0gMDsgbCA8IHUubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIHAgPSB1W2xdO1xuICAgICAgICAoIWwgfHwgcC54IDwgbikgJiYgKG4gPSBwLngpLCAoIWwgfHwgcC55IDwgYSkgJiYgKGEgPSBwLnkpLCAoIWwgfHwgcC54ID4gbykgJiYgKG8gPSBwLngpLCAoIWwgfHwgcC55ID4gcykgJiYgKHMgPSBwLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYyA9IE1hdGgubWluKG8gLSBuLCBzIC0gYSksXG4gICAgICAgICAgaCA9IGMgLyAyLFxuICAgICAgICAgIGYgPSBuZXcgUXUoW10sIHJsKTtcbiAgICAgIGlmICgwID09PSBjKSByZXR1cm4gbmV3IGkobiwgYSk7XG5cbiAgICAgIGZvciAodmFyIHkgPSBuOyB5IDwgbzsgeSArPSBjKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSBhOyBkIDwgczsgZCArPSBjKSB7XG4gICAgICAgICAgZi5wdXNoKG5ldyBubCh5ICsgaCwgZCArIGgsIGgsIHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBtID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gMCwgaSA9IHRbMF0sIGEgPSAwLCBvID0gaS5sZW5ndGgsIHMgPSBvIC0gMTsgYSA8IG87IHMgPSBhKyspIHtcbiAgICAgICAgICB2YXIgdSA9IGlbYV0sXG4gICAgICAgICAgICAgIGwgPSBpW3NdLFxuICAgICAgICAgICAgICBwID0gdS54ICogbC55IC0gbC54ICogdS55O1xuICAgICAgICAgIHIgKz0gKHUueCArIGwueCkgKiBwLCBuICs9ICh1LnkgKyBsLnkpICogcCwgZSArPSAzICogcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgbmwociAvIGUsIG4gLyBlLCAwLCB0KTtcbiAgICAgIH0odCksIHYgPSBmLmxlbmd0aDsgZi5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBnID0gZi5wb3AoKTtcbiAgICAgICAgKGcuZCA+IG0uZCB8fCAhbS5kKSAmJiAobSA9IGcsIHIgJiYgY29uc29sZS5sb2coXCJmb3VuZCBiZXN0ICVkIGFmdGVyICVkIHByb2Jlc1wiLCBNYXRoLnJvdW5kKDFlNCAqIGcuZCkgLyAxZTQsIHYpKSwgZy5tYXggLSBtLmQgPD0gZSB8fCAoZi5wdXNoKG5ldyBubChnLnAueCAtIChoID0gZy5oIC8gMiksIGcucC55IC0gaCwgaCwgdCkpLCBmLnB1c2gobmV3IG5sKGcucC54ICsgaCwgZy5wLnkgLSBoLCBoLCB0KSksIGYucHVzaChuZXcgbmwoZy5wLnggLSBoLCBnLnAueSArIGgsIGgsIHQpKSwgZi5wdXNoKG5ldyBubChnLnAueCArIGgsIGcucC55ICsgaCwgaCwgdCkpLCB2ICs9IDQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gciAmJiAoY29uc29sZS5sb2coXCJudW0gcHJvYmVzOiBcIiArIHYpLCBjb25zb2xlLmxvZyhcImJlc3QgZGlzdGFuY2U6IFwiICsgbS5kKSksIG0ucDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBybCh0LCBlKSB7XG4gICAgICByZXR1cm4gZS5tYXggLSB0Lm1heDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBubCh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLnAgPSBuZXcgaSh0LCBlKSwgdGhpcy5oID0gciwgdGhpcy5kID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9ICExLCBuID0gMSAvIDAsIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBlW2ldLCBvID0gMCwgcyA9IGEubGVuZ3RoLCB1ID0gcyAtIDE7IG8gPCBzOyB1ID0gbysrKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGFbb10sXG4gICAgICAgICAgICAgICAgcCA9IGFbdV07XG4gICAgICAgICAgICBsLnkgPiB0LnkgIT0gcC55ID4gdC55ICYmIHQueCA8IChwLnggLSBsLngpICogKHQueSAtIGwueSkgLyAocC55IC0gbC55KSArIGwueCAmJiAociA9ICFyKSwgbiA9IE1hdGgubWluKG4sIFlhKHQsIGwsIHApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHIgPyAxIDogLTEpICogTWF0aC5zcXJ0KG4pO1xuICAgICAgfSh0aGlzLnAsIG4pLCB0aGlzLm1heCA9IHRoaXMuZCArIHRoaXMuaCAqIE1hdGguU1FSVDI7XG4gICAgfVxuXG4gICAgUXUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5kYXRhLnB1c2godCksIHRoaXMubGVuZ3RoKyssIHRoaXMuX3VwKHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfSwgUXUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgwICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZGF0YVswXSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmRhdGEucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aC0tLCB0aGlzLmxlbmd0aCA+IDAgJiYgKHRoaXMuZGF0YVswXSA9IGUsIHRoaXMuX2Rvd24oMCkpLCB0O1xuICAgICAgfVxuICAgIH0sIFF1LnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbiAgICB9LCBRdS5wcm90b3R5cGUuX3VwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLmRhdGEsIHIgPSB0aGlzLmNvbXBhcmUsIG4gPSBlW3RdOyB0ID4gMDspIHtcbiAgICAgICAgdmFyIGkgPSB0IC0gMSA+PiAxLFxuICAgICAgICAgICAgYSA9IGVbaV07XG4gICAgICAgIGlmIChyKG4sIGEpID49IDApIGJyZWFrO1xuICAgICAgICBlW3RdID0gYSwgdCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGVbdF0gPSBuO1xuICAgIH0sIFF1LnByb3RvdHlwZS5fZG93biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5kYXRhLCByID0gdGhpcy5jb21wYXJlLCBuID0gdGhpcy5sZW5ndGggPj4gMSwgaSA9IGVbdF07IHQgPCBuOykge1xuICAgICAgICB2YXIgYSA9IDEgKyAodCA8PCAxKSxcbiAgICAgICAgICAgIG8gPSBlW2FdLFxuICAgICAgICAgICAgcyA9IGEgKyAxO1xuICAgICAgICBpZiAocyA8IHRoaXMubGVuZ3RoICYmIHIoZVtzXSwgbykgPCAwICYmIChhID0gcywgbyA9IGVbc10pLCByKG8sIGkpID49IDApIGJyZWFrO1xuICAgICAgICBlW3RdID0gbywgdCA9IGE7XG4gICAgICB9XG5cbiAgICAgIGVbdF0gPSBpO1xuICAgIH07XG4gICAgdmFyIGlsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgZnVuY3Rpb24gYWwodCwgZSkge1xuICAgICAgcmV0dXJuIGVbMV0gIT09IGlsID8gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgc3dpdGNoIChlID0gTWF0aC5hYnMoZSksIHIgPSBNYXRoLmFicyhyKSwgdCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICBpID0gciAtIDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICBpID0gNyAtIHI7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgbiA9IC1lO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgbiA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW24sIGldO1xuICAgICAgfSh0LCBlWzBdLCBlWzFdKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gMCxcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICBlIDwgMCAmJiAoZSA9IDApO1xuICAgICAgICB2YXIgaSA9IGUgLyBNYXRoLnNxcnQoMik7XG5cbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgICAgICAgbiA9IGkgLSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgICBuID0gNyAtIGk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIG4gPSA3IC0gZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgbiA9IGUgLSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgICAgIHIgPSAtaTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgICByID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIHIgPSBlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgIHIgPSAtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbciwgbl07XG4gICAgICB9KHQsIGVbMF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9sKHQpIHtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcblxuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbCh0LCBlLCByLCBuLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkKSB7XG4gICAgICB2YXIgbSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBhLCBvLCBzLCB1KSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBuLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0ZVwiKS5ldmFsdWF0ZShvLCB7fSkgKiBNYXRoLlBJIC8gMTgwLCBwID0gW10sIGMgPSAwLCBoID0gZS5wb3NpdGlvbmVkTGluZXM7IGMgPCBoLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgZiA9IGhbY10sIHkgPSAwLCBkID0gZi5wb3NpdGlvbmVkR2x5cGhzOyB5IDwgZC5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG0gPSBkW3ldO1xuXG4gICAgICAgICAgICBpZiAobS5yZWN0KSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gbS5yZWN0IHx8IHt9LFxuICAgICAgICAgICAgICAgICAgZyA9IDQsXG4gICAgICAgICAgICAgICAgICB4ID0gITAsXG4gICAgICAgICAgICAgICAgICBiID0gMSxcbiAgICAgICAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgICAgICAgXyA9IChhIHx8IHUpICYmIG0udmVydGljYWwsXG4gICAgICAgICAgICAgICAgICBBID0gbS5tZXRyaWNzLmFkdmFuY2UgKiBtLnNjYWxlIC8gMjtcblxuICAgICAgICAgICAgICBpZiAodSAmJiBlLnZlcnRpY2FsaXphYmxlICYmICh3ID0gZi5saW5lT2Zmc2V0IC8gMiAtIChtLmltYWdlTmFtZSA/IC0oMjQgLSBtLm1ldHJpY3Mud2lkdGggKiBtLnNjYWxlKSAvIDIgOiAyNCAqIChtLnNjYWxlIC0gMSkpKSwgbS5pbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgUyA9IHNbbS5pbWFnZU5hbWVdO1xuICAgICAgICAgICAgICAgIHggPSBTLnNkZiwgZyA9IDEgLyAoYiA9IFMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgayA9IGEgPyBbbS54ICsgQSwgbS55XSA6IFswLCAwXSxcbiAgICAgICAgICAgICAgICAgIEkgPSBhID8gWzAsIDBdIDogW20ueCArIEEgKyByWzBdLCBtLnkgKyByWzFdIC0gd10sXG4gICAgICAgICAgICAgICAgICB6ID0gWzAsIDBdO1xuICAgICAgICAgICAgICBfICYmICh6ID0gSSwgSSA9IFswLCAwXSk7XG4gICAgICAgICAgICAgIHZhciBDID0gKG0ubWV0cmljcy5sZWZ0IC0gZykgKiBtLnNjYWxlIC0gQSArIElbMF0sXG4gICAgICAgICAgICAgICAgICBFID0gKC1tLm1ldHJpY3MudG9wIC0gZykgKiBtLnNjYWxlICsgSVsxXSxcbiAgICAgICAgICAgICAgICAgIFAgPSBDICsgdi53ICogbS5zY2FsZSAvIGIsXG4gICAgICAgICAgICAgICAgICBNID0gRSArIHYuaCAqIG0uc2NhbGUgLyBiLFxuICAgICAgICAgICAgICAgICAgQiA9IG5ldyBpKEMsIEUpLFxuICAgICAgICAgICAgICAgICAgVCA9IG5ldyBpKFAsIEUpLFxuICAgICAgICAgICAgICAgICAgViA9IG5ldyBpKEMsIE0pLFxuICAgICAgICAgICAgICAgICAgRiA9IG5ldyBpKFAsIE0pO1xuXG4gICAgICAgICAgICAgIGlmIChfKSB7XG4gICAgICAgICAgICAgICAgdmFyIEQgPSBuZXcgaSgtQSwgQSAtIC0xNyksXG4gICAgICAgICAgICAgICAgICAgIEwgPSAtTWF0aC5QSSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIE8gPSAxMiAtIEEsXG4gICAgICAgICAgICAgICAgICAgIFIgPSBuZXcgaSgyMiAtIE8sIC0obS5pbWFnZU5hbWUgPyBPIDogMCkpLFxuICAgICAgICAgICAgICAgICAgICBVID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShpLCBbbnVsbF0uY29uY2F0KHopKSkoKTtcbiAgICAgICAgICAgICAgICBCLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChSKS5fYWRkKFUpLCBULl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChSKS5fYWRkKFUpLCBWLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChSKS5fYWRkKFUpLCBGLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChSKS5fYWRkKFUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IE1hdGguc2luKGwpLFxuICAgICAgICAgICAgICAgICAgICBxID0gTWF0aC5jb3MobCksXG4gICAgICAgICAgICAgICAgICAgIE4gPSBbcSwgLWosIGosIHFdO1xuICAgICAgICAgICAgICAgIEIuX21hdE11bHQoTiksIFQuX21hdE11bHQoTiksIFYuX21hdE11bHQoTiksIEYuX21hdE11bHQoTik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBpKDAsIDApLFxuICAgICAgICAgICAgICAgICAgRyA9IG5ldyBpKDAsIDApO1xuICAgICAgICAgICAgICBwLnB1c2goe1xuICAgICAgICAgICAgICAgIHRsOiBCLFxuICAgICAgICAgICAgICAgIHRyOiBULFxuICAgICAgICAgICAgICAgIGJsOiBWLFxuICAgICAgICAgICAgICAgIGJyOiBGLFxuICAgICAgICAgICAgICAgIHRleDogdixcbiAgICAgICAgICAgICAgICB3cml0aW5nTW9kZTogZS53cml0aW5nTW9kZSxcbiAgICAgICAgICAgICAgICBnbHlwaE9mZnNldDogayxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXg6IG0uc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgICAgIGlzU0RGOiB4LFxuICAgICAgICAgICAgICAgIHBpeGVsT2Zmc2V0VEw6IEssXG4gICAgICAgICAgICAgICAgcGl4ZWxPZmZzZXRCUjogRyxcbiAgICAgICAgICAgICAgICBtaW5Gb250U2NhbGVYOiAwLFxuICAgICAgICAgICAgICAgIG1pbkZvbnRTY2FsZVk6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KDAsIHIsIHUsIGEsIG8sIHMsIG4sIHQuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCksXG4gICAgICAgICAgdiA9IHQudGV4dFNpemVEYXRhLFxuICAgICAgICAgIGcgPSBudWxsO1xuXG4gICAgICBcInNvdXJjZVwiID09PSB2LmtpbmQgPyAoZyA9IFsxMjggKiBhLmxheW91dC5nZXQoXCJ0ZXh0LXNpemVcIikuZXZhbHVhdGUocywge30pXSlbMF0gPiAzMjY0MCAmJiBBKHQubGF5ZXJJZHNbMF0gKyAnOiBWYWx1ZSBmb3IgXCJ0ZXh0LXNpemVcIiBpcyA+PSAyNTUuIFJlZHVjZSB5b3VyIFwidGV4dC1zaXplXCIuJykgOiBcImNvbXBvc2l0ZVwiID09PSB2LmtpbmQgJiYgKChnID0gWzEyOCAqIHkuY29tcG9zaXRlVGV4dFNpemVzWzBdLmV2YWx1YXRlKHMsIHt9LCBkKSwgMTI4ICogeS5jb21wb3NpdGVUZXh0U2l6ZXNbMV0uZXZhbHVhdGUocywge30sIGQpXSlbMF0gPiAzMjY0MCB8fCBnWzFdID4gMzI2NDApICYmIEEodC5sYXllcklkc1swXSArICc6IFZhbHVlIGZvciBcInRleHQtc2l6ZVwiIGlzID49IDI1NS4gUmVkdWNlIHlvdXIgXCJ0ZXh0LXNpemVcIi4nKSwgdC5hZGRTeW1ib2xzKHQudGV4dCwgbSwgZywgdSwgbywgcywgcCwgZSwgbC5saW5lU3RhcnRJbmRleCwgbC5saW5lTGVuZ3RoLCBmLCBkKTtcblxuICAgICAgZm9yICh2YXIgeCA9IDAsIGIgPSBjOyB4IDwgYi5sZW5ndGg7IHggKz0gMSkge1xuICAgICAgICBoW2JbeF1dID0gdC50ZXh0LnBsYWNlZFN5bWJvbEFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiA0ICogbS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWwodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0KSB7XG4gICAgICAgIHJldHVybiB0W2VdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsbCh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHQuY29tcGFyZVRleHQ7XG5cbiAgICAgIGlmIChlIGluIGkpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IGlbZV0sIG8gPSBhLmxlbmd0aCAtIDE7IG8gPj0gMDsgby0tKSB7XG4gICAgICAgICAgaWYgKG4uZGlzdChhW29dKSA8IHIpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlbZV0gPSBbXTtcblxuICAgICAgcmV0dXJuIGlbZV0ucHVzaChuKSwgITE7XG4gICAgfVxuXG4gICAgdmFyIHBsID0gYnMuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICAgIGNsID0gW3tcbiAgICAgIG5hbWU6IFwiYV9mYWRlX29wYWNpdHlcIixcbiAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICB0eXBlOiBcIlVpbnQ4XCIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XTtcblxuICAgIGZ1bmN0aW9uIGhsKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgpIHtcbiAgICAgIHZhciBmID0gcyA/IE1hdGgubWluKDMyNjQwLCBNYXRoLnJvdW5kKHNbMF0pKSA6IDAsXG4gICAgICAgICAgeSA9IHMgPyBNYXRoLm1pbigzMjY0MCwgTWF0aC5yb3VuZChzWzFdKSkgOiAwO1xuICAgICAgdC5lbXBsYWNlQmFjayhlLCByLCBNYXRoLnJvdW5kKDMyICogbiksIE1hdGgucm91bmQoMzIgKiBpKSwgYSwgbywgKGYgPDwgMSkgKyAodSA/IDEgOiAwKSwgeSwgMTYgKiBsLCAxNiAqIHAsIDI1NiAqIGMsIDI1NiAqIGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsKHQsIGUsIHIpIHtcbiAgICAgIHQuZW1wbGFjZUJhY2soZS54LCBlLnksIHIpLCB0LmVtcGxhY2VCYWNrKGUueCwgZS55LCByKSwgdC5lbXBsYWNlQmFjayhlLngsIGUueSwgciksIHQuZW1wbGFjZUJhY2soZS54LCBlLnksIHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHlsKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdC5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgaWYgKCRuKHJbZV0udGV4dCkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIHZhciBkbCA9IGZ1bmN0aW9uIGRsKHQpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgVmkoKSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IGppKCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zID0gdCwgdGhpcy5zZWdtZW50cyA9IG5ldyBzYSgpLCB0aGlzLmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBGaSgpLCB0aGlzLm9wYWNpdHlWZXJ0ZXhBcnJheSA9IG5ldyBEaSgpLCB0aGlzLnBsYWNlZFN5bWJvbEFycmF5ID0gbmV3IFFpKCk7XG4gICAgfTtcblxuICAgIGRsLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoICYmIDAgPT09IHRoaXMuaW5kZXhBcnJheS5sZW5ndGggJiYgMCA9PT0gdGhpcy5keW5hbWljTGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoICYmIDAgPT09IHRoaXMub3BhY2l0eVZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICB9LCBkbC5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMuaXNFbXB0eSgpIHx8IChyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGpzLm1lbWJlcnMpLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXksIGUpLCB0aGlzLmR5bmFtaWNMYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheSwgcXMubWVtYmVycywgITApLCB0aGlzLm9wYWNpdHlWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLm9wYWNpdHlWZXJ0ZXhBcnJheSwgY2wsICEwKSwgdGhpcy5vcGFjaXR5VmVydGV4QnVmZmVyLml0ZW1TaXplID0gMSksIChyIHx8IG4pICYmIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSk7XG4gICAgfSwgZGwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZGVzdHJveSgpLCB0aGlzLnNlZ21lbnRzLmRlc3Ryb3koKSwgdGhpcy5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5vcGFjaXR5VmVydGV4QnVmZmVyLmRlc3Ryb3koKSk7XG4gICAgfSwgT24oXCJTeW1ib2xCdWZmZXJzXCIsIGRsKTtcblxuICAgIHZhciBtbCA9IGZ1bmN0aW9uIG1sKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgdCgpLCB0aGlzLmxheW91dEF0dHJpYnV0ZXMgPSBlLCB0aGlzLmluZGV4QXJyYXkgPSBuZXcgcigpLCB0aGlzLnNlZ21lbnRzID0gbmV3IHNhKCksIHRoaXMuY29sbGlzaW9uVmVydGV4QXJyYXkgPSBuZXcgVWkoKTtcbiAgICB9O1xuXG4gICAgbWwucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMubGF5b3V0QXR0cmlidXRlcyksIHRoaXMuaW5kZXhCdWZmZXIgPSB0LmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhBcnJheSksIHRoaXMuY29sbGlzaW9uVmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5jb2xsaXNpb25WZXJ0ZXhBcnJheSwgTnMubWVtYmVycywgITApO1xuICAgIH0sIG1sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMuZGVzdHJveSgpLCB0aGlzLmNvbGxpc2lvblZlcnRleEJ1ZmZlci5kZXN0cm95KCkpO1xuICAgIH0sIE9uKFwiQ29sbGlzaW9uQnVmZmVyc1wiLCBtbCk7XG5cbiAgICB2YXIgdmwgPSBmdW5jdGlvbiB2bCh0KSB7XG4gICAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gdC5jb2xsaXNpb25Cb3hBcnJheSwgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLmluZGV4ID0gdC5pbmRleCwgdGhpcy5waXhlbFJhdGlvID0gdC5waXhlbFJhdGlvLCB0aGlzLnNvdXJjZUxheWVySW5kZXggPSB0LnNvdXJjZUxheWVySW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLmhhc1JUTFRleHQgPSAhMSwgdGhpcy5zb3J0S2V5UmFuZ2VzID0gW10sIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXkgPSBbXSwgdGhpcy5wbGFjZW1lbnRJbnZQcm9qTWF0cml4ID0gb28oW10pLCB0aGlzLnBsYWNlbWVudFZpZXdwb3J0TWF0cml4ID0gb28oW10pO1xuICAgICAgdmFyIGUgPSB0aGlzLmxheWVyc1swXS5fdW5ldmFsdWF0ZWRMYXlvdXQuX3ZhbHVlcztcbiAgICAgIHRoaXMudGV4dFNpemVEYXRhID0gRHUodGhpcy56b29tLCBlW1widGV4dC1zaXplXCJdKSwgdGhpcy5pY29uU2l6ZURhdGEgPSBEdSh0aGlzLnpvb20sIGVbXCJpY29uLXNpemVcIl0pO1xuICAgICAgdmFyIHIgPSB0aGlzLmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgbiA9IHIuZ2V0KFwic3ltYm9sLXNvcnQta2V5XCIpLFxuICAgICAgICAgIGkgPSByLmdldChcInN5bWJvbC16LW9yZGVyXCIpO1xuICAgICAgdGhpcy5jYW5PdmVybGFwID0gci5nZXQoXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIikgfHwgci5nZXQoXCJpY29uLWFsbG93LW92ZXJsYXBcIikgfHwgci5nZXQoXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIikgfHwgci5nZXQoXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIiksIHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgPSBcInZpZXdwb3J0LXlcIiAhPT0gaSAmJiB2b2lkIDAgIT09IG4uY29uc3RhbnRPcigxKSwgdGhpcy5zb3J0RmVhdHVyZXNCeVkgPSAoXCJ2aWV3cG9ydC15XCIgPT09IGkgfHwgXCJhdXRvXCIgPT09IGkgJiYgIXRoaXMuc29ydEZlYXR1cmVzQnlLZXkpICYmIHRoaXMuY2FuT3ZlcmxhcCwgXCJwb2ludFwiID09PSByLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIikgJiYgKHRoaXMud3JpdGluZ01vZGVzID0gci5nZXQoXCJ0ZXh0LXdyaXRpbmctbW9kZVwiKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHd1W3RdO1xuICAgICAgfSkpLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJJZHMgPSB0aGlzLmxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaXNTdGF0ZURlcGVuZGVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSksIHRoaXMuc291cmNlSUQgPSB0LnNvdXJjZUlEO1xuICAgIH07XG5cbiAgICB2bC5wcm90b3R5cGUuY3JlYXRlQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50ZXh0ID0gbmV3IGRsKG5ldyBWYSh0aGlzLmxheWVycywgdGhpcy56b29tLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gL150ZXh0Ly50ZXN0KHQpO1xuICAgICAgfSkpLCB0aGlzLmljb24gPSBuZXcgZGwobmV3IFZhKHRoaXMubGF5ZXJzLCB0aGlzLnpvb20sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAvXmljb24vLnRlc3QodCk7XG4gICAgICB9KSksIHRoaXMuZ2x5cGhPZmZzZXRBcnJheSA9IG5ldyByYSgpLCB0aGlzLmxpbmVWZXJ0ZXhBcnJheSA9IG5ldyBuYSgpLCB0aGlzLnN5bWJvbEluc3RhbmNlcyA9IG5ldyBlYSgpO1xuICAgIH0sIHZsLnByb3RvdHlwZS5jYWxjdWxhdGVHbHlwaERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgaWYgKGVbdC5jaGFyQ29kZUF0KGEpXSA9ICEwLCAociB8fCBuKSAmJiBpKSB7XG4gICAgICAgICAgdmFyIG8gPSBYc1t0LmNoYXJBdChhKV07XG4gICAgICAgICAgbyAmJiAoZVtvLmNoYXJDb2RlQXQoMCldID0gITApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdmwucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5sYXllcnNbMF0sXG4gICAgICAgICAgaSA9IG4ubGF5b3V0LFxuICAgICAgICAgIGEgPSBpLmdldChcInRleHQtZm9udFwiKSxcbiAgICAgICAgICBvID0gaS5nZXQoXCJ0ZXh0LWZpZWxkXCIpLFxuICAgICAgICAgIHMgPSBpLmdldChcImljb24taW1hZ2VcIiksXG4gICAgICAgICAgdSA9IChcImNvbnN0YW50XCIgIT09IG8udmFsdWUua2luZCB8fCBvLnZhbHVlLnZhbHVlIGluc3RhbmNlb2YgbmUgJiYgIW8udmFsdWUudmFsdWUuaXNFbXB0eSgpIHx8IG8udmFsdWUudmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiAwKSAmJiAoXCJjb25zdGFudFwiICE9PSBhLnZhbHVlLmtpbmQgfHwgYS52YWx1ZS52YWx1ZS5sZW5ndGggPiAwKSxcbiAgICAgICAgICBsID0gXCJjb25zdGFudFwiICE9PSBzLnZhbHVlLmtpbmQgfHwgISFzLnZhbHVlLnZhbHVlIHx8IE9iamVjdC5rZXlzKHMucGFyYW1ldGVycykubGVuZ3RoID4gMCxcbiAgICAgICAgICBwID0gaS5nZXQoXCJzeW1ib2wtc29ydC1rZXlcIik7XG5cbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzID0gW10sIHUgfHwgbCkge1xuICAgICAgICBmb3IgKHZhciBjID0gZS5pY29uRGVwZW5kZW5jaWVzLCBoID0gZS5nbHlwaERlcGVuZGVuY2llcywgZiA9IGUuYXZhaWxhYmxlSW1hZ2VzLCB5ID0gbmV3IHNpKHRoaXMuem9vbSksIGQgPSAwLCBtID0gdDsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICB2YXIgdiA9IG1bZF0sXG4gICAgICAgICAgICAgIGcgPSB2LmZlYXR1cmUsXG4gICAgICAgICAgICAgIHggPSB2LmlkLFxuICAgICAgICAgICAgICBiID0gdi5pbmRleCxcbiAgICAgICAgICAgICAgdyA9IHYuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICAgICAgXyA9IG4uX2ZlYXR1cmVGaWx0ZXIubmVlZEdlb21ldHJ5LFxuICAgICAgICAgICAgICBBID0gVWEoZywgXyk7XG5cbiAgICAgICAgICBpZiAobi5fZmVhdHVyZUZpbHRlci5maWx0ZXIoeSwgQSwgcikpIHtcbiAgICAgICAgICAgIF8gfHwgKEEuZ2VvbWV0cnkgPSBSYShnKSk7XG4gICAgICAgICAgICB2YXIgUyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBuLmdldFZhbHVlQW5kUmVzb2x2ZVRva2VucyhcInRleHQtZmllbGRcIiwgQSwgciwgZiksXG4gICAgICAgICAgICAgICAgICBJID0gbmUuZmFjdG9yeShrKTtcbiAgICAgICAgICAgICAgeWwoSSkgJiYgKHRoaXMuaGFzUlRMVGV4dCA9ICEwKSwgKCF0aGlzLmhhc1JUTFRleHQgfHwgXCJ1bmF2YWlsYWJsZVwiID09PSBpaSgpIHx8IHRoaXMuaGFzUlRMVGV4dCAmJiBvaS5pc1BhcnNlZCgpKSAmJiAoUyA9IFpzKEksIG4sIEEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHogPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICAgIHZhciBDID0gbi5nZXRWYWx1ZUFuZFJlc29sdmVUb2tlbnMoXCJpY29uLWltYWdlXCIsIEEsIHIsIGYpO1xuICAgICAgICAgICAgICB6ID0gQyBpbnN0YW5jZW9mIGllID8gQyA6IGllLmZyb21TdHJpbmcoQyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChTIHx8IHopIHtcbiAgICAgICAgICAgICAgdmFyIEUgPSB0aGlzLnNvcnRGZWF0dXJlc0J5S2V5ID8gcC5ldmFsdWF0ZShBLCB7fSwgcikgOiB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHgsXG4gICAgICAgICAgICAgICAgdGV4dDogUyxcbiAgICAgICAgICAgICAgICBpY29uOiB6LFxuICAgICAgICAgICAgICAgIGluZGV4OiBiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IHcsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IEEuZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogZy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHBsW2cudHlwZV0sXG4gICAgICAgICAgICAgICAgc29ydEtleTogRVxuICAgICAgICAgICAgICB9KSwgeiAmJiAoY1t6Lm5hbWVdID0gITApLCBTKSB7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBhLmV2YWx1YXRlKEEsIHt9LCByKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgTSA9IFwibWFwXCIgPT09IGkuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgXCJwb2ludFwiICE9PSBpLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ID0gdGhpcy53cml0aW5nTW9kZXMgJiYgdGhpcy53cml0aW5nTW9kZXMuaW5kZXhPZih3dS52ZXJ0aWNhbCkgPj0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIEIgPSAwLCBUID0gUy5zZWN0aW9uczsgQiA8IFQubGVuZ3RoOyBCICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBWID0gVFtCXTtcbiAgICAgICAgICAgICAgICAgIGlmIChWLmltYWdlKSBjW1YuaW1hZ2UubmFtZV0gPSAhMDtlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEYgPSBabihTLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgRCA9IFYuZm9udFN0YWNrIHx8IFAsXG4gICAgICAgICAgICAgICAgICAgICAgICBMID0gaFtEXSA9IGhbRF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlR2x5cGhEZXBlbmRlbmNpZXMoVi50ZXh0LCBMLCBNLCB0aGlzLmFsbG93VmVydGljYWxQbGFjZW1lbnQsIEYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFwibGluZVwiID09PSBpLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIikgJiYgKHRoaXMuZmVhdHVyZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgICAgIHIgPSB7fSxcbiAgICAgICAgICAgICAgbiA9IFtdLFxuICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgICAgbi5wdXNoKHRbZV0pLCBpKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbyh0LCBlLCBpKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJbdF07XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIHJbdF0sIHJbZV0gPSBhLCBuW2FdLmdlb21ldHJ5WzBdLnBvcCgpLCBuW2FdLmdlb21ldHJ5WzBdID0gblthXS5nZW9tZXRyeVswXS5jb25jYXQoaVswXSksIGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcyh0LCByLCBpKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGVbcl07XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIGVbcl0sIGVbdF0gPSBhLCBuW2FdLmdlb21ldHJ5WzBdLnNoaWZ0KCksIG5bYV0uZ2VvbWV0cnlbMF0gPSBpWzBdLmNvbmNhdChuW2FdLmdlb21ldHJ5WzBdKSwgYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1KHQsIGUsIHIpIHtcbiAgICAgICAgICAgIHZhciBuID0gciA/IGVbMF1bZVswXS5sZW5ndGggLSAxXSA6IGVbMF1bMF07XG4gICAgICAgICAgICByZXR1cm4gdCArIFwiOlwiICsgbi54ICsgXCI6XCIgKyBuLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRbbF0sXG4gICAgICAgICAgICAgICAgYyA9IHAuZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgaCA9IHAudGV4dCA/IHAudGV4dC50b1N0cmluZygpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSB1KGgsIGMpLFxuICAgICAgICAgICAgICAgICAgeSA9IHUoaCwgYywgITApO1xuXG4gICAgICAgICAgICAgIGlmIChmIGluIHIgJiYgeSBpbiBlICYmIHJbZl0gIT09IGVbeV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHMoZiwgeSwgYyksXG4gICAgICAgICAgICAgICAgICAgIG0gPSBvKGYsIHksIG5bZF0uZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlW2ZdLCBkZWxldGUgclt5XSwgclt1KGgsIG5bbV0uZ2VvbWV0cnksICEwKV0gPSBtLCBuW2RdLmdlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGYgaW4gciA/IG8oZiwgeSwgYykgOiB5IGluIGUgPyBzKGYsIHksIGMpIDogKGEobCksIGVbZl0gPSBpIC0gMSwgclt5XSA9IGkgLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBhKGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZ2VvbWV0cnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0odGhpcy5mZWF0dXJlcykpLCB0aGlzLnNvcnRGZWF0dXJlc0J5S2V5ICYmIHRoaXMuZmVhdHVyZXMuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHZsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgKHRoaXMudGV4dC5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5sYXllcnMsIHIpLCB0aGlzLmljb24ucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwZGF0ZVBhaW50QXJyYXlzKHQsIGUsIHRoaXMubGF5ZXJzLCByKSk7XG4gICAgfSwgdmwucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoICYmICF0aGlzLmhhc1JUTFRleHQ7XG4gICAgfSwgdmwucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy50ZXh0LnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZCB8fCB0aGlzLmljb24ucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkO1xuICAgIH0sIHZsLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgIXRoaXMudXBsb2FkZWQgJiYgdGhpcy5oYXNEZWJ1Z0RhdGEoKSAmJiAodGhpcy50ZXh0Q29sbGlzaW9uQm94LnVwbG9hZCh0KSwgdGhpcy5pY29uQ29sbGlzaW9uQm94LnVwbG9hZCh0KSksIHRoaXMudGV4dC51cGxvYWQodCwgdGhpcy5zb3J0RmVhdHVyZXNCeVksICF0aGlzLnVwbG9hZGVkLCB0aGlzLnRleHQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkKSwgdGhpcy5pY29uLnVwbG9hZCh0LCB0aGlzLnNvcnRGZWF0dXJlc0J5WSwgIXRoaXMudXBsb2FkZWQsIHRoaXMuaWNvbi5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQpLCB0aGlzLnVwbG9hZGVkID0gITA7XG4gICAgfSwgdmwucHJvdG90eXBlLmRlc3Ryb3lEZWJ1Z0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHRDb2xsaXNpb25Cb3guZGVzdHJveSgpLCB0aGlzLmljb25Db2xsaXNpb25Cb3guZGVzdHJveSgpO1xuICAgIH0sIHZsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50ZXh0LmRlc3Ryb3koKSwgdGhpcy5pY29uLmRlc3Ryb3koKSwgdGhpcy5oYXNEZWJ1Z0RhdGEoKSAmJiB0aGlzLmRlc3Ryb3lEZWJ1Z0RhdGEoKTtcbiAgICB9LCB2bC5wcm90b3R5cGUuYWRkVG9MaW5lVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLmxpbmVWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh2b2lkIDAgIT09IHQuc2VnbWVudCkge1xuICAgICAgICBmb3IgKHZhciBuID0gdC5kaXN0KGVbdC5zZWdtZW50ICsgMV0pLCBpID0gdC5kaXN0KGVbdC5zZWdtZW50XSksIGEgPSB7fSwgbyA9IHQuc2VnbWVudCArIDE7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgYVtvXSA9IHtcbiAgICAgICAgICAgIHg6IGVbb10ueCxcbiAgICAgICAgICAgIHk6IGVbb10ueSxcbiAgICAgICAgICAgIHRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yOiBuXG4gICAgICAgICAgfSwgbyA8IGUubGVuZ3RoIC0gMSAmJiAobiArPSBlW28gKyAxXS5kaXN0KGVbb10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHMgPSB0LnNlZ21lbnQgfHwgMDsgcyA+PSAwOyBzLS0pIHtcbiAgICAgICAgICBhW3NdID0ge1xuICAgICAgICAgICAgeDogZVtzXS54LFxuICAgICAgICAgICAgeTogZVtzXS55LFxuICAgICAgICAgICAgdGlsZVVuaXREaXN0YW5jZUZyb21BbmNob3I6IGlcbiAgICAgICAgICB9LCBzID4gMCAmJiAoaSArPSBlW3MgLSAxXS5kaXN0KGVbc10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgZS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgIHZhciBsID0gYVt1XTtcbiAgICAgICAgICB0aGlzLmxpbmVWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayhsLngsIGwueSwgbC50aWxlVW5pdERpc3RhbmNlRnJvbUFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVN0YXJ0SW5kZXg6IHIsXG4gICAgICAgIGxpbmVMZW5ndGg6IHRoaXMubGluZVZlcnRleEFycmF5Lmxlbmd0aCAtIHJcbiAgICAgIH07XG4gICAgfSwgdmwucHJvdG90eXBlLmFkZFN5bWJvbHMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYykge1xuICAgICAgZm9yICh2YXIgaCA9IHQuaW5kZXhBcnJheSwgZiA9IHQubGF5b3V0VmVydGV4QXJyYXksIHkgPSB0LnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQgKiBlLmxlbmd0aCwgZiwgaCwgdGhpcy5jYW5PdmVybGFwID8gYS5zb3J0S2V5IDogdm9pZCAwKSwgZCA9IHRoaXMuZ2x5cGhPZmZzZXRBcnJheS5sZW5ndGgsIG0gPSB5LnZlcnRleExlbmd0aCwgdiA9IHRoaXMuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiBvID09PSB3dS52ZXJ0aWNhbCA/IE1hdGguUEkgLyAyIDogMCwgZyA9IGEudGV4dCAmJiBhLnRleHQuc2VjdGlvbnMsIHggPSAwOyB4IDwgZS5sZW5ndGg7IHgrKykge1xuICAgICAgICB2YXIgYiA9IGVbeF0sXG4gICAgICAgICAgICB3ID0gYi50bCxcbiAgICAgICAgICAgIF8gPSBiLnRyLFxuICAgICAgICAgICAgQSA9IGIuYmwsXG4gICAgICAgICAgICBTID0gYi5icixcbiAgICAgICAgICAgIGsgPSBiLnRleCxcbiAgICAgICAgICAgIEkgPSBiLnBpeGVsT2Zmc2V0VEwsXG4gICAgICAgICAgICB6ID0gYi5waXhlbE9mZnNldEJSLFxuICAgICAgICAgICAgQyA9IGIubWluRm9udFNjYWxlWCxcbiAgICAgICAgICAgIEUgPSBiLm1pbkZvbnRTY2FsZVksXG4gICAgICAgICAgICBQID0gYi5nbHlwaE9mZnNldCxcbiAgICAgICAgICAgIE0gPSBiLmlzU0RGLFxuICAgICAgICAgICAgQiA9IGIuc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgVCA9IHkudmVydGV4TGVuZ3RoLFxuICAgICAgICAgICAgViA9IFBbMV07XG4gICAgICAgIGhsKGYsIHMueCwgcy55LCB3LngsIFYgKyB3LnksIGsueCwgay55LCByLCBNLCBJLngsIEkueSwgQywgRSksIGhsKGYsIHMueCwgcy55LCBfLngsIFYgKyBfLnksIGsueCArIGsudywgay55LCByLCBNLCB6LngsIEkueSwgQywgRSksIGhsKGYsIHMueCwgcy55LCBBLngsIFYgKyBBLnksIGsueCwgay55ICsgay5oLCByLCBNLCBJLngsIHoueSwgQywgRSksIGhsKGYsIHMueCwgcy55LCBTLngsIFYgKyBTLnksIGsueCArIGsudywgay55ICsgay5oLCByLCBNLCB6LngsIHoueSwgQywgRSksIGZsKHQuZHluYW1pY0xheW91dFZlcnRleEFycmF5LCBzLCB2KSwgaC5lbXBsYWNlQmFjayhULCBUICsgMSwgVCArIDIpLCBoLmVtcGxhY2VCYWNrKFQgKyAxLCBUICsgMiwgVCArIDMpLCB5LnZlcnRleExlbmd0aCArPSA0LCB5LnByaW1pdGl2ZUxlbmd0aCArPSAyLCB0aGlzLmdseXBoT2Zmc2V0QXJyYXkuZW1wbGFjZUJhY2soUFswXSksIHggIT09IGUubGVuZ3RoIC0gMSAmJiBCID09PSBlW3ggKyAxXS5zZWN0aW9uSW5kZXggfHwgdC5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyhmLmxlbmd0aCwgYSwgYS5pbmRleCwge30sIGMsIGcgJiYgZ1tCXSk7XG4gICAgICB9XG5cbiAgICAgIHQucGxhY2VkU3ltYm9sQXJyYXkuZW1wbGFjZUJhY2socy54LCBzLnksIGQsIHRoaXMuZ2x5cGhPZmZzZXRBcnJheS5sZW5ndGggLSBkLCBtLCB1LCBsLCBzLnNlZ21lbnQsIHIgPyByWzBdIDogMCwgciA/IHJbMV0gOiAwLCBuWzBdLCBuWzFdLCBvLCAwLCAhMSwgMCwgcCk7XG4gICAgfSwgdmwucHJvdG90eXBlLl9hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRleCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gZS5lbXBsYWNlQmFjaygwLCAwKSwgdC5lbXBsYWNlQmFjayhyLngsIHIueSwgbiwgaSwgTWF0aC5yb3VuZChhLngpLCBNYXRoLnJvdW5kKGEueSkpO1xuICAgIH0sIHZsLnByb3RvdHlwZS5hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRpY2VzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGEsIG8sIHMpIHtcbiAgICAgIHZhciB1ID0gYS5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCg0LCBhLmxheW91dFZlcnRleEFycmF5LCBhLmluZGV4QXJyYXkpLFxuICAgICAgICAgIGwgPSB1LnZlcnRleExlbmd0aCxcbiAgICAgICAgICBwID0gYS5sYXlvdXRWZXJ0ZXhBcnJheSxcbiAgICAgICAgICBjID0gYS5jb2xsaXNpb25WZXJ0ZXhBcnJheSxcbiAgICAgICAgICBoID0gcy5hbmNob3JYLFxuICAgICAgICAgIGYgPSBzLmFuY2hvclk7XG4gICAgICB0aGlzLl9hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRleChwLCBjLCBvLCBoLCBmLCBuZXcgaSh0LCBlKSksIHRoaXMuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4KHAsIGMsIG8sIGgsIGYsIG5ldyBpKHIsIGUpKSwgdGhpcy5fYWRkQ29sbGlzaW9uRGVidWdWZXJ0ZXgocCwgYywgbywgaCwgZiwgbmV3IGkociwgbikpLCB0aGlzLl9hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRleChwLCBjLCBvLCBoLCBmLCBuZXcgaSh0LCBuKSksIHUudmVydGV4TGVuZ3RoICs9IDQ7XG4gICAgICB2YXIgeSA9IGEuaW5kZXhBcnJheTtcbiAgICAgIHkuZW1wbGFjZUJhY2sobCwgbCArIDEpLCB5LmVtcGxhY2VCYWNrKGwgKyAxLCBsICsgMiksIHkuZW1wbGFjZUJhY2sobCArIDIsIGwgKyAzKSwgeS5lbXBsYWNlQmFjayhsICsgMywgbCksIHUucHJpbWl0aXZlTGVuZ3RoICs9IDQ7XG4gICAgfSwgdmwucHJvdG90eXBlLmFkZERlYnVnQ29sbGlzaW9uQm94ZXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IHQ7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNvbGxpc2lvbkJveEFycmF5LmdldChpKTtcbiAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRpY2VzKGEueDEsIGEueTEsIGEueDIsIGEueTIsIG4gPyB0aGlzLnRleHRDb2xsaXNpb25Cb3ggOiB0aGlzLmljb25Db2xsaXNpb25Cb3gsIGEuYW5jaG9yUG9pbnQsIHIpO1xuICAgICAgfVxuICAgIH0sIHZsLnByb3RvdHlwZS5nZW5lcmF0ZUNvbGxpc2lvbkRlYnVnQnVmZmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzRGVidWdEYXRhKCkgJiYgdGhpcy5kZXN0cm95RGVidWdEYXRhKCksIHRoaXMudGV4dENvbGxpc2lvbkJveCA9IG5ldyBtbChPaSwgS3MubWVtYmVycywgWGkpLCB0aGlzLmljb25Db2xsaXNpb25Cb3ggPSBuZXcgbWwoT2ksIEtzLm1lbWJlcnMsIFhpKTtcblxuICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmdldCh0KTtcbiAgICAgICAgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUudGV4dEJveFN0YXJ0SW5kZXgsIGUudGV4dEJveEVuZEluZGV4LCBlLCAhMCksIHRoaXMuYWRkRGVidWdDb2xsaXNpb25Cb3hlcyhlLnZlcnRpY2FsVGV4dEJveFN0YXJ0SW5kZXgsIGUudmVydGljYWxUZXh0Qm94RW5kSW5kZXgsIGUsICEwKSwgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUuaWNvbkJveFN0YXJ0SW5kZXgsIGUuaWNvbkJveEVuZEluZGV4LCBlLCAhMSksIHRoaXMuYWRkRGVidWdDb2xsaXNpb25Cb3hlcyhlLnZlcnRpY2FsSWNvbkJveFN0YXJ0SW5kZXgsIGUudmVydGljYWxJY29uQm94RW5kSW5kZXgsIGUsICExKTtcbiAgICAgIH1cbiAgICB9LCB2bC5wcm90b3R5cGUuX2Rlc2VyaWFsaXplQ29sbGlzaW9uQm94ZXNGb3JTeW1ib2wgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSkge1xuICAgICAgZm9yICh2YXIgbCA9IHt9LCBwID0gZTsgcCA8IHI7IHArKykge1xuICAgICAgICB2YXIgYyA9IHQuZ2V0KHApO1xuICAgICAgICBsLnRleHRCb3ggPSB7XG4gICAgICAgICAgeDE6IGMueDEsXG4gICAgICAgICAgeTE6IGMueTEsXG4gICAgICAgICAgeDI6IGMueDIsXG4gICAgICAgICAgeTI6IGMueTIsXG4gICAgICAgICAgYW5jaG9yUG9pbnRYOiBjLmFuY2hvclBvaW50WCxcbiAgICAgICAgICBhbmNob3JQb2ludFk6IGMuYW5jaG9yUG9pbnRZXG4gICAgICAgIH0sIGwudGV4dEZlYXR1cmVJbmRleCA9IGMuZmVhdHVyZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaCA9IG47IGggPCBpOyBoKyspIHtcbiAgICAgICAgdmFyIGYgPSB0LmdldChoKTtcbiAgICAgICAgbC52ZXJ0aWNhbFRleHRCb3ggPSB7XG4gICAgICAgICAgeDE6IGYueDEsXG4gICAgICAgICAgeTE6IGYueTEsXG4gICAgICAgICAgeDI6IGYueDIsXG4gICAgICAgICAgeTI6IGYueTIsXG4gICAgICAgICAgYW5jaG9yUG9pbnRYOiBmLmFuY2hvclBvaW50WCxcbiAgICAgICAgICBhbmNob3JQb2ludFk6IGYuYW5jaG9yUG9pbnRZXG4gICAgICAgIH0sIGwudmVydGljYWxUZXh0RmVhdHVyZUluZGV4ID0gZi5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB5ID0gYTsgeSA8IG87IHkrKykge1xuICAgICAgICB2YXIgZCA9IHQuZ2V0KHkpO1xuICAgICAgICBsLmljb25Cb3ggPSB7XG4gICAgICAgICAgeDE6IGQueDEsXG4gICAgICAgICAgeTE6IGQueTEsXG4gICAgICAgICAgeDI6IGQueDIsXG4gICAgICAgICAgeTI6IGQueTIsXG4gICAgICAgICAgYW5jaG9yUG9pbnRYOiBkLmFuY2hvclBvaW50WCxcbiAgICAgICAgICBhbmNob3JQb2ludFk6IGQuYW5jaG9yUG9pbnRZXG4gICAgICAgIH0sIGwuaWNvbkZlYXR1cmVJbmRleCA9IGQuZmVhdHVyZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbSA9IHM7IG0gPCB1OyBtKyspIHtcbiAgICAgICAgdmFyIHYgPSB0LmdldChtKTtcbiAgICAgICAgbC52ZXJ0aWNhbEljb25Cb3ggPSB7XG4gICAgICAgICAgeDE6IHYueDEsXG4gICAgICAgICAgeTE6IHYueTEsXG4gICAgICAgICAgeDI6IHYueDIsXG4gICAgICAgICAgeTI6IHYueTIsXG4gICAgICAgICAgYW5jaG9yUG9pbnRYOiB2LmFuY2hvclBvaW50WCxcbiAgICAgICAgICBhbmNob3JQb2ludFk6IHYuYW5jaG9yUG9pbnRZXG4gICAgICAgIH0sIGwudmVydGljYWxJY29uRmVhdHVyZUluZGV4ID0gdi5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbDtcbiAgICB9LCB2bC5wcm90b3R5cGUuZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNvbGxpc2lvbkFycmF5cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KGUpO1xuICAgICAgICB0aGlzLmNvbGxpc2lvbkFycmF5cy5wdXNoKHRoaXMuX2Rlc2VyaWFsaXplQ29sbGlzaW9uQm94ZXNGb3JTeW1ib2wodCwgci50ZXh0Qm94U3RhcnRJbmRleCwgci50ZXh0Qm94RW5kSW5kZXgsIHIudmVydGljYWxUZXh0Qm94U3RhcnRJbmRleCwgci52ZXJ0aWNhbFRleHRCb3hFbmRJbmRleCwgci5pY29uQm94U3RhcnRJbmRleCwgci5pY29uQm94RW5kSW5kZXgsIHIudmVydGljYWxJY29uQm94U3RhcnRJbmRleCwgci52ZXJ0aWNhbEljb25Cb3hFbmRJbmRleCkpO1xuICAgICAgfVxuICAgIH0sIHZsLnByb3RvdHlwZS5oYXNUZXh0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMDtcbiAgICB9LCB2bC5wcm90b3R5cGUuaGFzSWNvbkRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uLnNlZ21lbnRzLmdldCgpLmxlbmd0aCA+IDA7XG4gICAgfSwgdmwucHJvdG90eXBlLmhhc0RlYnVnRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRDb2xsaXNpb25Cb3ggJiYgdGhpcy5pY29uQ29sbGlzaW9uQm94O1xuICAgIH0sIHZsLnByb3RvdHlwZS5oYXNUZXh0Q29sbGlzaW9uQm94RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0RlYnVnRGF0YSgpICYmIHRoaXMudGV4dENvbGxpc2lvbkJveC5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAwO1xuICAgIH0sIHZsLnByb3RvdHlwZS5oYXNJY29uQ29sbGlzaW9uQm94RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0RlYnVnRGF0YSgpICYmIHRoaXMuaWNvbkNvbGxpc2lvbkJveC5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAwO1xuICAgIH0sIHZsLnByb3RvdHlwZS5hZGRJbmRpY2VzRm9yUGxhY2VkU3ltYm9sID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSB0LnBsYWNlZFN5bWJvbEFycmF5LmdldChlKSwgbiA9IHIudmVydGV4U3RhcnRJbmRleCArIDQgKiByLm51bUdseXBocywgaSA9IHIudmVydGV4U3RhcnRJbmRleDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgICB0LmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaSwgaSArIDEsIGkgKyAyKSwgdC5pbmRleEFycmF5LmVtcGxhY2VCYWNrKGkgKyAxLCBpICsgMiwgaSArIDMpO1xuICAgICAgfVxuICAgIH0sIHZsLnByb3RvdHlwZS5nZXRTb3J0ZWRTeW1ib2xJbmRleGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLnNvcnRlZEFuZ2xlID09PSB0ICYmIHZvaWQgMCAhPT0gdGhpcy5zeW1ib2xJbnN0YW5jZUluZGV4ZXMpIHJldHVybiB0aGlzLnN5bWJvbEluc3RhbmNlSW5kZXhlcztcblxuICAgICAgZm9yICh2YXIgZSA9IE1hdGguc2luKHQpLCByID0gTWF0aC5jb3ModCksIG4gPSBbXSwgaSA9IFtdLCBhID0gW10sIG8gPSAwOyBvIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyArK28pIHtcbiAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmdldChvKTtcbiAgICAgICAgbi5wdXNoKDAgfCBNYXRoLnJvdW5kKGUgKiBzLmFuY2hvclggKyByICogcy5hbmNob3JZKSksIGkucHVzaChzLmZlYXR1cmVJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIG5bdF0gLSBuW2VdIHx8IGlbZV0gLSBpW3RdO1xuICAgICAgfSksIGE7XG4gICAgfSwgdmwucHJvdG90eXBlLmFkZFRvU29ydEtleVJhbmdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXMuc29ydEtleVJhbmdlc1t0aGlzLnNvcnRLZXlSYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICByICYmIHIuc29ydEtleSA9PT0gZSA/IHIuc3ltYm9sSW5zdGFuY2VFbmQgPSB0ICsgMSA6IHRoaXMuc29ydEtleVJhbmdlcy5wdXNoKHtcbiAgICAgICAgc29ydEtleTogZSxcbiAgICAgICAgc3ltYm9sSW5zdGFuY2VTdGFydDogdCxcbiAgICAgICAgc3ltYm9sSW5zdGFuY2VFbmQ6IHQgKyAxXG4gICAgICB9KTtcbiAgICB9LCB2bC5wcm90b3R5cGUuc29ydEZlYXR1cmVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc29ydEZlYXR1cmVzQnlZICYmIHRoaXMuc29ydGVkQW5nbGUgIT09IHQgJiYgISh0aGlzLnRleHQuc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMSB8fCB0aGlzLmljb24uc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgdGhpcy5zeW1ib2xJbnN0YW5jZUluZGV4ZXMgPSB0aGlzLmdldFNvcnRlZFN5bWJvbEluZGV4ZXModCksIHRoaXMuc29ydGVkQW5nbGUgPSB0LCB0aGlzLnRleHQuaW5kZXhBcnJheS5jbGVhcigpLCB0aGlzLmljb24uaW5kZXhBcnJheS5jbGVhcigpLCB0aGlzLmZlYXR1cmVTb3J0T3JkZXIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IHRoaXMuc3ltYm9sSW5zdGFuY2VJbmRleGVzOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KG5bcl0pO1xuICAgICAgICAgIHRoaXMuZmVhdHVyZVNvcnRPcmRlci5wdXNoKGkuZmVhdHVyZUluZGV4KSwgW2kucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGkuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBpLmxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKHQsIHIsIG4pIHtcbiAgICAgICAgICAgIHQgPj0gMCAmJiBuLmluZGV4T2YodCkgPT09IHIgJiYgZS5hZGRJbmRpY2VzRm9yUGxhY2VkU3ltYm9sKGUudGV4dCwgdCk7XG4gICAgICAgICAgfSksIGkudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy50ZXh0LCBpLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4KSwgaS5wbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy5pY29uLCBpLnBsYWNlZEljb25TeW1ib2xJbmRleCksIGkudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy5pY29uLCBpLnZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGV4dC5pbmRleEJ1ZmZlciAmJiB0aGlzLnRleHQuaW5kZXhCdWZmZXIudXBkYXRlRGF0YSh0aGlzLnRleHQuaW5kZXhBcnJheSksIHRoaXMuaWNvbi5pbmRleEJ1ZmZlciAmJiB0aGlzLmljb24uaW5kZXhCdWZmZXIudXBkYXRlRGF0YSh0aGlzLmljb24uaW5kZXhBcnJheSk7XG4gICAgICB9XG4gICAgfSwgT24oXCJTeW1ib2xCdWNrZXRcIiwgdmwsIHtcbiAgICAgIG9taXQ6IFtcImxheWVyc1wiLCBcImNvbGxpc2lvbkJveEFycmF5XCIsIFwiZmVhdHVyZXNcIiwgXCJjb21wYXJlVGV4dFwiXVxuICAgIH0pLCB2bC5NQVhfR0xZUEhTID0gNjU1MzUsIHZsLmFkZER5bmFtaWNBdHRyaWJ1dGVzID0gZmw7XG5cbiAgICB2YXIgZ2wgPSBuZXcgd2koe1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1wic3ltYm9sLXBsYWNlbWVudFwiXSksXG4gICAgICBcInN5bWJvbC1zcGFjaW5nXCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1wic3ltYm9sLXNwYWNpbmdcIl0pLFxuICAgICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJzeW1ib2wtYXZvaWQtZWRnZXNcIl0pLFxuICAgICAgXCJzeW1ib2wtc29ydC1rZXlcIjogbmV3IHZpKEV0LmxheW91dF9zeW1ib2xbXCJzeW1ib2wtc29ydC1rZXlcIl0pLFxuICAgICAgXCJzeW1ib2wtei1vcmRlclwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC16LW9yZGVyXCJdKSxcbiAgICAgIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1hbGxvdy1vdmVybGFwXCJdKSxcbiAgICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCJdKSxcbiAgICAgIFwiaWNvbi1vcHRpb25hbFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcImljb24tb3B0aW9uYWxcIl0pLFxuICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcImljb24tcm90YXRpb24tYWxpZ25tZW50XCJdKSxcbiAgICAgIFwiaWNvbi1zaXplXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1zaXplXCJdKSxcbiAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcImljb24tdGV4dC1maXRcIl0pLFxuICAgICAgXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIl0pLFxuICAgICAgXCJpY29uLWltYWdlXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1pbWFnZVwiXSksXG4gICAgICBcImljb24tcm90YXRlXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1yb3RhdGVcIl0pLFxuICAgICAgXCJpY29uLXBhZGRpbmdcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJpY29uLXBhZGRpbmdcIl0pLFxuICAgICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcImljb24ta2VlcC11cHJpZ2h0XCJdKSxcbiAgICAgIFwiaWNvbi1vZmZzZXRcIjogbmV3IHZpKEV0LmxheW91dF9zeW1ib2xbXCJpY29uLW9mZnNldFwiXSksXG4gICAgICBcImljb24tYW5jaG9yXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1hbmNob3JcIl0pLFxuICAgICAgXCJpY29uLXBpdGNoLWFsaWdubWVudFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcImljb24tcGl0Y2gtYWxpZ25tZW50XCJdKSxcbiAgICAgIFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiXSksXG4gICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIl0pLFxuICAgICAgXCJ0ZXh0LWZpZWxkXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1maWVsZFwiXSksXG4gICAgICBcInRleHQtZm9udFwiOiBuZXcgdmkoRXQubGF5b3V0X3N5bWJvbFtcInRleHQtZm9udFwiXSksXG4gICAgICBcInRleHQtc2l6ZVwiOiBuZXcgdmkoRXQubGF5b3V0X3N5bWJvbFtcInRleHQtc2l6ZVwiXSksXG4gICAgICBcInRleHQtbWF4LXdpZHRoXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1tYXgtd2lkdGhcIl0pLFxuICAgICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1saW5lLWhlaWdodFwiXSksXG4gICAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjogbmV3IHZpKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCJdKSxcbiAgICAgIFwidGV4dC1qdXN0aWZ5XCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1qdXN0aWZ5XCJdKSxcbiAgICAgIFwidGV4dC1yYWRpYWwtb2Zmc2V0XCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1yYWRpYWwtb2Zmc2V0XCJdKSxcbiAgICAgIFwidGV4dC12YXJpYWJsZS1hbmNob3JcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiXSksXG4gICAgICBcInRleHQtYW5jaG9yXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1hbmNob3JcIl0pLFxuICAgICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcInRleHQtbWF4LWFuZ2xlXCJdKSxcbiAgICAgIFwidGV4dC13cml0aW5nLW1vZGVcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXdyaXRpbmctbW9kZVwiXSksXG4gICAgICBcInRleHQtcm90YXRlXCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1yb3RhdGVcIl0pLFxuICAgICAgXCJ0ZXh0LXBhZGRpbmdcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXBhZGRpbmdcIl0pLFxuICAgICAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiBuZXcgbWkoRXQubGF5b3V0X3N5bWJvbFtcInRleHQta2VlcC11cHJpZ2h0XCJdKSxcbiAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjogbmV3IHZpKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXRyYW5zZm9ybVwiXSksXG4gICAgICBcInRleHQtb2Zmc2V0XCI6IG5ldyB2aShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1vZmZzZXRcIl0pLFxuICAgICAgXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIl0pLFxuICAgICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjogbmV3IG1pKEV0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIl0pLFxuICAgICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IG5ldyBtaShFdC5sYXlvdXRfc3ltYm9sW1widGV4dC1vcHRpb25hbFwiXSlcbiAgICB9KSxcbiAgICAgICAgeGwgPSB7XG4gICAgICBwYWludDogbmV3IHdpKHtcbiAgICAgICAgXCJpY29uLW9wYWNpdHlcIjogbmV3IHZpKEV0LnBhaW50X3N5bWJvbFtcImljb24tb3BhY2l0eVwiXSksXG4gICAgICAgIFwiaWNvbi1jb2xvclwiOiBuZXcgdmkoRXQucGFpbnRfc3ltYm9sW1wiaWNvbi1jb2xvclwiXSksXG4gICAgICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IG5ldyB2aShFdC5wYWludF9zeW1ib2xbXCJpY29uLWhhbG8tY29sb3JcIl0pLFxuICAgICAgICBcImljb24taGFsby13aWR0aFwiOiBuZXcgdmkoRXQucGFpbnRfc3ltYm9sW1wiaWNvbi1oYWxvLXdpZHRoXCJdKSxcbiAgICAgICAgXCJpY29uLWhhbG8tYmx1clwiOiBuZXcgdmkoRXQucGFpbnRfc3ltYm9sW1wiaWNvbi1oYWxvLWJsdXJcIl0pLFxuICAgICAgICBcImljb24tdHJhbnNsYXRlXCI6IG5ldyBtaShFdC5wYWludF9zeW1ib2xbXCJpY29uLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IG5ldyBtaShFdC5wYWludF9zeW1ib2xbXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIl0pLFxuICAgICAgICBcInRleHQtb3BhY2l0eVwiOiBuZXcgdmkoRXQucGFpbnRfc3ltYm9sW1widGV4dC1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJ0ZXh0LWNvbG9yXCI6IG5ldyB2aShFdC5wYWludF9zeW1ib2xbXCJ0ZXh0LWNvbG9yXCJdLCB7XG4gICAgICAgICAgcnVudGltZVR5cGU6IGp0LFxuICAgICAgICAgIGdldE92ZXJyaWRlOiBmdW5jdGlvbiBnZXRPdmVycmlkZSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC50ZXh0Q29sb3I7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNPdmVycmlkZTogZnVuY3Rpb24gaGFzT3ZlcnJpZGUodCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdC50ZXh0Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjogbmV3IHZpKEV0LnBhaW50X3N5bWJvbFtcInRleHQtaGFsby1jb2xvclwiXSksXG4gICAgICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IG5ldyB2aShFdC5wYWludF9zeW1ib2xbXCJ0ZXh0LWhhbG8td2lkdGhcIl0pLFxuICAgICAgICBcInRleHQtaGFsby1ibHVyXCI6IG5ldyB2aShFdC5wYWludF9zeW1ib2xbXCJ0ZXh0LWhhbG8tYmx1clwiXSksXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIjogbmV3IG1pKEV0LnBhaW50X3N5bWJvbFtcInRleHQtdHJhbnNsYXRlXCJdKSxcbiAgICAgICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IG1pKEV0LnBhaW50X3N5bWJvbFtcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiXSlcbiAgICAgIH0pLFxuICAgICAgbGF5b3V0OiBnbFxuICAgIH0sXG4gICAgICAgIGJsID0gZnVuY3Rpb24gYmwodCkge1xuICAgICAgdGhpcy50eXBlID0gdC5wcm9wZXJ0eS5vdmVycmlkZXMgPyB0LnByb3BlcnR5Lm92ZXJyaWRlcy5ydW50aW1lVHlwZSA6IEx0LCB0aGlzLmRlZmF1bHRWYWx1ZSA9IHQ7XG4gICAgfTtcblxuICAgIGJsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodC5mb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5kZWZhdWx0VmFsdWUucHJvcGVydHkub3ZlcnJpZGVzO1xuICAgICAgICBpZiAoZSAmJiBlLmhhc092ZXJyaWRlKHQuZm9ybWF0dGVkU2VjdGlvbikpIHJldHVybiBlLmdldE92ZXJyaWRlKHQuZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LmZlYXR1cmUgJiYgdC5mZWF0dXJlU3RhdGUgPyB0aGlzLmRlZmF1bHRWYWx1ZS5ldmFsdWF0ZSh0LmZlYXR1cmUsIHQuZmVhdHVyZVN0YXRlKSA6IHRoaXMuZGVmYXVsdFZhbHVlLnByb3BlcnR5LnNwZWNpZmljYXRpb24uZGVmYXVsdDtcbiAgICB9LCBibC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlLmlzQ29uc3RhbnQoKSB8fCB0KHRoaXMuZGVmYXVsdFZhbHVlLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG4gICAgfSwgYmwucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgYmwucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIE9uKFwiRm9ybWF0U2VjdGlvbk92ZXJyaWRlXCIsIGJsLCB7XG4gICAgICBvbWl0OiBbXCJkZWZhdWx0VmFsdWVcIl1cbiAgICB9KTtcblxuICAgIHZhciB3bCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHhsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICBpZiAodC5wcm90b3R5cGUucmVjYWxjdWxhdGUuY2FsbCh0aGlzLCBlLCByKSwgXCJhdXRvXCIgPT09IHRoaXMubGF5b3V0LmdldChcImljb24tcm90YXRpb24tYWxpZ25tZW50XCIpICYmICh0aGlzLmxheW91dC5fdmFsdWVzW1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIl0gPSBcInBvaW50XCIgIT09IHRoaXMubGF5b3V0LmdldChcInN5bWJvbC1wbGFjZW1lbnRcIikgPyBcIm1hcFwiIDogXCJ2aWV3cG9ydFwiKSwgXCJhdXRvXCIgPT09IHRoaXMubGF5b3V0LmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpICYmICh0aGlzLmxheW91dC5fdmFsdWVzW1widGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIl0gPSBcInBvaW50XCIgIT09IHRoaXMubGF5b3V0LmdldChcInN5bWJvbC1wbGFjZW1lbnRcIikgPyBcIm1hcFwiIDogXCJ2aWV3cG9ydFwiKSwgXCJhdXRvXCIgPT09IHRoaXMubGF5b3V0LmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpICYmICh0aGlzLmxheW91dC5fdmFsdWVzW1widGV4dC1waXRjaC1hbGlnbm1lbnRcIl0gPSB0aGlzLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSksIFwiYXV0b1wiID09PSB0aGlzLmxheW91dC5nZXQoXCJpY29uLXBpdGNoLWFsaWdubWVudFwiKSAmJiAodGhpcy5sYXlvdXQuX3ZhbHVlc1tcImljb24tcGl0Y2gtYWxpZ25tZW50XCJdID0gdGhpcy5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIikpLCBcInBvaW50XCIgPT09IHRoaXMubGF5b3V0LmdldChcInN5bWJvbC1wbGFjZW1lbnRcIikpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubGF5b3V0LmdldChcInRleHQtd3JpdGluZy1tb2RlXCIpO1xuXG4gICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBbXSwgYSA9IDAsIG8gPSBuOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgcyA9IG9bYV07XG4gICAgICAgICAgICAgIGkuaW5kZXhPZihzKSA8IDAgJiYgaS5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxheW91dC5fdmFsdWVzW1widGV4dC13cml0aW5nLW1vZGVcIl0gPSBpO1xuICAgICAgICAgIH0gZWxzZSB0aGlzLmxheW91dC5fdmFsdWVzW1widGV4dC13cml0aW5nLW1vZGVcIl0gPSBbXCJob3Jpem9udGFsXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0UGFpbnRPdmVycmlkZXMoKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmdldFZhbHVlQW5kUmVzb2x2ZVRva2VucyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sYXlvdXQuZ2V0KHQpLmV2YWx1YXRlKGUsIHt9LCByLCBuKSxcbiAgICAgICAgICAgIGEgPSB0aGlzLl91bmV2YWx1YXRlZExheW91dC5fdmFsdWVzW3RdO1xuICAgICAgICByZXR1cm4gYS5pc0RhdGFEcml2ZW4oKSB8fCBHcihhLnZhbHVlKSB8fCAhaSA/IGkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoL3soW157fV0rKX0vZywgZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByIGluIHQgPyBTdHJpbmcodFtyXSkgOiBcIlwiO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KGUucHJvcGVydGllcywgaSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IHZsKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3NldFBhaW50T3ZlcnJpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0ID0gMCwgciA9IHhsLnBhaW50Lm92ZXJyaWRhYmxlUHJvcGVydGllczsgdCA8IHIubGVuZ3RoOyB0ICs9IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IHJbdF07XG5cbiAgICAgICAgICBpZiAoZS5oYXNQYWludE92ZXJyaWRlKHRoaXMubGF5b3V0LCBuKSkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMucGFpbnQuZ2V0KG4pLFxuICAgICAgICAgICAgICAgIG8gPSBuZXcgYmwoYSksXG4gICAgICAgICAgICAgICAgcyA9IG5ldyBLcihvLCBhLnByb3BlcnR5LnNwZWNpZmljYXRpb24pO1xuICAgICAgICAgICAgaSA9IFwiY29uc3RhbnRcIiA9PT0gYS52YWx1ZS5raW5kIHx8IFwic291cmNlXCIgPT09IGEudmFsdWUua2luZCA/IG5ldyBYcihcInNvdXJjZVwiLCBzKSA6IG5ldyBKcihcImNvbXBvc2l0ZVwiLCBzLCBhLnZhbHVlLnpvb21TdG9wcywgYS52YWx1ZS5faW50ZXJwb2xhdGlvblR5cGUpLCB0aGlzLnBhaW50Ll92YWx1ZXNbbl0gPSBuZXcgeWkoYS5wcm9wZXJ0eSwgaSwgYS5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGUucHJvdG90eXBlLl9oYW5kbGVPdmVycmlkYWJsZVBhaW50UHJvcGVydHlVcGRhdGUgPSBmdW5jdGlvbiAodCwgciwgbikge1xuICAgICAgICByZXR1cm4gISghdGhpcy5sYXlvdXQgfHwgci5pc0RhdGFEcml2ZW4oKSB8fCBuLmlzRGF0YURyaXZlbigpKSAmJiBlLmhhc1BhaW50T3ZlcnJpZGUodGhpcy5sYXlvdXQsIHQpO1xuICAgICAgfSwgZS5oYXNQYWludE92ZXJyaWRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0LmdldChcInRleHQtZmllbGRcIiksXG4gICAgICAgICAgICBuID0geGwucGFpbnQucHJvcGVydGllc1tlXSxcbiAgICAgICAgICAgIGkgPSAhMSxcbiAgICAgICAgICAgIGEgPSBmdW5jdGlvbiBhKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgICBpZiAobi5vdmVycmlkZXMgJiYgbi5vdmVycmlkZXMuaGFzT3ZlcnJpZGUocltlXSkpIHJldHVybiB2b2lkIChpID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoXCJjb25zdGFudFwiID09PSByLnZhbHVlLmtpbmQgJiYgci52YWx1ZS52YWx1ZSBpbnN0YW5jZW9mIG5lKSBhKHIudmFsdWUudmFsdWUuc2VjdGlvbnMpO2Vsc2UgaWYgKFwic291cmNlXCIgPT09IHIudmFsdWUua2luZCkge1xuICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24gbyh0KSB7XG4gICAgICAgICAgICBpIHx8ICh0IGluc3RhbmNlb2YgbGUgJiYgc2UodC52YWx1ZSkgPT09IEd0ID8gYSh0LnZhbHVlLnNlY3Rpb25zKSA6IHQgaW5zdGFuY2VvZiBmZSA/IGEodC5zZWN0aW9ucykgOiB0LmVhY2hDaGlsZChvKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcyA9IHIudmFsdWU7XG5cbiAgICAgICAgICBzLl9zdHlsZUV4cHJlc3Npb24gJiYgbyhzLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9LCBlO1xuICAgIH0oX2kpLFxuICAgICAgICBfbCA9IHtcbiAgICAgIHBhaW50OiBuZXcgd2koe1xuICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogbmV3IG1pKEV0LnBhaW50X2JhY2tncm91bmRbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdKSxcbiAgICAgICAgXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjogbmV3IHhpKEV0LnBhaW50X2JhY2tncm91bmRbXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIl0pLFxuICAgICAgICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiBuZXcgbWkoRXQucGFpbnRfYmFja2dyb3VuZFtcImJhY2tncm91bmQtb3BhY2l0eVwiXSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAgICAgQWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBfbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgfShfaSksXG4gICAgICAgIFNsID0ge1xuICAgICAgcGFpbnQ6IG5ldyB3aSh7XG4gICAgICAgIFwicmFzdGVyLW9wYWNpdHlcIjogbmV3IG1pKEV0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiBuZXcgbWkoRXQucGFpbnRfcmFzdGVyW1wicmFzdGVyLWh1ZS1yb3RhdGVcIl0pLFxuICAgICAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiBuZXcgbWkoRXQucGFpbnRfcmFzdGVyW1wicmFzdGVyLWJyaWdodG5lc3MtbWluXCJdKSxcbiAgICAgICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjogbmV3IG1pKEV0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiXSksXG4gICAgICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjogbmV3IG1pKEV0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1zYXR1cmF0aW9uXCJdKSxcbiAgICAgICAgXCJyYXN0ZXItY29udHJhc3RcIjogbmV3IG1pKEV0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1jb250cmFzdFwiXSksXG4gICAgICAgIFwicmFzdGVyLXJlc2FtcGxpbmdcIjogbmV3IG1pKEV0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1yZXNhbXBsaW5nXCJdKSxcbiAgICAgICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiBuZXcgbWkoRXQucGFpbnRfcmFzdGVyW1wicmFzdGVyLWZhZGUtZHVyYXRpb25cIl0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgICAgIGtsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgU2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgIH0oX2kpLFxuICAgICAgICBJbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHt9KSwgdGhpcy5pbXBsZW1lbnRhdGlvbiA9IGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmlzM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIjNkXCIgPT09IHRoaXMuaW1wbGVtZW50YXRpb24ucmVuZGVyaW5nTW9kZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmhhc09mZnNjcmVlblBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgIT09IHRoaXMuaW1wbGVtZW50YXRpb24ucHJlcmVuZGVyO1xuICAgICAgfSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmltcGxlbWVudGF0aW9uLm9uQWRkICYmIHRoaXMuaW1wbGVtZW50YXRpb24ub25BZGQodCwgdC5wYWludGVyLmNvbnRleHQuZ2wpO1xuICAgICAgfSwgZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmltcGxlbWVudGF0aW9uLm9uUmVtb3ZlICYmIHRoaXMuaW1wbGVtZW50YXRpb24ub25SZW1vdmUodCwgdC5wYWludGVyLmNvbnRleHQuZ2wpO1xuICAgICAgfSwgZTtcbiAgICB9KF9pKSxcbiAgICAgICAgemwgPSB7XG4gICAgICBjaXJjbGU6IGNvLFxuICAgICAgaGVhdG1hcDogX28sXG4gICAgICBoaWxsc2hhZGU6IFNvLFxuICAgICAgZmlsbDogcHMsXG4gICAgICBcImZpbGwtZXh0cnVzaW9uXCI6IHpzLFxuICAgICAgbGluZTogUnMsXG4gICAgICBzeW1ib2w6IHdsLFxuICAgICAgYmFja2dyb3VuZDogQWwsXG4gICAgICByYXN0ZXI6IGtsXG4gICAgfSxcbiAgICAgICAgQ2wgPSBvLkhUTUxJbWFnZUVsZW1lbnQsXG4gICAgICAgIEVsID0gby5IVE1MQ2FudmFzRWxlbWVudCxcbiAgICAgICAgUGwgPSBvLkhUTUxWaWRlb0VsZW1lbnQsXG4gICAgICAgIE1sID0gby5JbWFnZURhdGEsXG4gICAgICAgIEJsID0gby5JbWFnZUJpdG1hcCxcbiAgICAgICAgVGwgPSBmdW5jdGlvbiBUbCh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSB0LCB0aGlzLmZvcm1hdCA9IHIsIHRoaXMudGV4dHVyZSA9IHQuZ2wuY3JlYXRlVGV4dHVyZSgpLCB0aGlzLnVwZGF0ZShlLCBuKTtcbiAgICB9O1xuXG4gICAgVGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHQud2lkdGgsXG4gICAgICAgICAgaSA9IHQuaGVpZ2h0LFxuICAgICAgICAgIGEgPSAhKHRoaXMuc2l6ZSAmJiB0aGlzLnNpemVbMF0gPT09IG4gJiYgdGhpcy5zaXplWzFdID09PSBpIHx8IHIpLFxuICAgICAgICAgIG8gPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgcyA9IG8uZ2w7XG4gICAgICBpZiAodGhpcy51c2VNaXBtYXAgPSBCb29sZWFuKGUgJiYgZS51c2VNaXBtYXApLCBzLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKSwgby5waXhlbFN0b3JlVW5wYWNrRmxpcFkuc2V0KCExKSwgby5waXhlbFN0b3JlVW5wYWNrLnNldCgxKSwgby5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYS5zZXQodGhpcy5mb3JtYXQgPT09IHMuUkdCQSAmJiAoIWUgfHwgITEgIT09IGUucHJlbXVsdGlwbHkpKSwgYSkgdGhpcy5zaXplID0gW24sIGldLCB0IGluc3RhbmNlb2YgQ2wgfHwgdCBpbnN0YW5jZW9mIEVsIHx8IHQgaW5zdGFuY2VvZiBQbCB8fCB0IGluc3RhbmNlb2YgTWwgfHwgQmwgJiYgdCBpbnN0YW5jZW9mIEJsID8gcy50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuZm9ybWF0LCBzLlVOU0lHTkVEX0JZVEUsIHQpIDogcy50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIG4sIGksIDAsIHRoaXMuZm9ybWF0LCBzLlVOU0lHTkVEX0JZVEUsIHQuZGF0YSk7ZWxzZSB7XG4gICAgICAgIHZhciB1ID0gciB8fCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgICAgICBsID0gdS54LFxuICAgICAgICAgICAgcCA9IHUueTtcbiAgICAgICAgdCBpbnN0YW5jZW9mIENsIHx8IHQgaW5zdGFuY2VvZiBFbCB8fCB0IGluc3RhbmNlb2YgUGwgfHwgdCBpbnN0YW5jZW9mIE1sIHx8IEJsICYmIHQgaW5zdGFuY2VvZiBCbCA/IHMudGV4U3ViSW1hZ2UyRChzLlRFWFRVUkVfMkQsIDAsIGwsIHAsIHMuUkdCQSwgcy5VTlNJR05FRF9CWVRFLCB0KSA6IHMudGV4U3ViSW1hZ2UyRChzLlRFWFRVUkVfMkQsIDAsIGwsIHAsIG4sIGksIHMuUkdCQSwgcy5VTlNJR05FRF9CWVRFLCB0LmRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy51c2VNaXBtYXAgJiYgdGhpcy5pc1NpemVQb3dlck9mVHdvKCkgJiYgcy5nZW5lcmF0ZU1pcG1hcChzLlRFWFRVUkVfMkQpO1xuICAgIH0sIFRsLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgbi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSksIHIgIT09IG4uTElORUFSX01JUE1BUF9ORUFSRVNUIHx8IHRoaXMuaXNTaXplUG93ZXJPZlR3bygpIHx8IChyID0gbi5MSU5FQVIpLCB0ICE9PSB0aGlzLmZpbHRlciAmJiAobi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX01BR19GSUxURVIsIHQpLCBuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfTUlOX0ZJTFRFUiwgciB8fCB0KSwgdGhpcy5maWx0ZXIgPSB0KSwgZSAhPT0gdGhpcy53cmFwICYmIChuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfV1JBUF9TLCBlKSwgbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX1dSQVBfVCwgZSksIHRoaXMud3JhcCA9IGUpO1xuICAgIH0sIFRsLnByb3RvdHlwZS5pc1NpemVQb3dlck9mVHdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZVswXSA9PT0gdGhpcy5zaXplWzFdICYmIE1hdGgubG9nKHRoaXMuc2l6ZVswXSkgLyBNYXRoLkxOMiAlIDEgPT0gMDtcbiAgICB9LCBUbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29udGV4dC5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSksIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBWbCA9IGZ1bmN0aW9uIFZsKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gdCwgdGhpcy5fdHJpZ2dlcmVkID0gITEsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmICh0aGlzLl9jaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksIHRoaXMuX2NoYW5uZWwucG9ydDIub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlLl90cmlnZ2VyZWQgPSAhMSwgZS5fY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBWbC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgIHRoaXMuX3RyaWdnZXJlZCB8fCAodGhpcy5fdHJpZ2dlcmVkID0gITAsIHRoaXMuX2NoYW5uZWwgPyB0aGlzLl9jaGFubmVsLnBvcnQxLnBvc3RNZXNzYWdlKCEwKSA6IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0Ll90cmlnZ2VyZWQgPSAhMSwgdC5fY2FsbGJhY2soKTtcbiAgICAgIH0sIDApKTtcbiAgICB9LCBWbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NoYW5uZWwsIHRoaXMuX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgfTtcblxuICAgIHZhciBGbCA9IGZ1bmN0aW9uIEZsKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdCwgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLm1hcElkID0gciwgdGhpcy5jYWxsYmFja3MgPSB7fSwgdGhpcy50YXNrcyA9IHt9LCB0aGlzLnRhc2tRdWV1ZSA9IFtdLCB0aGlzLmNhbmNlbENhbGxiYWNrcyA9IHt9LCB2KFtcInJlY2VpdmVcIiwgXCJwcm9jZXNzXCJdLCB0aGlzKSwgdGhpcy5pbnZva2VyID0gbmV3IFZsKHRoaXMucHJvY2VzcyksIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMucmVjZWl2ZSwgITEpLCB0aGlzLmdsb2JhbFNjb3BlID0gSSgpID8gdCA6IG87XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIERsKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gMjU2IC8gTWF0aC5wb3coMiwgcik7XG4gICAgICByZXR1cm4gW3QgKiBuIC0gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gMiwgZSAqIG4gLSAyICogTWF0aC5QSSAqIDYzNzgxMzcgLyAyXTtcbiAgICB9XG5cbiAgICBGbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSAhMSk7XG4gICAgICB2YXIgbyA9IE1hdGgucm91bmQoMWUxOCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgciAmJiAodGhpcy5jYWxsYmFja3Nbb10gPSByKTtcbiAgICAgIHZhciBzID0gRSh0aGlzLmdsb2JhbFNjb3BlKSA/IHZvaWQgMCA6IFtdO1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQ6IG8sXG4gICAgICAgIHR5cGU6IHQsXG4gICAgICAgIGhhc0NhbGxiYWNrOiAhIXIsXG4gICAgICAgIHRhcmdldE1hcElkOiBuLFxuICAgICAgICBtdXN0UXVldWU6IGksXG4gICAgICAgIHNvdXJjZU1hcElkOiB0aGlzLm1hcElkLFxuICAgICAgICBkYXRhOiBxbihlLCBzKVxuICAgICAgfSwgcyksIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgciAmJiBkZWxldGUgYS5jYWxsYmFja3Nbb10sIGEudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBvLFxuICAgICAgICAgICAgdHlwZTogXCI8Y2FuY2VsPlwiLFxuICAgICAgICAgICAgdGFyZ2V0TWFwSWQ6IG4sXG4gICAgICAgICAgICBzb3VyY2VNYXBJZDogYS5tYXBJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIEZsLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdC5kYXRhLFxuICAgICAgICAgIHIgPSBlLmlkO1xuICAgICAgaWYgKHIgJiYgKCFlLnRhcmdldE1hcElkIHx8IHRoaXMubWFwSWQgPT09IGUudGFyZ2V0TWFwSWQpKSBpZiAoXCI8Y2FuY2VsPlwiID09PSBlLnR5cGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFza3Nbcl07XG4gICAgICAgIHZhciBuID0gdGhpcy5jYW5jZWxDYWxsYmFja3Nbcl07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbmNlbENhbGxiYWNrc1tyXSwgbiAmJiBuKCk7XG4gICAgICB9IGVsc2UgSSgpIHx8IGUubXVzdFF1ZXVlID8gKHRoaXMudGFza3Nbcl0gPSBlLCB0aGlzLnRhc2tRdWV1ZS5wdXNoKHIpLCB0aGlzLmludm9rZXIudHJpZ2dlcigpKSA6IHRoaXMucHJvY2Vzc1Rhc2sociwgZSk7XG4gICAgfSwgRmwucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy50YXNrUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50YXNrUXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgIGUgPSB0aGlzLnRhc2tzW3RdO1xuICAgICAgICBkZWxldGUgdGhpcy50YXNrc1t0XSwgdGhpcy50YXNrUXVldWUubGVuZ3RoICYmIHRoaXMuaW52b2tlci50cmlnZ2VyKCksIGUgJiYgdGhpcy5wcm9jZXNzVGFzayh0LCBlKTtcbiAgICAgIH1cbiAgICB9LCBGbC5wcm90b3R5cGUucHJvY2Vzc1Rhc2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgICBpZiAoXCI8cmVzcG9uc2U+XCIgPT09IGUudHlwZSkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY2FsbGJhY2tzW3RdO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbdF0sIG4gJiYgKGUuZXJyb3IgPyBuKE5uKGUuZXJyb3IpKSA6IG4obnVsbCwgTm4oZS5kYXRhKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAhMSxcbiAgICAgICAgICAgIGEgPSBFKHRoaXMuZ2xvYmFsU2NvcGUpID8gdm9pZCAwIDogW10sXG4gICAgICAgICAgICBvID0gZS5oYXNDYWxsYmFjayA/IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgaSA9ICEwLCBkZWxldGUgci5jYW5jZWxDYWxsYmFja3NbdF0sIHIudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiB0LFxuICAgICAgICAgICAgdHlwZTogXCI8cmVzcG9uc2U+XCIsXG4gICAgICAgICAgICBzb3VyY2VNYXBJZDogci5tYXBJZCxcbiAgICAgICAgICAgIGVycm9yOiBlID8gcW4oZSkgOiBudWxsLFxuICAgICAgICAgICAgZGF0YTogcW4obiwgYSlcbiAgICAgICAgICB9LCBhKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaSA9ICEwO1xuICAgICAgICB9LFxuICAgICAgICAgICAgcyA9IG51bGwsXG4gICAgICAgICAgICB1ID0gTm4oZS5kYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50W2UudHlwZV0pIHMgPSB0aGlzLnBhcmVudFtlLnR5cGVdKGUuc291cmNlTWFwSWQsIHUsIG8pO2Vsc2UgaWYgKHRoaXMucGFyZW50LmdldFdvcmtlclNvdXJjZSkge1xuICAgICAgICAgIHZhciBsID0gZS50eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBzID0gdGhpcy5wYXJlbnQuZ2V0V29ya2VyU291cmNlKGUuc291cmNlTWFwSWQsIGxbMF0sIHUuc291cmNlKVtsWzFdXSh1LCBvKTtcbiAgICAgICAgfSBlbHNlIG8obmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgZnVuY3Rpb24gXCIgKyBlLnR5cGUpKTtcbiAgICAgICAgIWkgJiYgcyAmJiBzLmNhbmNlbCAmJiAodGhpcy5jYW5jZWxDYWxsYmFja3NbdF0gPSBzLmNhbmNlbCk7XG4gICAgICB9XG4gICAgfSwgRmwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW52b2tlci5yZW1vdmUoKSwgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5yZWNlaXZlLCAhMSk7XG4gICAgfTtcblxuICAgIHZhciBMbCA9IGZ1bmN0aW9uIExsKHQsIGUpIHtcbiAgICAgIHQgJiYgKGUgPyB0aGlzLnNldFNvdXRoV2VzdCh0KS5zZXROb3J0aEVhc3QoZSkgOiA0ID09PSB0Lmxlbmd0aCA/IHRoaXMuc2V0U291dGhXZXN0KFt0WzBdLCB0WzFdXSkuc2V0Tm9ydGhFYXN0KFt0WzJdLCB0WzNdXSkgOiB0aGlzLnNldFNvdXRoV2VzdCh0WzBdKS5zZXROb3J0aEVhc3QodFsxXSkpO1xuICAgIH07XG5cbiAgICBMbC5wcm90b3R5cGUuc2V0Tm9ydGhFYXN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZSA9IHQgaW5zdGFuY2VvZiBPbCA/IG5ldyBPbCh0LmxuZywgdC5sYXQpIDogT2wuY29udmVydCh0KSwgdGhpcztcbiAgICB9LCBMbC5wcm90b3R5cGUuc2V0U291dGhXZXN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdyA9IHQgaW5zdGFuY2VvZiBPbCA/IG5ldyBPbCh0LmxuZywgdC5sYXQpIDogT2wuY29udmVydCh0KSwgdGhpcztcbiAgICB9LCBMbC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgbiA9IHRoaXMuX3N3LFxuICAgICAgICAgIGkgPSB0aGlzLl9uZTtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgT2wpIGUgPSB0LCByID0gdDtlbHNlIHtcbiAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIExsKSkgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyA0ID09PSB0Lmxlbmd0aCB8fCB0LmV2ZXJ5KEFycmF5LmlzQXJyYXkpID8gdGhpcy5leHRlbmQoTGwuY29udmVydCh0KSkgOiB0aGlzLmV4dGVuZChPbC5jb252ZXJ0KHQpKSA6IHRoaXM7XG4gICAgICAgIGlmIChyID0gdC5fbmUsICEoZSA9IHQuX3N3KSB8fCAhcikgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiB8fCBpID8gKG4ubG5nID0gTWF0aC5taW4oZS5sbmcsIG4ubG5nKSwgbi5sYXQgPSBNYXRoLm1pbihlLmxhdCwgbi5sYXQpLCBpLmxuZyA9IE1hdGgubWF4KHIubG5nLCBpLmxuZyksIGkubGF0ID0gTWF0aC5tYXgoci5sYXQsIGkubGF0KSkgOiAodGhpcy5fc3cgPSBuZXcgT2woZS5sbmcsIGUubGF0KSwgdGhpcy5fbmUgPSBuZXcgT2woci5sbmcsIHIubGF0KSksIHRoaXM7XG4gICAgfSwgTGwucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2woKHRoaXMuX3N3LmxuZyArIHRoaXMuX25lLmxuZykgLyAyLCAodGhpcy5fc3cubGF0ICsgdGhpcy5fbmUubGF0KSAvIDIpO1xuICAgIH0sIExsLnByb3RvdHlwZS5nZXRTb3V0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3c7XG4gICAgfSwgTGwucHJvdG90eXBlLmdldE5vcnRoRWFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZTtcbiAgICB9LCBMbC5wcm90b3R5cGUuZ2V0Tm9ydGhXZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPbCh0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXROb3J0aCgpKTtcbiAgICB9LCBMbC5wcm90b3R5cGUuZ2V0U291dGhFYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPbCh0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXRTb3V0aCgpKTtcbiAgICB9LCBMbC5wcm90b3R5cGUuZ2V0V2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdy5sbmc7XG4gICAgfSwgTGwucHJvdG90eXBlLmdldFNvdXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N3LmxhdDtcbiAgICB9LCBMbC5wcm90b3R5cGUuZ2V0RWFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZS5sbmc7XG4gICAgfSwgTGwucHJvdG90eXBlLmdldE5vcnRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lLmxhdDtcbiAgICB9LCBMbC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5fc3cudG9BcnJheSgpLCB0aGlzLl9uZS50b0FycmF5KCldO1xuICAgIH0sIExsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIkxuZ0xhdEJvdW5kcyhcIiArIHRoaXMuX3N3LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9uZS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfSwgTGwucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISh0aGlzLl9zdyAmJiB0aGlzLl9uZSk7XG4gICAgfSwgTGwucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gT2wuY29udmVydCh0KSxcbiAgICAgICAgICByID0gZS5sbmcsXG4gICAgICAgICAgbiA9IGUubGF0LFxuICAgICAgICAgIGkgPSB0aGlzLl9zdy5sbmcgPD0gciAmJiByIDw9IHRoaXMuX25lLmxuZztcbiAgICAgIHJldHVybiB0aGlzLl9zdy5sbmcgPiB0aGlzLl9uZS5sbmcgJiYgKGkgPSB0aGlzLl9zdy5sbmcgPj0gciAmJiByID49IHRoaXMuX25lLmxuZyksIHRoaXMuX3N3LmxhdCA8PSBuICYmIG4gPD0gdGhpcy5fbmUubGF0ICYmIGk7XG4gICAgfSwgTGwuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgdCBpbnN0YW5jZW9mIExsID8gdCA6IG5ldyBMbCh0KTtcbiAgICB9O1xuXG4gICAgdmFyIE9sID0gZnVuY3Rpb24gT2wodCwgZSkge1xuICAgICAgaWYgKGlzTmFOKHQpIHx8IGlzTmFOKGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExuZ0xhdCBvYmplY3Q6IChcIiArIHQgKyBcIiwgXCIgKyBlICsgXCIpXCIpO1xuICAgICAgaWYgKHRoaXMubG5nID0gK3QsIHRoaXMubGF0ID0gK2UsIHRoaXMubGF0ID4gOTAgfHwgdGhpcy5sYXQgPCAtOTApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTG5nTGF0IGxhdGl0dWRlIHZhbHVlOiBtdXN0IGJlIGJldHdlZW4gLTkwIGFuZCA5MFwiKTtcbiAgICB9O1xuXG4gICAgT2wucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKGModGhpcy5sbmcsIC0xODAsIDE4MCksIHRoaXMubGF0KTtcbiAgICB9LCBPbC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5sbmcsIHRoaXMubGF0XTtcbiAgICB9LCBPbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJMbmdMYXQoXCIgKyB0aGlzLmxuZyArIFwiLCBcIiArIHRoaXMubGF0ICsgXCIpXCI7XG4gICAgfSwgT2wucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgIHIgPSB0aGlzLmxhdCAqIGUsXG4gICAgICAgICAgbiA9IHQubGF0ICogZSxcbiAgICAgICAgICBpID0gTWF0aC5zaW4ocikgKiBNYXRoLnNpbihuKSArIE1hdGguY29zKHIpICogTWF0aC5jb3MobikgKiBNYXRoLmNvcygodC5sbmcgLSB0aGlzLmxuZykgKiBlKTtcbiAgICAgIHJldHVybiA2MzcxMDA4LjggKiBNYXRoLmFjb3MoTWF0aC5taW4oaSwgMSkpO1xuICAgIH0sIE9sLnByb3RvdHlwZS50b0JvdW5kcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSAwKTtcbiAgICAgIHZhciBlID0gMzYwICogdCAvIDQwMDc1MDE3LFxuICAgICAgICAgIHIgPSBlIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIHRoaXMubGF0KTtcbiAgICAgIHJldHVybiBuZXcgTGwobmV3IE9sKHRoaXMubG5nIC0gciwgdGhpcy5sYXQgLSBlKSwgbmV3IE9sKHRoaXMubG5nICsgciwgdGhpcy5sYXQgKyBlKSk7XG4gICAgfSwgT2wuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIE9sKSByZXR1cm4gdDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpICYmICgyID09PSB0Lmxlbmd0aCB8fCAzID09PSB0Lmxlbmd0aCkpIHJldHVybiBuZXcgT2woTnVtYmVyKHRbMF0pLCBOdW1iZXIodFsxXSkpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHQpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgcmV0dXJuIG5ldyBPbChOdW1iZXIoXCJsbmdcIiBpbiB0ID8gdC5sbmcgOiB0LmxvbiksIE51bWJlcih0LmxhdCkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYExuZ0xhdExpa2VgIGFyZ3VtZW50IG11c3QgYmUgc3BlY2lmaWVkIGFzIGEgTG5nTGF0IGluc3RhbmNlLCBhbiBvYmplY3Qge2xuZzogPGxuZz4sIGxhdDogPGxhdD59LCBhbiBvYmplY3Qge2xvbjogPGxuZz4sIGxhdDogPGxhdD59LCBvciBhbiBhcnJheSBvZiBbPGxuZz4sIDxsYXQ+XVwiKTtcbiAgICB9O1xuICAgIHZhciBSbCA9IDIgKiBNYXRoLlBJICogNjM3MTAwOC44O1xuXG4gICAgZnVuY3Rpb24gVWwodCkge1xuICAgICAgcmV0dXJuIFJsICogTWF0aC5jb3ModCAqIE1hdGguUEkgLyAxODApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpsKHQpIHtcbiAgICAgIHJldHVybiAoMTgwICsgdCkgLyAzNjA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcWwodCkge1xuICAgICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyB0ICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBObCh0LCBlKSB7XG4gICAgICByZXR1cm4gdCAvIFVsKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtsKHQpIHtcbiAgICAgIHJldHVybiAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKCgxODAgLSAzNjAgKiB0KSAqIE1hdGguUEkgLyAxODApKSAtIDkwO1xuICAgIH1cblxuICAgIHZhciBHbCA9IGZ1bmN0aW9uIEdsKHQsIGUsIHIpIHtcbiAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IDApLCB0aGlzLnggPSArdCwgdGhpcy55ID0gK2UsIHRoaXMueiA9ICtyO1xuICAgIH07XG5cbiAgICBHbC5mcm9tTG5nTGF0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApO1xuICAgICAgdmFyIHIgPSBPbC5jb252ZXJ0KHQpO1xuICAgICAgcmV0dXJuIG5ldyBHbChqbChyLmxuZyksIHFsKHIubGF0KSwgTmwoZSwgci5sYXQpKTtcbiAgICB9LCBHbC5wcm90b3R5cGUudG9MbmdMYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKDM2MCAqIHRoaXMueCAtIDE4MCwgS2wodGhpcy55KSk7XG4gICAgfSwgR2wucHJvdG90eXBlLnRvQWx0aXR1ZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy56ICogVWwoS2wodGhpcy55KSk7XG4gICAgfSwgR2wucHJvdG90eXBlLm1ldGVySW5NZXJjYXRvckNvb3JkaW5hdGVVbml0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxIC8gUmwgKiAodCA9IEtsKHRoaXMueSksIDEgLyBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDE4MCkpO1xuICAgICAgdmFyIHQ7XG4gICAgfTtcblxuICAgIHZhciBabCA9IGZ1bmN0aW9uIFpsKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMueiA9IHQsIHRoaXMueCA9IGUsIHRoaXMueSA9IHIsIHRoaXMua2V5ID0gSGwoMCwgdCwgdCwgZSwgcik7XG4gICAgfTtcblxuICAgIFpsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMueiA9PT0gdC56ICYmIHRoaXMueCA9PT0gdC54ICYmIHRoaXMueSA9PT0gdC55O1xuICAgIH0sIFpsLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBzID0gKG4gPSB0aGlzLnksIGkgPSB0aGlzLnosIGEgPSBEbCgyNTYgKiAociA9IHRoaXMueCksIDI1NiAqIChuID0gTWF0aC5wb3coMiwgaSkgLSBuIC0gMSksIGkpLCBvID0gRGwoMjU2ICogKHIgKyAxKSwgMjU2ICogKG4gKyAxKSwgaSksIGFbMF0gKyBcIixcIiArIGFbMV0gKyBcIixcIiArIG9bMF0gKyBcIixcIiArIG9bMV0pLFxuICAgICAgICAgIHUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICBmb3IgKHZhciBuLCBpID0gXCJcIiwgYSA9IHQ7IGEgPiAwOyBhLS0pIHtcbiAgICAgICAgICBpICs9IChlICYgKG4gPSAxIDw8IGEgLSAxKSA/IDEgOiAwKSArIChyICYgbiA/IDIgOiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSh0aGlzLnosIHRoaXMueCwgdGhpcy55KTtcblxuICAgICAgcmV0dXJuIHRbKHRoaXMueCArIHRoaXMueSkgJSB0Lmxlbmd0aF0ucmVwbGFjZShcIntwcmVmaXh9XCIsICh0aGlzLnggJSAxNikudG9TdHJpbmcoMTYpICsgKHRoaXMueSAlIDE2KS50b1N0cmluZygxNikpLnJlcGxhY2UoXCJ7en1cIiwgU3RyaW5nKHRoaXMueikpLnJlcGxhY2UoXCJ7eH1cIiwgU3RyaW5nKHRoaXMueCkpLnJlcGxhY2UoXCJ7eX1cIiwgU3RyaW5nKFwidG1zXCIgPT09IGUgPyBNYXRoLnBvdygyLCB0aGlzLnopIC0gdGhpcy55IC0gMSA6IHRoaXMueSkpLnJlcGxhY2UoXCJ7cXVhZGtleX1cIiwgdSkucmVwbGFjZShcIntiYm94LWVwc2ctMzg1N31cIiwgcyk7XG4gICAgfSwgWmwucHJvdG90eXBlLmdldFRpbGVQb2ludCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE1hdGgucG93KDIsIHRoaXMueik7XG4gICAgICByZXR1cm4gbmV3IGkoODE5MiAqICh0LnggKiBlIC0gdGhpcy54KSwgODE5MiAqICh0LnkgKiBlIC0gdGhpcy55KSk7XG4gICAgfSwgWmwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueiArIFwiL1wiICsgdGhpcy54ICsgXCIvXCIgKyB0aGlzLnk7XG4gICAgfTtcblxuICAgIHZhciBYbCA9IGZ1bmN0aW9uIFhsKHQsIGUpIHtcbiAgICAgIHRoaXMud3JhcCA9IHQsIHRoaXMuY2Fub25pY2FsID0gZSwgdGhpcy5rZXkgPSBIbCh0LCBlLnosIGUueiwgZS54LCBlLnkpO1xuICAgIH0sXG4gICAgICAgIEpsID0gZnVuY3Rpb24gSmwodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy5vdmVyc2NhbGVkWiA9IHQsIHRoaXMud3JhcCA9IGUsIHRoaXMuY2Fub25pY2FsID0gbmV3IFpsKHIsICtuLCAraSksIHRoaXMua2V5ID0gSGwoZSwgdCwgciwgbiwgaSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEhsKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICh0ICo9IDIpIDwgMCAmJiAodCA9IC0xICogdCAtIDEpO1xuICAgICAgdmFyIGEgPSAxIDw8IHI7XG4gICAgICByZXR1cm4gKGEgKiBhICogdCArIGEgKiBpICsgbikudG9TdHJpbmcoMzYpICsgci50b1N0cmluZygzNikgKyBlLnRvU3RyaW5nKDM2KTtcbiAgICB9XG5cbiAgICBKbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJzY2FsZWRaID09PSB0Lm92ZXJzY2FsZWRaICYmIHRoaXMud3JhcCA9PT0gdC53cmFwICYmIHRoaXMuY2Fub25pY2FsLmVxdWFscyh0LmNhbm9uaWNhbCk7XG4gICAgfSwgSmwucHJvdG90eXBlLnNjYWxlZFRvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jYW5vbmljYWwueiAtIHQ7XG4gICAgICByZXR1cm4gdCA+IHRoaXMuY2Fub25pY2FsLnogPyBuZXcgSmwodCwgdGhpcy53cmFwLCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KSA6IG5ldyBKbCh0LCB0aGlzLndyYXAsIHQsIHRoaXMuY2Fub25pY2FsLnggPj4gZSwgdGhpcy5jYW5vbmljYWwueSA+PiBlKTtcbiAgICB9LCBKbC5wcm90b3R5cGUuY2FsY3VsYXRlU2NhbGVkS2V5ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdGhpcy5jYW5vbmljYWwueiAtIHQ7XG4gICAgICByZXR1cm4gdCA+IHRoaXMuY2Fub25pY2FsLnogPyBIbCh0aGlzLndyYXAgKiArZSwgdCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSkgOiBIbCh0aGlzLndyYXAgKiArZSwgdCwgdCwgdGhpcy5jYW5vbmljYWwueCA+PiByLCB0aGlzLmNhbm9uaWNhbC55ID4+IHIpO1xuICAgIH0sIEpsLnByb3RvdHlwZS5pc0NoaWxkT2YgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQud3JhcCAhPT0gdGhpcy53cmFwKSByZXR1cm4gITE7XG4gICAgICB2YXIgZSA9IHRoaXMuY2Fub25pY2FsLnogLSB0LmNhbm9uaWNhbC56O1xuICAgICAgcmV0dXJuIDAgPT09IHQub3ZlcnNjYWxlZFogfHwgdC5vdmVyc2NhbGVkWiA8IHRoaXMub3ZlcnNjYWxlZFogJiYgdC5jYW5vbmljYWwueCA9PT0gdGhpcy5jYW5vbmljYWwueCA+PiBlICYmIHQuY2Fub25pY2FsLnkgPT09IHRoaXMuY2Fub25pY2FsLnkgPj4gZTtcbiAgICB9LCBKbC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMub3ZlcnNjYWxlZFogPj0gdCkgcmV0dXJuIFtuZXcgSmwodGhpcy5vdmVyc2NhbGVkWiArIDEsIHRoaXMud3JhcCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSldO1xuICAgICAgdmFyIGUgPSB0aGlzLmNhbm9uaWNhbC56ICsgMSxcbiAgICAgICAgICByID0gMiAqIHRoaXMuY2Fub25pY2FsLngsXG4gICAgICAgICAgbiA9IDIgKiB0aGlzLmNhbm9uaWNhbC55O1xuICAgICAgcmV0dXJuIFtuZXcgSmwoZSwgdGhpcy53cmFwLCBlLCByLCBuKSwgbmV3IEpsKGUsIHRoaXMud3JhcCwgZSwgciArIDEsIG4pLCBuZXcgSmwoZSwgdGhpcy53cmFwLCBlLCByLCBuICsgMSksIG5ldyBKbChlLCB0aGlzLndyYXAsIGUsIHIgKyAxLCBuICsgMSldO1xuICAgIH0sIEpsLnByb3RvdHlwZS5pc0xlc3NUaGFuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndyYXAgPCB0LndyYXAgfHwgISh0aGlzLndyYXAgPiB0LndyYXApICYmICh0aGlzLm92ZXJzY2FsZWRaIDwgdC5vdmVyc2NhbGVkWiB8fCAhKHRoaXMub3ZlcnNjYWxlZFogPiB0Lm92ZXJzY2FsZWRaKSAmJiAodGhpcy5jYW5vbmljYWwueCA8IHQuY2Fub25pY2FsLnggfHwgISh0aGlzLmNhbm9uaWNhbC54ID4gdC5jYW5vbmljYWwueCkgJiYgdGhpcy5jYW5vbmljYWwueSA8IHQuY2Fub25pY2FsLnkpKTtcbiAgICB9LCBKbC5wcm90b3R5cGUud3JhcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgSmwodGhpcy5vdmVyc2NhbGVkWiwgMCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSk7XG4gICAgfSwgSmwucHJvdG90eXBlLnVud3JhcFRvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgSmwodGhpcy5vdmVyc2NhbGVkWiwgdCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSk7XG4gICAgfSwgSmwucHJvdG90eXBlLm92ZXJzY2FsZUZhY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCB0aGlzLm92ZXJzY2FsZWRaIC0gdGhpcy5jYW5vbmljYWwueik7XG4gICAgfSwgSmwucHJvdG90eXBlLnRvVW53cmFwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBYbCh0aGlzLndyYXAsIHRoaXMuY2Fub25pY2FsKTtcbiAgICB9LCBKbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdmVyc2NhbGVkWiArIFwiL1wiICsgdGhpcy5jYW5vbmljYWwueCArIFwiL1wiICsgdGhpcy5jYW5vbmljYWwueTtcbiAgICB9LCBKbC5wcm90b3R5cGUuZ2V0VGlsZVBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbC5nZXRUaWxlUG9pbnQobmV3IEdsKHQueCAtIHRoaXMud3JhcCwgdC55KSk7XG4gICAgfSwgT24oXCJDYW5vbmljYWxUaWxlSURcIiwgWmwpLCBPbihcIk92ZXJzY2FsZWRUaWxlSURcIiwgSmwsIHtcbiAgICAgIG9taXQ6IFtcInBvc01hdHJpeFwiXVxuICAgIH0pO1xuXG4gICAgdmFyIFlsID0gZnVuY3Rpb24gWWwodCwgZSwgcikge1xuICAgICAgaWYgKHRoaXMudWlkID0gdCwgZS5oZWlnaHQgIT09IGUud2lkdGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiREVNIHRpbGVzIG11c3QgYmUgc3F1YXJlXCIpO1xuICAgICAgaWYgKHIgJiYgXCJtYXBib3hcIiAhPT0gciAmJiBcInRlcnJhcml1bVwiICE9PSByKSByZXR1cm4gQSgnXCInICsgciArICdcIiBpcyBub3QgYSB2YWxpZCBlbmNvZGluZyB0eXBlLiBWYWxpZCB0eXBlcyBpbmNsdWRlIFwibWFwYm94XCIgYW5kIFwidGVycmFyaXVtXCIuJyk7XG4gICAgICB0aGlzLnN0cmlkZSA9IGUuaGVpZ2h0O1xuICAgICAgdmFyIG4gPSB0aGlzLmRpbSA9IGUuaGVpZ2h0IC0gMjtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheShlLmRhdGEuYnVmZmVyKSwgdGhpcy5lbmNvZGluZyA9IHIgfHwgXCJtYXBib3hcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW3RoaXMuX2lkeCgtMSwgaSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeCgwLCBpKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgobiwgaSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeChuIC0gMSwgaSldLCB0aGlzLmRhdGFbdGhpcy5faWR4KGksIC0xKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KGksIDApXSwgdGhpcy5kYXRhW3RoaXMuX2lkeChpLCBuKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KGksIG4gLSAxKV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YVt0aGlzLl9pZHgoLTEsIC0xKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KDAsIDApXSwgdGhpcy5kYXRhW3RoaXMuX2lkeChuLCAtMSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeChuIC0gMSwgMCldLCB0aGlzLmRhdGFbdGhpcy5faWR4KC0xLCBuKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KDAsIG4gLSAxKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgobiwgbildID0gdGhpcy5kYXRhW3RoaXMuX2lkeChuIC0gMSwgbiAtIDEpXTtcbiAgICB9O1xuXG4gICAgWWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpLFxuICAgICAgICAgIG4gPSA0ICogdGhpcy5faWR4KHQsIGUpO1xuXG4gICAgICByZXR1cm4gKFwidGVycmFyaXVtXCIgPT09IHRoaXMuZW5jb2RpbmcgPyB0aGlzLl91bnBhY2tUZXJyYXJpdW0gOiB0aGlzLl91bnBhY2tNYXBib3gpKHJbbl0sIHJbbiArIDFdLCByW24gKyAyXSk7XG4gICAgfSwgWWwucHJvdG90eXBlLmdldFVucGFja1ZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcInRlcnJhcml1bVwiID09PSB0aGlzLmVuY29kaW5nID8gWzI1NiwgMSwgMSAvIDI1NiwgMzI3NjhdIDogWzY1NTMuNiwgMjUuNiwgLjEsIDFlNF07XG4gICAgfSwgWWwucHJvdG90eXBlLl9pZHggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQgPCAtMSB8fCB0ID49IHRoaXMuZGltICsgMSB8fCBlIDwgLTEgfHwgZSA+PSB0aGlzLmRpbSArIDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIHNvdXJjZSBjb29yZGluYXRlcyBmb3IgREVNIGRhdGFcIik7XG4gICAgICByZXR1cm4gKGUgKyAxKSAqIHRoaXMuc3RyaWRlICsgKHQgKyAxKTtcbiAgICB9LCBZbC5wcm90b3R5cGUuX3VucGFja01hcGJveCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gKDI1NiAqIHQgKiAyNTYgKyAyNTYgKiBlICsgcikgLyAxMCAtIDFlNDtcbiAgICB9LCBZbC5wcm90b3R5cGUuX3VucGFja1RlcnJhcml1bSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gMjU2ICogdCArIGUgKyByIC8gMjU2IC0gMzI3Njg7XG4gICAgfSwgWWwucHJvdG90eXBlLmdldFBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgeG8oe1xuICAgICAgICB3aWR0aDogdGhpcy5zdHJpZGUsXG4gICAgICAgIGhlaWdodDogdGhpcy5zdHJpZGVcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpKTtcbiAgICB9LCBZbC5wcm90b3R5cGUuYmFja2ZpbGxCb3JkZXIgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHRoaXMuZGltICE9PSB0LmRpbSkgdGhyb3cgbmV3IEVycm9yKFwiZGVtIGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgICAgIHZhciBuID0gZSAqIHRoaXMuZGltLFxuICAgICAgICAgIGkgPSBlICogdGhpcy5kaW0gKyB0aGlzLmRpbSxcbiAgICAgICAgICBhID0gciAqIHRoaXMuZGltLFxuICAgICAgICAgIG8gPSByICogdGhpcy5kaW0gKyB0aGlzLmRpbTtcblxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgbiA9IGkgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpID0gbiArIDE7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgIGEgPSBvIC0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbyA9IGEgKyAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBzID0gLWUgKiB0aGlzLmRpbSwgdSA9IC1yICogdGhpcy5kaW0sIGwgPSBhOyBsIDwgbzsgbCsrKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSBuOyBwIDwgaTsgcCsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMuX2lkeChwLCBsKV0gPSB0LmRhdGFbdGhpcy5faWR4KHAgKyBzLCBsICsgdSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgT24oXCJERU1EYXRhXCIsIFlsKTtcblxuICAgIHZhciAkbCA9IGZ1bmN0aW9uICRsKHQpIHtcbiAgICAgIHRoaXMuX3N0cmluZ1RvTnVtYmVyID0ge30sIHRoaXMuX251bWJlclRvU3RyaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgciA9IHRbZV07XG4gICAgICAgIHRoaXMuX3N0cmluZ1RvTnVtYmVyW3JdID0gZSwgdGhpcy5fbnVtYmVyVG9TdHJpbmdbZV0gPSByO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkbC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdUb051bWJlclt0XTtcbiAgICB9LCAkbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9udW1iZXJUb1N0cmluZ1t0XTtcbiAgICB9O1xuXG4gICAgdmFyIFdsID0gZnVuY3Rpb24gV2wodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy50eXBlID0gXCJGZWF0dXJlXCIsIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlID0gdCwgdC5feiA9IGUsIHQuX3ggPSByLCB0Ll95ID0gbiwgdGhpcy5wcm9wZXJ0aWVzID0gdC5wcm9wZXJ0aWVzLCB0aGlzLmlkID0gaTtcbiAgICB9LFxuICAgICAgICBRbCA9IHtcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUWwuZ2VvbWV0cnkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5fZ2VvbWV0cnkgJiYgKHRoaXMuX2dlb21ldHJ5ID0gdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUudG9HZW9KU09OKHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlLl94LCB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feSwgdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUuX3opLmdlb21ldHJ5KSwgdGhpcy5fZ2VvbWV0cnk7XG4gICAgfSwgUWwuZ2VvbWV0cnkuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5ID0gdDtcbiAgICB9LCBXbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB7XG4gICAgICAgIGdlb21ldHJ5OiB0aGlzLmdlb21ldHJ5XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMpIHtcbiAgICAgICAgXCJfZ2VvbWV0cnlcIiAhPT0gZSAmJiBcIl92ZWN0b3JUaWxlRmVhdHVyZVwiICE9PSBlICYmICh0W2VdID0gdGhpc1tlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdsLnByb3RvdHlwZSwgUWwpO1xuXG4gICAgdmFyIHRwID0gZnVuY3Rpb24gdHAoKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge30sIHRoaXMuc3RhdGVDaGFuZ2VzID0ge30sIHRoaXMuZGVsZXRlZFN0YXRlcyA9IHt9O1xuICAgIH07XG5cbiAgICB0cC5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBTdHJpbmcoZSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZUNoYW5nZXNbdF0gPSB0aGlzLnN0YXRlQ2hhbmdlc1t0XSB8fCB7fSwgdGhpcy5zdGF0ZUNoYW5nZXNbdF1bbl0gPSB0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSB8fCB7fSwgaCh0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSwgciksIG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XSkgZm9yICh2YXIgaSBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gPSB7fSwgdGhpcy5zdGF0ZVt0XSkge1xuICAgICAgICBpICE9PSBuICYmICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1baV0gPSBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVkU3RhdGVzW3RdICYmIG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSkgZm9yICh2YXIgYSBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gPSB7fSwgdGhpcy5zdGF0ZVt0XVtuXSkge1xuICAgICAgICByW2FdIHx8ICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl1bYV0gPSBudWxsKTtcbiAgICAgIH0gZWxzZSBmb3IgKHZhciBvIGluIHIpIHtcbiAgICAgICAgdGhpcy5kZWxldGVkU3RhdGVzW3RdICYmIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSAmJiBudWxsID09PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl1bb10gJiYgZGVsZXRlIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXVtvXTtcbiAgICAgIH1cbiAgICB9LCB0cC5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmIChudWxsICE9PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0pIHtcbiAgICAgICAgdmFyIG4gPSBTdHJpbmcoZSk7XG4gICAgICAgIGlmICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gPSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gfHwge30sIHIgJiYgdm9pZCAwICE9PSBlKSBudWxsICE9PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gJiYgKHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSA9IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSB8fCB7fSwgdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dW3JdID0gbnVsbCk7ZWxzZSBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGVDaGFuZ2VzW3RdICYmIHRoaXMuc3RhdGVDaGFuZ2VzW3RdW25dKSBmb3IgKHIgaW4gdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dID0ge30sIHRoaXMuc3RhdGVDaGFuZ2VzW3RdW25dKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl1bcl0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gPSBudWxsO1xuICAgICAgICB9IGVsc2UgdGhpcy5kZWxldGVkU3RhdGVzW3RdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB0cC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBTdHJpbmcoZSksXG4gICAgICAgICAgbiA9IGgoe30sICh0aGlzLnN0YXRlW3RdIHx8IHt9KVtyXSwgKHRoaXMuc3RhdGVDaGFuZ2VzW3RdIHx8IHt9KVtyXSk7XG4gICAgICBpZiAobnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdKSByZXR1cm4ge307XG5cbiAgICAgIGlmICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bZV07XG4gICAgICAgIGlmIChudWxsID09PSBpKSByZXR1cm4ge307XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiBpKSB7XG4gICAgICAgICAgZGVsZXRlIG5bYV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgdHAucHJvdG90eXBlLmluaXRpYWxpemVUaWxlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdC5zZXRGZWF0dXJlU3RhdGUodGhpcy5zdGF0ZSwgZSk7XG4gICAgfSwgdHAucHJvdG90eXBlLmNvYWxlc2NlQ2hhbmdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBuIGluIHRoaXMuc3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVbbl0gPSB0aGlzLnN0YXRlW25dIHx8IHt9O1xuICAgICAgICB2YXIgaSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5zdGF0ZUNoYW5nZXNbbl0pIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25dW2FdIHx8ICh0aGlzLnN0YXRlW25dW2FdID0ge30pLCBoKHRoaXMuc3RhdGVbbl1bYV0sIHRoaXMuc3RhdGVDaGFuZ2VzW25dW2FdKSwgaVthXSA9IHRoaXMuc3RhdGVbbl1bYV07XG4gICAgICAgIH1cblxuICAgICAgICByW25dID0gaTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVtvXSA9IHRoaXMuc3RhdGVbb10gfHwge307XG4gICAgICAgIHZhciBzID0ge307XG4gICAgICAgIGlmIChudWxsID09PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbb10pIGZvciAodmFyIHUgaW4gdGhpcy5zdGF0ZVtvXSkge1xuICAgICAgICAgIHNbdV0gPSB7fSwgdGhpcy5zdGF0ZVtvXVt1XSA9IHt9O1xuICAgICAgICB9IGVsc2UgZm9yICh2YXIgbCBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbb10pIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW29dW2xdKSB0aGlzLnN0YXRlW29dW2xdID0ge307ZWxzZSBmb3IgKHZhciBwID0gMCwgYyA9IE9iamVjdC5rZXlzKHRoaXMuZGVsZXRlZFN0YXRlc1tvXVtsXSk7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdGF0ZVtvXVtsXVtjW3BdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc1tsXSA9IHRoaXMuc3RhdGVbb11bbF07XG4gICAgICAgIH1cbiAgICAgICAgcltvXSA9IHJbb10gfHwge30sIGgocltvXSwgcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlcyA9IHt9LCB0aGlzLmRlbGV0ZWRTdGF0ZXMgPSB7fSwgMCAhPT0gT2JqZWN0LmtleXMocikubGVuZ3RoKSBmb3IgKHZhciBmIGluIHQpIHtcbiAgICAgICAgdFtmXS5zZXRGZWF0dXJlU3RhdGUociwgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBlcCA9IGZ1bmN0aW9uIGVwKHQsIGUpIHtcbiAgICAgIHRoaXMudGlsZUlEID0gdCwgdGhpcy54ID0gdC5jYW5vbmljYWwueCwgdGhpcy55ID0gdC5jYW5vbmljYWwueSwgdGhpcy56ID0gdC5jYW5vbmljYWwueiwgdGhpcy5ncmlkID0gbmV3IFRuKDgxOTIsIDE2LCAwKSwgdGhpcy5ncmlkM0QgPSBuZXcgVG4oODE5MiwgMTYsIDApLCB0aGlzLmZlYXR1cmVJbmRleEFycmF5ID0gbmV3IGFhKCksIHRoaXMucHJvbW90ZUlkID0gZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnAodCwgZSwgciwgbiwgaSkge1xuICAgICAgcmV0dXJuIHgodCwgZnVuY3Rpb24gKHQsIGEpIHtcbiAgICAgICAgdmFyIG8gPSBlIGluc3RhbmNlb2YgZGkgPyBlLmdldChhKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBvICYmIG8uZXZhbHVhdGUgPyBvLmV2YWx1YXRlKHIsIG4sIGkpIDogbztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5wKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAxIC8gMCwgciA9IDEgLyAwLCBuID0gLTEgLyAwLCBpID0gLTEgLyAwLCBhID0gMCwgbyA9IHQ7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gb1thXTtcbiAgICAgICAgZSA9IE1hdGgubWluKGUsIHMueCksIHIgPSBNYXRoLm1pbihyLCBzLnkpLCBuID0gTWF0aC5tYXgobiwgcy54KSwgaSA9IE1hdGgubWF4KGksIHMueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IGUsXG4gICAgICAgIG1pblk6IHIsXG4gICAgICAgIG1heFg6IG4sXG4gICAgICAgIG1heFk6IGlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXAodCwgZSkge1xuICAgICAgcmV0dXJuIGUgLSB0O1xuICAgIH1cblxuICAgIGVwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdmFyIG8gPSB0aGlzLmZlYXR1cmVJbmRleEFycmF5Lmxlbmd0aDtcbiAgICAgIHRoaXMuZmVhdHVyZUluZGV4QXJyYXkuZW1wbGFjZUJhY2sociwgbiwgaSk7XG5cbiAgICAgIGZvciAodmFyIHMgPSBhID8gdGhpcy5ncmlkM0QgOiB0aGlzLmdyaWQsIHUgPSAwOyB1IDwgZS5sZW5ndGg7IHUrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gZVt1XSwgcCA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSwgYyA9IDA7IGMgPCBsLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgdmFyIGggPSBsW2NdO1xuICAgICAgICAgIHBbMF0gPSBNYXRoLm1pbihwWzBdLCBoLngpLCBwWzFdID0gTWF0aC5taW4ocFsxXSwgaC55KSwgcFsyXSA9IE1hdGgubWF4KHBbMl0sIGgueCksIHBbM10gPSBNYXRoLm1heChwWzNdLCBoLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcFswXSA8IDgxOTIgJiYgcFsxXSA8IDgxOTIgJiYgcFsyXSA+PSAwICYmIHBbM10gPj0gMCAmJiBzLmluc2VydChvLCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcbiAgICAgIH1cbiAgICB9LCBlcC5wcm90b3R5cGUubG9hZFZUTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudnRMYXllcnMgfHwgKHRoaXMudnRMYXllcnMgPSBuZXcgYnMuVmVjdG9yVGlsZShuZXcgWXModGhpcy5yYXdUaWxlRGF0YSkpLmxheWVycywgdGhpcy5zb3VyY2VMYXllckNvZGVyID0gbmV3ICRsKHRoaXMudnRMYXllcnMgPyBPYmplY3Qua2V5cyh0aGlzLnZ0TGF5ZXJzKS5zb3J0KCkgOiBbXCJfZ2VvanNvblRpbGVMYXllclwiXSkpLCB0aGlzLnZ0TGF5ZXJzO1xuICAgIH0sIGVwLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICB0aGlzLmxvYWRWVExheWVycygpO1xuXG4gICAgICBmb3IgKHZhciBvID0gdC5wYXJhbXMgfHwge30sIHMgPSA4MTkyIC8gdC50aWxlU2l6ZSAvIHQuc2NhbGUsIHUgPSBvbihvLmZpbHRlciksIGwgPSB0LnF1ZXJ5R2VvbWV0cnksIHAgPSB0LnF1ZXJ5UGFkZGluZyAqIHMsIGMgPSBucChsKSwgaCA9IHRoaXMuZ3JpZC5xdWVyeShjLm1pblggLSBwLCBjLm1pblkgLSBwLCBjLm1heFggKyBwLCBjLm1heFkgKyBwKSwgZiA9IG5wKHQuY2FtZXJhUXVlcnlHZW9tZXRyeSksIHkgPSB0aGlzLmdyaWQzRC5xdWVyeShmLm1pblggLSBwLCBmLm1pblkgLSBwLCBmLm1heFggKyBwLCBmLm1heFkgKyBwLCBmdW5jdGlvbiAoZSwgciwgbiwgYSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGEpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IHQ7IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHNbb107XG4gICAgICAgICAgICBpZiAoZSA8PSB1LnggJiYgciA8PSB1LnkgJiYgbiA+PSB1LnggJiYgYSA+PSB1LnkpIHJldHVybiAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbCA9IFtuZXcgaShlLCByKSwgbmV3IGkoZSwgYSksIG5ldyBpKG4sIGEpLCBuZXcgaShuLCByKV07XG4gICAgICAgICAgaWYgKHQubGVuZ3RoID4gMikgZm9yICh2YXIgcCA9IDAsIGMgPSBsOyBwIDwgYy5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICAgICAgaWYgKFdhKHQsIGNbcF0pKSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCB0Lmxlbmd0aCAtIDE7IGgrKykge1xuICAgICAgICAgICAgaWYgKFFhKHRbaF0sIHRbaCArIDFdLCBsKSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSh0LmNhbWVyYVF1ZXJ5R2VvbWV0cnksIGUgLSBwLCByIC0gcCwgbiArIHAsIGEgKyBwKTtcbiAgICAgIH0pLCBkID0gMCwgbSA9IHk7IGQgPCBtLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgIGgucHVzaChtW2RdKTtcbiAgICAgIH1cblxuICAgICAgaC5zb3J0KGlwKTtcblxuICAgICAgZm9yICh2YXIgdiwgZyA9IHt9LCB4ID0gZnVuY3Rpb24geChpKSB7XG4gICAgICAgIHZhciBwID0gaFtpXTtcblxuICAgICAgICBpZiAocCAhPT0gdikge1xuICAgICAgICAgIHYgPSBwO1xuICAgICAgICAgIHZhciBjID0gYS5mZWF0dXJlSW5kZXhBcnJheS5nZXQocCksXG4gICAgICAgICAgICAgIGYgPSBudWxsO1xuICAgICAgICAgIGEubG9hZE1hdGNoaW5nRmVhdHVyZShnLCBjLmJ1Y2tldEluZGV4LCBjLnNvdXJjZUxheWVySW5kZXgsIGMuZmVhdHVyZUluZGV4LCB1LCBvLmxheWVycywgby5hdmFpbGFibGVJbWFnZXMsIGUsIHIsIG4sIGZ1bmN0aW9uIChlLCByLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gZiB8fCAoZiA9IFJhKGUpKSwgci5xdWVyeUludGVyc2VjdHNGZWF0dXJlKGwsIGUsIG4sIGYsIGEueiwgdC50cmFuc2Zvcm0sIHMsIHQucGl4ZWxQb3NNYXRyaXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBiID0gMDsgYiA8IGgubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgeChiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfSwgZXAucHJvdG90eXBlLmxvYWRNYXRjaGluZ0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCkge1xuICAgICAgdmFyIGMgPSB0aGlzLmJ1Y2tldExheWVySURzW2VdO1xuXG4gICAgICBpZiAoIWEgfHwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZih0W3JdKSA+PSAwKSByZXR1cm4gITA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9KGEsIGMpKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5zb3VyY2VMYXllckNvZGVyLmRlY29kZShyKSxcbiAgICAgICAgICAgIHkgPSB0aGlzLnZ0TGF5ZXJzW2ZdLmZlYXR1cmUobik7XG5cbiAgICAgICAgaWYgKGkubmVlZEdlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGQgPSBVYSh5LCAhMCk7XG4gICAgICAgICAgaWYgKCFpLmZpbHRlcihuZXcgc2kodGhpcy50aWxlSUQub3ZlcnNjYWxlZFopLCBkLCB0aGlzLnRpbGVJRC5jYW5vbmljYWwpKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoIWkuZmlsdGVyKG5ldyBzaSh0aGlzLnRpbGVJRC5vdmVyc2NhbGVkWiksIHkpKSByZXR1cm47XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IHRoaXMuZ2V0SWQoeSwgZiksIHYgPSAwOyB2IDwgYy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIHZhciBnID0gY1t2XTtcblxuICAgICAgICAgIGlmICghKGEgJiYgYS5pbmRleE9mKGcpIDwgMCkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc1tnXTtcblxuICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSB7fTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBtICYmIGwgJiYgKGIgPSBsLmdldFN0YXRlKHguc291cmNlTGF5ZXIgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLCBtKSk7XG4gICAgICAgICAgICAgIHZhciB3ID0gaCh7fSwgdVtnXSk7XG4gICAgICAgICAgICAgIHcucGFpbnQgPSBycCh3LnBhaW50LCB4LnBhaW50LCB5LCBiLCBvKSwgdy5sYXlvdXQgPSBycCh3LmxheW91dCwgeC5sYXlvdXQsIHksIGIsIG8pO1xuXG4gICAgICAgICAgICAgIHZhciBfID0gIXAgfHwgcCh5LCB4LCBiKTtcblxuICAgICAgICAgICAgICBpZiAoXykge1xuICAgICAgICAgICAgICAgIHZhciBBID0gbmV3IFdsKHksIHRoaXMueiwgdGhpcy54LCB0aGlzLnksIG0pO1xuICAgICAgICAgICAgICAgIEEubGF5ZXIgPSB3O1xuICAgICAgICAgICAgICAgIHZhciBTID0gdFtnXTtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IFMgJiYgKFMgPSB0W2ddID0gW10pLCBTLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4OiBuLFxuICAgICAgICAgICAgICAgICAgZmVhdHVyZTogQSxcbiAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblo6IF9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVwLnByb3RvdHlwZS5sb29rdXBTeW1ib2xGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICB2YXIgdSA9IHt9O1xuICAgICAgdGhpcy5sb2FkVlRMYXllcnMoKTtcblxuICAgICAgZm9yICh2YXIgbCA9IG9uKGkpLCBwID0gMCwgYyA9IHQ7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgIHRoaXMubG9hZE1hdGNoaW5nRmVhdHVyZSh1LCByLCBuLCBjW3BdLCBsLCBhLCBvLCBzLCBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgZXAucHJvdG90eXBlLmhhc0xheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5idWNrZXRMYXllcklEczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSByW2VdOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIGlmICh0ID09PSBpW25dKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVwLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHQuaWQ7XG4gICAgICByZXR1cm4gdGhpcy5wcm9tb3RlSWQgJiYgXCJib29sZWFuXCIgPT0gdHlwZW9mIChyID0gdC5wcm9wZXJ0aWVzW1wic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMucHJvbW90ZUlkID8gdGhpcy5wcm9tb3RlSWQgOiB0aGlzLnByb21vdGVJZFtlXV0pICYmIChyID0gTnVtYmVyKHIpKSwgcjtcbiAgICB9LCBPbihcIkZlYXR1cmVJbmRleFwiLCBlcCwge1xuICAgICAgb21pdDogW1wicmF3VGlsZURhdGFcIiwgXCJzb3VyY2VMYXllckNvZGVyXCJdXG4gICAgfSk7XG5cbiAgICB2YXIgYXAgPSBmdW5jdGlvbiBhcCh0LCBlKSB7XG4gICAgICB0aGlzLnRpbGVJRCA9IHQsIHRoaXMudWlkID0geSgpLCB0aGlzLnVzZXMgPSAwLCB0aGlzLnRpbGVTaXplID0gZSwgdGhpcy5idWNrZXRzID0ge30sIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBudWxsLCB0aGlzLnF1ZXJ5UGFkZGluZyA9IDAsIHRoaXMuaGFzU3ltYm9sQnVja2V0cyA9ICExLCB0aGlzLmhhc1JUTFRleHQgPSAhMSwgdGhpcy5kZXBlbmRlbmNpZXMgPSB7fSwgdGhpcy5leHBpcmVkUmVxdWVzdENvdW50ID0gMCwgdGhpcy5zdGF0ZSA9IFwibG9hZGluZ1wiO1xuICAgIH07XG5cbiAgICBhcC5wcm90b3R5cGUucmVnaXN0ZXJGYWRlRHVyYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0ICsgdGhpcy50aW1lQWRkZWQ7XG4gICAgICBlIDwgTy5ub3coKSB8fCB0aGlzLmZhZGVFbmRUaW1lICYmIGUgPCB0aGlzLmZhZGVFbmRUaW1lIHx8ICh0aGlzLmZhZGVFbmRUaW1lID0gZSk7XG4gICAgfSwgYXAucHJvdG90eXBlLndhc1JlcXVlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImVycm9yZWRcIiA9PT0gdGhpcy5zdGF0ZSB8fCBcImxvYWRlZFwiID09PSB0aGlzLnN0YXRlIHx8IFwicmVsb2FkaW5nXCIgPT09IHRoaXMuc3RhdGU7XG4gICAgfSwgYXAucHJvdG90eXBlLmxvYWRWZWN0b3JEYXRhID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmICh0aGlzLmhhc0RhdGEoKSAmJiB0aGlzLnVubG9hZFZlY3RvckRhdGEoKSwgdGhpcy5zdGF0ZSA9IFwibG9hZGVkXCIsIHQpIHtcbiAgICAgICAgZm9yICh2YXIgbiBpbiB0LmZlYXR1cmVJbmRleCAmJiAodGhpcy5sYXRlc3RGZWF0dXJlSW5kZXggPSB0LmZlYXR1cmVJbmRleCwgdC5yYXdUaWxlRGF0YSA/ICh0aGlzLmxhdGVzdFJhd1RpbGVEYXRhID0gdC5yYXdUaWxlRGF0YSwgdGhpcy5sYXRlc3RGZWF0dXJlSW5kZXgucmF3VGlsZURhdGEgPSB0LnJhd1RpbGVEYXRhKSA6IHRoaXMubGF0ZXN0UmF3VGlsZURhdGEgJiYgKHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4LnJhd1RpbGVEYXRhID0gdGhpcy5sYXRlc3RSYXdUaWxlRGF0YSkpLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gdC5jb2xsaXNpb25Cb3hBcnJheSwgdGhpcy5idWNrZXRzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgICBmb3IgKHZhciBuID0gZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICAgIHZhciB0ID0gYVtpXSxcbiAgICAgICAgICAgICAgICBuID0gdC5sYXllcklkcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0TGF5ZXIodCk7XG4gICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgICAgICAgIGlmICgwICE9PSBuLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0LmxheWVycyA9IG4sIHQuc3RhdGVEZXBlbmRlbnRMYXllcklkcyAmJiAodC5zdGF0ZURlcGVuZGVudExheWVycyA9IHQuc3RhdGVEZXBlbmRlbnRMYXllcklkcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09PSB0O1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IDAsIHMgPSBuOyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgICAgICAgIHJbc1tvXS5pZF0gPSB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgaSA9IDAsIGEgPSB0OyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KHQuYnVja2V0cywgZS5zdHlsZSksIHRoaXMuaGFzU3ltYm9sQnVja2V0cyA9ICExLCB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuYnVja2V0c1tuXTtcblxuICAgICAgICAgIGlmIChpIGluc3RhbmNlb2YgdmwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N5bWJvbEJ1Y2tldHMgPSAhMCwgIXIpIGJyZWFrO1xuICAgICAgICAgICAgaS5qdXN0UmVsb2FkZWQgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNSVExUZXh0ID0gITEsIHRoaXMuaGFzU3ltYm9sQnVja2V0cykgZm9yICh2YXIgYSBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuYnVja2V0c1thXTtcblxuICAgICAgICAgIGlmIChvIGluc3RhbmNlb2YgdmwgJiYgby5oYXNSVExUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JUTFRleHQgPSAhMCwgb2kuaXNMb2FkaW5nKCkgfHwgb2kuaXNMb2FkZWQoKSB8fCBcImRlZmVycmVkXCIgIT09IGlpKCkgfHwgYWkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHMgaW4gdGhpcy5xdWVyeVBhZGRpbmcgPSAwLCB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXMuYnVja2V0c1tzXTtcbiAgICAgICAgICB0aGlzLnF1ZXJ5UGFkZGluZyA9IE1hdGgubWF4KHRoaXMucXVlcnlQYWRkaW5nLCBlLnN0eWxlLmdldExheWVyKHMpLnF1ZXJ5UmFkaXVzKHUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuaW1hZ2VBdGxhcyAmJiAodGhpcy5pbWFnZUF0bGFzID0gdC5pbWFnZUF0bGFzKSwgdC5nbHlwaEF0bGFzSW1hZ2UgJiYgKHRoaXMuZ2x5cGhBdGxhc0ltYWdlID0gdC5nbHlwaEF0bGFzSW1hZ2UpO1xuICAgICAgfSBlbHNlIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBuZXcgJGkoKTtcbiAgICB9LCBhcC5wcm90b3R5cGUudW5sb2FkVmVjdG9yRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c1t0XS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVja2V0cyA9IHt9LCB0aGlzLmltYWdlQXRsYXNUZXh0dXJlICYmIHRoaXMuaW1hZ2VBdGxhc1RleHR1cmUuZGVzdHJveSgpLCB0aGlzLmltYWdlQXRsYXMgJiYgKHRoaXMuaW1hZ2VBdGxhcyA9IG51bGwpLCB0aGlzLmdseXBoQXRsYXNUZXh0dXJlICYmIHRoaXMuZ2x5cGhBdGxhc1RleHR1cmUuZGVzdHJveSgpLCB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCA9IG51bGwsIHRoaXMuc3RhdGUgPSBcInVubG9hZGVkXCI7XG4gICAgfSwgYXAucHJvdG90eXBlLmdldEJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5idWNrZXRzW3QuaWRdO1xuICAgIH0sIGFwLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJ1Y2tldHNbZV07XG4gICAgICAgIHIudXBsb2FkUGVuZGluZygpICYmIHIudXBsb2FkKHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IHQuZ2w7XG4gICAgICB0aGlzLmltYWdlQXRsYXMgJiYgIXRoaXMuaW1hZ2VBdGxhcy51cGxvYWRlZCAmJiAodGhpcy5pbWFnZUF0bGFzVGV4dHVyZSA9IG5ldyBUbCh0LCB0aGlzLmltYWdlQXRsYXMuaW1hZ2UsIG4uUkdCQSksIHRoaXMuaW1hZ2VBdGxhcy51cGxvYWRlZCA9ICEwKSwgdGhpcy5nbHlwaEF0bGFzSW1hZ2UgJiYgKHRoaXMuZ2x5cGhBdGxhc1RleHR1cmUgPSBuZXcgVGwodCwgdGhpcy5nbHlwaEF0bGFzSW1hZ2UsIG4uQUxQSEEpLCB0aGlzLmdseXBoQXRsYXNJbWFnZSA9IG51bGwpO1xuICAgIH0sIGFwLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuaW1hZ2VBdGxhcyAmJiB0aGlzLmltYWdlQXRsYXMucGF0Y2hVcGRhdGVkSW1hZ2VzKHQsIHRoaXMuaW1hZ2VBdGxhc1RleHR1cmUpO1xuICAgIH0sIGFwLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4ICYmIHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4LnJhd1RpbGVEYXRhID8gdGhpcy5sYXRlc3RGZWF0dXJlSW5kZXgucXVlcnkoe1xuICAgICAgICBxdWVyeUdlb21ldHJ5OiBuLFxuICAgICAgICBjYW1lcmFRdWVyeUdlb21ldHJ5OiBpLFxuICAgICAgICBzY2FsZTogYSxcbiAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUsXG4gICAgICAgIHBpeGVsUG9zTWF0cml4OiBsLFxuICAgICAgICB0cmFuc2Zvcm06IHMsXG4gICAgICAgIHBhcmFtczogbyxcbiAgICAgICAgcXVlcnlQYWRkaW5nOiB0aGlzLnF1ZXJ5UGFkZGluZyAqIHVcbiAgICAgIH0sIHQsIGUsIHIpIDoge307XG4gICAgfSwgYXAucHJvdG90eXBlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleDtcblxuICAgICAgaWYgKHIgJiYgci5yYXdUaWxlRGF0YSkge1xuICAgICAgICB2YXIgbiA9IHIubG9hZFZUTGF5ZXJzKCksXG4gICAgICAgICAgICBpID0gZSA/IGUuc291cmNlTGF5ZXIgOiBcIlwiLFxuICAgICAgICAgICAgYSA9IG4uX2dlb2pzb25UaWxlTGF5ZXIgfHwgbltpXTtcbiAgICAgICAgaWYgKGEpIGZvciAodmFyIG8gPSBvbihlICYmIGUuZmlsdGVyKSwgcyA9IHRoaXMudGlsZUlELmNhbm9uaWNhbCwgdSA9IHMueiwgbCA9IHMueCwgcCA9IHMueSwgYyA9IHtcbiAgICAgICAgICB6OiB1LFxuICAgICAgICAgIHg6IGwsXG4gICAgICAgICAgeTogcFxuICAgICAgICB9LCBoID0gMDsgaCA8IGEubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGEuZmVhdHVyZShoKTtcblxuICAgICAgICAgIGlmIChvLm5lZWRHZW9tZXRyeSkge1xuICAgICAgICAgICAgdmFyIHkgPSBVYShmLCAhMCk7XG4gICAgICAgICAgICBpZiAoIW8uZmlsdGVyKG5ldyBzaSh0aGlzLnRpbGVJRC5vdmVyc2NhbGVkWiksIHksIHRoaXMudGlsZUlELmNhbm9uaWNhbCkpIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW8uZmlsdGVyKG5ldyBzaSh0aGlzLnRpbGVJRC5vdmVyc2NhbGVkWiksIGYpKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciBkID0gci5nZXRJZChmLCBpKSxcbiAgICAgICAgICAgICAgbSA9IG5ldyBXbChmLCB1LCBsLCBwLCBkKTtcbiAgICAgICAgICBtLnRpbGUgPSBjLCB0LnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBhcC5wcm90b3R5cGUuaGFzRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImxvYWRlZFwiID09PSB0aGlzLnN0YXRlIHx8IFwicmVsb2FkaW5nXCIgPT09IHRoaXMuc3RhdGUgfHwgXCJleHBpcmVkXCIgPT09IHRoaXMuc3RhdGU7XG4gICAgfSwgYXAucHJvdG90eXBlLnBhdHRlcm5zTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VBdGxhcyAmJiAhIU9iamVjdC5rZXlzKHRoaXMuaW1hZ2VBdGxhcy5wYXR0ZXJuUG9zaXRpb25zKS5sZW5ndGg7XG4gICAgfSwgYXAucHJvdG90eXBlLnNldEV4cGlyeURhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmV4cGlyYXRpb25UaW1lO1xuXG4gICAgICBpZiAodC5jYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgdmFyIHIgPSB6KHQuY2FjaGVDb250cm9sKTtcbiAgICAgICAgcltcIm1heC1hZ2VcIl0gJiYgKHRoaXMuZXhwaXJhdGlvblRpbWUgPSBEYXRlLm5vdygpICsgMWUzICogcltcIm1heC1hZ2VcIl0pO1xuICAgICAgfSBlbHNlIHQuZXhwaXJlcyAmJiAodGhpcy5leHBpcmF0aW9uVGltZSA9IG5ldyBEYXRlKHQuZXhwaXJlcykuZ2V0VGltZSgpKTtcblxuICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgdmFyIG4gPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgaSA9ICExO1xuICAgICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSA+IG4pIGkgPSAhMTtlbHNlIGlmIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUgPCBlKSBpID0gITA7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZXhwaXJhdGlvblRpbWUgLSBlO1xuICAgICAgICAgICAgYSA/IHRoaXMuZXhwaXJhdGlvblRpbWUgPSBuICsgTWF0aC5tYXgoYSwgM2U0KSA6IGkgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpID0gITA7XG4gICAgICAgIGkgPyAodGhpcy5leHBpcmVkUmVxdWVzdENvdW50KyssIHRoaXMuc3RhdGUgPSBcImV4cGlyZWRcIikgOiB0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICAgICAgfVxuICAgIH0sIGFwLnByb3RvdHlwZS5nZXRFeHBpcnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHJldHVybiB0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgPyAxZTMgKiAoMSA8PCBNYXRoLm1pbih0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgLSAxLCAzMSkpIDogTWF0aC5taW4odGhpcy5leHBpcmF0aW9uVGltZSAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBNYXRoLnBvdygyLCAzMSkgLSAxKTtcbiAgICB9LCBhcC5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCAmJiB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5yYXdUaWxlRGF0YSAmJiAwICE9PSBPYmplY3Qua2V5cyh0KS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5sb2FkVlRMYXllcnMoKTtcblxuICAgICAgICBmb3IgKHZhciBuIGluIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgIGlmIChlLnN0eWxlLmhhc0xheWVyKG4pKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuYnVja2V0c1tuXSxcbiAgICAgICAgICAgICAgICBhID0gaS5sYXllcnNbMF0uc291cmNlTGF5ZXIgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLFxuICAgICAgICAgICAgICAgIG8gPSByW2FdLFxuICAgICAgICAgICAgICAgIHMgPSB0W2FdO1xuXG4gICAgICAgICAgICBpZiAobyAmJiBzICYmIDAgIT09IE9iamVjdC5rZXlzKHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpLnVwZGF0ZShzLCBvLCB0aGlzLmltYWdlQXRsYXMgJiYgdGhpcy5pbWFnZUF0bGFzLnBhdHRlcm5Qb3NpdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICB2YXIgdSA9IGUgJiYgZS5zdHlsZSAmJiBlLnN0eWxlLmdldExheWVyKG4pO1xuICAgICAgICAgICAgICB1ICYmICh0aGlzLnF1ZXJ5UGFkZGluZyA9IE1hdGgubWF4KHRoaXMucXVlcnlQYWRkaW5nLCB1LnF1ZXJ5UmFkaXVzKGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgYXAucHJvdG90eXBlLmhvbGRpbmdGb3JGYWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsO1xuICAgIH0sIGFwLnByb3RvdHlwZS5zeW1ib2xGYWRlRmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3ltYm9sRmFkZUhvbGRVbnRpbCB8fCB0aGlzLnN5bWJvbEZhZGVIb2xkVW50aWwgPCBPLm5vdygpO1xuICAgIH0sIGFwLnByb3RvdHlwZS5jbGVhckZhZGVIb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsID0gdm9pZCAwO1xuICAgIH0sIGFwLnByb3RvdHlwZS5zZXRIb2xkRHVyYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsID0gTy5ub3coKSArIHQ7XG4gICAgfSwgYXAucHJvdG90eXBlLnNldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0ge30sIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgcltpW25dXSA9ICEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlcGVuZGVuY2llc1t0XSA9IHI7XG4gICAgfSwgYXAucHJvdG90eXBlLmhhc0RlcGVuZGVuY3kgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSB0OyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwZW5kZW5jaWVzW25bcl1dO1xuICAgICAgICBpZiAoaSkgZm9yICh2YXIgYSA9IDAsIG8gPSBlOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgIGlmIChpW29bYV1dKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH07XG5cbiAgICB2YXIgb3AgPSBvLnBlcmZvcm1hbmNlLFxuICAgICAgICBzcCA9IGZ1bmN0aW9uIHNwKHQpIHtcbiAgICAgIHRoaXMuX21hcmtzID0ge1xuICAgICAgICBzdGFydDogW3QudXJsLCBcInN0YXJ0XCJdLmpvaW4oXCIjXCIpLFxuICAgICAgICBlbmQ6IFt0LnVybCwgXCJlbmRcIl0uam9pbihcIiNcIiksXG4gICAgICAgIG1lYXN1cmU6IHQudXJsLnRvU3RyaW5nKClcbiAgICAgIH0sIG9wLm1hcmsodGhpcy5fbWFya3Muc3RhcnQpO1xuICAgIH07XG5cbiAgICBzcC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3AubWFyayh0aGlzLl9tYXJrcy5lbmQpO1xuICAgICAgdmFyIHQgPSBvcC5nZXRFbnRyaWVzQnlOYW1lKHRoaXMuX21hcmtzLm1lYXN1cmUpO1xuICAgICAgcmV0dXJuIDAgPT09IHQubGVuZ3RoICYmIChvcC5tZWFzdXJlKHRoaXMuX21hcmtzLm1lYXN1cmUsIHRoaXMuX21hcmtzLnN0YXJ0LCB0aGlzLl9tYXJrcy5lbmQpLCB0ID0gb3AuZ2V0RW50cmllc0J5TmFtZSh0aGlzLl9tYXJrcy5tZWFzdXJlKSwgb3AuY2xlYXJNYXJrcyh0aGlzLl9tYXJrcy5zdGFydCksIG9wLmNsZWFyTWFya3ModGhpcy5fbWFya3MuZW5kKSwgb3AuY2xlYXJNZWFzdXJlcyh0aGlzLl9tYXJrcy5tZWFzdXJlKSksIHQ7XG4gICAgfSwgdC5BY3RvciA9IEZsLCB0LkFscGhhSW1hZ2UgPSBnbywgdC5DYW5vbmljYWxUaWxlSUQgPSBabCwgdC5Db2xsaXNpb25Cb3hBcnJheSA9ICRpLCB0LkNvbG9yID0gdGUsIHQuREVNRGF0YSA9IFlsLCB0LkRhdGFDb25zdGFudFByb3BlcnR5ID0gbWksIHQuRGljdGlvbmFyeUNvZGVyID0gJGwsIHQuRVhURU5UID0gODE5MiwgdC5FcnJvckV2ZW50ID0genQsIHQuRXZhbHVhdGlvblBhcmFtZXRlcnMgPSBzaSwgdC5FdmVudCA9IEl0LCB0LkV2ZW50ZWQgPSBDdCwgdC5GZWF0dXJlSW5kZXggPSBlcCwgdC5GaWxsQnVja2V0ID0gc3MsIHQuRmlsbEV4dHJ1c2lvbkJ1Y2tldCA9IFNzLCB0LkltYWdlQXRsYXMgPSBidSwgdC5JbWFnZVBvc2l0aW9uID0gZ3UsIHQuTGluZUJ1Y2tldCA9IEZzLCB0LkxuZ0xhdCA9IE9sLCB0LkxuZ0xhdEJvdW5kcyA9IExsLCB0Lk1lcmNhdG9yQ29vcmRpbmF0ZSA9IEdsLCB0Lk9ORV9FTSA9IDI0LCB0Lk92ZXJzY2FsZWRUaWxlSUQgPSBKbCwgdC5Qb2ludCA9IGksIHQuUG9pbnQkMSA9IGksIHQuUHJvcGVydGllcyA9IHdpLCB0LlByb3RvYnVmID0gWXMsIHQuUkdCQUltYWdlID0geG8sIHQuUmVxdWVzdE1hbmFnZXIgPSBHLCB0LlJlcXVlc3RQZXJmb3JtYW5jZSA9IHNwLCB0LlJlc291cmNlVHlwZSA9IHl0LCB0LlNlZ21lbnRWZWN0b3IgPSBzYSwgdC5Tb3VyY2VGZWF0dXJlU3RhdGUgPSB0cCwgdC5TdHJ1Y3RBcnJheUxheW91dDF1aTIgPSBKaSwgdC5TdHJ1Y3RBcnJheUxheW91dDJmMWYyaTE2ID0gUmksIHQuU3RydWN0QXJyYXlMYXlvdXQyaTQgPSBDaSwgdC5TdHJ1Y3RBcnJheUxheW91dDN1aTYgPSBqaSwgdC5TdHJ1Y3RBcnJheUxheW91dDRpOCA9IEVpLCB0LlN5bWJvbEJ1Y2tldCA9IHZsLCB0LlRleHR1cmUgPSBUbCwgdC5UaWxlID0gYXAsIHQuVHJhbnNpdGlvbmFibGUgPSBwaSwgdC5Vbmlmb3JtMWYgPSBiYSwgdC5Vbmlmb3JtMWkgPSB4YSwgdC5Vbmlmb3JtMmYgPSB3YSwgdC5Vbmlmb3JtM2YgPSBfYSwgdC5Vbmlmb3JtNGYgPSBBYSwgdC5Vbmlmb3JtQ29sb3IgPSBTYSwgdC5Vbmlmb3JtTWF0cml4NGYgPSBJYSwgdC5VbndyYXBwZWRUaWxlSUQgPSBYbCwgdC5WYWxpZGF0aW9uRXJyb3IgPSBQdCwgdC5Xcml0aW5nTW9kZSA9IHd1LCB0Llpvb21IaXN0b3J5ID0gS24sIHQuYWRkID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSArIHJbMF0sIHRbMV0gPSBlWzFdICsgclsxXSwgdFsyXSA9IGVbMl0gKyByWzJdLCB0O1xuICAgIH0sIHQuYWRkRHluYW1pY0F0dHJpYnV0ZXMgPSBmbCwgdC5hc3luY0FsbCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAoIXQubGVuZ3RoKSByZXR1cm4gcihudWxsLCBbXSk7XG4gICAgICB2YXIgbiA9IHQubGVuZ3RoLFxuICAgICAgICAgIGkgPSBuZXcgQXJyYXkodC5sZW5ndGgpLFxuICAgICAgICAgIGEgPSBudWxsO1xuICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgIGUodCwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB0ICYmIChhID0gdCksIGlbb10gPSBlLCAwID09IC0tbiAmJiByKGEsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHQuYmV6aWVyID0gdSwgdC5iaW5kQWxsID0gdiwgdC5icm93c2VyID0gTywgdC5jYWNoZUVudHJ5UG9zc2libHlBZGRlZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICArK2h0ID4gdXQgJiYgKHQuZ2V0QWN0b3IoKS5zZW5kKFwiZW5mb3JjZUNhY2hlU2l6ZUxpbWl0XCIsIHN0KSwgaHQgPSAwKTtcbiAgICB9LCB0LmNsYW1wID0gcCwgdC5jbGVhclRpbGVDYWNoZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG8uY2FjaGVzLmRlbGV0ZShcIm1hcGJveC10aWxlc1wiKTtcbiAgICAgIHQgJiYgZS5jYXRjaCh0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQoKTtcbiAgICAgIH0pO1xuICAgIH0sIHQuY2xpcExpbmUgPSBadSwgdC5jbG9uZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyBhbygxNik7XG4gICAgICByZXR1cm4gZVswXSA9IHRbMF0sIGVbMV0gPSB0WzFdLCBlWzJdID0gdFsyXSwgZVszXSA9IHRbM10sIGVbNF0gPSB0WzRdLCBlWzVdID0gdFs1XSwgZVs2XSA9IHRbNl0sIGVbN10gPSB0WzddLCBlWzhdID0gdFs4XSwgZVs5XSA9IHRbOV0sIGVbMTBdID0gdFsxMF0sIGVbMTFdID0gdFsxMV0sIGVbMTJdID0gdFsxMl0sIGVbMTNdID0gdFsxM10sIGVbMTRdID0gdFsxNF0sIGVbMTVdID0gdFsxNV0sIGU7XG4gICAgfSwgdC5jbG9uZSQxID0gdywgdC5jbG9uZSQyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IGFvKDMpO1xuICAgICAgcmV0dXJuIGVbMF0gPSB0WzBdLCBlWzFdID0gdFsxXSwgZVsyXSA9IHRbMl0sIGU7XG4gICAgfSwgdC5jb2xsaXNpb25DaXJjbGVMYXlvdXQgPSBHcywgdC5jb25maWcgPSBSLCB0LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gbmV3IGFvKDE2KTtcbiAgICAgIHJldHVybiBhbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNF0gPSAwLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAwLCB0WzldID0gMCwgdFsxMV0gPSAwLCB0WzEyXSA9IDAsIHRbMTNdID0gMCwgdFsxNF0gPSAwKSwgdFswXSA9IDEsIHRbNV0gPSAxLCB0WzEwXSA9IDEsIHRbMTVdID0gMSwgdDtcbiAgICB9LCB0LmNyZWF0ZSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgYW8oOSk7XG4gICAgICByZXR1cm4gYW8gIT0gRmxvYXQzMkFycmF5ICYmICh0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwLCB0WzVdID0gMCwgdFs2XSA9IDAsIHRbN10gPSAwKSwgdFswXSA9IDEsIHRbNF0gPSAxLCB0WzhdID0gMSwgdDtcbiAgICB9LCB0LmNyZWF0ZSQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgYW8oNCk7XG4gICAgICByZXR1cm4gYW8gIT0gRmxvYXQzMkFycmF5ICYmICh0WzFdID0gMCwgdFsyXSA9IDApLCB0WzBdID0gMSwgdFszXSA9IDEsIHQ7XG4gICAgfSwgdC5jcmVhdGVDb21tb25qc01vZHVsZSA9IGUsIHQuY3JlYXRlRXhwcmVzc2lvbiA9IFpyLCB0LmNyZWF0ZUxheW91dCA9IElpLCB0LmNyZWF0ZVN0eWxlTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIFwiY3VzdG9tXCIgPT09IHQudHlwZSA/IG5ldyBJbCh0KSA6IG5ldyB6bFt0LnR5cGVdKHQpO1xuICAgIH0sIHQuY3Jvc3MgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICAgIGkgPSBlWzFdLFxuICAgICAgICAgIGEgPSBlWzJdLFxuICAgICAgICAgIG8gPSByWzBdLFxuICAgICAgICAgIHMgPSByWzFdLFxuICAgICAgICAgIHUgPSByWzJdO1xuICAgICAgcmV0dXJuIHRbMF0gPSBpICogdSAtIGEgKiBzLCB0WzFdID0gYSAqIG8gLSBuICogdSwgdFsyXSA9IG4gKiBzIC0gaSAqIG8sIHQ7XG4gICAgfSwgdC5kZWVwRXF1YWwgPSBmdW5jdGlvbiB0KGUsIHIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyKSB8fCBlLmxlbmd0aCAhPT0gci5sZW5ndGgpIHJldHVybiAhMTtcblxuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBpZiAoIXQoZVtuXSwgcltuXSkpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSAmJiBudWxsICE9PSByKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiByKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhlKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHIpLmxlbmd0aCkgcmV0dXJuICExO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gZSkge1xuICAgICAgICAgIGlmICghdChlW2ldLCByW2ldKSkgcmV0dXJuICExO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSA9PT0gcjtcbiAgICB9LCB0LmRvdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdFswXSAqIGVbMF0gKyB0WzFdICogZVsxXSArIHRbMl0gKiBlWzJdO1xuICAgIH0sIHQuZG90JDEgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRbMF0gKiBlWzBdICsgdFsxXSAqIGVbMV0gKyB0WzJdICogZVsyXSArIHRbM10gKiBlWzNdO1xuICAgIH0sIHQuZWFzZSA9IGwsIHQuZW1pdFZhbGlkYXRpb25FcnJvcnMgPSBCbiwgdC5lbmRzV2l0aCA9IGcsIHQuZW5mb3JjZUNhY2hlU2l6ZUxpbWl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGx0KCksIHR0ICYmIHR0LnRoZW4oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5rZXlzKCkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgci5sZW5ndGggLSB0OyBuKyspIHtcbiAgICAgICAgICAgIGUuZGVsZXRlKHJbbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCB0LmV2YWx1YXRlU2l6ZUZvckZlYXR1cmUgPSBMdSwgdC5ldmFsdWF0ZVNpemVGb3Jab29tID0gT3UsIHQuZXZhbHVhdGVWYXJpYWJsZU9mZnNldCA9IGFsLCB0LmV2ZW50ZWQgPSBuaSwgdC5leHRlbmQgPSBoLCB0LmZlYXR1cmVGaWx0ZXIgPSBvbiwgdC5maWx0ZXJPYmplY3QgPSBiLCB0LmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IE1hdGguc2luKGUpLFxuICAgICAgICAgIG4gPSBNYXRoLmNvcyhlKTtcbiAgICAgIHJldHVybiB0WzBdID0gbiwgdFsxXSA9IHIsIHRbMl0gPSAwLCB0WzNdID0gLXIsIHRbNF0gPSBuLCB0WzVdID0gMCwgdFs2XSA9IDAsIHRbN10gPSAwLCB0WzhdID0gMSwgdDtcbiAgICB9LCB0LmdldEFuY2hvckFsaWdubWVudCA9IEJ1LCB0LmdldEFuY2hvckp1c3RpZmljYXRpb24gPSBvbCwgdC5nZXRBcnJheUJ1ZmZlciA9IGJ0LCB0LmdldEltYWdlID0gQXQsIHQuZ2V0SlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4geHQoaCh0LCB7XG4gICAgICAgIHR5cGU6IFwianNvblwiXG4gICAgICB9KSwgZSk7XG4gICAgfSwgdC5nZXRSVExUZXh0UGx1Z2luU3RhdHVzID0gaWksIHQuZ2V0UmVmZXJyZXIgPSBtdCwgdC5nZXRWaWRlbyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIGkgPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgIGkubXV0ZWQgPSAhMCwgaS5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZShudWxsLCBpKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgcyA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgICAgciA9IHRbYV0sIG4gPSB2b2lkIDAsIChuID0gby5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSkuaHJlZiA9IHIsIChuLnByb3RvY29sICE9PSBvLmRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sIHx8IG4uaG9zdCAhPT0gby5kb2N1bWVudC5sb2NhdGlvbi5ob3N0KSAmJiAoaS5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCIpLCBzLnNyYyA9IHRbYV0sIGkuYXBwZW5kQ2hpbGQocyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge31cbiAgICAgIH07XG4gICAgfSwgdC5pZGVudGl0eSA9IG9vLCB0LmludmVydCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgICAgaSA9IGVbMl0sXG4gICAgICAgICAgYSA9IGVbM10sXG4gICAgICAgICAgbyA9IGVbNF0sXG4gICAgICAgICAgcyA9IGVbNV0sXG4gICAgICAgICAgdSA9IGVbNl0sXG4gICAgICAgICAgbCA9IGVbN10sXG4gICAgICAgICAgcCA9IGVbOF0sXG4gICAgICAgICAgYyA9IGVbOV0sXG4gICAgICAgICAgaCA9IGVbMTBdLFxuICAgICAgICAgIGYgPSBlWzExXSxcbiAgICAgICAgICB5ID0gZVsxMl0sXG4gICAgICAgICAgZCA9IGVbMTNdLFxuICAgICAgICAgIG0gPSBlWzE0XSxcbiAgICAgICAgICB2ID0gZVsxNV0sXG4gICAgICAgICAgZyA9IHIgKiBzIC0gbiAqIG8sXG4gICAgICAgICAgeCA9IHIgKiB1IC0gaSAqIG8sXG4gICAgICAgICAgYiA9IHIgKiBsIC0gYSAqIG8sXG4gICAgICAgICAgdyA9IG4gKiB1IC0gaSAqIHMsXG4gICAgICAgICAgXyA9IG4gKiBsIC0gYSAqIHMsXG4gICAgICAgICAgQSA9IGkgKiBsIC0gYSAqIHUsXG4gICAgICAgICAgUyA9IHAgKiBkIC0gYyAqIHksXG4gICAgICAgICAgayA9IHAgKiBtIC0gaCAqIHksXG4gICAgICAgICAgSSA9IHAgKiB2IC0gZiAqIHksXG4gICAgICAgICAgeiA9IGMgKiBtIC0gaCAqIGQsXG4gICAgICAgICAgQyA9IGMgKiB2IC0gZiAqIGQsXG4gICAgICAgICAgRSA9IGggKiB2IC0gZiAqIG0sXG4gICAgICAgICAgUCA9IGcgKiBFIC0geCAqIEMgKyBiICogeiArIHcgKiBJIC0gXyAqIGsgKyBBICogUztcblxuICAgICAgcmV0dXJuIFAgPyAodFswXSA9IChzICogRSAtIHUgKiBDICsgbCAqIHopICogKFAgPSAxIC8gUCksIHRbMV0gPSAoaSAqIEMgLSBuICogRSAtIGEgKiB6KSAqIFAsIHRbMl0gPSAoZCAqIEEgLSBtICogXyArIHYgKiB3KSAqIFAsIHRbM10gPSAoaCAqIF8gLSBjICogQSAtIGYgKiB3KSAqIFAsIHRbNF0gPSAodSAqIEkgLSBvICogRSAtIGwgKiBrKSAqIFAsIHRbNV0gPSAociAqIEUgLSBpICogSSArIGEgKiBrKSAqIFAsIHRbNl0gPSAobSAqIGIgLSB5ICogQSAtIHYgKiB4KSAqIFAsIHRbN10gPSAocCAqIEEgLSBoICogYiArIGYgKiB4KSAqIFAsIHRbOF0gPSAobyAqIEMgLSBzICogSSArIGwgKiBTKSAqIFAsIHRbOV0gPSAobiAqIEkgLSByICogQyAtIGEgKiBTKSAqIFAsIHRbMTBdID0gKHkgKiBfIC0gZCAqIGIgKyB2ICogZykgKiBQLCB0WzExXSA9IChjICogYiAtIHAgKiBfIC0gZiAqIGcpICogUCwgdFsxMl0gPSAocyAqIGsgLSBvICogeiAtIHUgKiBTKSAqIFAsIHRbMTNdID0gKHIgKiB6IC0gbiAqIGsgKyBpICogUykgKiBQLCB0WzE0XSA9IChkICogeCAtIHkgKiB3IC0gbSAqIGcpICogUCwgdFsxNV0gPSAocCAqIHcgLSBjICogeCArIGggKiBnKSAqIFAsIHQpIDogbnVsbDtcbiAgICB9LCB0LmlzQ2hhciA9IEduLCB0LmlzTWFwYm94VVJMID0gWiwgdC5rZXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuIGluIHQpIHtcbiAgICAgICAgbiBpbiBlIHx8IHIucHVzaChuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgdC5tYWtlUmVxdWVzdCA9IHh0LCB0Lm1hcE9iamVjdCA9IHgsIHQubWVyY2F0b3JYZnJvbUxuZyA9IGpsLCB0Lm1lcmNhdG9yWWZyb21MYXQgPSBxbCwgdC5tZXJjYXRvclpmcm9tQWx0aXR1ZGUgPSBObCwgdC5tdWwgPSBsbywgdC5tdWx0aXBseSA9IHNvLCB0Lm12dCA9IGJzLCB0Lm5leHRQb3dlck9mVHdvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0IDw9IDEgPyAxIDogTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHQpIC8gTWF0aC5MTjIpKTtcbiAgICB9LCB0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgICAgaSA9IGVbMl0sXG4gICAgICAgICAgYSA9IHIgKiByICsgbiAqIG4gKyBpICogaTtcbiAgICAgIHJldHVybiBhID4gMCAmJiAoYSA9IDEgLyBNYXRoLnNxcnQoYSkpLCB0WzBdID0gZVswXSAqIGEsIHRbMV0gPSBlWzFdICogYSwgdFsyXSA9IGVbMl0gKiBhLCB0O1xuICAgIH0sIHQubnVtYmVyID0gS2UsIHQub2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gZnQsIHQub3J0aG8gPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgdmFyIHMgPSAxIC8gKGUgLSByKSxcbiAgICAgICAgICB1ID0gMSAvIChuIC0gaSksXG4gICAgICAgICAgbCA9IDEgLyAoYSAtIG8pO1xuICAgICAgcmV0dXJuIHRbMF0gPSAtMiAqIHMsIHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNF0gPSAwLCB0WzVdID0gLTIgKiB1LCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAwLCB0WzldID0gMCwgdFsxMF0gPSAyICogbCwgdFsxMV0gPSAwLCB0WzEyXSA9IChlICsgcikgKiBzLCB0WzEzXSA9IChpICsgbikgKiB1LCB0WzE0XSA9IChvICsgYSkgKiBsLCB0WzE1XSA9IDEsIHQ7XG4gICAgfSwgdC5wYXJzZUdseXBoUEJGID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgWXModCkucmVhZEZpZWxkcyh5dSwgW10pO1xuICAgIH0sIHQucGJmID0gWXMsIHQucGVyZm9ybVN5bWJvbExheW91dCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICB0LmNyZWF0ZUFycmF5cygpLCB0LnRpbGVQaXhlbFJhdGlvID0gODE5MiAvICg1MTIgKiB0Lm92ZXJzY2FsaW5nKSwgdC5jb21wYXJlVGV4dCA9IHt9LCB0Lmljb25zTmVlZExpbmVhciA9ICExO1xuICAgICAgdmFyIHMgPSB0LmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgdSA9IHQubGF5ZXJzWzBdLl91bmV2YWx1YXRlZExheW91dC5fdmFsdWVzLFxuICAgICAgICAgIGwgPSB7fTtcblxuICAgICAgaWYgKFwiY29tcG9zaXRlXCIgPT09IHQudGV4dFNpemVEYXRhLmtpbmQpIHtcbiAgICAgICAgdmFyIHAgPSB0LnRleHRTaXplRGF0YSxcbiAgICAgICAgICAgIGMgPSBwLm1heFpvb207XG4gICAgICAgIGwuY29tcG9zaXRlVGV4dFNpemVzID0gW3VbXCJ0ZXh0LXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgc2kocC5taW5ab29tKSwgbyksIHVbXCJ0ZXh0LXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgc2koYyksIG8pXTtcbiAgICAgIH1cblxuICAgICAgaWYgKFwiY29tcG9zaXRlXCIgPT09IHQuaWNvblNpemVEYXRhLmtpbmQpIHtcbiAgICAgICAgdmFyIGggPSB0Lmljb25TaXplRGF0YSxcbiAgICAgICAgICAgIGYgPSBoLm1heFpvb207XG4gICAgICAgIGwuY29tcG9zaXRlSWNvblNpemVzID0gW3VbXCJpY29uLXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgc2koaC5taW5ab29tKSwgbyksIHVbXCJpY29uLXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgc2koZiksIG8pXTtcbiAgICAgIH1cblxuICAgICAgbC5sYXlvdXRUZXh0U2l6ZSA9IHVbXCJ0ZXh0LXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgc2kodC56b29tICsgMSksIG8pLCBsLmxheW91dEljb25TaXplID0gdVtcImljb24tc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyBzaSh0Lnpvb20gKyAxKSwgbyksIGwudGV4dE1heFNpemUgPSB1W1widGV4dC1zaXplXCJdLnBvc3NpYmx5RXZhbHVhdGUobmV3IHNpKDE4KSk7XG5cbiAgICAgIGZvciAodmFyIHkgPSAyNCAqIHMuZ2V0KFwidGV4dC1saW5lLWhlaWdodFwiKSwgZCA9IFwibWFwXCIgPT09IHMuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgXCJwb2ludFwiICE9PSBzLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksIG0gPSBzLmdldChcInRleHQta2VlcC11cHJpZ2h0XCIpLCB2ID0gcy5nZXQoXCJ0ZXh0LXNpemVcIiksIGcgPSBmdW5jdGlvbiBnKCkge1xuICAgICAgICB2YXIgYSA9IGJbeF0sXG4gICAgICAgICAgICB1ID0gcy5nZXQoXCJ0ZXh0LWZvbnRcIikuZXZhbHVhdGUoYSwge30sIG8pLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgcCA9IHYuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgYyA9IGwubGF5b3V0VGV4dFNpemUuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgaCA9IGwubGF5b3V0SWNvblNpemUuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgZiA9IHtcbiAgICAgICAgICBob3Jpem9udGFsOiB7fSxcbiAgICAgICAgICB2ZXJ0aWNhbDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgICAgICBnID0gYS50ZXh0LFxuICAgICAgICAgICAgdyA9IFswLCAwXTtcblxuICAgICAgICBpZiAoZykge1xuICAgICAgICAgIHZhciBfID0gZy50b1N0cmluZygpLFxuICAgICAgICAgICAgICBTID0gMjQgKiBzLmdldChcInRleHQtbGV0dGVyLXNwYWNpbmdcIikuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgICBrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG4gPSByW2VdLmNoYXJDb2RlQXQoMCksIEduLkFyYWJpYyhuKSB8fCBHbltcIkFyYWJpYyBTdXBwbGVtZW50XCJdKG4pIHx8IEduW1wiQXJhYmljIEV4dGVuZGVkLUFcIl0obikgfHwgR25bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIl0obikgfHwgR25bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIl0obikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgfShfKSA/IFMgOiAwLFxuICAgICAgICAgICAgICBJID0gcy5nZXQoXCJ0ZXh0LWFuY2hvclwiKS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICAgIHogPSBzLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpO1xuXG4gICAgICAgICAgaWYgKCF6KSB7XG4gICAgICAgICAgICB2YXIgQyA9IHMuZ2V0KFwidGV4dC1yYWRpYWwtb2Zmc2V0XCIpLmV2YWx1YXRlKGEsIHt9LCBvKTtcbiAgICAgICAgICAgIHcgPSBDID8gYWwoSSwgWzI0ICogQywgaWxdKSA6IHMuZ2V0KFwidGV4dC1vZmZzZXRcIikuZXZhbHVhdGUoYSwge30sIG8pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gMjQgKiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEUgPSBkID8gXCJjZW50ZXJcIiA6IHMuZ2V0KFwidGV4dC1qdXN0aWZ5XCIpLmV2YWx1YXRlKGEsIHt9LCBvKSxcbiAgICAgICAgICAgICAgUCA9IHMuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSxcbiAgICAgICAgICAgICAgTSA9IFwicG9pbnRcIiA9PT0gUCA/IDI0ICogcy5nZXQoXCJ0ZXh0LW1heC13aWR0aFwiKS5ldmFsdWF0ZShhLCB7fSwgbykgOiAwLFxuICAgICAgICAgICAgICBCID0gZnVuY3Rpb24gQigpIHtcbiAgICAgICAgICAgIHQuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiBabihfKSAmJiAoZi52ZXJ0aWNhbCA9IFN1KGcsIGUsIHIsIGksIHUsIE0sIHksIEksIFwibGVmdFwiLCBrLCB3LCB3dS52ZXJ0aWNhbCwgITAsIFAsIGMsIHApKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFkICYmIHopIHtcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSBcImF1dG9cIiA9PT0gRSA/IHoubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBvbCh0KTtcbiAgICAgICAgICAgIH0pIDogW0VdLCBWID0gITEsIEYgPSAwOyBGIDwgVC5sZW5ndGg7IEYrKykge1xuICAgICAgICAgICAgICB2YXIgRCA9IFRbRl07XG4gICAgICAgICAgICAgIGlmICghZi5ob3Jpem9udGFsW0RdKSBpZiAoVikgZi5ob3Jpem9udGFsW0RdID0gZi5ob3Jpem9udGFsWzBdO2Vsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBMID0gU3UoZywgZSwgciwgaSwgdSwgTSwgeSwgXCJjZW50ZXJcIiwgRCwgaywgdywgd3UuaG9yaXpvbnRhbCwgITEsIFAsIGMsIHApO1xuICAgICAgICAgICAgICAgIEwgJiYgKGYuaG9yaXpvbnRhbFtEXSA9IEwsIFYgPSAxID09PSBMLnBvc2l0aW9uZWRMaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXCJhdXRvXCIgPT09IEUgJiYgKEUgPSBvbChJKSk7XG4gICAgICAgICAgICB2YXIgTyA9IFN1KGcsIGUsIHIsIGksIHUsIE0sIHksIEksIEUsIGssIHcsIHd1Lmhvcml6b250YWwsICExLCBQLCBjLCBwKTtcbiAgICAgICAgICAgIE8gJiYgKGYuaG9yaXpvbnRhbFtFXSA9IE8pLCBCKCksIFpuKF8pICYmIGQgJiYgbSAmJiAoZi52ZXJ0aWNhbCA9IFN1KGcsIGUsIHIsIGksIHUsIE0sIHksIEksIEUsIGssIHcsIHd1LnZlcnRpY2FsLCAhMSwgUCwgYywgcCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBSID0gdm9pZCAwLFxuICAgICAgICAgICAgVSA9ICExO1xuXG4gICAgICAgIGlmIChhLmljb24gJiYgYS5pY29uLm5hbWUpIHtcbiAgICAgICAgICB2YXIgaiA9IG5bYS5pY29uLm5hbWVdO1xuICAgICAgICAgIGogJiYgKFIgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIG4gPSBCdShyKSxcbiAgICAgICAgICAgICAgICBpID0gZVswXSAtIHQuZGlzcGxheVNpemVbMF0gKiBuLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgICAgICAgICBhID0gZVsxXSAtIHQuZGlzcGxheVNpemVbMV0gKiBuLnZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbWFnZTogdCxcbiAgICAgICAgICAgICAgdG9wOiBhLFxuICAgICAgICAgICAgICBib3R0b206IGEgKyB0LmRpc3BsYXlTaXplWzFdLFxuICAgICAgICAgICAgICBsZWZ0OiBpLFxuICAgICAgICAgICAgICByaWdodDogaSArIHQuZGlzcGxheVNpemVbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShpW2EuaWNvbi5uYW1lXSwgcy5nZXQoXCJpY29uLW9mZnNldFwiKS5ldmFsdWF0ZShhLCB7fSwgbyksIHMuZ2V0KFwiaWNvbi1hbmNob3JcIikuZXZhbHVhdGUoYSwge30sIG8pKSwgVSA9IGouc2RmLCB2b2lkIDAgPT09IHQuc2RmSWNvbnMgPyB0LnNkZkljb25zID0gai5zZGYgOiB0LnNkZkljb25zICE9PSBqLnNkZiAmJiBBKFwiU3R5bGUgc2hlZXQgd2FybmluZzogQ2Fubm90IG1peCBTREYgYW5kIG5vbi1TREYgaWNvbnMgaW4gb25lIGJ1ZmZlclwiKSwgKGoucGl4ZWxSYXRpbyAhPT0gdC5waXhlbFJhdGlvIHx8IDAgIT09IHMuZ2V0KFwiaWNvbi1yb3RhdGVcIikuY29uc3RhbnRPcigxKSkgJiYgKHQuaWNvbnNOZWVkTGluZWFyID0gITApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBxID0gdWwoZi5ob3Jpem9udGFsKSB8fCBmLnZlcnRpY2FsO1xuICAgICAgICB0Lmljb25zSW5UZXh0ID0gISFxICYmIHEuaWNvbnNJblRleHQsIChxIHx8IFIpICYmIGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwKSB7XG4gICAgICAgICAgdmFyIGMgPSBhLnRleHRNYXhTaXplLmV2YWx1YXRlKGUsIHt9KTtcbiAgICAgICAgICB2b2lkIDAgPT09IGMgJiYgKGMgPSBvKTtcblxuICAgICAgICAgIHZhciBoLFxuICAgICAgICAgICAgICBmID0gdC5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgICAgICB5ID0gZi5nZXQoXCJpY29uLW9mZnNldFwiKS5ldmFsdWF0ZShlLCB7fSwgcCksXG4gICAgICAgICAgICAgIGQgPSB1bChyLmhvcml6b250YWwpLFxuICAgICAgICAgICAgICBtID0gbyAvIDI0LFxuICAgICAgICAgICAgICB2ID0gdC50aWxlUGl4ZWxSYXRpbyAqIG0sXG4gICAgICAgICAgICAgIGcgPSB0LnRpbGVQaXhlbFJhdGlvICogYyAvIDI0LFxuICAgICAgICAgICAgICB4ID0gdC50aWxlUGl4ZWxSYXRpbyAqIHMsXG4gICAgICAgICAgICAgIGIgPSB0LnRpbGVQaXhlbFJhdGlvICogZi5nZXQoXCJzeW1ib2wtc3BhY2luZ1wiKSxcbiAgICAgICAgICAgICAgdyA9IGYuZ2V0KFwidGV4dC1wYWRkaW5nXCIpICogdC50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgXyA9IGYuZ2V0KFwiaWNvbi1wYWRkaW5nXCIpICogdC50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgUyA9IGYuZ2V0KFwidGV4dC1tYXgtYW5nbGVcIikgLyAxODAgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICBrID0gXCJtYXBcIiA9PT0gZi5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSAmJiBcInBvaW50XCIgIT09IGYuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSxcbiAgICAgICAgICAgICAgSSA9IFwibWFwXCIgPT09IGYuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgXCJwb2ludFwiICE9PSBmLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksXG4gICAgICAgICAgICAgIHogPSBmLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksXG4gICAgICAgICAgICAgIEMgPSBiIC8gMixcbiAgICAgICAgICAgICAgRSA9IGYuZ2V0KFwiaWNvbi10ZXh0LWZpdFwiKTtcblxuICAgICAgICAgIG4gJiYgXCJub25lXCIgIT09IEUgJiYgKHQuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiByLnZlcnRpY2FsICYmIChoID0gVnUobiwgci52ZXJ0aWNhbCwgRSwgZi5nZXQoXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIiksIHksIG0pKSwgZCAmJiAobiA9IFZ1KG4sIGQsIEUsIGYuZ2V0KFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCIpLCB5LCBtKSkpO1xuXG4gICAgICAgICAgdmFyIFAgPSBmdW5jdGlvbiBQKHMsIGMpIHtcbiAgICAgICAgICAgIGMueCA8IDAgfHwgYy54ID49IDgxOTIgfHwgYy55IDwgMCB8fCBjLnkgPj0gODE5MiB8fCBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCwgbSwgdiwgZywgeCwgYiwgdywgXywgUywgaykge1xuICAgICAgICAgICAgICB2YXIgSSxcbiAgICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICAgICAgICBDLFxuICAgICAgICAgICAgICAgICAgRSxcbiAgICAgICAgICAgICAgICAgIFAsXG4gICAgICAgICAgICAgICAgICBNID0gdC5hZGRUb0xpbmVWZXJ0ZXhBcnJheShlLCByKSxcbiAgICAgICAgICAgICAgICAgIEIgPSAwLFxuICAgICAgICAgICAgICAgICAgVCA9IDAsXG4gICAgICAgICAgICAgICAgICBWID0gMCxcbiAgICAgICAgICAgICAgICAgIEYgPSAwLFxuICAgICAgICAgICAgICAgICAgRCA9IC0xLFxuICAgICAgICAgICAgICAgICAgTCA9IC0xLFxuICAgICAgICAgICAgICAgICAgTyA9IHt9LFxuICAgICAgICAgICAgICAgICAgUiA9IGhhKFwiXCIpLFxuICAgICAgICAgICAgICAgICAgVSA9IDAsXG4gICAgICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBzLl91bmV2YWx1YXRlZExheW91dC5nZXRWYWx1ZShcInRleHQtcmFkaWFsLW9mZnNldFwiKSA/IChVID0gKEkgPSBzLmxheW91dC5nZXQoXCJ0ZXh0LW9mZnNldFwiKS5ldmFsdWF0ZShiLCB7fSwgUykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI0ICogdDtcbiAgICAgICAgICAgICAgfSkpWzBdLCBqID0gSVsxXSkgOiAoVSA9IDI0ICogcy5sYXlvdXQuZ2V0KFwidGV4dC1yYWRpYWwtb2Zmc2V0XCIpLmV2YWx1YXRlKGIsIHt9LCBTKSwgaiA9IGlsKSwgdC5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIG4udmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHMubGF5b3V0LmdldChcInRleHQtcm90YXRlXCIpLmV2YWx1YXRlKGIsIHt9LCBTKSArIDkwO1xuICAgICAgICAgICAgICAgIEUgPSBuZXcgV3UodSwgZSwgbCwgcCwgYywgbi52ZXJ0aWNhbCwgaCwgZiwgeSwgcSksIG8gJiYgKFAgPSBuZXcgV3UodSwgZSwgbCwgcCwgYywgbywgbSwgdiwgeSwgcSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IHMubGF5b3V0LmdldChcImljb24tcm90YXRlXCIpLmV2YWx1YXRlKGIsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgSyA9IFwibm9uZVwiICE9PSBzLmxheW91dC5nZXQoXCJpY29uLXRleHQtZml0XCIpLFxuICAgICAgICAgICAgICAgICAgICBHID0gWHUoaSwgTiwgXywgSyksXG4gICAgICAgICAgICAgICAgICAgIFogPSBvID8gWHUobywgTiwgXywgSykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgQyA9IG5ldyBXdSh1LCBlLCBsLCBwLCBjLCBpLCBtLCB2LCAhMSwgTiksIEIgPSA0ICogRy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIFggPSB0Lmljb25TaXplRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgSiA9IG51bGw7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIiA9PT0gWC5raW5kID8gKEogPSBbMTI4ICogcy5sYXlvdXQuZ2V0KFwiaWNvbi1zaXplXCIpLmV2YWx1YXRlKGIsIHt9KV0pWzBdID4gMzI2NDAgJiYgQSh0LmxheWVySWRzWzBdICsgJzogVmFsdWUgZm9yIFwiaWNvbi1zaXplXCIgaXMgPj0gMjU1LiBSZWR1Y2UgeW91ciBcImljb24tc2l6ZVwiLicpIDogXCJjb21wb3NpdGVcIiA9PT0gWC5raW5kICYmICgoSiA9IFsxMjggKiB3LmNvbXBvc2l0ZUljb25TaXplc1swXS5ldmFsdWF0ZShiLCB7fSwgUyksIDEyOCAqIHcuY29tcG9zaXRlSWNvblNpemVzWzFdLmV2YWx1YXRlKGIsIHt9LCBTKV0pWzBdID4gMzI2NDAgfHwgSlsxXSA+IDMyNjQwKSAmJiBBKHQubGF5ZXJJZHNbMF0gKyAnOiBWYWx1ZSBmb3IgXCJpY29uLXNpemVcIiBpcyA+PSAyNTUuIFJlZHVjZSB5b3VyIFwiaWNvbi1zaXplXCIuJyksIHQuYWRkU3ltYm9scyh0Lmljb24sIEcsIEosIHgsIGcsIGIsICExLCBlLCBNLmxpbmVTdGFydEluZGV4LCBNLmxpbmVMZW5ndGgsIC0xLCBTKSwgRCA9IHQuaWNvbi5wbGFjZWRTeW1ib2xBcnJheS5sZW5ndGggLSAxLCBaICYmIChUID0gNCAqIFoubGVuZ3RoLCB0LmFkZFN5bWJvbHModC5pY29uLCBaLCBKLCB4LCBnLCBiLCB3dS52ZXJ0aWNhbCwgZSwgTS5saW5lU3RhcnRJbmRleCwgTS5saW5lTGVuZ3RoLCAtMSwgUyksIEwgPSB0Lmljb24ucGxhY2VkU3ltYm9sQXJyYXkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBIIGluIG4uaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciBZID0gbi5ob3Jpem9udGFsW0hdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF6KSB7XG4gICAgICAgICAgICAgICAgICBSID0gaGEoWS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgIHZhciAkID0gcy5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGVcIikuZXZhbHVhdGUoYiwge30sIFMpO1xuICAgICAgICAgICAgICAgICAgeiA9IG5ldyBXdSh1LCBlLCBsLCBwLCBjLCBZLCBoLCBmLCB5LCAkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgVyA9IDEgPT09IFkucG9zaXRpb25lZExpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoViArPSBzbCh0LCBlLCBZLCBhLCBzLCB5LCBiLCBkLCBNLCBuLnZlcnRpY2FsID8gd3UuaG9yaXpvbnRhbCA6IHd1Lmhvcml6b250YWxPbmx5LCBXID8gT2JqZWN0LmtleXMobi5ob3Jpem9udGFsKSA6IFtIXSwgTywgRCwgdywgUyksIFcpIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbi52ZXJ0aWNhbCAmJiAoRiArPSBzbCh0LCBlLCBuLnZlcnRpY2FsLCBhLCBzLCB5LCBiLCBkLCBNLCB3dS52ZXJ0aWNhbCwgW1widmVydGljYWxcIl0sIE8sIEwsIHcsIFMpKTtcblxuICAgICAgICAgICAgICB2YXIgUSA9IHogPyB6LmJveFN0YXJ0SW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHR0ID0geiA/IHouYm94RW5kSW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGV0ID0gRSA/IEUuYm94U3RhcnRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgcnQgPSBFID8gRS5ib3hFbmRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgbnQgPSBDID8gQy5ib3hTdGFydEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBpdCA9IEMgPyBDLmJveEVuZEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBhdCA9IFAgPyBQLmJveFN0YXJ0SW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIG90ID0gUCA/IFAuYm94RW5kSW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHN0ID0gLTEsXG4gICAgICAgICAgICAgICAgICB1dCA9IGZ1bmN0aW9uIHV0KHQsIGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiB0LmNpcmNsZURpYW1ldGVyID8gTWF0aC5tYXgodC5jaXJjbGVEaWFtZXRlciwgZSkgOiBlO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHN0ID0gdXQoeiwgc3QpLCBzdCA9IHV0KEUsIHN0KSwgc3QgPSB1dChDLCBzdCk7XG4gICAgICAgICAgICAgIHZhciBsdCA9IChzdCA9IHV0KFAsIHN0KSkgPiAtMSA/IDEgOiAwO1xuICAgICAgICAgICAgICBsdCAmJiAoc3QgKj0gayAvIDI0KSwgdC5nbHlwaE9mZnNldEFycmF5Lmxlbmd0aCA+PSB2bC5NQVhfR0xZUEhTICYmIEEoXCJUb28gbWFueSBnbHlwaHMgYmVpbmcgcmVuZGVyZWQgaW4gYSB0aWxlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzI5MDdcIiksIHZvaWQgMCAhPT0gYi5zb3J0S2V5ICYmIHQuYWRkVG9Tb3J0S2V5UmFuZ2VzKHQuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aCwgYi5zb3J0S2V5KSwgdC5zeW1ib2xJbnN0YW5jZXMuZW1wbGFjZUJhY2soZS54LCBlLnksIE8ucmlnaHQgPj0gMCA/IE8ucmlnaHQgOiAtMSwgTy5jZW50ZXIgPj0gMCA/IE8uY2VudGVyIDogLTEsIE8ubGVmdCA+PSAwID8gTy5sZWZ0IDogLTEsIE8udmVydGljYWwgfHwgLTEsIEQsIEwsIFIsIFEsIHR0LCBldCwgcnQsIG50LCBpdCwgYXQsIG90LCBsLCBWLCBGLCBCLCBULCBsdCwgMCwgaCwgVSwgaiwgc3QpO1xuICAgICAgICAgICAgfSh0LCBjLCBzLCByLCBuLCBpLCBoLCB0LmxheWVyc1swXSwgdC5jb2xsaXNpb25Cb3hBcnJheSwgZS5pbmRleCwgZS5zb3VyY2VMYXllckluZGV4LCB0LmluZGV4LCB2LCB3LCBrLCB1LCB4LCBfLCBJLCB5LCBlLCBhLCBsLCBwLCBvKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKFwibGluZVwiID09PSB6KSBmb3IgKHZhciBNID0gMCwgQiA9IFp1KGUuZ2VvbWV0cnksIDAsIDAsIDgxOTIsIDgxOTIpOyBNIDwgQi5sZW5ndGg7IE0gKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgVCA9IEJbTV0sIFYgPSAwLCBGID0gR3UoVCwgYiwgUywgci52ZXJ0aWNhbCB8fCBkLCBuLCAyNCwgZywgdC5vdmVyc2NhbGluZywgODE5Mik7IFYgPCBGLmxlbmd0aDsgViArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBEID0gRltWXTtcbiAgICAgICAgICAgICAgZCAmJiBsbCh0LCBkLnRleHQsIEMsIEQpIHx8IFAoVCwgRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChcImxpbmUtY2VudGVyXCIgPT09IHopIGZvciAodmFyIEwgPSAwLCBPID0gZS5nZW9tZXRyeTsgTCA8IE8ubGVuZ3RoOyBMICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBSID0gT1tMXTtcblxuICAgICAgICAgICAgaWYgKFIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YXIgVSA9IEt1KFIsIFMsIHIudmVydGljYWwgfHwgZCwgbiwgMjQsIGcpO1xuICAgICAgICAgICAgICBVICYmIFAoUiwgVSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gZS50eXBlKSBmb3IgKHZhciBqID0gMCwgcSA9IG5zKGUuZ2VvbWV0cnksIDApOyBqIDwgcS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIE4gPSBxW2pdLFxuICAgICAgICAgICAgICAgIEsgPSBlbChOLCAxNik7XG4gICAgICAgICAgICBQKE5bMF0sIG5ldyBGdShLLngsIEsueSwgMCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJMaW5lU3RyaW5nXCIgPT09IGUudHlwZSkgZm9yICh2YXIgRyA9IDAsIFogPSBlLmdlb21ldHJ5OyBHIDwgWi5sZW5ndGg7IEcgKz0gMSkge1xuICAgICAgICAgICAgdmFyIFggPSBaW0ddO1xuICAgICAgICAgICAgUChYLCBuZXcgRnUoWFswXS54LCBYWzBdLnksIDApKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiUG9pbnRcIiA9PT0gZS50eXBlKSBmb3IgKHZhciBKID0gMCwgSCA9IGUuZ2VvbWV0cnk7IEogPCBILmxlbmd0aDsgSiArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBZID0gMCwgJCA9IEhbSl07IFkgPCAkLmxlbmd0aDsgWSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBXID0gJFtZXTtcbiAgICAgICAgICAgICAgUChbV10sIG5ldyBGdShXLngsIFcueSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSh0LCBhLCBmLCBSLCBuLCBsLCBjLCBoLCB3LCBVLCBvKTtcbiAgICAgIH0sIHggPSAwLCBiID0gdC5mZWF0dXJlczsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgZygpO1xuICAgICAgfVxuXG4gICAgICBhICYmIHQuZ2VuZXJhdGVDb2xsaXNpb25EZWJ1Z0J1ZmZlcnMoKTtcbiAgICB9LCB0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhLFxuICAgICAgICAgIG8gPSAxIC8gTWF0aC50YW4oZSAvIDIpO1xuICAgICAgcmV0dXJuIHRbMF0gPSBvIC8gciwgdFsxXSA9IDAsIHRbMl0gPSAwLCB0WzNdID0gMCwgdFs0XSA9IDAsIHRbNV0gPSBvLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAwLCB0WzldID0gMCwgdFsxMV0gPSAtMSwgdFsxMl0gPSAwLCB0WzEzXSA9IDAsIHRbMTVdID0gMCwgbnVsbCAhPSBpICYmIGkgIT09IDEgLyAwID8gKHRbMTBdID0gKGkgKyBuKSAqIChhID0gMSAvIChuIC0gaSkpLCB0WzE0XSA9IDIgKiBpICogbiAqIGEpIDogKHRbMTBdID0gLTEsIHRbMTRdID0gLTIgKiBuKSwgdDtcbiAgICB9LCB0LnBpY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IHt9LCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGkgPSBlW25dO1xuICAgICAgICBpIGluIHQgJiYgKHJbaV0gPSB0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgdC5wbHVnaW4gPSBvaSwgdC5wb2x5Z29uSW50ZXJzZWN0c1BvbHlnb24gPSBOYSwgdC5wb3N0TWFwTG9hZEV2ZW50ID0gb3QsIHQucG9zdFR1cm5zdGlsZUV2ZW50ID0gaXQsIHQucG90cGFjayA9IHZ1LCB0LnJlZlByb3BlcnRpZXMgPSBbXCJ0eXBlXCIsIFwic291cmNlXCIsIFwic291cmNlLWxheWVyXCIsIFwibWluem9vbVwiLCBcIm1heHpvb21cIiwgXCJmaWx0ZXJcIiwgXCJsYXlvdXRcIl0sIHQucmVnaXN0ZXIgPSBPbiwgdC5yZWdpc3RlckZvclBsdWdpblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0KHtcbiAgICAgICAgcGx1Z2luU3RhdHVzOiBRbixcbiAgICAgICAgcGx1Z2luVVJMOiB0aVxuICAgICAgfSksIG5pLm9uKFwicGx1Z2luU3RhdGVDaGFuZ2VcIiwgdCksIHQ7XG4gICAgfSwgdC5yZW5kZXJDb2xvclJhbXAgPSB3bywgdC5yb3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICAgIGkgPSBlWzFdLFxuICAgICAgICAgIGEgPSBlWzJdLFxuICAgICAgICAgIG8gPSBlWzNdLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbihyKSxcbiAgICAgICAgICB1ID0gTWF0aC5jb3Mocik7XG4gICAgICByZXR1cm4gdFswXSA9IG4gKiB1ICsgYSAqIHMsIHRbMV0gPSBpICogdSArIG8gKiBzLCB0WzJdID0gbiAqIC1zICsgYSAqIHUsIHRbM10gPSBpICogLXMgKyBvICogdSwgdDtcbiAgICB9LCB0LnJvdGF0ZVggPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBNYXRoLnNpbihyKSxcbiAgICAgICAgICBpID0gTWF0aC5jb3MociksXG4gICAgICAgICAgYSA9IGVbNF0sXG4gICAgICAgICAgbyA9IGVbNV0sXG4gICAgICAgICAgcyA9IGVbNl0sXG4gICAgICAgICAgdSA9IGVbN10sXG4gICAgICAgICAgbCA9IGVbOF0sXG4gICAgICAgICAgcCA9IGVbOV0sXG4gICAgICAgICAgYyA9IGVbMTBdLFxuICAgICAgICAgIGggPSBlWzExXTtcbiAgICAgIHJldHVybiBlICE9PSB0ICYmICh0WzBdID0gZVswXSwgdFsxXSA9IGVbMV0sIHRbMl0gPSBlWzJdLCB0WzNdID0gZVszXSwgdFsxMl0gPSBlWzEyXSwgdFsxM10gPSBlWzEzXSwgdFsxNF0gPSBlWzE0XSwgdFsxNV0gPSBlWzE1XSksIHRbNF0gPSBhICogaSArIGwgKiBuLCB0WzVdID0gbyAqIGkgKyBwICogbiwgdFs2XSA9IHMgKiBpICsgYyAqIG4sIHRbN10gPSB1ICogaSArIGggKiBuLCB0WzhdID0gbCAqIGkgLSBhICogbiwgdFs5XSA9IHAgKiBpIC0gbyAqIG4sIHRbMTBdID0gYyAqIGkgLSBzICogbiwgdFsxMV0gPSBoICogaSAtIHUgKiBuLCB0O1xuICAgIH0sIHQucm90YXRlWiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IE1hdGguc2luKHIpLFxuICAgICAgICAgIGkgPSBNYXRoLmNvcyhyKSxcbiAgICAgICAgICBhID0gZVswXSxcbiAgICAgICAgICBvID0gZVsxXSxcbiAgICAgICAgICBzID0gZVsyXSxcbiAgICAgICAgICB1ID0gZVszXSxcbiAgICAgICAgICBsID0gZVs0XSxcbiAgICAgICAgICBwID0gZVs1XSxcbiAgICAgICAgICBjID0gZVs2XSxcbiAgICAgICAgICBoID0gZVs3XTtcbiAgICAgIHJldHVybiBlICE9PSB0ICYmICh0WzhdID0gZVs4XSwgdFs5XSA9IGVbOV0sIHRbMTBdID0gZVsxMF0sIHRbMTFdID0gZVsxMV0sIHRbMTJdID0gZVsxMl0sIHRbMTNdID0gZVsxM10sIHRbMTRdID0gZVsxNF0sIHRbMTVdID0gZVsxNV0pLCB0WzBdID0gYSAqIGkgKyBsICogbiwgdFsxXSA9IG8gKiBpICsgcCAqIG4sIHRbMl0gPSBzICogaSArIGMgKiBuLCB0WzNdID0gdSAqIGkgKyBoICogbiwgdFs0XSA9IGwgKiBpIC0gYSAqIG4sIHRbNV0gPSBwICogaSAtIG8gKiBuLCB0WzZdID0gYyAqIGkgLSBzICogbiwgdFs3XSA9IGggKiBpIC0gdSAqIG4sIHQ7XG4gICAgfSwgdC5zY2FsZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHJbMF0sXG4gICAgICAgICAgaSA9IHJbMV0sXG4gICAgICAgICAgYSA9IHJbMl07XG4gICAgICByZXR1cm4gdFswXSA9IGVbMF0gKiBuLCB0WzFdID0gZVsxXSAqIG4sIHRbMl0gPSBlWzJdICogbiwgdFszXSA9IGVbM10gKiBuLCB0WzRdID0gZVs0XSAqIGksIHRbNV0gPSBlWzVdICogaSwgdFs2XSA9IGVbNl0gKiBpLCB0WzddID0gZVs3XSAqIGksIHRbOF0gPSBlWzhdICogYSwgdFs5XSA9IGVbOV0gKiBhLCB0WzEwXSA9IGVbMTBdICogYSwgdFsxMV0gPSBlWzExXSAqIGEsIHRbMTJdID0gZVsxMl0sIHRbMTNdID0gZVsxM10sIHRbMTRdID0gZVsxNF0sIHRbMTVdID0gZVsxNV0sIHQ7XG4gICAgfSwgdC5zY2FsZSQxID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAqIHIsIHRbMV0gPSBlWzFdICogciwgdFsyXSA9IGVbMl0gKiByLCB0WzNdID0gZVszXSAqIHIsIHQ7XG4gICAgfSwgdC5zY2FsZSQyID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAqIHIsIHRbMV0gPSBlWzFdICogciwgdFsyXSA9IGVbMl0gKiByLCB0O1xuICAgIH0sIHQuc2V0Q2FjaGVMaW1pdHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgc3QgPSB0LCB1dCA9IGU7XG4gICAgfSwgdC5zZXRSVExUZXh0UGx1Z2luID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHIgJiYgKHIgPSAhMSksIFwiZGVmZXJyZWRcIiA9PT0gUW4gfHwgXCJsb2FkaW5nXCIgPT09IFFuIHx8IFwibG9hZGVkXCIgPT09IFFuKSB0aHJvdyBuZXcgRXJyb3IoXCJzZXRSVExUZXh0UGx1Z2luIGNhbm5vdCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXCIpO1xuICAgICAgdGkgPSBPLnJlc29sdmVVUkwodCksIFFuID0gXCJkZWZlcnJlZFwiLCBXbiA9IGUsIHJpKCksIHIgfHwgYWkoKTtcbiAgICB9LCB0LnNwaGVyaWNhbFRvQ2FydGVzaWFuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdFswXSxcbiAgICAgICAgICByID0gdFsxXSxcbiAgICAgICAgICBuID0gdFsyXTtcbiAgICAgIHJldHVybiByICs9IDkwLCByICo9IE1hdGguUEkgLyAxODAsIG4gKj0gTWF0aC5QSSAvIDE4MCwge1xuICAgICAgICB4OiBlICogTWF0aC5jb3MocikgKiBNYXRoLnNpbihuKSxcbiAgICAgICAgeTogZSAqIE1hdGguc2luKHIpICogTWF0aC5zaW4obiksXG4gICAgICAgIHo6IGUgKiBNYXRoLmNvcyhuKVxuICAgICAgfTtcbiAgICB9LCB0LnNxckxlbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRbMF0sXG4gICAgICAgICAgciA9IHRbMV07XG4gICAgICByZXR1cm4gZSAqIGUgKyByICogcjtcbiAgICB9LCB0LnN0eWxlU3BlYyA9IEV0LCB0LnN1YiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdFswXSA9IGVbMF0gLSByWzBdLCB0WzFdID0gZVsxXSAtIHJbMV0sIHRbMl0gPSBlWzJdIC0gclsyXSwgdDtcbiAgICB9LCB0LnN5bWJvbFNpemUgPSBSdSwgdC50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgICBpID0gZVsxXSxcbiAgICAgICAgICBhID0gZVsyXTtcbiAgICAgIHJldHVybiB0WzBdID0gbiAqIHJbMF0gKyBpICogclszXSArIGEgKiByWzZdLCB0WzFdID0gbiAqIHJbMV0gKyBpICogcls0XSArIGEgKiByWzddLCB0WzJdID0gbiAqIHJbMl0gKyBpICogcls1XSArIGEgKiByWzhdLCB0O1xuICAgIH0sIHQudHJhbnNmb3JtTWF0NCA9IHBvLCB0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBzLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIHksXG4gICAgICAgICAgZCA9IHJbMF0sXG4gICAgICAgICAgbSA9IHJbMV0sXG4gICAgICAgICAgdiA9IHJbMl07XG4gICAgICByZXR1cm4gZSA9PT0gdCA/ICh0WzEyXSA9IGVbMF0gKiBkICsgZVs0XSAqIG0gKyBlWzhdICogdiArIGVbMTJdLCB0WzEzXSA9IGVbMV0gKiBkICsgZVs1XSAqIG0gKyBlWzldICogdiArIGVbMTNdLCB0WzE0XSA9IGVbMl0gKiBkICsgZVs2XSAqIG0gKyBlWzEwXSAqIHYgKyBlWzE0XSwgdFsxNV0gPSBlWzNdICogZCArIGVbN10gKiBtICsgZVsxMV0gKiB2ICsgZVsxNV0pIDogKGkgPSBlWzFdLCBhID0gZVsyXSwgbyA9IGVbM10sIHMgPSBlWzRdLCB1ID0gZVs1XSwgbCA9IGVbNl0sIHAgPSBlWzddLCBjID0gZVs4XSwgaCA9IGVbOV0sIGYgPSBlWzEwXSwgeSA9IGVbMTFdLCB0WzBdID0gbiA9IGVbMF0sIHRbMV0gPSBpLCB0WzJdID0gYSwgdFszXSA9IG8sIHRbNF0gPSBzLCB0WzVdID0gdSwgdFs2XSA9IGwsIHRbN10gPSBwLCB0WzhdID0gYywgdFs5XSA9IGgsIHRbMTBdID0gZiwgdFsxMV0gPSB5LCB0WzEyXSA9IG4gKiBkICsgcyAqIG0gKyBjICogdiArIGVbMTJdLCB0WzEzXSA9IGkgKiBkICsgdSAqIG0gKyBoICogdiArIGVbMTNdLCB0WzE0XSA9IGEgKiBkICsgbCAqIG0gKyBmICogdiArIGVbMTRdLCB0WzE1XSA9IG8gKiBkICsgcCAqIG0gKyB5ICogdiArIGVbMTVdKSwgdDtcbiAgICB9LCB0LnRyaWdnZXJQbHVnaW5Db21wbGV0aW9uRXZlbnQgPSBlaSwgdC51bmlxdWVJZCA9IHksIHQudmFsaWRhdGVDdXN0b21TdHlsZUxheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gW10sXG4gICAgICAgICAgciA9IHQuaWQ7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSByICYmIGUucHVzaCh7XG4gICAgICAgIG1lc3NhZ2U6IFwibGF5ZXJzLlwiICsgciArICc6IG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJpZFwiJ1xuICAgICAgfSksIHZvaWQgMCA9PT0gdC5yZW5kZXIgJiYgZS5wdXNoKHtcbiAgICAgICAgbWVzc2FnZTogXCJsYXllcnMuXCIgKyByICsgJzogbWlzc2luZyByZXF1aXJlZCBtZXRob2QgXCJyZW5kZXJcIidcbiAgICAgIH0pLCB0LnJlbmRlcmluZ01vZGUgJiYgXCIyZFwiICE9PSB0LnJlbmRlcmluZ01vZGUgJiYgXCIzZFwiICE9PSB0LnJlbmRlcmluZ01vZGUgJiYgZS5wdXNoKHtcbiAgICAgICAgbWVzc2FnZTogXCJsYXllcnMuXCIgKyByICsgJzogcHJvcGVydHkgXCJyZW5kZXJpbmdNb2RlXCIgbXVzdCBiZSBlaXRoZXIgXCIyZFwiIG9yIFwiM2RcIidcbiAgICAgIH0pLCBlO1xuICAgIH0sIHQudmFsaWRhdGVMaWdodCA9IEVuLCB0LnZhbGlkYXRlU3R5bGUgPSBDbiwgdC52YWx1ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgciBpbiB0KSB7XG4gICAgICAgIGUucHVzaCh0W3JdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfSwgdC52ZWN0b3JUaWxlID0gYnMsIHQudmVyc2lvbiA9IFwiMS4xMy4xXCIsIHQud2Fybk9uY2UgPSBBLCB0LndlYnBTdXBwb3J0ZWQgPSBVLCB0LndpbmRvdyA9IG8sIHQud3JhcCA9IGM7XG4gIH0pO1xuICBkZWZpbmUoW1wiLi9zaGFyZWRcIl0sIGZ1bmN0aW9uIChlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiB0KGUpIHtcbiAgICAgIHZhciByID0gdHlwZW9mIGU7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gciB8fCBcImJvb2xlYW5cIiA9PT0gciB8fCBcInN0cmluZ1wiID09PSByIHx8IG51bGwgPT0gZSkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gXCJbXCIsIG8gPSAwLCBuID0gZTsgbyA8IG4ubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICBpICs9IHQobltvXSkgKyBcIixcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpICsgXCJdXCI7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHMgPSBPYmplY3Qua2V5cyhlKS5zb3J0KCksIGEgPSBcIntcIiwgbCA9IDA7IGwgPCBzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGEgKz0gSlNPTi5zdHJpbmdpZnkoc1tsXSkgKyBcIjpcIiArIHQoZVtzW2xdXSkgKyBcIixcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgKyBcIn1cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByKHIpIHtcbiAgICAgIGZvciAodmFyIGkgPSBcIlwiLCBvID0gMCwgbiA9IGUucmVmUHJvcGVydGllczsgbyA8IG4ubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgaSArPSBcIi9cIiArIHQocltuW29dXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHZhciBpID0gZnVuY3Rpb24gaShlKSB7XG4gICAgICB0aGlzLmtleUNhY2hlID0ge30sIGUgJiYgdGhpcy5yZXBsYWNlKGUpO1xuICAgIH07XG5cbiAgICBpLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2xheWVyQ29uZmlncyA9IHt9LCB0aGlzLl9sYXllcnMgPSB7fSwgdGhpcy51cGRhdGUoZSwgW10pO1xuICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcywgbiA9IDAsIHMgPSB0OyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IHNbbl07XG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnc1thLmlkXSA9IGE7XG4gICAgICAgIHZhciBsID0gdGhpcy5fbGF5ZXJzW2EuaWRdID0gZS5jcmVhdGVTdHlsZUxheWVyKGEpO1xuICAgICAgICBsLl9mZWF0dXJlRmlsdGVyID0gZS5mZWF0dXJlRmlsdGVyKGwuZmlsdGVyKSwgdGhpcy5rZXlDYWNoZVthLmlkXSAmJiBkZWxldGUgdGhpcy5rZXlDYWNoZVthLmlkXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSBpOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGhbdV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmtleUNhY2hlW2NdLCBkZWxldGUgdGhpcy5fbGF5ZXJDb25maWdzW2NdLCBkZWxldGUgdGhpcy5fbGF5ZXJzW2NdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhbWlsaWVzQnlTb3VyY2UgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcCA9IDAsIGYgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBmb3IgKHZhciBpID0ge30sIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgIHZhciBuID0gdCAmJiB0W2Vbb10uaWRdIHx8IHIoZVtvXSk7XG4gICAgICAgICAgdCAmJiAodFtlW29dLmlkXSA9IG4pO1xuICAgICAgICAgIHZhciBzID0gaVtuXTtcbiAgICAgICAgICBzIHx8IChzID0gaVtuXSA9IFtdKSwgcy5wdXNoKGVbb10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBsIGluIGkpIHtcbiAgICAgICAgICBhLnB1c2goaVtsXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0oZS52YWx1ZXModGhpcy5fbGF5ZXJDb25maWdzKSwgdGhpcy5rZXlDYWNoZSk7IHAgPCBmLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgIHZhciBkID0gZltwXS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gby5fbGF5ZXJzW2UuaWRdO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGcgPSBkWzBdO1xuXG4gICAgICAgIGlmIChcIm5vbmVcIiAhPT0gZy52aXNpYmlsaXR5KSB7XG4gICAgICAgICAgdmFyIHYgPSBnLnNvdXJjZSB8fCBcIlwiLFxuICAgICAgICAgICAgICBtID0gdGhpcy5mYW1pbGllc0J5U291cmNlW3ZdO1xuICAgICAgICAgIG0gfHwgKG0gPSB0aGlzLmZhbWlsaWVzQnlTb3VyY2Vbdl0gPSB7fSk7XG4gICAgICAgICAgdmFyIHkgPSBnLnNvdXJjZUxheWVyIHx8IFwiX2dlb2pzb25UaWxlTGF5ZXJcIixcbiAgICAgICAgICAgICAgeCA9IG1beV07XG4gICAgICAgICAgeCB8fCAoeCA9IG1beV0gPSBbXSksIHgucHVzaChkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbyA9IGZ1bmN0aW9uIG8odCkge1xuICAgICAgdmFyIHIgPSB7fSxcbiAgICAgICAgICBpID0gW107XG5cbiAgICAgIGZvciAodmFyIG8gaW4gdCkge1xuICAgICAgICB2YXIgbiA9IHRbb10sXG4gICAgICAgICAgICBzID0gcltvXSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGEgaW4gbikge1xuICAgICAgICAgIHZhciBsID0gblsrYV07XG5cbiAgICAgICAgICBpZiAobCAmJiAwICE9PSBsLmJpdG1hcC53aWR0aCAmJiAwICE9PSBsLmJpdG1hcC5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB1ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICB3OiBsLmJpdG1hcC53aWR0aCArIDIsXG4gICAgICAgICAgICAgIGg6IGwuYml0bWFwLmhlaWdodCArIDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpLnB1c2godSksIHNbYV0gPSB7XG4gICAgICAgICAgICAgIHJlY3Q6IHUsXG4gICAgICAgICAgICAgIG1ldHJpY3M6IGwubWV0cmljc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBlLnBvdHBhY2soaSksXG4gICAgICAgICAgYyA9IG5ldyBlLkFscGhhSW1hZ2Uoe1xuICAgICAgICB3aWR0aDogaC53IHx8IDEsXG4gICAgICAgIGhlaWdodDogaC5oIHx8IDFcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHQpIHtcbiAgICAgICAgdmFyIGYgPSB0W3BdO1xuXG4gICAgICAgIGZvciAodmFyIGQgaW4gZikge1xuICAgICAgICAgIHZhciBnID0gZlsrZF07XG5cbiAgICAgICAgICBpZiAoZyAmJiAwICE9PSBnLmJpdG1hcC53aWR0aCAmJiAwICE9PSBnLmJpdG1hcC5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcltwXVtkXS5yZWN0O1xuICAgICAgICAgICAgZS5BbHBoYUltYWdlLmNvcHkoZy5iaXRtYXAsIGMsIHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB4OiB2LnggKyAxLFxuICAgICAgICAgICAgICB5OiB2LnkgKyAxXG4gICAgICAgICAgICB9LCBnLmJpdG1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW1hZ2UgPSBjLCB0aGlzLnBvc2l0aW9ucyA9IHI7XG4gICAgfTtcblxuICAgIGUucmVnaXN0ZXIoXCJHbHlwaEF0bGFzXCIsIG8pO1xuXG4gICAgdmFyIG4gPSBmdW5jdGlvbiBuKHQpIHtcbiAgICAgIHRoaXMudGlsZUlEID0gbmV3IGUuT3ZlcnNjYWxlZFRpbGVJRCh0LnRpbGVJRC5vdmVyc2NhbGVkWiwgdC50aWxlSUQud3JhcCwgdC50aWxlSUQuY2Fub25pY2FsLnosIHQudGlsZUlELmNhbm9uaWNhbC54LCB0LnRpbGVJRC5jYW5vbmljYWwueSksIHRoaXMudWlkID0gdC51aWQsIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5waXhlbFJhdGlvID0gdC5waXhlbFJhdGlvLCB0aGlzLnRpbGVTaXplID0gdC50aWxlU2l6ZSwgdGhpcy5zb3VyY2UgPSB0LnNvdXJjZSwgdGhpcy5vdmVyc2NhbGluZyA9IHRoaXMudGlsZUlELm92ZXJzY2FsZUZhY3RvcigpLCB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyA9IHQuc2hvd0NvbGxpc2lvbkJveGVzLCB0aGlzLmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9ICEhdC5jb2xsZWN0UmVzb3VyY2VUaW1pbmcsIHRoaXMucmV0dXJuRGVwZW5kZW5jaWVzID0gISF0LnJldHVybkRlcGVuZGVuY2llcywgdGhpcy5wcm9tb3RlSWQgPSB0LnByb21vdGVJZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcyh0LCByLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gbmV3IGUuRXZhbHVhdGlvblBhcmFtZXRlcnMociksIG4gPSAwLCBzID0gdDsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgc1tuXS5yZWNhbGN1bGF0ZShvLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhKHQsIHIpIHtcbiAgICAgIHZhciBpID0gZS5nZXRBcnJheUJ1ZmZlcih0LnJlcXVlc3QsIGZ1bmN0aW9uICh0LCBpLCBvLCBuKSB7XG4gICAgICAgIHQgPyByKHQpIDogaSAmJiByKG51bGwsIHtcbiAgICAgICAgICB2ZWN0b3JUaWxlOiBuZXcgZS52ZWN0b3JUaWxlLlZlY3RvclRpbGUobmV3IGUucGJmKGkpKSxcbiAgICAgICAgICByYXdEYXRhOiBpLFxuICAgICAgICAgIGNhY2hlQ29udHJvbDogbyxcbiAgICAgICAgICBleHBpcmVzOiBuXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpLmNhbmNlbCgpLCByKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIG4ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHQsIHIsIGksIG4sIGEpIHtcbiAgICAgIHZhciBsID0gdGhpcztcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJwYXJzaW5nXCIsIHRoaXMuZGF0YSA9IHQsIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBuZXcgZS5Db2xsaXNpb25Cb3hBcnJheSgpO1xuICAgICAgdmFyIHUgPSBuZXcgZS5EaWN0aW9uYXJ5Q29kZXIoT2JqZWN0LmtleXModC5sYXllcnMpLnNvcnQoKSksXG4gICAgICAgICAgaCA9IG5ldyBlLkZlYXR1cmVJbmRleCh0aGlzLnRpbGVJRCwgdGhpcy5wcm9tb3RlSWQpO1xuICAgICAgaC5idWNrZXRMYXllcklEcyA9IFtdO1xuICAgICAgdmFyIGMsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGQsXG4gICAgICAgICAgZyA9IHt9LFxuICAgICAgICAgIHYgPSB7XG4gICAgICAgIGZlYXR1cmVJbmRleDogaCxcbiAgICAgICAgaWNvbkRlcGVuZGVuY2llczoge30sXG4gICAgICAgIHBhdHRlcm5EZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgICBnbHlwaERlcGVuZGVuY2llczoge30sXG4gICAgICAgIGF2YWlsYWJsZUltYWdlczogaVxuICAgICAgfSxcbiAgICAgICAgICBtID0gci5mYW1pbGllc0J5U291cmNlW3RoaXMuc291cmNlXTtcblxuICAgICAgZm9yICh2YXIgeSBpbiBtKSB7XG4gICAgICAgIHZhciB4ID0gdC5sYXllcnNbeV07XG5cbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAxID09PSB4LnZlcnNpb24gJiYgZS53YXJuT25jZSgnVmVjdG9yIHRpbGUgc291cmNlIFwiJyArIHRoaXMuc291cmNlICsgJ1wiIGxheWVyIFwiJyArIHkgKyAnXCIgZG9lcyBub3QgdXNlIHZlY3RvciB0aWxlIHNwZWMgdjIgYW5kIHRoZXJlZm9yZSBtYXkgaGF2ZSBzb21lIHJlbmRlcmluZyBlcnJvcnMuJyk7XG5cbiAgICAgICAgICBmb3IgKHZhciB3ID0gdS5lbmNvZGUoeSksIFMgPSBbXSwgSSA9IDA7IEkgPCB4Lmxlbmd0aDsgSSsrKSB7XG4gICAgICAgICAgICB2YXIgTSA9IHguZmVhdHVyZShJKSxcbiAgICAgICAgICAgICAgICBiID0gaC5nZXRJZChNLCB5KTtcbiAgICAgICAgICAgIFMucHVzaCh7XG4gICAgICAgICAgICAgIGZlYXR1cmU6IE0sXG4gICAgICAgICAgICAgIGlkOiBiLFxuICAgICAgICAgICAgICBpbmRleDogSSxcbiAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgXyA9IDAsIGsgPSBtW3ldOyBfIDwgay5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICAgICAgdmFyIFAgPSBrW19dLFxuICAgICAgICAgICAgICAgIFQgPSBQWzBdO1xuICAgICAgICAgICAgVC5taW56b29tICYmIHRoaXMuem9vbSA8IE1hdGguZmxvb3IoVC5taW56b29tKSB8fCBULm1heHpvb20gJiYgdGhpcy56b29tID49IFQubWF4em9vbSB8fCBcIm5vbmVcIiAhPT0gVC52aXNpYmlsaXR5ICYmIChzKFAsIHRoaXMuem9vbSwgaSksIChnW1QuaWRdID0gVC5jcmVhdGVCdWNrZXQoe1xuICAgICAgICAgICAgICBpbmRleDogaC5idWNrZXRMYXllcklEcy5sZW5ndGgsXG4gICAgICAgICAgICAgIGxheWVyczogUCxcbiAgICAgICAgICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgICAgICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgIG92ZXJzY2FsaW5nOiB0aGlzLm92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgICBjb2xsaXNpb25Cb3hBcnJheTogdGhpcy5jb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogdyxcbiAgICAgICAgICAgICAgc291cmNlSUQ6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KSkucG9wdWxhdGUoUywgdiwgdGhpcy50aWxlSUQuY2Fub25pY2FsKSwgaC5idWNrZXRMYXllcklEcy5wdXNoKFAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlLmlkO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIEMgPSBlLm1hcE9iamVjdCh2LmdseXBoRGVwZW5kZW5jaWVzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkubWFwKE51bWJlcik7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKEMpLmxlbmd0aCA/IG4uc2VuZChcImdldEdseXBoc1wiLCB7XG4gICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgIHN0YWNrczogQ1xuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYyB8fCAoYyA9IGUsIHAgPSB0LCB6LmNhbGwobCkpO1xuICAgICAgfSkgOiBwID0ge307XG4gICAgICB2YXIgRCA9IE9iamVjdC5rZXlzKHYuaWNvbkRlcGVuZGVuY2llcyk7XG4gICAgICBELmxlbmd0aCA/IG4uc2VuZChcImdldEltYWdlc1wiLCB7XG4gICAgICAgIGljb25zOiBELFxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB0aWxlSUQ6IHRoaXMudGlsZUlELFxuICAgICAgICB0eXBlOiBcImljb25zXCJcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGMgfHwgKGMgPSBlLCBmID0gdCwgei5jYWxsKGwpKTtcbiAgICAgIH0pIDogZiA9IHt9O1xuICAgICAgdmFyIEwgPSBPYmplY3Qua2V5cyh2LnBhdHRlcm5EZXBlbmRlbmNpZXMpO1xuXG4gICAgICBmdW5jdGlvbiB6KCkge1xuICAgICAgICBpZiAoYykgcmV0dXJuIGEoYyk7XG5cbiAgICAgICAgaWYgKHAgJiYgZiAmJiBkKSB7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgbyhwKSxcbiAgICAgICAgICAgICAgciA9IG5ldyBlLkltYWdlQXRsYXMoZiwgZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBuIGluIGcpIHtcbiAgICAgICAgICAgIHZhciBsID0gZ1tuXTtcbiAgICAgICAgICAgIGwgaW5zdGFuY2VvZiBlLlN5bWJvbEJ1Y2tldCA/IChzKGwubGF5ZXJzLCB0aGlzLnpvb20sIGkpLCBlLnBlcmZvcm1TeW1ib2xMYXlvdXQobCwgcCwgdC5wb3NpdGlvbnMsIGYsIHIuaWNvblBvc2l0aW9ucywgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMudGlsZUlELmNhbm9uaWNhbCkpIDogbC5oYXNQYXR0ZXJuICYmIChsIGluc3RhbmNlb2YgZS5MaW5lQnVja2V0IHx8IGwgaW5zdGFuY2VvZiBlLkZpbGxCdWNrZXQgfHwgbCBpbnN0YW5jZW9mIGUuRmlsbEV4dHJ1c2lvbkJ1Y2tldCkgJiYgKHMobC5sYXllcnMsIHRoaXMuem9vbSwgaSksIGwuYWRkRmVhdHVyZXModiwgdGhpcy50aWxlSUQuY2Fub25pY2FsLCByLnBhdHRlcm5Qb3NpdGlvbnMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZG9uZVwiLCBhKG51bGwsIHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IGUudmFsdWVzKGcpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWUuaXNFbXB0eSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmZWF0dXJlSW5kZXg6IGgsXG4gICAgICAgICAgICBjb2xsaXNpb25Cb3hBcnJheTogdGhpcy5jb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIGdseXBoQXRsYXNJbWFnZTogdC5pbWFnZSxcbiAgICAgICAgICAgIGltYWdlQXRsYXM6IHIsXG4gICAgICAgICAgICBnbHlwaE1hcDogdGhpcy5yZXR1cm5EZXBlbmRlbmNpZXMgPyBwIDogbnVsbCxcbiAgICAgICAgICAgIGljb25NYXA6IHRoaXMucmV0dXJuRGVwZW5kZW5jaWVzID8gZiA6IG51bGwsXG4gICAgICAgICAgICBnbHlwaFBvc2l0aW9uczogdGhpcy5yZXR1cm5EZXBlbmRlbmNpZXMgPyB0LnBvc2l0aW9ucyA6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBMLmxlbmd0aCA/IG4uc2VuZChcImdldEltYWdlc1wiLCB7XG4gICAgICAgIGljb25zOiBMLFxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB0aWxlSUQ6IHRoaXMudGlsZUlELFxuICAgICAgICB0eXBlOiBcInBhdHRlcm5zXCJcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGMgfHwgKGMgPSBlLCBkID0gdCwgei5jYWxsKGwpKTtcbiAgICAgIH0pIDogZCA9IHt9LCB6LmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIHZhciBsID0gZnVuY3Rpb24gbChlLCB0LCByLCBpKSB7XG4gICAgICB0aGlzLmFjdG9yID0gZSwgdGhpcy5sYXllckluZGV4ID0gdCwgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSByLCB0aGlzLmxvYWRWZWN0b3JEYXRhID0gaSB8fCBhLCB0aGlzLmxvYWRpbmcgPSB7fSwgdGhpcy5sb2FkZWQgPSB7fTtcbiAgICB9O1xuXG4gICAgbC5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgcikge1xuICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgIG8gPSB0LnVpZDtcbiAgICAgIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0ge30pO1xuICAgICAgdmFyIHMgPSAhISh0ICYmIHQucmVxdWVzdCAmJiB0LnJlcXVlc3QuY29sbGVjdFJlc291cmNlVGltaW5nKSAmJiBuZXcgZS5SZXF1ZXN0UGVyZm9ybWFuY2UodC5yZXF1ZXN0KSxcbiAgICAgICAgICBhID0gdGhpcy5sb2FkaW5nW29dID0gbmV3IG4odCk7XG4gICAgICBhLmFib3J0ID0gdGhpcy5sb2FkVmVjdG9yRGF0YSh0LCBmdW5jdGlvbiAodCwgbikge1xuICAgICAgICBpZiAoZGVsZXRlIGkubG9hZGluZ1tvXSwgdCB8fCAhbikgcmV0dXJuIGEuc3RhdHVzID0gXCJkb25lXCIsIGkubG9hZGVkW29dID0gYSwgcih0KTtcbiAgICAgICAgdmFyIGwgPSBuLnJhd0RhdGEsXG4gICAgICAgICAgICB1ID0ge307XG4gICAgICAgIG4uZXhwaXJlcyAmJiAodS5leHBpcmVzID0gbi5leHBpcmVzKSwgbi5jYWNoZUNvbnRyb2wgJiYgKHUuY2FjaGVDb250cm9sID0gbi5jYWNoZUNvbnRyb2wpO1xuICAgICAgICB2YXIgaCA9IHt9O1xuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgdmFyIGMgPSBzLmZpbmlzaCgpO1xuICAgICAgICAgIGMgJiYgKGgucmVzb3VyY2VUaW1pbmcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhLnZlY3RvclRpbGUgPSBuLnZlY3RvclRpbGUsIGEucGFyc2Uobi52ZWN0b3JUaWxlLCBpLmxheWVySW5kZXgsIGkuYXZhaWxhYmxlSW1hZ2VzLCBpLmFjdG9yLCBmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICAgIGlmICh0IHx8ICFpKSByZXR1cm4gcih0KTtcbiAgICAgICAgICByKG51bGwsIGUuZXh0ZW5kKHtcbiAgICAgICAgICAgIHJhd1RpbGVEYXRhOiBsLnNsaWNlKDApXG4gICAgICAgICAgfSwgaSwgdSwgaCkpO1xuICAgICAgICB9KSwgaS5sb2FkZWQgPSBpLmxvYWRlZCB8fCB7fSwgaS5sb2FkZWRbb10gPSBhO1xuICAgICAgfSk7XG4gICAgfSwgbC5wcm90b3R5cGUucmVsb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgICAgaSA9IHRoaXMubG9hZGVkLFxuICAgICAgICAgIG8gPSBlLnVpZCxcbiAgICAgICAgICBuID0gdGhpcztcblxuICAgICAgaWYgKGkgJiYgaVtvXSkge1xuICAgICAgICB2YXIgcyA9IGlbb107XG4gICAgICAgIHMuc2hvd0NvbGxpc2lvbkJveGVzID0gZS5zaG93Q29sbGlzaW9uQm94ZXM7XG5cbiAgICAgICAgdmFyIGEgPSBmdW5jdGlvbiBhKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHMucmVsb2FkQ2FsbGJhY2s7XG4gICAgICAgICAgbyAmJiAoZGVsZXRlIHMucmVsb2FkQ2FsbGJhY2ssIHMucGFyc2Uocy52ZWN0b3JUaWxlLCBuLmxheWVySW5kZXgsIHIuYXZhaWxhYmxlSW1hZ2VzLCBuLmFjdG9yLCBvKSksIHQoZSwgaSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgXCJwYXJzaW5nXCIgPT09IHMuc3RhdHVzID8gcy5yZWxvYWRDYWxsYmFjayA9IGEgOiBcImRvbmVcIiA9PT0gcy5zdGF0dXMgJiYgKHMudmVjdG9yVGlsZSA/IHMucGFyc2Uocy52ZWN0b3JUaWxlLCB0aGlzLmxheWVySW5kZXgsIHRoaXMuYXZhaWxhYmxlSW1hZ2VzLCB0aGlzLmFjdG9yLCBhKSA6IGEoKSk7XG4gICAgICB9XG4gICAgfSwgbC5wcm90b3R5cGUuYWJvcnRUaWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHZhciByID0gdGhpcy5sb2FkaW5nLFxuICAgICAgICAgIGkgPSBlLnVpZDtcbiAgICAgIHIgJiYgcltpXSAmJiByW2ldLmFib3J0ICYmIChyW2ldLmFib3J0KCksIGRlbGV0ZSByW2ldKSwgdCgpO1xuICAgIH0sIGwucHJvdG90eXBlLnJlbW92ZVRpbGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0aGlzLmxvYWRlZCxcbiAgICAgICAgICBpID0gZS51aWQ7XG4gICAgICByICYmIHJbaV0gJiYgZGVsZXRlIHJbaV0sIHQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHUgPSBlLndpbmRvdy5JbWFnZUJpdG1hcCxcbiAgICAgICAgaCA9IGZ1bmN0aW9uIGgoKSB7XG4gICAgICB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjKGUsIHQpIHtcbiAgICAgIGlmICgwICE9PSBlLmxlbmd0aCkge1xuICAgICAgICBwKGVbMF0sIHQpO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAxOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgIHAoZVtyXSwgIXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcChlLCB0KSB7XG4gICAgICBmb3IgKHZhciByID0gMCwgaSA9IDAsIG8gPSBlLmxlbmd0aCwgbiA9IG8gLSAxOyBpIDwgbzsgbiA9IGkrKykge1xuICAgICAgICByICs9IChlW2ldWzBdIC0gZVtuXVswXSkgKiAoZVtuXVsxXSArIGVbaV1bMV0pO1xuICAgICAgfVxuXG4gICAgICByID49IDAgIT0gISF0ICYmIGUucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGgucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgIHZhciBpID0gdC51aWQsXG4gICAgICAgICAgbyA9IHQuZW5jb2RpbmcsXG4gICAgICAgICAgbiA9IHQucmF3SW1hZ2VEYXRhLFxuICAgICAgICAgIHMgPSB1ICYmIG4gaW5zdGFuY2VvZiB1ID8gdGhpcy5nZXRJbWFnZURhdGEobikgOiBuLFxuICAgICAgICAgIGEgPSBuZXcgZS5ERU1EYXRhKGksIHMsIG8pO1xuICAgICAgdGhpcy5sb2FkZWQgPSB0aGlzLmxvYWRlZCB8fCB7fSwgdGhpcy5sb2FkZWRbaV0gPSBhLCByKG51bGwsIGEpO1xuICAgIH0sIGgucHJvdG90eXBlLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcyAmJiB0aGlzLm9mZnNjcmVlbkNhbnZhc0NvbnRleHQgfHwgKHRoaXMub2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0LndpZHRoLCB0LmhlaWdodCksIHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dCA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSksIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdC53aWR0aCwgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gdC5oZWlnaHQsIHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UodCwgMCwgMCwgdC53aWR0aCwgdC5oZWlnaHQpO1xuICAgICAgdmFyIHIgPSB0aGlzLm9mZnNjcmVlbkNhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKC0xLCAtMSwgdC53aWR0aCArIDIsIHQuaGVpZ2h0ICsgMik7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzY3JlZW5DYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCwgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0KSwgbmV3IGUuUkdCQUltYWdlKHtcbiAgICAgICAgd2lkdGg6IHIud2lkdGgsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH0sIHIuZGF0YSk7XG4gICAgfSwgaC5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubG9hZGVkLFxuICAgICAgICAgIHIgPSBlLnVpZDtcbiAgICAgIHQgJiYgdFtyXSAmJiBkZWxldGUgdFtyXTtcbiAgICB9O1xuXG4gICAgdmFyIGYgPSBlLnZlY3RvclRpbGUuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTixcbiAgICAgICAgZCA9IGZ1bmN0aW9uIGQodCkge1xuICAgICAgdGhpcy5fZmVhdHVyZSA9IHQsIHRoaXMuZXh0ZW50ID0gZS5FWFRFTlQsIHRoaXMudHlwZSA9IHQudHlwZSwgdGhpcy5wcm9wZXJ0aWVzID0gdC50YWdzLCBcImlkXCIgaW4gdCAmJiAhaXNOYU4odC5pZCkgJiYgKHRoaXMuaWQgPSBwYXJzZUludCh0LmlkLCAxMCkpO1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoMSA9PT0gdGhpcy5fZmVhdHVyZS50eXBlKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSBbXSwgciA9IDAsIGkgPSB0aGlzLl9mZWF0dXJlLmdlb21ldHJ5OyByIDwgaS5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIHZhciBvID0gaVtyXTtcbiAgICAgICAgICB0LnB1c2goW25ldyBlLlBvaW50JDEob1swXSwgb1sxXSldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuID0gW10sIHMgPSAwLCBhID0gdGhpcy5fZmVhdHVyZS5nZW9tZXRyeTsgcyA8IGEubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IFtdLCB1ID0gMCwgaCA9IGFbc107IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgICAgdmFyIGMgPSBoW3VdO1xuICAgICAgICAgIGwucHVzaChuZXcgZS5Qb2ludCQxKGNbMF0sIGNbMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4ucHVzaChsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgZC5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHJldHVybiBmLmNhbGwodGhpcywgZSwgdCwgcik7XG4gICAgfTtcblxuICAgIHZhciBnID0gZnVuY3Rpb24gZyh0KSB7XG4gICAgICB0aGlzLmxheWVycyA9IHtcbiAgICAgICAgX2dlb2pzb25UaWxlTGF5ZXI6IHRoaXNcbiAgICAgIH0sIHRoaXMubmFtZSA9IFwiX2dlb2pzb25UaWxlTGF5ZXJcIiwgdGhpcy5leHRlbnQgPSBlLkVYVEVOVCwgdGhpcy5sZW5ndGggPSB0Lmxlbmd0aCwgdGhpcy5fZmVhdHVyZXMgPSB0O1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBuZXcgZCh0aGlzLl9mZWF0dXJlc1tlXSk7XG4gICAgfTtcblxuICAgIHZhciB2ID0gZS52ZWN0b3JUaWxlLlZlY3RvclRpbGVGZWF0dXJlLFxuICAgICAgICBtID0geTtcblxuICAgIGZ1bmN0aW9uIHkoZSwgdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gdCB8fCB7fSwgdGhpcy5mZWF0dXJlcyA9IGUsIHRoaXMubGVuZ3RoID0gZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geChlLCB0KSB7XG4gICAgICB0aGlzLmlkID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgZS5pZCA/IGUuaWQgOiB2b2lkIDAsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5yYXdHZW9tZXRyeSA9IDEgPT09IGUudHlwZSA/IFtlLmdlb21ldHJ5XSA6IGUuZ2VvbWV0cnksIHRoaXMucHJvcGVydGllcyA9IGUudGFncywgdGhpcy5leHRlbnQgPSB0IHx8IDQwOTY7XG4gICAgfVxuXG4gICAgeS5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gbmV3IHgodGhpcy5mZWF0dXJlc1tlXSwgdGhpcy5vcHRpb25zLmV4dGVudCk7XG4gICAgfSwgeC5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnJhd0dlb21ldHJ5O1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRbcl0sIG8gPSBbXSwgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgby5wdXNoKG5ldyBlLlBvaW50JDEoaVtuXVswXSwgaVtuXVsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeTtcbiAgICB9LCB4LnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5nZW9tZXRyeSB8fCB0aGlzLmxvYWRHZW9tZXRyeSgpO1xuXG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5nZW9tZXRyeSwgdCA9IDEgLyAwLCByID0gLTEgLyAwLCBpID0gMSAvIDAsIG8gPSAtMSAvIDAsIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICBmb3IgKHZhciBzID0gZVtuXSwgYSA9IDA7IGEgPCBzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgdmFyIGwgPSBzW2FdO1xuICAgICAgICAgIHQgPSBNYXRoLm1pbih0LCBsLngpLCByID0gTWF0aC5tYXgociwgbC54KSwgaSA9IE1hdGgubWluKGksIGwueSksIG8gPSBNYXRoLm1heChvLCBsLnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdCwgaSwgciwgb107XG4gICAgfSwgeC5wcm90b3R5cGUudG9HZW9KU09OID0gdi5wcm90b3R5cGUudG9HZW9KU09OO1xuICAgIHZhciB3ID0gSSxcbiAgICAgICAgUyA9IG07XG5cbiAgICBmdW5jdGlvbiBJKHQpIHtcbiAgICAgIHZhciByID0gbmV3IGUucGJmKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgZm9yICh2YXIgciBpbiBlLmxheWVycykge1xuICAgICAgICAgIHQud3JpdGVNZXNzYWdlKDMsIE0sIGUubGF5ZXJzW3JdKTtcbiAgICAgICAgfVxuICAgICAgfSh0LCByKSwgci5maW5pc2goKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNKGUsIHQpIHtcbiAgICAgIHZhciByO1xuICAgICAgdC53cml0ZVZhcmludEZpZWxkKDE1LCBlLnZlcnNpb24gfHwgMSksIHQud3JpdGVTdHJpbmdGaWVsZCgxLCBlLm5hbWUgfHwgXCJcIiksIHQud3JpdGVWYXJpbnRGaWVsZCg1LCBlLmV4dGVudCB8fCA0MDk2KTtcbiAgICAgIHZhciBpID0ge1xuICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAga2V5Y2FjaGU6IHt9LFxuICAgICAgICB2YWx1ZWNhY2hlOiB7fVxuICAgICAgfTtcblxuICAgICAgZm9yIChyID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICAgICAgaS5mZWF0dXJlID0gZS5mZWF0dXJlKHIpLCB0LndyaXRlTWVzc2FnZSgyLCBiLCBpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG8gPSBpLmtleXM7XG5cbiAgICAgIGZvciAociA9IDA7IHIgPCBvLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHQud3JpdGVTdHJpbmdGaWVsZCgzLCBvW3JdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG4gPSBpLnZhbHVlcztcblxuICAgICAgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdC53cml0ZU1lc3NhZ2UoNCwgQywgbltyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYihlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZmVhdHVyZTtcbiAgICAgIHZvaWQgMCAhPT0gci5pZCAmJiB0LndyaXRlVmFyaW50RmllbGQoMSwgci5pZCksIHQud3JpdGVNZXNzYWdlKDIsIF8sIGUpLCB0LndyaXRlVmFyaW50RmllbGQoMywgci50eXBlKSwgdC53cml0ZU1lc3NhZ2UoNCwgVCwgcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gXyhlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZmVhdHVyZSxcbiAgICAgICAgICBpID0gZS5rZXlzLFxuICAgICAgICAgIG8gPSBlLnZhbHVlcyxcbiAgICAgICAgICBuID0gZS5rZXljYWNoZSxcbiAgICAgICAgICBzID0gZS52YWx1ZWNhY2hlO1xuXG4gICAgICBmb3IgKHZhciBhIGluIHIucHJvcGVydGllcykge1xuICAgICAgICB2YXIgbCA9IG5bYV07XG4gICAgICAgIHZvaWQgMCA9PT0gbCAmJiAoaS5wdXNoKGEpLCBuW2FdID0gbCA9IGkubGVuZ3RoIC0gMSksIHQud3JpdGVWYXJpbnQobCk7XG4gICAgICAgIHZhciB1ID0gci5wcm9wZXJ0aWVzW2FdLFxuICAgICAgICAgICAgaCA9IHR5cGVvZiB1O1xuICAgICAgICBcInN0cmluZ1wiICE9PSBoICYmIFwiYm9vbGVhblwiICE9PSBoICYmIFwibnVtYmVyXCIgIT09IGggJiYgKHUgPSBKU09OLnN0cmluZ2lmeSh1KSk7XG4gICAgICAgIHZhciBjID0gaCArIFwiOlwiICsgdSxcbiAgICAgICAgICAgIHAgPSBzW2NdO1xuICAgICAgICB2b2lkIDAgPT09IHAgJiYgKG8ucHVzaCh1KSwgc1tjXSA9IHAgPSBvLmxlbmd0aCAtIDEpLCB0LndyaXRlVmFyaW50KHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGsoZSwgdCkge1xuICAgICAgcmV0dXJuICh0IDw8IDMpICsgKDcgJiBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgIHJldHVybiBlIDw8IDEgXiBlID4+IDMxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFQoZSwgdCkge1xuICAgICAgZm9yICh2YXIgciA9IGUubG9hZEdlb21ldHJ5KCksIGkgPSBlLnR5cGUsIG8gPSAwLCBuID0gMCwgcyA9IHIubGVuZ3RoLCBhID0gMDsgYSA8IHM7IGErKykge1xuICAgICAgICB2YXIgbCA9IHJbYV0sXG4gICAgICAgICAgICB1ID0gMTtcbiAgICAgICAgMSA9PT0gaSAmJiAodSA9IGwubGVuZ3RoKSwgdC53cml0ZVZhcmludChrKDEsIHUpKTtcblxuICAgICAgICBmb3IgKHZhciBoID0gMyA9PT0gaSA/IGwubGVuZ3RoIC0gMSA6IGwubGVuZ3RoLCBjID0gMDsgYyA8IGg7IGMrKykge1xuICAgICAgICAgIDEgPT09IGMgJiYgMSAhPT0gaSAmJiB0LndyaXRlVmFyaW50KGsoMiwgaCAtIDEpKTtcbiAgICAgICAgICB2YXIgcCA9IGxbY10ueCAtIG8sXG4gICAgICAgICAgICAgIGYgPSBsW2NdLnkgLSBuO1xuICAgICAgICAgIHQud3JpdGVWYXJpbnQoUChwKSksIHQud3JpdGVWYXJpbnQoUChmKSksIG8gKz0gcCwgbiArPSBmO1xuICAgICAgICB9XG5cbiAgICAgICAgMyA9PT0gaSAmJiB0LndyaXRlVmFyaW50KGsoNywgMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEMoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0eXBlb2YgZTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHIgPyB0LndyaXRlU3RyaW5nRmllbGQoMSwgZSkgOiBcImJvb2xlYW5cIiA9PT0gciA/IHQud3JpdGVCb29sZWFuRmllbGQoNywgZSkgOiBcIm51bWJlclwiID09PSByICYmIChlICUgMSAhPSAwID8gdC53cml0ZURvdWJsZUZpZWxkKDMsIGUpIDogZSA8IDAgPyB0LndyaXRlU1ZhcmludEZpZWxkKDYsIGUpIDogdC53cml0ZVZhcmludEZpZWxkKDUsIGUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEKGUsIHQsIHIsIGkpIHtcbiAgICAgIEwoZSwgciwgaSksIEwodCwgMiAqIHIsIDIgKiBpKSwgTCh0LCAyICogciArIDEsIDIgKiBpICsgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTChlLCB0LCByKSB7XG4gICAgICB2YXIgaSA9IGVbdF07XG4gICAgICBlW3RdID0gZVtyXSwgZVtyXSA9IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geihlLCB0LCByLCBpKSB7XG4gICAgICB2YXIgbyA9IGUgLSByLFxuICAgICAgICAgIG4gPSB0IC0gaTtcbiAgICAgIHJldHVybiBvICogbyArIG4gKiBuO1xuICAgIH1cblxuICAgIHcuZnJvbVZlY3RvclRpbGVKcyA9IEksIHcuZnJvbUdlb2pzb25WdCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB0ID0gdCB8fCB7fTtcbiAgICAgIHZhciByID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgaW4gZSkge1xuICAgICAgICByW2ldID0gbmV3IG0oZVtpXS5mZWF0dXJlcywgdCksIHJbaV0ubmFtZSA9IGksIHJbaV0udmVyc2lvbiA9IHQudmVyc2lvbiwgcltpXS5leHRlbnQgPSB0LmV4dGVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEkoe1xuICAgICAgICBsYXllcnM6IHJcbiAgICAgIH0pO1xuICAgIH0sIHcuR2VvSlNPTldyYXBwZXIgPSBTO1xuXG4gICAgdmFyIE8gPSBmdW5jdGlvbiBPKGUpIHtcbiAgICAgIHJldHVybiBlWzBdO1xuICAgIH0sXG4gICAgICAgIEUgPSBmdW5jdGlvbiBFKGUpIHtcbiAgICAgIHJldHVybiBlWzFdO1xuICAgIH0sXG4gICAgICAgIEYgPSBmdW5jdGlvbiBGKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IE8pLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBFKSwgdm9pZCAwID09PSBpICYmIChpID0gNjQpLCB2b2lkIDAgPT09IG8gJiYgKG8gPSBGbG9hdDY0QXJyYXkpLCB0aGlzLm5vZGVTaXplID0gaSwgdGhpcy5wb2ludHMgPSBlO1xuXG4gICAgICBmb3IgKHZhciBuID0gZS5sZW5ndGggPCA2NTUzNiA/IFVpbnQxNkFycmF5IDogVWludDMyQXJyYXksIHMgPSB0aGlzLmlkcyA9IG5ldyBuKGUubGVuZ3RoKSwgYSA9IHRoaXMuY29vcmRzID0gbmV3IG8oMiAqIGUubGVuZ3RoKSwgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHNbbF0gPSBsLCBhWzIgKiBsXSA9IHQoZVtsXSksIGFbMiAqIGwgKyAxXSA9IHIoZVtsXSk7XG4gICAgICB9XG5cbiAgICAgICFmdW5jdGlvbiBlKHQsIHIsIGksIG8sIG4sIHMpIHtcbiAgICAgICAgaWYgKCEobiAtIG8gPD0gaSkpIHtcbiAgICAgICAgICB2YXIgYSA9IG8gKyBuID4+IDE7XG4gICAgICAgICAgIWZ1bmN0aW9uIGUodCwgciwgaSwgbywgbiwgcykge1xuICAgICAgICAgICAgZm9yICg7IG4gPiBvOykge1xuICAgICAgICAgICAgICBpZiAobiAtIG8gPiA2MDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG4gLSBvICsgMSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IGkgLSBvICsgMSxcbiAgICAgICAgICAgICAgICAgICAgdSA9IE1hdGgubG9nKGEpLFxuICAgICAgICAgICAgICAgICAgICBoID0gLjUgKiBNYXRoLmV4cCgyICogdSAvIDMpLFxuICAgICAgICAgICAgICAgICAgICBjID0gLjUgKiBNYXRoLnNxcnQodSAqIGggKiAoYSAtIGgpIC8gYSkgKiAobCAtIGEgLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZSh0LCByLCBpLCBNYXRoLm1heChvLCBNYXRoLmZsb29yKGkgLSBsICogaCAvIGEgKyBjKSksIE1hdGgubWluKG4sIE1hdGguZmxvb3IoaSArIChhIC0gbCkgKiBoIC8gYSArIGMpKSwgcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcCA9IHJbMiAqIGkgKyBzXSxcbiAgICAgICAgICAgICAgICAgIGYgPSBvLFxuICAgICAgICAgICAgICAgICAgZCA9IG47XG5cbiAgICAgICAgICAgICAgZm9yIChEKHQsIHIsIG8sIGkpLCByWzIgKiBuICsgc10gPiBwICYmIEQodCwgciwgbywgbik7IGYgPCBkOykge1xuICAgICAgICAgICAgICAgIGZvciAoRCh0LCByLCBmLCBkKSwgZisrLCBkLS07IHJbMiAqIGYgKyBzXSA8IHA7KSB7XG4gICAgICAgICAgICAgICAgICBmKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IHJbMiAqIGQgKyBzXSA+IHA7KSB7XG4gICAgICAgICAgICAgICAgICBkLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgclsyICogbyArIHNdID09PSBwID8gRCh0LCByLCBvLCBkKSA6IEQodCwgciwgKytkLCBuKSwgZCA8PSBpICYmIChvID0gZCArIDEpLCBpIDw9IGQgJiYgKG4gPSBkIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSh0LCByLCBhLCBvLCBuLCBzICUgMiksIGUodCwgciwgaSwgbywgYSAtIDEsIHMgKyAxKSwgZSh0LCByLCBpLCBhICsgMSwgbiwgcyArIDEpO1xuICAgICAgICB9XG4gICAgICB9KHMsIGEsIGksIDAsIHMubGVuZ3RoIC0gMSwgMCk7XG4gICAgfTtcblxuICAgIEYucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKGUsIHQsIHIsIGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCwgciwgaSwgbywgbiwgcykge1xuICAgICAgICBmb3IgKHZhciBhLCBsLCB1ID0gWzAsIGUubGVuZ3RoIC0gMSwgMF0sIGggPSBbXTsgdS5sZW5ndGg7KSB7XG4gICAgICAgICAgdmFyIGMgPSB1LnBvcCgpLFxuICAgICAgICAgICAgICBwID0gdS5wb3AoKSxcbiAgICAgICAgICAgICAgZiA9IHUucG9wKCk7XG4gICAgICAgICAgaWYgKHAgLSBmIDw9IHMpIGZvciAodmFyIGQgPSBmOyBkIDw9IHA7IGQrKykge1xuICAgICAgICAgICAgbCA9IHRbMiAqIGQgKyAxXSwgKGEgPSB0WzIgKiBkXSkgPj0gciAmJiBhIDw9IG8gJiYgbCA+PSBpICYmIGwgPD0gbiAmJiBoLnB1c2goZVtkXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBnID0gTWF0aC5mbG9vcigoZiArIHApIC8gMik7XG4gICAgICAgICAgICBsID0gdFsyICogZyArIDFdLCAoYSA9IHRbMiAqIGddKSA+PSByICYmIGEgPD0gbyAmJiBsID49IGkgJiYgbCA8PSBuICYmIGgucHVzaChlW2ddKTtcbiAgICAgICAgICAgIHZhciB2ID0gKGMgKyAxKSAlIDI7XG4gICAgICAgICAgICAoMCA9PT0gYyA/IHIgPD0gYSA6IGkgPD0gbCkgJiYgKHUucHVzaChmKSwgdS5wdXNoKGcgLSAxKSwgdS5wdXNoKHYpKSwgKDAgPT09IGMgPyBvID49IGEgOiBuID49IGwpICYmICh1LnB1c2goZyArIDEpLCB1LnB1c2gocCksIHUucHVzaCh2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9KHRoaXMuaWRzLCB0aGlzLmNvb3JkcywgZSwgdCwgciwgaSwgdGhpcy5ub2RlU2l6ZSk7XG4gICAgfSwgRi5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgICBmb3IgKHZhciBzID0gWzAsIGUubGVuZ3RoIC0gMSwgMF0sIGEgPSBbXSwgbCA9IG8gKiBvOyBzLmxlbmd0aDspIHtcbiAgICAgICAgICB2YXIgdSA9IHMucG9wKCksXG4gICAgICAgICAgICAgIGggPSBzLnBvcCgpLFxuICAgICAgICAgICAgICBjID0gcy5wb3AoKTtcbiAgICAgICAgICBpZiAoaCAtIGMgPD0gbikgZm9yICh2YXIgcCA9IGM7IHAgPD0gaDsgcCsrKSB7XG4gICAgICAgICAgICB6KHRbMiAqIHBdLCB0WzIgKiBwICsgMV0sIHIsIGkpIDw9IGwgJiYgYS5wdXNoKGVbcF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IE1hdGguZmxvb3IoKGMgKyBoKSAvIDIpLFxuICAgICAgICAgICAgICAgIGQgPSB0WzIgKiBmXSxcbiAgICAgICAgICAgICAgICBnID0gdFsyICogZiArIDFdO1xuICAgICAgICAgICAgeihkLCBnLCByLCBpKSA8PSBsICYmIGEucHVzaChlW2ZdKTtcbiAgICAgICAgICAgIHZhciB2ID0gKHUgKyAxKSAlIDI7XG4gICAgICAgICAgICAoMCA9PT0gdSA/IHIgLSBvIDw9IGQgOiBpIC0gbyA8PSBnKSAmJiAocy5wdXNoKGMpLCBzLnB1c2goZiAtIDEpLCBzLnB1c2godikpLCAoMCA9PT0gdSA/IHIgKyBvID49IGQgOiBpICsgbyA+PSBnKSAmJiAocy5wdXNoKGYgKyAxKSwgcy5wdXNoKGgpLCBzLnB1c2godikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSh0aGlzLmlkcywgdGhpcy5jb29yZHMsIGUsIHQsIHIsIHRoaXMubm9kZVNpemUpO1xuICAgIH07XG5cbiAgICB2YXIgTiA9IHtcbiAgICAgIG1pblpvb206IDAsXG4gICAgICBtYXhab29tOiAxNixcbiAgICAgIG1pblBvaW50czogMixcbiAgICAgIHJhZGl1czogNDAsXG4gICAgICBleHRlbnQ6IDUxMixcbiAgICAgIG5vZGVTaXplOiA2NCxcbiAgICAgIGxvZzogITEsXG4gICAgICBnZW5lcmF0ZUlkOiAhMSxcbiAgICAgIHJlZHVjZTogbnVsbCxcbiAgICAgIG1hcDogZnVuY3Rpb24gbWFwKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgSiA9IGZ1bmN0aW9uIEooZSkge1xuICAgICAgdGhpcy5vcHRpb25zID0gVihPYmplY3QuY3JlYXRlKE4pLCBlKSwgdGhpcy50cmVlcyA9IG5ldyBBcnJheSh0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBaKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUsXG4gICAgICAgIHk6IHQsXG4gICAgICAgIHpvb206IDEgLyAwLFxuICAgICAgICBpZDogcixcbiAgICAgICAgcGFyZW50SWQ6IC0xLFxuICAgICAgICBudW1Qb2ludHM6IGksXG4gICAgICAgIHByb3BlcnRpZXM6IG9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQShlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgaSA9IHJbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBZKHJbMF0pLFxuICAgICAgICB5OiBqKGkpLFxuICAgICAgICB6b29tOiAxIC8gMCxcbiAgICAgICAgaW5kZXg6IHQsXG4gICAgICAgIHBhcmVudElkOiAtMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgcHJvcGVydGllczogRyhlKSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFsoaSA9IGUueCwgMzYwICogKGkgLSAuNSkpLCAodCA9IGUueSwgciA9ICgxODAgLSAzNjAgKiB0KSAqIE1hdGguUEkgLyAxODAsIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cChyKSkgLyBNYXRoLlBJIC0gOTApXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHQsIHIsIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRyhlKSB7XG4gICAgICB2YXIgdCA9IGUubnVtUG9pbnRzLFxuICAgICAgICAgIHIgPSB0ID49IDFlNCA/IE1hdGgucm91bmQodCAvIDFlMykgKyBcImtcIiA6IHQgPj0gMWUzID8gTWF0aC5yb3VuZCh0IC8gMTAwKSAvIDEwICsgXCJrXCIgOiB0O1xuICAgICAgcmV0dXJuIFYoVih7fSwgZS5wcm9wZXJ0aWVzKSwge1xuICAgICAgICBjbHVzdGVyOiAhMCxcbiAgICAgICAgY2x1c3Rlcl9pZDogZS5pZCxcbiAgICAgICAgcG9pbnRfY291bnQ6IHQsXG4gICAgICAgIHBvaW50X2NvdW50X2FiYnJldmlhdGVkOiByXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBZKGUpIHtcbiAgICAgIHJldHVybiBlIC8gMzYwICsgLjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaihlKSB7XG4gICAgICB2YXIgdCA9IE1hdGguc2luKGUgKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgICByID0gLjUgLSAuMjUgKiBNYXRoLmxvZygoMSArIHQpIC8gKDEgLSB0KSkgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIHIgPCAwID8gMCA6IHIgPiAxID8gMSA6IHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVihlLCB0KSB7XG4gICAgICBmb3IgKHZhciByIGluIHQpIHtcbiAgICAgICAgZVtyXSA9IHRbcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFgoZSkge1xuICAgICAgcmV0dXJuIGUueDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXKGUpIHtcbiAgICAgIHJldHVybiBlLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUihlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICB2YXIgcyA9IG8gLSByLFxuICAgICAgICAgIGEgPSBuIC0gaTtcblxuICAgICAgaWYgKDAgIT09IHMgfHwgMCAhPT0gYSkge1xuICAgICAgICB2YXIgbCA9ICgoZSAtIHIpICogcyArICh0IC0gaSkgKiBhKSAvIChzICogcyArIGEgKiBhKTtcbiAgICAgICAgbCA+IDEgPyAociA9IG8sIGkgPSBuKSA6IGwgPiAwICYmIChyICs9IHMgKiBsLCBpICs9IGEgKiBsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChzID0gZSAtIHIpICogcyArIChhID0gdCAtIGkpICogYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxKGUsIHQsIHIsIGkpIHtcbiAgICAgIHZhciBvID0ge1xuICAgICAgICBpZDogdm9pZCAwID09PSBlID8gbnVsbCA6IGUsXG4gICAgICAgIHR5cGU6IHQsXG4gICAgICAgIGdlb21ldHJ5OiByLFxuICAgICAgICB0YWdzOiBpLFxuICAgICAgICBtaW5YOiAxIC8gMCxcbiAgICAgICAgbWluWTogMSAvIDAsXG4gICAgICAgIG1heFg6IC0xIC8gMCxcbiAgICAgICAgbWF4WTogLTEgLyAwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHIgPSBlLnR5cGU7XG4gICAgICAgIGlmIChcIlBvaW50XCIgPT09IHIgfHwgXCJNdWx0aVBvaW50XCIgPT09IHIgfHwgXCJMaW5lU3RyaW5nXCIgPT09IHIpIFUoZSwgdCk7ZWxzZSBpZiAoXCJQb2x5Z29uXCIgPT09IHIgfHwgXCJNdWx0aUxpbmVTdHJpbmdcIiA9PT0gcikgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgVShlLCB0W2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIk11bHRpUG9seWdvblwiID09PSByKSBmb3IgKGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdFtpXS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgVShlLCB0W2ldW29dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0obyksIG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVShlLCB0KSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDMpIHtcbiAgICAgICAgZS5taW5YID0gTWF0aC5taW4oZS5taW5YLCB0W3JdKSwgZS5taW5ZID0gTWF0aC5taW4oZS5taW5ZLCB0W3IgKyAxXSksIGUubWF4WCA9IE1hdGgubWF4KGUubWF4WCwgdFtyXSksIGUubWF4WSA9IE1hdGgubWF4KGUubWF4WSwgdFtyICsgMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQoZSwgdCwgciwgaSkge1xuICAgICAgaWYgKHQuZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIG8gPSB0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgbiA9IHQuZ2VvbWV0cnkudHlwZSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnBvdyhyLnRvbGVyYW5jZSAvICgoMSA8PCByLm1heFpvb20pICogci5leHRlbnQpLCAyKSxcbiAgICAgICAgICAgIGEgPSBbXSxcbiAgICAgICAgICAgIGwgPSB0LmlkO1xuICAgICAgICBpZiAoci5wcm9tb3RlSWQgPyBsID0gdC5wcm9wZXJ0aWVzW3IucHJvbW90ZUlkXSA6IHIuZ2VuZXJhdGVJZCAmJiAobCA9IGkgfHwgMCksIFwiUG9pbnRcIiA9PT0gbikgSChvLCBhKTtlbHNlIGlmIChcIk11bHRpUG9pbnRcIiA9PT0gbikgZm9yICh2YXIgdSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgSChvW3VdLCBhKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gbikgSyhvLCBhLCBzLCAhMSk7ZWxzZSBpZiAoXCJNdWx0aUxpbmVTdHJpbmdcIiA9PT0gbikge1xuICAgICAgICAgIGlmIChyLmxpbmVNZXRyaWNzKSB7XG4gICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgby5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICBLKG9bdV0sIGEgPSBbXSwgcywgITEpLCBlLnB1c2gocShsLCBcIkxpbmVTdHJpbmdcIiwgYSwgdC5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBRKG8sIGEsIHMsICExKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gbikgUShvLCBhLCBzLCAhMCk7ZWxzZSB7XG4gICAgICAgICAgaWYgKFwiTXVsdGlQb2x5Z29uXCIgIT09IG4pIHtcbiAgICAgICAgICAgIGlmIChcIkdlb21ldHJ5Q29sbGVjdGlvblwiID09PSBuKSB7XG4gICAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCB0Lmdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAkKGUsIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBsLFxuICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHQuZ2VvbWV0cnkuZ2VvbWV0cmllc1t1XSxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHQucHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sIHIsIGkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIGlzIG5vdCBhIHZhbGlkIEdlb0pTT04gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgby5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgdmFyIGggPSBbXTtcbiAgICAgICAgICAgIFEob1t1XSwgaCwgcywgITApLCBhLnB1c2goaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucHVzaChxKGwsIG4sIGEsIHQucHJvcGVydGllcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEgoZSwgdCkge1xuICAgICAgdC5wdXNoKGVlKGVbMF0pKSwgdC5wdXNoKHRlKGVbMV0pKSwgdC5wdXNoKDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEsoZSwgdCwgciwgaSkge1xuICAgICAgZm9yICh2YXIgbywgbiwgcyA9IDAsIGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbCA9IGVlKGVbYV1bMF0pLFxuICAgICAgICAgICAgdSA9IHRlKGVbYV1bMV0pO1xuICAgICAgICB0LnB1c2gobCksIHQucHVzaCh1KSwgdC5wdXNoKDApLCBhID4gMCAmJiAocyArPSBpID8gKG8gKiB1IC0gbCAqIG4pIC8gMiA6IE1hdGguc3FydChNYXRoLnBvdyhsIC0gbywgMikgKyBNYXRoLnBvdyh1IC0gbiwgMikpKSwgbyA9IGwsIG4gPSB1O1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHQubGVuZ3RoIC0gMztcbiAgICAgIHRbMl0gPSAxLCBmdW5jdGlvbiBlKHQsIHIsIGksIG8pIHtcbiAgICAgICAgZm9yICh2YXIgbiwgcyA9IG8sIGEgPSBpIC0gciA+PiAxLCBsID0gaSAtIHIsIHUgPSB0W3JdLCBoID0gdFtyICsgMV0sIGMgPSB0W2ldLCBwID0gdFtpICsgMV0sIGYgPSByICsgMzsgZiA8IGk7IGYgKz0gMykge1xuICAgICAgICAgIHZhciBkID0gUih0W2ZdLCB0W2YgKyAxXSwgdSwgaCwgYywgcCk7XG4gICAgICAgICAgaWYgKGQgPiBzKSBuID0gZiwgcyA9IGQ7ZWxzZSBpZiAoZCA9PT0gcykge1xuICAgICAgICAgICAgdmFyIGcgPSBNYXRoLmFicyhmIC0gYSk7XG4gICAgICAgICAgICBnIDwgbCAmJiAobiA9IGYsIGwgPSBnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzID4gbyAmJiAobiAtIHIgPiAzICYmIGUodCwgciwgbiwgbyksIHRbbiArIDJdID0gcywgaSAtIG4gPiAzICYmIGUodCwgbiwgaSwgbykpO1xuICAgICAgfSh0LCAwLCBoLCByKSwgdFtoICsgMl0gPSAxLCB0LnNpemUgPSBNYXRoLmFicyhzKSwgdC5zdGFydCA9IDAsIHQuZW5kID0gdC5zaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFEoZSwgdCwgciwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciBuID0gW107XG4gICAgICAgIEsoZVtvXSwgbiwgciwgaSksIHQucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlZShlKSB7XG4gICAgICByZXR1cm4gZSAvIDM2MCArIC41O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlKGUpIHtcbiAgICAgIHZhciB0ID0gTWF0aC5zaW4oZSAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgIHIgPSAuNSAtIC4yNSAqIE1hdGgubG9nKCgxICsgdCkgLyAoMSAtIHQpKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gciA8IDAgPyAwIDogciA+IDEgPyAxIDogcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZShlLCB0LCByLCBpLCBvLCBuLCBzLCBhKSB7XG4gICAgICBpZiAoaSAvPSB0LCBuID49IChyIC89IHQpICYmIHMgPCBpKSByZXR1cm4gZTtcbiAgICAgIGlmIChzIDwgciB8fCBuID49IGkpIHJldHVybiBudWxsO1xuXG4gICAgICBmb3IgKHZhciBsID0gW10sIHUgPSAwOyB1IDwgZS5sZW5ndGg7IHUrKykge1xuICAgICAgICB2YXIgaCA9IGVbdV0sXG4gICAgICAgICAgICBjID0gaC5nZW9tZXRyeSxcbiAgICAgICAgICAgIHAgPSBoLnR5cGUsXG4gICAgICAgICAgICBmID0gMCA9PT0gbyA/IGgubWluWCA6IGgubWluWSxcbiAgICAgICAgICAgIGQgPSAwID09PSBvID8gaC5tYXhYIDogaC5tYXhZO1xuICAgICAgICBpZiAoZiA+PSByICYmIGQgPCBpKSBsLnB1c2goaCk7ZWxzZSBpZiAoIShkIDwgciB8fCBmID49IGkpKSB7XG4gICAgICAgICAgdmFyIGcgPSBbXTtcbiAgICAgICAgICBpZiAoXCJQb2ludFwiID09PSBwIHx8IFwiTXVsdGlQb2ludFwiID09PSBwKSBpZShjLCBnLCByLCBpLCBvKTtlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gcCkgb2UoYywgZywgciwgaSwgbywgITEsIGEubGluZU1ldHJpY3MpO2Vsc2UgaWYgKFwiTXVsdGlMaW5lU3RyaW5nXCIgPT09IHApIHNlKGMsIGcsIHIsIGksIG8sICExKTtlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gcCkgc2UoYywgZywgciwgaSwgbywgITApO2Vsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IHApIGZvciAodmFyIHYgPSAwOyB2IDwgYy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIHNlKGNbdl0sIG0sIHIsIGksIG8sICEwKSwgbS5sZW5ndGggJiYgZy5wdXNoKG0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGEubGluZU1ldHJpY3MgJiYgXCJMaW5lU3RyaW5nXCIgPT09IHApIHtcbiAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IGcubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgICAgICBsLnB1c2gocShoLmlkLCBwLCBnW3ZdLCBoLnRhZ3MpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBcIkxpbmVTdHJpbmdcIiAhPT0gcCAmJiBcIk11bHRpTGluZVN0cmluZ1wiICE9PSBwIHx8ICgxID09PSBnLmxlbmd0aCA/IChwID0gXCJMaW5lU3RyaW5nXCIsIGcgPSBnWzBdKSA6IHAgPSBcIk11bHRpTGluZVN0cmluZ1wiKSwgXCJQb2ludFwiICE9PSBwICYmIFwiTXVsdGlQb2ludFwiICE9PSBwIHx8IChwID0gMyA9PT0gZy5sZW5ndGggPyBcIlBvaW50XCIgOiBcIk11bHRpUG9pbnRcIiksIGwucHVzaChxKGguaWQsIHAsIGcsIGgudGFncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbC5sZW5ndGggPyBsIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZShlLCB0LCByLCBpLCBvKSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuICs9IDMpIHtcbiAgICAgICAgdmFyIHMgPSBlW24gKyBvXTtcbiAgICAgICAgcyA+PSByICYmIHMgPD0gaSAmJiAodC5wdXNoKGVbbl0pLCB0LnB1c2goZVtuICsgMV0pLCB0LnB1c2goZVtuICsgMl0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZShlLCB0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICBmb3IgKHZhciBhLCBsLCB1ID0gbmUoZSksIGggPSAwID09PSBvID8gbGUgOiB1ZSwgYyA9IGUuc3RhcnQsIHAgPSAwOyBwIDwgZS5sZW5ndGggLSAzOyBwICs9IDMpIHtcbiAgICAgICAgdmFyIGYgPSBlW3BdLFxuICAgICAgICAgICAgZCA9IGVbcCArIDFdLFxuICAgICAgICAgICAgZyA9IGVbcCArIDJdLFxuICAgICAgICAgICAgdiA9IGVbcCArIDNdLFxuICAgICAgICAgICAgbSA9IGVbcCArIDRdLFxuICAgICAgICAgICAgeSA9IDAgPT09IG8gPyBmIDogZCxcbiAgICAgICAgICAgIHggPSAwID09PSBvID8gdiA6IG0sXG4gICAgICAgICAgICB3ID0gITE7XG4gICAgICAgIHMgJiYgKGEgPSBNYXRoLnNxcnQoTWF0aC5wb3coZiAtIHYsIDIpICsgTWF0aC5wb3coZCAtIG0sIDIpKSksIHkgPCByID8geCA+IHIgJiYgKGwgPSBoKHUsIGYsIGQsIHYsIG0sIHIpLCBzICYmICh1LnN0YXJ0ID0gYyArIGEgKiBsKSkgOiB5ID4gaSA/IHggPCBpICYmIChsID0gaCh1LCBmLCBkLCB2LCBtLCBpKSwgcyAmJiAodS5zdGFydCA9IGMgKyBhICogbCkpIDogYWUodSwgZiwgZCwgZyksIHggPCByICYmIHkgPj0gciAmJiAobCA9IGgodSwgZiwgZCwgdiwgbSwgciksIHcgPSAhMCksIHggPiBpICYmIHkgPD0gaSAmJiAobCA9IGgodSwgZiwgZCwgdiwgbSwgaSksIHcgPSAhMCksICFuICYmIHcgJiYgKHMgJiYgKHUuZW5kID0gYyArIGEgKiBsKSwgdC5wdXNoKHUpLCB1ID0gbmUoZSkpLCBzICYmIChjICs9IGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgUyA9IGUubGVuZ3RoIC0gMztcbiAgICAgIGYgPSBlW1NdLCBkID0gZVtTICsgMV0sIGcgPSBlW1MgKyAyXSwgKHkgPSAwID09PSBvID8gZiA6IGQpID49IHIgJiYgeSA8PSBpICYmIGFlKHUsIGYsIGQsIGcpLCBTID0gdS5sZW5ndGggLSAzLCBuICYmIFMgPj0gMyAmJiAodVtTXSAhPT0gdVswXSB8fCB1W1MgKyAxXSAhPT0gdVsxXSkgJiYgYWUodSwgdVswXSwgdVsxXSwgdVsyXSksIHUubGVuZ3RoICYmIHQucHVzaCh1KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZShlKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuICAgICAgcmV0dXJuIHQuc2l6ZSA9IGUuc2l6ZSwgdC5zdGFydCA9IGUuc3RhcnQsIHQuZW5kID0gZS5lbmQsIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2UoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIG9lKGVbc10sIHQsIHIsIGksIG8sIG4sICExKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZShlLCB0LCByLCBpKSB7XG4gICAgICBlLnB1c2godCksIGUucHVzaChyKSwgZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gKG4gLSB0KSAvIChpIC0gdCk7XG4gICAgICByZXR1cm4gZS5wdXNoKG4pLCBlLnB1c2gociArIChvIC0gcikgKiBzKSwgZS5wdXNoKDEpLCBzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVlKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gKG4gLSByKSAvIChvIC0gcik7XG4gICAgICByZXR1cm4gZS5wdXNoKHQgKyAoaSAtIHQpICogcyksIGUucHVzaChuKSwgZS5wdXNoKDEpLCBzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhlKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSBbXSwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvLFxuICAgICAgICAgICAgbiA9IGVbaV0sXG4gICAgICAgICAgICBzID0gbi50eXBlO1xuICAgICAgICBpZiAoXCJQb2ludFwiID09PSBzIHx8IFwiTXVsdGlQb2ludFwiID09PSBzIHx8IFwiTGluZVN0cmluZ1wiID09PSBzKSBvID0gY2Uobi5nZW9tZXRyeSwgdCk7ZWxzZSBpZiAoXCJNdWx0aUxpbmVTdHJpbmdcIiA9PT0gcyB8fCBcIlBvbHlnb25cIiA9PT0gcykge1xuICAgICAgICAgIG8gPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5nZW9tZXRyeS5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgby5wdXNoKGNlKG4uZ2VvbWV0cnlbYV0sIHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gcykgZm9yIChvID0gW10sIGEgPSAwOyBhIDwgbi5nZW9tZXRyeS5sZW5ndGg7IGErKykge1xuICAgICAgICAgIGZvciAodmFyIGwgPSBbXSwgdSA9IDA7IHUgPCBuLmdlb21ldHJ5W2FdLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBsLnB1c2goY2Uobi5nZW9tZXRyeVthXVt1XSwgdCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG8ucHVzaChsKTtcbiAgICAgICAgfVxuICAgICAgICByLnB1c2gocShuLmlkLCBzLCBvLCBuLnRhZ3MpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2UoZSwgdCkge1xuICAgICAgdmFyIHIgPSBbXTtcbiAgICAgIHIuc2l6ZSA9IGUuc2l6ZSwgdm9pZCAwICE9PSBlLnN0YXJ0ICYmIChyLnN0YXJ0ID0gZS5zdGFydCwgci5lbmQgPSBlLmVuZCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICByLnB1c2goZVtpXSArIHQsIGVbaSArIDFdLCBlW2kgKyAyXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlKGUsIHQpIHtcbiAgICAgIGlmIChlLnRyYW5zZm9ybWVkKSByZXR1cm4gZTtcbiAgICAgIHZhciByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbyxcbiAgICAgICAgICBuID0gMSA8PCBlLnosXG4gICAgICAgICAgcyA9IGUueCxcbiAgICAgICAgICBhID0gZS55O1xuXG4gICAgICBmb3IgKHIgPSAwOyByIDwgZS5mZWF0dXJlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgbCA9IGUuZmVhdHVyZXNbcl0sXG4gICAgICAgICAgICB1ID0gbC5nZW9tZXRyeSxcbiAgICAgICAgICAgIGggPSBsLnR5cGU7XG4gICAgICAgIGlmIChsLmdlb21ldHJ5ID0gW10sIDEgPT09IGgpIGZvciAoaSA9IDA7IGkgPCB1Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgbC5nZW9tZXRyeS5wdXNoKGZlKHVbaV0sIHVbaSArIDFdLCB0LCBuLCBzLCBhKSk7XG4gICAgICAgIH0gZWxzZSBmb3IgKGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjID0gW107XG5cbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgdVtpXS5sZW5ndGg7IG8gKz0gMikge1xuICAgICAgICAgICAgYy5wdXNoKGZlKHVbaV1bb10sIHVbaV1bbyArIDFdLCB0LCBuLCBzLCBhKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbC5nZW9tZXRyeS5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLnRyYW5zZm9ybWVkID0gITAsIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmUoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiAoZSAqIGkgLSBvKSksIE1hdGgucm91bmQociAqICh0ICogaSAtIG4pKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGUoZSwgdCwgciwgaSwgbykge1xuICAgICAgZm9yICh2YXIgbiA9IHQgPT09IG8ubWF4Wm9vbSA/IDAgOiBvLnRvbGVyYW5jZSAvICgoMSA8PCB0KSAqIG8uZXh0ZW50KSwgcyA9IHtcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBudW1Qb2ludHM6IDAsXG4gICAgICAgIG51bVNpbXBsaWZpZWQ6IDAsXG4gICAgICAgIG51bUZlYXR1cmVzOiAwLFxuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHg6IHIsXG4gICAgICAgIHk6IGksXG4gICAgICAgIHo6IHQsXG4gICAgICAgIHRyYW5zZm9ybWVkOiAhMSxcbiAgICAgICAgbWluWDogMixcbiAgICAgICAgbWluWTogMSxcbiAgICAgICAgbWF4WDogLTEsXG4gICAgICAgIG1heFk6IDBcbiAgICAgIH0sIGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykge1xuICAgICAgICBzLm51bUZlYXR1cmVzKyssIGdlKHMsIGVbYV0sIG4sIG8pO1xuICAgICAgICB2YXIgbCA9IGVbYV0ubWluWCxcbiAgICAgICAgICAgIHUgPSBlW2FdLm1pblksXG4gICAgICAgICAgICBoID0gZVthXS5tYXhYLFxuICAgICAgICAgICAgYyA9IGVbYV0ubWF4WTtcbiAgICAgICAgbCA8IHMubWluWCAmJiAocy5taW5YID0gbCksIHUgPCBzLm1pblkgJiYgKHMubWluWSA9IHUpLCBoID4gcy5tYXhYICYmIChzLm1heFggPSBoKSwgYyA+IHMubWF4WSAmJiAocy5tYXhZID0gYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlKGUsIHQsIHIsIGkpIHtcbiAgICAgIHZhciBvID0gdC5nZW9tZXRyeSxcbiAgICAgICAgICBuID0gdC50eXBlLFxuICAgICAgICAgIHMgPSBbXTtcbiAgICAgIGlmIChcIlBvaW50XCIgPT09IG4gfHwgXCJNdWx0aVBvaW50XCIgPT09IG4pIGZvciAodmFyIGEgPSAwOyBhIDwgby5sZW5ndGg7IGEgKz0gMykge1xuICAgICAgICBzLnB1c2gob1thXSksIHMucHVzaChvW2EgKyAxXSksIGUubnVtUG9pbnRzKyssIGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgfSBlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gbikgdmUocywgbywgZSwgciwgITEsICExKTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBuIHx8IFwiUG9seWdvblwiID09PSBuKSBmb3IgKGEgPSAwOyBhIDwgby5sZW5ndGg7IGErKykge1xuICAgICAgICB2ZShzLCBvW2FdLCBlLCByLCBcIlBvbHlnb25cIiA9PT0gbiwgMCA9PT0gYSk7XG4gICAgICB9IGVsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IG4pIGZvciAodmFyIGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgdSA9IG9bbF07XG5cbiAgICAgICAgZm9yIChhID0gMDsgYSA8IHUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICB2ZShzLCB1W2FdLCBlLCByLCAhMCwgMCA9PT0gYSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoID0gdC50YWdzIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKFwiTGluZVN0cmluZ1wiID09PSBuICYmIGkubGluZU1ldHJpY3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBjIGluIGggPSB7fSwgdC50YWdzKSB7XG4gICAgICAgICAgICBoW2NdID0gdC50YWdzW2NdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGgubWFwYm94X2NsaXBfc3RhcnQgPSBvLnN0YXJ0IC8gby5zaXplLCBoLm1hcGJveF9jbGlwX2VuZCA9IG8uZW5kIC8gby5zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgZ2VvbWV0cnk6IHMsXG4gICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIgPT09IG4gfHwgXCJNdWx0aVBvbHlnb25cIiA9PT0gbiA/IDMgOiBcIkxpbmVTdHJpbmdcIiA9PT0gbiB8fCBcIk11bHRpTGluZVN0cmluZ1wiID09PSBuID8gMiA6IDEsXG4gICAgICAgICAgdGFnczogaFxuICAgICAgICB9O1xuICAgICAgICBudWxsICE9PSB0LmlkICYmIChwLmlkID0gdC5pZCksIGUuZmVhdHVyZXMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZShlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICB2YXIgcyA9IGkgKiBpO1xuICAgICAgaWYgKGkgPiAwICYmIHQuc2l6ZSA8IChvID8gcyA6IGkpKSByLm51bVBvaW50cyArPSB0Lmxlbmd0aCAvIDM7ZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgbCA9IDA7IGwgPCB0Lmxlbmd0aDsgbCArPSAzKSB7XG4gICAgICAgICAgKDAgPT09IGkgfHwgdFtsICsgMl0gPiBzKSAmJiAoci5udW1TaW1wbGlmaWVkKyssIGEucHVzaCh0W2xdKSwgYS5wdXNoKHRbbCArIDFdKSksIHIubnVtUG9pbnRzKys7XG4gICAgICAgIH1cblxuICAgICAgICBvICYmIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDAsIGkgPSAwLCBvID0gZS5sZW5ndGgsIG4gPSBvIC0gMjsgaSA8IG87IG4gPSBpLCBpICs9IDIpIHtcbiAgICAgICAgICAgIHIgKz0gKGVbaV0gLSBlW25dKSAqIChlW2kgKyAxXSArIGVbbiArIDFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAociA+IDAgPT09IHQpIGZvciAoaSA9IDAsIG8gPSBlLmxlbmd0aDsgaSA8IG8gLyAyOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBzID0gZVtpXSxcbiAgICAgICAgICAgICAgICBhID0gZVtpICsgMV07XG4gICAgICAgICAgICBlW2ldID0gZVtvIC0gMiAtIGldLCBlW2kgKyAxXSA9IGVbbyAtIDEgLSBpXSwgZVtvIC0gMiAtIGldID0gcywgZVtvIC0gMSAtIGldID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oYSwgbiksIGUucHVzaChhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZShlLCB0KSB7XG4gICAgICB2YXIgciA9ICh0ID0gdGhpcy5vcHRpb25zID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgZm9yICh2YXIgciBpbiB0KSB7XG4gICAgICAgICAgZVtyXSA9IHRbcl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpLCB0KSkuZGVidWc7XG5cbiAgICAgIGlmIChyICYmIGNvbnNvbGUudGltZShcInByZXByb2Nlc3MgZGF0YVwiKSwgdC5tYXhab29tIDwgMCB8fCB0Lm1heFpvb20gPiAyNCkgdGhyb3cgbmV3IEVycm9yKFwibWF4Wm9vbSBzaG91bGQgYmUgaW4gdGhlIDAtMjQgcmFuZ2VcIik7XG4gICAgICBpZiAodC5wcm9tb3RlSWQgJiYgdC5nZW5lcmF0ZUlkKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9tb3RlSWQgYW5kIGdlbmVyYXRlSWQgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIuXCIpO1xuXG4gICAgICB2YXIgaSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGlmIChcIkZlYXR1cmVDb2xsZWN0aW9uXCIgPT09IGUudHlwZSkgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgJChyLCBlLmZlYXR1cmVzW2ldLCB0LCBpKTtcbiAgICAgICAgfSBlbHNlICQociwgXCJGZWF0dXJlXCIgPT09IGUudHlwZSA/IGUgOiB7XG4gICAgICAgICAgZ2VvbWV0cnk6IGVcbiAgICAgICAgfSwgdCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfShlLCB0KTtcblxuICAgICAgdGhpcy50aWxlcyA9IHt9LCB0aGlzLnRpbGVDb29yZHMgPSBbXSwgciAmJiAoY29uc29sZS50aW1lRW5kKFwicHJlcHJvY2VzcyBkYXRhXCIpLCBjb25zb2xlLmxvZyhcImluZGV4OiBtYXhab29tOiAlZCwgbWF4UG9pbnRzOiAlZFwiLCB0LmluZGV4TWF4Wm9vbSwgdC5pbmRleE1heFBvaW50cyksIGNvbnNvbGUudGltZShcImdlbmVyYXRlIHRpbGVzXCIpLCB0aGlzLnN0YXRzID0ge30sIHRoaXMudG90YWwgPSAwKSwgKGkgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgciA9IHQuYnVmZmVyIC8gdC5leHRlbnQsXG4gICAgICAgICAgICBpID0gZSxcbiAgICAgICAgICAgIG8gPSByZShlLCAxLCAtMSAtIHIsIHIsIDAsIC0xLCAyLCB0KSxcbiAgICAgICAgICAgIG4gPSByZShlLCAxLCAxIC0gciwgMiArIHIsIDAsIC0xLCAyLCB0KTtcbiAgICAgICAgcmV0dXJuIChvIHx8IG4pICYmIChpID0gcmUoZSwgMSwgLXIsIDEgKyByLCAwLCAtMSwgMiwgdCkgfHwgW10sIG8gJiYgKGkgPSBoZShvLCAxKS5jb25jYXQoaSkpLCBuICYmIChpID0gaS5jb25jYXQoaGUobiwgLTEpKSkpLCBpO1xuICAgICAgfShpLCB0KSkubGVuZ3RoICYmIHRoaXMuc3BsaXRUaWxlKGksIDAsIDAsIDApLCByICYmIChpLmxlbmd0aCAmJiBjb25zb2xlLmxvZyhcImZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZFwiLCB0aGlzLnRpbGVzWzBdLm51bUZlYXR1cmVzLCB0aGlzLnRpbGVzWzBdLm51bVBvaW50cyksIGNvbnNvbGUudGltZUVuZChcImdlbmVyYXRlIHRpbGVzXCIpLCBjb25zb2xlLmxvZyhcInRpbGVzIGdlbmVyYXRlZDpcIiwgdGhpcy50b3RhbCwgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0cykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5ZShlLCB0LCByKSB7XG4gICAgICByZXR1cm4gMzIgKiAoKDEgPDwgZSkgKiByICsgdCkgKyBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHhlKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS50aWxlSUQuY2Fub25pY2FsO1xuICAgICAgaWYgKCF0aGlzLl9nZW9KU09OSW5kZXgpIHJldHVybiB0KG51bGwsIG51bGwpO1xuXG4gICAgICB2YXIgaSA9IHRoaXMuX2dlb0pTT05JbmRleC5nZXRUaWxlKHIueiwgci54LCByLnkpO1xuXG4gICAgICBpZiAoIWkpIHJldHVybiB0KG51bGwsIG51bGwpO1xuICAgICAgdmFyIG8gPSBuZXcgZyhpLmZlYXR1cmVzKSxcbiAgICAgICAgICBuID0gdyhvKTtcbiAgICAgIDAgPT09IG4uYnl0ZU9mZnNldCAmJiBuLmJ5dGVMZW5ndGggPT09IG4uYnVmZmVyLmJ5dGVMZW5ndGggfHwgKG4gPSBuZXcgVWludDhBcnJheShuKSksIHQobnVsbCwge1xuICAgICAgICB2ZWN0b3JUaWxlOiBvLFxuICAgICAgICByYXdEYXRhOiBuLmJ1ZmZlclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgSi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICByID0gdC5sb2csXG4gICAgICAgICAgaSA9IHQubWluWm9vbSxcbiAgICAgICAgICBvID0gdC5tYXhab29tLFxuICAgICAgICAgIG4gPSB0Lm5vZGVTaXplO1xuICAgICAgciAmJiBjb25zb2xlLnRpbWUoXCJ0b3RhbCB0aW1lXCIpO1xuICAgICAgdmFyIHMgPSBcInByZXBhcmUgXCIgKyBlLmxlbmd0aCArIFwiIHBvaW50c1wiO1xuICAgICAgciAmJiBjb25zb2xlLnRpbWUocyksIHRoaXMucG9pbnRzID0gZTtcblxuICAgICAgZm9yICh2YXIgYSA9IFtdLCBsID0gMDsgbCA8IGUubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgZVtsXS5nZW9tZXRyeSAmJiBhLnB1c2goQShlW2xdLCBsKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJlZXNbbyArIDFdID0gbmV3IEYoYSwgWCwgVywgbiwgRmxvYXQzMkFycmF5KSwgciAmJiBjb25zb2xlLnRpbWVFbmQocyk7XG5cbiAgICAgIGZvciAodmFyIHUgPSBvOyB1ID49IGk7IHUtLSkge1xuICAgICAgICB2YXIgaCA9ICtEYXRlLm5vdygpO1xuICAgICAgICBhID0gdGhpcy5fY2x1c3RlcihhLCB1KSwgdGhpcy50cmVlc1t1XSA9IG5ldyBGKGEsIFgsIFcsIG4sIEZsb2F0MzJBcnJheSksIHIgJiYgY29uc29sZS5sb2coXCJ6JWQ6ICVkIGNsdXN0ZXJzIGluICVkbXNcIiwgdSwgYS5sZW5ndGgsICtEYXRlLm5vdygpIC0gaCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByICYmIGNvbnNvbGUudGltZUVuZChcInRvdGFsIHRpbWVcIiksIHRoaXM7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0Q2x1c3RlcnMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdmFyIHIgPSAoKGVbMF0gKyAxODApICUgMzYwICsgMzYwKSAlIDM2MCAtIDE4MCxcbiAgICAgICAgICBpID0gTWF0aC5tYXgoLTkwLCBNYXRoLm1pbig5MCwgZVsxXSkpLFxuICAgICAgICAgIG8gPSAxODAgPT09IGVbMl0gPyAxODAgOiAoKGVbMl0gKyAxODApICUgMzYwICsgMzYwKSAlIDM2MCAtIDE4MCxcbiAgICAgICAgICBuID0gTWF0aC5tYXgoLTkwLCBNYXRoLm1pbig5MCwgZVszXSkpO1xuICAgICAgaWYgKGVbMl0gLSBlWzBdID49IDM2MCkgciA9IC0xODAsIG8gPSAxODA7ZWxzZSBpZiAociA+IG8pIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmdldENsdXN0ZXJzKFtyLCBpLCAxODAsIG5dLCB0KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmdldENsdXN0ZXJzKFstMTgwLCBpLCBvLCBuXSwgdCk7XG4gICAgICAgIHJldHVybiBzLmNvbmNhdChhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbCA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKHQpXSwgdSA9IFtdLCBoID0gMCwgYyA9IGwucmFuZ2UoWShyKSwgaihuKSwgWShvKSwgaihpKSk7IGggPCBjLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgIHZhciBwID0gbC5wb2ludHNbY1toXV07XG4gICAgICAgIHUucHVzaChwLm51bVBvaW50cyA/IEIocCkgOiB0aGlzLnBvaW50c1twLmluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1O1xuICAgIH0sIEoucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZ2V0T3JpZ2luSWQoZSksXG4gICAgICAgICAgciA9IHRoaXMuX2dldE9yaWdpblpvb20oZSksXG4gICAgICAgICAgaSA9IFwiTm8gY2x1c3RlciB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuXCIsXG4gICAgICAgICAgbyA9IHRoaXMudHJlZXNbcl07XG5cbiAgICAgIGlmICghbykgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgICAgdmFyIG4gPSBvLnBvaW50c1t0XTtcbiAgICAgIGlmICghbikgdGhyb3cgbmV3IEVycm9yKGkpO1xuXG4gICAgICBmb3IgKHZhciBzID0gdGhpcy5vcHRpb25zLnJhZGl1cyAvICh0aGlzLm9wdGlvbnMuZXh0ZW50ICogTWF0aC5wb3coMiwgciAtIDEpKSwgYSA9IFtdLCBsID0gMCwgdSA9IG8ud2l0aGluKG4ueCwgbi55LCBzKTsgbCA8IHUubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgdmFyIGggPSBvLnBvaW50c1t1W2xdXTtcbiAgICAgICAgaC5wYXJlbnRJZCA9PT0gZSAmJiBhLnB1c2goaC5udW1Qb2ludHMgPyBCKGgpIDogdGhpcy5wb2ludHNbaC5pbmRleF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoMCA9PT0gYS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihpKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIEoucHJvdG90eXBlLmdldExlYXZlcyA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB2YXIgaSA9IFtdO1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZExlYXZlcyhpLCBlLCB0ID0gdCB8fCAxMCwgciA9IHIgfHwgMCwgMCksIGk7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB2YXIgaSA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKGUpXSxcbiAgICAgICAgICBvID0gTWF0aC5wb3coMiwgZSksXG4gICAgICAgICAgbiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBzID0gbi5yYWRpdXMgLyBuLmV4dGVudCxcbiAgICAgICAgICBhID0gKHIgLSBzKSAvIG8sXG4gICAgICAgICAgbCA9IChyICsgMSArIHMpIC8gbyxcbiAgICAgICAgICB1ID0ge1xuICAgICAgICBmZWF0dXJlczogW11cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLl9hZGRUaWxlRmVhdHVyZXMoaS5yYW5nZSgodCAtIHMpIC8gbywgYSwgKHQgKyAxICsgcykgLyBvLCBsKSwgaS5wb2ludHMsIHQsIHIsIG8sIHUpLCAwID09PSB0ICYmIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhpLnJhbmdlKDEgLSBzIC8gbywgYSwgMSwgbCksIGkucG9pbnRzLCBvLCByLCBvLCB1KSwgdCA9PT0gbyAtIDEgJiYgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKGkucmFuZ2UoMCwgYSwgcyAvIG8sIGwpLCBpLnBvaW50cywgLTEsIHIsIG8sIHUpLCB1LmZlYXR1cmVzLmxlbmd0aCA/IHUgOiBudWxsO1xuICAgIH0sIEoucHJvdG90eXBlLmdldENsdXN0ZXJFeHBhbnNpb25ab29tID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZvciAodmFyIHQgPSB0aGlzLl9nZXRPcmlnaW5ab29tKGUpIC0gMTsgdCA8PSB0aGlzLm9wdGlvbnMubWF4Wm9vbTspIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldENoaWxkcmVuKGUpO1xuICAgICAgICBpZiAodCsrLCAxICE9PSByLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIGUgPSByWzBdLnByb3BlcnRpZXMuY2x1c3Rlcl9pZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSwgSi5wcm90b3R5cGUuX2FwcGVuZExlYXZlcyA9IGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgcyA9IHRoaXMuZ2V0Q2hpbGRyZW4odCk7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gc1tuXSxcbiAgICAgICAgICAgIGwgPSBhLnByb3BlcnRpZXM7XG4gICAgICAgIGlmIChsICYmIGwuY2x1c3RlciA/IG8gKyBsLnBvaW50X2NvdW50IDw9IGkgPyBvICs9IGwucG9pbnRfY291bnQgOiBvID0gdGhpcy5fYXBwZW5kTGVhdmVzKGUsIGwuY2x1c3Rlcl9pZCwgciwgaSwgbykgOiBvIDwgaSA/IG8rKyA6IGUucHVzaChhKSwgZS5sZW5ndGggPT09IHIpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbztcbiAgICB9LCBKLnByb3RvdHlwZS5fYWRkVGlsZUZlYXR1cmVzID0gZnVuY3Rpb24gKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIGZvciAodmFyIHMgPSAwLCBhID0gZTsgcyA8IGEubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgdmFyIGwgPSB0W2Fbc11dLFxuICAgICAgICAgICAgdSA9IGwubnVtUG9pbnRzLFxuICAgICAgICAgICAgaCA9IHtcbiAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgIGdlb21ldHJ5OiBbW01hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChsLnggKiBvIC0gcikpLCBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5leHRlbnQgKiAobC55ICogbyAtIGkpKV1dLFxuICAgICAgICAgIHRhZ3M6IHUgPyBHKGwpIDogdGhpcy5wb2ludHNbbC5pbmRleF0ucHJvcGVydGllc1xuICAgICAgICB9LFxuICAgICAgICAgICAgYyA9IHZvaWQgMDtcbiAgICAgICAgdSA/IGMgPSBsLmlkIDogdGhpcy5vcHRpb25zLmdlbmVyYXRlSWQgPyBjID0gbC5pbmRleCA6IHRoaXMucG9pbnRzW2wuaW5kZXhdLmlkICYmIChjID0gdGhpcy5wb2ludHNbbC5pbmRleF0uaWQpLCB2b2lkIDAgIT09IGMgJiYgKGguaWQgPSBjKSwgbi5mZWF0dXJlcy5wdXNoKGgpO1xuICAgICAgfVxuICAgIH0sIEoucHJvdG90eXBlLl9saW1pdFpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbigrZSwgdGhpcy5vcHRpb25zLm1heFpvb20gKyAxKSk7XG4gICAgfSwgSi5wcm90b3R5cGUuX2NsdXN0ZXIgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gdGhpcy5vcHRpb25zLCBvID0gaS5yZWR1Y2UsIG4gPSBpLm1pblBvaW50cywgcyA9IGkucmFkaXVzIC8gKGkuZXh0ZW50ICogTWF0aC5wb3coMiwgdCkpLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIGwgPSBlW2FdO1xuXG4gICAgICAgIGlmICghKGwuem9vbSA8PSB0KSkge1xuICAgICAgICAgIGwuem9vbSA9IHQ7XG5cbiAgICAgICAgICBmb3IgKHZhciB1ID0gdGhpcy50cmVlc1t0ICsgMV0sIGggPSB1LndpdGhpbihsLngsIGwueSwgcyksIGMgPSBsLm51bVBvaW50cyB8fCAxLCBwID0gYywgZiA9IDAsIGQgPSBoOyBmIDwgZC5sZW5ndGg7IGYgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGcgPSB1LnBvaW50c1tkW2ZdXTtcbiAgICAgICAgICAgIGcuem9vbSA+IHQgJiYgKHAgKz0gZy5udW1Qb2ludHMgfHwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPj0gbikge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IGwueCAqIGMsIG0gPSBsLnkgKiBjLCB5ID0gbyAmJiBjID4gMSA/IHRoaXMuX21hcChsLCAhMCkgOiBudWxsLCB4ID0gKGEgPDwgNSkgKyAodCArIDEpICsgdGhpcy5wb2ludHMubGVuZ3RoLCB3ID0gMCwgUyA9IGg7IHcgPCBTLmxlbmd0aDsgdyArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBJID0gdS5wb2ludHNbU1t3XV07XG5cbiAgICAgICAgICAgICAgaWYgKCEoSS56b29tIDw9IHQpKSB7XG4gICAgICAgICAgICAgICAgSS56b29tID0gdDtcbiAgICAgICAgICAgICAgICB2YXIgTSA9IEkubnVtUG9pbnRzIHx8IDE7XG4gICAgICAgICAgICAgICAgdiArPSBJLnggKiBNLCBtICs9IEkueSAqIE0sIEkucGFyZW50SWQgPSB4LCBvICYmICh5IHx8ICh5ID0gdGhpcy5fbWFwKGwsICEwKSksIG8oeSwgdGhpcy5fbWFwKEkpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbC5wYXJlbnRJZCA9IHgsIHIucHVzaChaKHYgLyBwLCBtIC8gcCwgeCwgcCwgeSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoci5wdXNoKGwpLCBwID4gMSkgZm9yICh2YXIgYiA9IDAsIF8gPSBoOyBiIDwgXy5sZW5ndGg7IGIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSB1LnBvaW50c1tfW2JdXTtcbiAgICAgICAgICAgIGsuem9vbSA8PSB0IHx8IChrLnpvb20gPSB0LCByLnB1c2goaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBKLnByb3RvdHlwZS5fZ2V0T3JpZ2luSWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUgLSB0aGlzLnBvaW50cy5sZW5ndGggPj4gNTtcbiAgICB9LCBKLnByb3RvdHlwZS5fZ2V0T3JpZ2luWm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gKGUgLSB0aGlzLnBvaW50cy5sZW5ndGgpICUgMzI7XG4gICAgfSwgSi5wcm90b3R5cGUuX21hcCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICBpZiAoZS5udW1Qb2ludHMpIHJldHVybiB0ID8gVih7fSwgZS5wcm9wZXJ0aWVzKSA6IGUucHJvcGVydGllcztcbiAgICAgIHZhciByID0gdGhpcy5wb2ludHNbZS5pbmRleF0ucHJvcGVydGllcyxcbiAgICAgICAgICBpID0gdGhpcy5vcHRpb25zLm1hcChyKTtcbiAgICAgIHJldHVybiB0ICYmIGkgPT09IHIgPyBWKHt9LCBpKSA6IGk7XG4gICAgfSwgbWUucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgICBtYXhab29tOiAxNCxcbiAgICAgIGluZGV4TWF4Wm9vbTogNSxcbiAgICAgIGluZGV4TWF4UG9pbnRzOiAxZTUsXG4gICAgICB0b2xlcmFuY2U6IDMsXG4gICAgICBleHRlbnQ6IDQwOTYsXG4gICAgICBidWZmZXI6IDY0LFxuICAgICAgbGluZU1ldHJpY3M6ICExLFxuICAgICAgcHJvbW90ZUlkOiBudWxsLFxuICAgICAgZ2VuZXJhdGVJZDogITEsXG4gICAgICBkZWJ1ZzogMFxuICAgIH0sIG1lLnByb3RvdHlwZS5zcGxpdFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgciwgaSwgbywgbiwgcykge1xuICAgICAgZm9yICh2YXIgYSA9IFtlLCB0LCByLCBpXSwgbCA9IHRoaXMub3B0aW9ucywgdSA9IGwuZGVidWc7IGEubGVuZ3RoOykge1xuICAgICAgICBpID0gYS5wb3AoKSwgciA9IGEucG9wKCksIHQgPSBhLnBvcCgpLCBlID0gYS5wb3AoKTtcbiAgICAgICAgdmFyIGggPSAxIDw8IHQsXG4gICAgICAgICAgICBjID0geWUodCwgciwgaSksXG4gICAgICAgICAgICBwID0gdGhpcy50aWxlc1tjXTtcblxuICAgICAgICBpZiAoIXAgJiYgKHUgPiAxICYmIGNvbnNvbGUudGltZShcImNyZWF0aW9uXCIpLCBwID0gdGhpcy50aWxlc1tjXSA9IGRlKGUsIHQsIHIsIGksIGwpLCB0aGlzLnRpbGVDb29yZHMucHVzaCh7XG4gICAgICAgICAgejogdCxcbiAgICAgICAgICB4OiByLFxuICAgICAgICAgIHk6IGlcbiAgICAgICAgfSksIHUpKSB7XG4gICAgICAgICAgdSA+IDEgJiYgKGNvbnNvbGUubG9nKFwidGlsZSB6JWQtJWQtJWQgKGZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZCwgc2ltcGxpZmllZDogJWQpXCIsIHQsIHIsIGksIHAubnVtRmVhdHVyZXMsIHAubnVtUG9pbnRzLCBwLm51bVNpbXBsaWZpZWQpLCBjb25zb2xlLnRpbWVFbmQoXCJjcmVhdGlvblwiKSk7XG4gICAgICAgICAgdmFyIGYgPSBcInpcIiArIHQ7XG4gICAgICAgICAgdGhpcy5zdGF0c1tmXSA9ICh0aGlzLnN0YXRzW2ZdIHx8IDApICsgMSwgdGhpcy50b3RhbCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAuc291cmNlID0gZSwgbykge1xuICAgICAgICAgIGlmICh0ID09PSBsLm1heFpvb20gfHwgdCA9PT0gbykgY29udGludWU7XG4gICAgICAgICAgdmFyIGQgPSAxIDw8IG8gLSB0O1xuICAgICAgICAgIGlmIChyICE9PSBNYXRoLmZsb29yKG4gLyBkKSB8fCBpICE9PSBNYXRoLmZsb29yKHMgLyBkKSkgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gbC5pbmRleE1heFpvb20gfHwgcC5udW1Qb2ludHMgPD0gbC5pbmRleE1heFBvaW50cykgY29udGludWU7XG5cbiAgICAgICAgaWYgKHAuc291cmNlID0gbnVsbCwgMCAhPT0gZS5sZW5ndGgpIHtcbiAgICAgICAgICB1ID4gMSAmJiBjb25zb2xlLnRpbWUoXCJjbGlwcGluZ1wiKTtcbiAgICAgICAgICB2YXIgZyxcbiAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgdyxcbiAgICAgICAgICAgICAgUyA9IC41ICogbC5idWZmZXIgLyBsLmV4dGVudCxcbiAgICAgICAgICAgICAgSSA9IC41IC0gUyxcbiAgICAgICAgICAgICAgTSA9IC41ICsgUyxcbiAgICAgICAgICAgICAgYiA9IDEgKyBTO1xuICAgICAgICAgIGcgPSB2ID0gbSA9IHkgPSBudWxsLCB4ID0gcmUoZSwgaCwgciAtIFMsIHIgKyBNLCAwLCBwLm1pblgsIHAubWF4WCwgbCksIHcgPSByZShlLCBoLCByICsgSSwgciArIGIsIDAsIHAubWluWCwgcC5tYXhYLCBsKSwgZSA9IG51bGwsIHggJiYgKGcgPSByZSh4LCBoLCBpIC0gUywgaSArIE0sIDEsIHAubWluWSwgcC5tYXhZLCBsKSwgdiA9IHJlKHgsIGgsIGkgKyBJLCBpICsgYiwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB4ID0gbnVsbCksIHcgJiYgKG0gPSByZSh3LCBoLCBpIC0gUywgaSArIE0sIDEsIHAubWluWSwgcC5tYXhZLCBsKSwgeSA9IHJlKHcsIGgsIGkgKyBJLCBpICsgYiwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB3ID0gbnVsbCksIHUgPiAxICYmIGNvbnNvbGUudGltZUVuZChcImNsaXBwaW5nXCIpLCBhLnB1c2goZyB8fCBbXSwgdCArIDEsIDIgKiByLCAyICogaSksIGEucHVzaCh2IHx8IFtdLCB0ICsgMSwgMiAqIHIsIDIgKiBpICsgMSksIGEucHVzaChtIHx8IFtdLCB0ICsgMSwgMiAqIHIgKyAxLCAyICogaSksIGEucHVzaCh5IHx8IFtdLCB0ICsgMSwgMiAqIHIgKyAxLCAyICogaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbWUucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdmFyIGkgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgbyA9IGkuZXh0ZW50LFxuICAgICAgICAgIG4gPSBpLmRlYnVnO1xuICAgICAgaWYgKGUgPCAwIHx8IGUgPiAyNCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcyA9IDEgPDwgZSxcbiAgICAgICAgICBhID0geWUoZSwgdCA9ICh0ICUgcyArIHMpICUgcywgcik7XG4gICAgICBpZiAodGhpcy50aWxlc1thXSkgcmV0dXJuIHBlKHRoaXMudGlsZXNbYV0sIG8pO1xuICAgICAgbiA+IDEgJiYgY29uc29sZS5sb2coXCJkcmlsbGluZyBkb3duIHRvIHolZC0lZC0lZFwiLCBlLCB0LCByKTtcblxuICAgICAgZm9yICh2YXIgbCwgdSA9IGUsIGggPSB0LCBjID0gcjsgIWwgJiYgdSA+IDA7KSB7XG4gICAgICAgIHUtLSwgaCA9IE1hdGguZmxvb3IoaCAvIDIpLCBjID0gTWF0aC5mbG9vcihjIC8gMiksIGwgPSB0aGlzLnRpbGVzW3llKHUsIGgsIGMpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGwgJiYgbC5zb3VyY2UgPyAobiA+IDEgJiYgY29uc29sZS5sb2coXCJmb3VuZCBwYXJlbnQgdGlsZSB6JWQtJWQtJWRcIiwgdSwgaCwgYyksIG4gPiAxICYmIGNvbnNvbGUudGltZShcImRyaWxsaW5nIGRvd25cIiksIHRoaXMuc3BsaXRUaWxlKGwuc291cmNlLCB1LCBoLCBjLCBlLCB0LCByKSwgbiA+IDEgJiYgY29uc29sZS50aW1lRW5kKFwiZHJpbGxpbmcgZG93blwiKSwgdGhpcy50aWxlc1thXSA/IHBlKHRoaXMudGlsZXNbYV0sIG8pIDogbnVsbCkgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgd2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gcihlLCByLCBpLCBvKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByLCBpLCB4ZSksIG8gJiYgKHRoaXMubG9hZEdlb0pTT04gPSBvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKHIuX19wcm90b19fID0gdCksIChyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gciwgci5wcm90b3R5cGUubG9hZERhdGEgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgJiYgdGhpcy5fcGVuZGluZ0NhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICBhYmFuZG9uZWQ6ICEwXG4gICAgICAgIH0pLCB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgPSB0LCB0aGlzLl9wZW5kaW5nTG9hZERhdGFQYXJhbXMgPSBlLCB0aGlzLl9zdGF0ZSAmJiBcIklkbGVcIiAhPT0gdGhpcy5fc3RhdGUgPyB0aGlzLl9zdGF0ZSA9IFwiTmVlZHNMb2FkRGF0YVwiIDogKHRoaXMuX3N0YXRlID0gXCJDb2FsZXNjaW5nXCIsIHRoaXMuX2xvYWREYXRhKCkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2xvYWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDYWxsYmFjayAmJiB0aGlzLl9wZW5kaW5nTG9hZERhdGFQYXJhbXMpIHtcbiAgICAgICAgICB2YXIgciA9IHRoaXMuX3BlbmRpbmdDYWxsYmFjayxcbiAgICAgICAgICAgICAgaSA9IHRoaXMuX3BlbmRpbmdMb2FkRGF0YVBhcmFtcztcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ0NhbGxiYWNrLCBkZWxldGUgdGhpcy5fcGVuZGluZ0xvYWREYXRhUGFyYW1zO1xuICAgICAgICAgIHZhciBvID0gISEoaSAmJiBpLnJlcXVlc3QgJiYgaS5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZykgJiYgbmV3IGUuUmVxdWVzdFBlcmZvcm1hbmNlKGkucmVxdWVzdCk7XG4gICAgICAgICAgdGhpcy5sb2FkR2VvSlNPTihpLCBmdW5jdGlvbiAobiwgcykge1xuICAgICAgICAgICAgaWYgKG4gfHwgIXMpIHJldHVybiByKG4pO1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHMpIHJldHVybiByKG5ldyBFcnJvcihcIklucHV0IGRhdGEgZ2l2ZW4gdG8gJ1wiICsgaS5zb3VyY2UgKyBcIicgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcbiAgICAgICAgICAgICFmdW5jdGlvbiBlKHQsIHIpIHtcbiAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICBvID0gdCAmJiB0LnR5cGU7XG4gICAgICAgICAgICAgIGlmIChcIkZlYXR1cmVDb2xsZWN0aW9uXCIgPT09IG8pIGZvciAoaSA9IDA7IGkgPCB0LmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZSh0LmZlYXR1cmVzW2ldLCByKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIkdlb21ldHJ5Q29sbGVjdGlvblwiID09PSBvKSBmb3IgKGkgPSAwOyBpIDwgdC5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZSh0Lmdlb21ldHJpZXNbaV0sIHIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiRmVhdHVyZVwiID09PSBvKSBlKHQuZ2VvbWV0cnksIHIpO2Vsc2UgaWYgKFwiUG9seWdvblwiID09PSBvKSBjKHQuY29vcmRpbmF0ZXMsIHIpO2Vsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IG8pIGZvciAoaSA9IDA7IGkgPCB0LmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyh0LmNvb3JkaW5hdGVzW2ldLCByKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0ocywgITApO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoaS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGUuY3JlYXRlRXhwcmVzc2lvbihpLmZpbHRlciwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuICAgICAgICAgICAgICAgICAgb3ZlcnJpZGFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogITFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiID09PSBhLnJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGEudmFsdWUubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5rZXkgKyBcIjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHMuZmVhdHVyZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZS5ldmFsdWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHpvb206IDBcbiAgICAgICAgICAgICAgICAgIH0sIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHMgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlczogbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0Ll9nZW9KU09OSW5kZXggPSBpLmNsdXN0ZXIgPyBuZXcgSihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gdC5zdXBlcmNsdXN0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpID0gdC5jbHVzdGVyUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBpZiAoIWkgfHwgIXIpIHJldHVybiByO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IHt9LCBuID0ge30sIHMgPSB7XG4gICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHpvb206IDBcbiAgICAgICAgICAgICAgICB9LCBhID0ge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgICAgIH0sIGwgPSBPYmplY3Qua2V5cyhpKSwgdSA9IDAsIGggPSBsOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGMgPSBoW3VdLFxuICAgICAgICAgICAgICAgICAgICAgIHAgPSBpW2NdLFxuICAgICAgICAgICAgICAgICAgICAgIGYgPSBwWzBdLFxuICAgICAgICAgICAgICAgICAgICAgIGQgPSBlLmNyZWF0ZUV4cHJlc3Npb24ocFsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgZyA9IGUuY3JlYXRlRXhwcmVzc2lvbihcInN0cmluZ1wiID09IHR5cGVvZiBmID8gW2YsIFtcImFjY3VtdWxhdGVkXCJdLCBbXCJnZXRcIiwgY11dIDogZik7XG4gICAgICAgICAgICAgICAgICBvW2NdID0gZC52YWx1ZSwgbltjXSA9IGcudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIubWFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGEucHJvcGVydGllcyA9IGU7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSB7fSwgciA9IDAsIGkgPSBsOyByIDwgaS5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGlbcl07XG4gICAgICAgICAgICAgICAgICAgIHRbbl0gPSBvW25dLmV2YWx1YXRlKHMsIGEpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9LCByLnJlZHVjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICBhLnByb3BlcnRpZXMgPSB0O1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgaSA9IGw7IHIgPCBpLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gaVtyXTtcbiAgICAgICAgICAgICAgICAgICAgcy5hY2N1bXVsYXRlZCA9IGVbb10sIGVbb10gPSBuW29dLmV2YWx1YXRlKHMsIGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHI7XG4gICAgICAgICAgICAgIH0oaSkpLmxvYWQocy5mZWF0dXJlcykgOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWUoZSwgdCk7XG4gICAgICAgICAgICAgIH0ocywgaS5nZW9qc29uVnRPcHRpb25zKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIobik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQubG9hZGVkID0ge307XG4gICAgICAgICAgICB2YXIgdSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICB2YXIgaCA9IG8uZmluaXNoKCk7XG4gICAgICAgICAgICAgIGggJiYgKHUucmVzb3VyY2VUaW1pbmcgPSB7fSwgdS5yZXNvdXJjZVRpbWluZ1tpLnNvdXJjZV0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGgpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIobnVsbCwgdSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLmNvYWxlc2NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBcIkNvYWxlc2NpbmdcIiA9PT0gdGhpcy5fc3RhdGUgPyB0aGlzLl9zdGF0ZSA9IFwiSWRsZVwiIDogXCJOZWVkc0xvYWREYXRhXCIgPT09IHRoaXMuX3N0YXRlICYmICh0aGlzLl9zdGF0ZSA9IFwiQ29hbGVzY2luZ1wiLCB0aGlzLl9sb2FkRGF0YSgpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnJlbG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICB2YXIgaSA9IHRoaXMubG9hZGVkO1xuICAgICAgICByZXR1cm4gaSAmJiBpW2UudWlkXSA/IHQucHJvdG90eXBlLnJlbG9hZFRpbGUuY2FsbCh0aGlzLCBlLCByKSA6IHRoaXMubG9hZFRpbGUoZSwgcik7XG4gICAgICB9LCByLnByb3RvdHlwZS5sb2FkR2VvSlNPTiA9IGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICAgIGlmICh0LnJlcXVlc3QpIGUuZ2V0SlNPTih0LnJlcXVlc3QsIHIpO2Vsc2Uge1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0LmRhdGEpIHJldHVybiByKG5ldyBFcnJvcihcIklucHV0IGRhdGEgZ2l2ZW4gdG8gJ1wiICsgdC5zb3VyY2UgKyBcIicgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcihudWxsLCBKU09OLnBhcnNlKHQuZGF0YSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByKG5ldyBFcnJvcihcIklucHV0IGRhdGEgZ2l2ZW4gdG8gJ1wiICsgdC5zb3VyY2UgKyBcIicgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFjayAmJiB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIGFiYW5kb25lZDogITBcbiAgICAgICAgfSksIHQoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldENsdXN0ZXJFeHBhbnNpb25ab29tID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0KG51bGwsIHRoaXMuX2dlb0pTT05JbmRleC5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbShlLmNsdXN0ZXJJZCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Q2x1c3RlckNoaWxkcmVuID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0KG51bGwsIHRoaXMuX2dlb0pTT05JbmRleC5nZXRDaGlsZHJlbihlLmNsdXN0ZXJJZCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Q2x1c3RlckxlYXZlcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdChudWxsLCB0aGlzLl9nZW9KU09OSW5kZXguZ2V0TGVhdmVzKGUuY2x1c3RlcklkLCBlLmxpbWl0LCBlLm9mZnNldCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcjtcbiAgICB9KGwpLFxuICAgICAgICBTZSA9IGZ1bmN0aW9uIFNlKHQpIHtcbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIHRoaXMuc2VsZiA9IHQsIHRoaXMuYWN0b3IgPSBuZXcgZS5BY3Rvcih0LCB0aGlzKSwgdGhpcy5sYXllckluZGV4ZXMgPSB7fSwgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSB7fSwgdGhpcy53b3JrZXJTb3VyY2VUeXBlcyA9IHtcbiAgICAgICAgdmVjdG9yOiBsLFxuICAgICAgICBnZW9qc29uOiB3ZVxuICAgICAgfSwgdGhpcy53b3JrZXJTb3VyY2VzID0ge30sIHRoaXMuZGVtV29ya2VyU291cmNlcyA9IHt9LCB0aGlzLnNlbGYucmVnaXN0ZXJXb3JrZXJTb3VyY2UgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBpZiAoci53b3JrZXJTb3VyY2VUeXBlc1tlXSkgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgc291cmNlIHdpdGggbmFtZSBcIicgKyBlICsgJ1wiIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICAgICAgci53b3JrZXJTb3VyY2VUeXBlc1tlXSA9IHQ7XG4gICAgICB9LCB0aGlzLnNlbGYucmVnaXN0ZXJSVExUZXh0UGx1Z2luID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKGUucGx1Z2luLmlzUGFyc2VkKCkpIHRocm93IG5ldyBFcnJvcihcIlJUTCB0ZXh0IHBsdWdpbiBhbHJlYWR5IHJlZ2lzdGVyZWQuXCIpO1xuICAgICAgICBlLnBsdWdpbi5hcHBseUFyYWJpY1NoYXBpbmcgPSB0LmFwcGx5QXJhYmljU2hhcGluZywgZS5wbHVnaW4ucHJvY2Vzc0JpZGlyZWN0aW9uYWxUZXh0ID0gdC5wcm9jZXNzQmlkaXJlY3Rpb25hbFRleHQsIGUucGx1Z2luLnByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dCA9IHQucHJvY2Vzc1N0eWxlZEJpZGlyZWN0aW9uYWxUZXh0O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlLnByb3RvdHlwZS5zZXRSZWZlcnJlciA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB0aGlzLnJlZmVycmVyID0gdDtcbiAgICB9LCBTZS5wcm90b3R5cGUuc2V0SW1hZ2VzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5hdmFpbGFibGVJbWFnZXNbZV0gPSB0LCB0aGlzLndvcmtlclNvdXJjZXNbZV0pIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLndvcmtlclNvdXJjZXNbZV1baV07XG5cbiAgICAgICAgZm9yICh2YXIgbiBpbiBvKSB7XG4gICAgICAgICAgb1tuXS5hdmFpbGFibGVJbWFnZXMgPSB0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIoKTtcbiAgICB9LCBTZS5wcm90b3R5cGUuc2V0TGF5ZXJzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0TGF5ZXJJbmRleChlKS5yZXBsYWNlKHQpLCByKCk7XG4gICAgfSwgU2UucHJvdG90eXBlLnVwZGF0ZUxheWVycyA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0aGlzLmdldExheWVySW5kZXgoZSkudXBkYXRlKHQubGF5ZXJzLCB0LnJlbW92ZWRJZHMpLCByKCk7XG4gICAgfSwgU2UucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0V29ya2VyU291cmNlKGUsIHQudHlwZSwgdC5zb3VyY2UpLmxvYWRUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5sb2FkREVNVGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0aGlzLmdldERFTVdvcmtlclNvdXJjZShlLCB0LnNvdXJjZSkubG9hZFRpbGUodCwgcik7XG4gICAgfSwgU2UucHJvdG90eXBlLnJlbG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRXb3JrZXJTb3VyY2UoZSwgdC50eXBlLCB0LnNvdXJjZSkucmVsb2FkVGlsZSh0LCByKTtcbiAgICB9LCBTZS5wcm90b3R5cGUuYWJvcnRUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0V29ya2VyU291cmNlKGUsIHQudHlwZSwgdC5zb3VyY2UpLmFib3J0VGlsZSh0LCByKTtcbiAgICB9LCBTZS5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0aGlzLmdldFdvcmtlclNvdXJjZShlLCB0LnR5cGUsIHQuc291cmNlKS5yZW1vdmVUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5yZW1vdmVERU1UaWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHRoaXMuZ2V0REVNV29ya2VyU291cmNlKGUsIHQuc291cmNlKS5yZW1vdmVUaWxlKHQpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgaWYgKHRoaXMud29ya2VyU291cmNlc1tlXSAmJiB0aGlzLndvcmtlclNvdXJjZXNbZV1bdC50eXBlXSAmJiB0aGlzLndvcmtlclNvdXJjZXNbZV1bdC50eXBlXVt0LnNvdXJjZV0pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLndvcmtlclNvdXJjZXNbZV1bdC50eXBlXVt0LnNvdXJjZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLndvcmtlclNvdXJjZXNbZV1bdC50eXBlXVt0LnNvdXJjZV0sIHZvaWQgMCAhPT0gaS5yZW1vdmVTb3VyY2UgPyBpLnJlbW92ZVNvdXJjZSh0LCByKSA6IHIoKTtcbiAgICAgIH1cbiAgICB9LCBTZS5wcm90b3R5cGUubG9hZFdvcmtlclNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNlbGYuaW1wb3J0U2NyaXB0cyh0LnVybCksIHIoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcihlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0sIFNlLnByb3RvdHlwZS5zeW5jUlRMUGx1Z2luU3RhdGUgPSBmdW5jdGlvbiAodCwgciwgaSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZS5wbHVnaW4uc2V0U3RhdGUocik7XG4gICAgICAgIHZhciBvID0gZS5wbHVnaW4uZ2V0UGx1Z2luVVJMKCk7XG5cbiAgICAgICAgaWYgKGUucGx1Z2luLmlzTG9hZGVkKCkgJiYgIWUucGx1Z2luLmlzUGFyc2VkKCkgJiYgbnVsbCAhPSBvKSB7XG4gICAgICAgICAgdGhpcy5zZWxmLmltcG9ydFNjcmlwdHMobyk7XG4gICAgICAgICAgdmFyIG4gPSBlLnBsdWdpbi5pc1BhcnNlZCgpO1xuICAgICAgICAgIGkobiA/IHZvaWQgMCA6IG5ldyBFcnJvcihcIlJUTCBUZXh0IFBsdWdpbiBmYWlsZWQgdG8gaW1wb3J0IHNjcmlwdHMgZnJvbSBcIiArIG8pLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpKGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSwgU2UucHJvdG90eXBlLmdldEF2YWlsYWJsZUltYWdlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuYXZhaWxhYmxlSW1hZ2VzW2VdO1xuICAgICAgcmV0dXJuIHQgfHwgKHQgPSBbXSksIHQ7XG4gICAgfSwgU2UucHJvdG90eXBlLmdldExheWVySW5kZXggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLmxheWVySW5kZXhlc1tlXTtcbiAgICAgIHJldHVybiB0IHx8ICh0ID0gdGhpcy5sYXllckluZGV4ZXNbZV0gPSBuZXcgaSgpKSwgdDtcbiAgICB9LCBTZS5wcm90b3R5cGUuZ2V0V29ya2VyU291cmNlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndvcmtlclNvdXJjZXNbZV0gfHwgKHRoaXMud29ya2VyU291cmNlc1tlXSA9IHt9KSwgdGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdIHx8ICh0aGlzLndvcmtlclNvdXJjZXNbZV1bdF0gPSB7fSksIHRoaXMud29ya2VyU291cmNlc1tlXVt0XVtyXSB8fCAodGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdW3JdID0gbmV3IHRoaXMud29ya2VyU291cmNlVHlwZXNbdF0oe1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKHQsIHIsIG8pIHtcbiAgICAgICAgICBpLmFjdG9yLnNlbmQodCwgciwgbywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuZ2V0TGF5ZXJJbmRleChlKSwgdGhpcy5nZXRBdmFpbGFibGVJbWFnZXMoZSkpKSwgdGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdW3JdO1xuICAgIH0sIFNlLnByb3RvdHlwZS5nZXRERU1Xb3JrZXJTb3VyY2UgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVtV29ya2VyU291cmNlc1tlXSB8fCAodGhpcy5kZW1Xb3JrZXJTb3VyY2VzW2VdID0ge30pLCB0aGlzLmRlbVdvcmtlclNvdXJjZXNbZV1bdF0gfHwgKHRoaXMuZGVtV29ya2VyU291cmNlc1tlXVt0XSA9IG5ldyBoKCkpLCB0aGlzLmRlbVdvcmtlclNvdXJjZXNbZV1bdF07XG4gICAgfSwgU2UucHJvdG90eXBlLmVuZm9yY2VDYWNoZVNpemVMaW1pdCA9IGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICBlLmVuZm9yY2VDYWNoZVNpemVMaW1pdChyKTtcbiAgICB9LCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiAoc2VsZi53b3JrZXIgPSBuZXcgU2Uoc2VsZikpLCBTZTtcbiAgfSk7XG4gIGRlZmluZShbXCIuL3NoYXJlZFwiXSwgZnVuY3Rpb24gKHQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBlID0gdC5jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgIHJldHVybiAhaSh0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaSh0KSB7XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiB3aW5kb3cgfHwgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZG9jdW1lbnQgPyBcIm5vdCBhIGJyb3dzZXJcIiA6IEFycmF5LnByb3RvdHlwZSAmJiBBcnJheS5wcm90b3R5cGUuZXZlcnkgJiYgQXJyYXkucHJvdG90eXBlLmZpbHRlciAmJiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAmJiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgJiYgQXJyYXkucHJvdG90eXBlLm1hcCAmJiBBcnJheS5wcm90b3R5cGUuc29tZSAmJiBBcnJheS5wcm90b3R5cGUucmVkdWNlICYmIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCAmJiBBcnJheS5pc0FycmF5ID8gRnVuY3Rpb24ucHJvdG90eXBlICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID8gT2JqZWN0LmtleXMgJiYgT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiYgT2JqZWN0LmlzU2VhbGVkICYmIE9iamVjdC5pc0Zyb3plbiAmJiBPYmplY3QuaXNFeHRlbnNpYmxlICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmIE9iamVjdC5zZWFsICYmIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID8gXCJKU09OXCIgaW4gd2luZG93ICYmIFwicGFyc2VcIiBpbiBKU09OICYmIFwic3RyaW5naWZ5XCIgaW4gSlNPTiA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIShcIldvcmtlclwiIGluIHdpbmRvdyAmJiBcIkJsb2JcIiBpbiB3aW5kb3cgJiYgXCJVUkxcIiBpbiB3aW5kb3cpKSByZXR1cm4gITE7XG4gICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgIGkgPSBuZXcgQmxvYihbXCJcIl0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZSA9IG5ldyBXb3JrZXIobyksIHQgPSAhMDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0ID0gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGUgJiYgZS50ZXJtaW5hdGUoKSwgVVJMLnJldm9rZU9iamVjdFVSTChvKSwgdDtcbiAgICAgICAgfSgpID8gXCJVaW50OENsYW1wZWRBcnJheVwiIGluIHdpbmRvdyA/IEFycmF5QnVmZmVyLmlzVmlldyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgdC53aWR0aCA9IHQuaGVpZ2h0ID0gMTtcbiAgICAgICAgICB2YXIgZSA9IHQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuICExO1xuICAgICAgICAgIHZhciBpID0gZS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgaS53aWR0aCA9PT0gdC53aWR0aDtcbiAgICAgICAgfSgpID8gKHZvaWQgMCA9PT0gb1tpID0gdCAmJiB0LmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRdICYmIChvW2ldID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgICAgICAgICAgbyA9IE9iamVjdC5jcmVhdGUoZS53ZWJHTENvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBvLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPSB0LCBpLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0ID8gaS5wcm9iYWJseVN1cHBvcnRzQ29udGV4dChcIndlYmdsXCIsIG8pIHx8IGkucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgbykgOiBpLnN1cHBvcnRzQ29udGV4dCA/IGkuc3VwcG9ydHNDb250ZXh0KFwid2ViZ2xcIiwgbykgfHwgaS5zdXBwb3J0c0NvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgbykgOiBpLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBvKSB8fCBpLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgbyk7XG4gICAgICAgICAgfSh0KTtcblxuICAgICAgICAgIGlmICghaSkgcmV0dXJuICExO1xuICAgICAgICAgIHZhciBvID0gaS5jcmVhdGVTaGFkZXIoaS5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgICByZXR1cm4gISghbyB8fCBpLmlzQ29udGV4dExvc3QoKSkgJiYgKGkuc2hhZGVyU291cmNlKG8sIFwidm9pZCBtYWluKCkge31cIiksIGkuY29tcGlsZVNoYWRlcihvKSwgITAgPT09IGkuZ2V0U2hhZGVyUGFyYW1ldGVyKG8sIGkuQ09NUElMRV9TVEFUVVMpKTtcbiAgICAgICAgfShpKSksIG9baV0gPyB2b2lkIDAgOiBcImluc3VmZmljaWVudCBXZWJHTCBzdXBwb3J0XCIpIDogXCJpbnN1ZmZpY2llbnQgQ2FudmFzL2dldEltYWdlRGF0YSBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBBcnJheUJ1ZmZlciBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBVaW50OENsYW1wZWRBcnJheSBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCB3b3JrZXIgc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2llbnQgSlNPTiBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBPYmplY3Qgc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2llbnQgRnVuY3Rpb24gc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2VudCBBcnJheSBzdXBwb3J0XCI7XG4gICAgICAgIHZhciBpO1xuICAgICAgfVxuXG4gICAgICB0LmV4cG9ydHMgPyB0LmV4cG9ydHMgPSBlIDogd2luZG93ICYmICh3aW5kb3cubWFwYm94Z2wgPSB3aW5kb3cubWFwYm94Z2wgfHwge30sIHdpbmRvdy5tYXBib3hnbC5zdXBwb3J0ZWQgPSBlLCB3aW5kb3cubWFwYm94Z2wubm90U3VwcG9ydGVkUmVhc29uID0gaSk7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZS53ZWJHTENvbnRleHRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBhbnRpYWxpYXM6ICExLFxuICAgICAgICBhbHBoYTogITAsXG4gICAgICAgIHN0ZW5jaWw6ICEwLFxuICAgICAgICBkZXB0aDogITBcbiAgICAgIH07XG4gICAgfSksXG4gICAgICAgIGkgPSB7XG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlLCBpLCBvKSB7XG4gICAgICAgIHZhciByID0gdC53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaSAmJiAoci5jbGFzc05hbWUgPSBpKSwgbyAmJiBvLmFwcGVuZENoaWxkKHIpLCByO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZU5TOiBmdW5jdGlvbiBjcmVhdGVOUyhlLCBpKSB7XG4gICAgICAgIHJldHVybiB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZSwgaSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgbyA9IHQud2luZG93LmRvY3VtZW50ICYmIHQud2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuICAgIGZ1bmN0aW9uIHIodCkge1xuICAgICAgaWYgKCFvKSByZXR1cm4gdFswXTtcblxuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIGlmICh0W2VdIGluIG8pIHJldHVybiB0W2VdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdFswXTtcbiAgICB9XG5cbiAgICB2YXIgYSxcbiAgICAgICAgbiA9IHIoW1widXNlclNlbGVjdFwiLCBcIk1velVzZXJTZWxlY3RcIiwgXCJXZWJraXRVc2VyU2VsZWN0XCIsIFwibXNVc2VyU2VsZWN0XCJdKTtcbiAgICBpLmRpc2FibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgbyAmJiBuICYmIChhID0gb1tuXSwgb1tuXSA9IFwibm9uZVwiKTtcbiAgICB9LCBpLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvICYmIG4gJiYgKG9bbl0gPSBhKTtcbiAgICB9O1xuICAgIHZhciBzID0gcihbXCJ0cmFuc2Zvcm1cIiwgXCJXZWJraXRUcmFuc2Zvcm1cIl0pO1xuXG4gICAgaS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdC5zdHlsZVtzXSA9IGU7XG4gICAgfTtcblxuICAgIHZhciBsID0gITE7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIGwgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBjLCBjKSwgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgYywgYyk7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgbCA9ICExO1xuICAgIH1cblxuICAgIGkuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHQuYWRkRXZlbnRMaXN0ZW5lcihlLCBpLCBcInBhc3NpdmVcIiBpbiBvICYmIGwgPyBvIDogby5jYXB0dXJlKTtcbiAgICB9LCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgaSwgXCJwYXNzaXZlXCIgaW4gbyAmJiBsID8gbyA6IG8uY2FwdHVyZSk7XG4gICAgfTtcblxuICAgIHZhciB1ID0gZnVuY3Rpb24gdShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB1LCAhMCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGgodCkge1xuICAgICAgdmFyIGUgPSB0LnVzZXJJbWFnZTtcbiAgICAgIHJldHVybiAhIShlICYmIGUucmVuZGVyICYmIGUucmVuZGVyKCkpICYmICh0LmRhdGEucmVwbGFjZShuZXcgVWludDhBcnJheShlLmRhdGEuYnVmZmVyKSksICEwKTtcbiAgICB9XG5cbiAgICBpLnN1cHByZXNzQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdSwgITApLCB0LndpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHUsICEwKTtcbiAgICAgIH0sIDApO1xuICAgIH0sIGkubW91c2VQb3MgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIG5ldyB0LlBvaW50KGkuY2xpZW50WCAtIG8ubGVmdCAtIGUuY2xpZW50TGVmdCwgaS5jbGllbnRZIC0gby50b3AgLSBlLmNsaWVudFRvcCk7XG4gICAgfSwgaS50b3VjaFBvcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IFtdLCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgci5wdXNoKG5ldyB0LlBvaW50KGlbYV0uY2xpZW50WCAtIG8ubGVmdCAtIGUuY2xpZW50TGVmdCwgaVthXS5jbGllbnRZIC0gby50b3AgLSBlLmNsaWVudFRvcCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBpLm1vdXNlQnV0dG9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IHQud2luZG93Lkluc3RhbGxUcmlnZ2VyICYmIDIgPT09IGUuYnV0dG9uICYmIGUuY3RybEtleSAmJiB0LndpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0udG9VcHBlckNhc2UoKS5pbmRleE9mKFwiTUFDXCIpID49IDAgPyAwIDogZS5idXR0b247XG4gICAgfSwgaS5yZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KTtcbiAgICB9O1xuXG4gICAgdmFyIHAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLmltYWdlcyA9IHt9LCB0aGlzLnVwZGF0ZWRJbWFnZXMgPSB7fSwgdGhpcy5jYWxsYmFja0Rpc3BhdGNoZWRUaGlzRnJhbWUgPSB7fSwgdGhpcy5sb2FkZWQgPSAhMSwgdGhpcy5yZXF1ZXN0b3JzID0gW10sIHRoaXMucGF0dGVybnMgPSB7fSwgdGhpcy5hdGxhc0ltYWdlID0gbmV3IHQuUkdCQUltYWdlKHtcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfSksIHRoaXMuZGlydHkgPSAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldExvYWRlZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCAhPT0gdCAmJiAodGhpcy5sb2FkZWQgPSB0LCB0KSkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdGhpcy5yZXF1ZXN0b3JzOyBlIDwgaS5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG8gPSBpW2VdO1xuXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkoby5pZHMsIG8uY2FsbGJhY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVxdWVzdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlc1t0XTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodCwgZSkgJiYgKHRoaXMuaW1hZ2VzW3RdID0gZSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbyA9ICEwO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVTdHJldGNoKGkuc3RyZXRjaFgsIGkuZGF0YSAmJiBpLmRhdGEud2lkdGgpIHx8ICh0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ0ltYWdlIFwiJyArIGUgKyAnXCIgaGFzIGludmFsaWQgXCJzdHJldGNoWFwiIHZhbHVlJykpKSwgbyA9ICExKSwgdGhpcy5fdmFsaWRhdGVTdHJldGNoKGkuc3RyZXRjaFksIGkuZGF0YSAmJiBpLmRhdGEuaGVpZ2h0KSB8fCAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdJbWFnZSBcIicgKyBlICsgJ1wiIGhhcyBpbnZhbGlkIFwic3RyZXRjaFlcIiB2YWx1ZScpKSksIG8gPSAhMSksIHRoaXMuX3ZhbGlkYXRlQ29udGVudChpLmNvbnRlbnQsIGkpIHx8ICh0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ0ltYWdlIFwiJyArIGUgKyAnXCIgaGFzIGludmFsaWQgXCJjb250ZW50XCIgdmFsdWUnKSkpLCBvID0gITEpLCBvO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlU3RyZXRjaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmICghdCkgcmV0dXJuICEwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvID0gMCwgciA9IHQ7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dO1xuICAgICAgICAgIGlmIChhWzBdIDwgaSB8fCBhWzFdIDwgYVswXSB8fCBlIDwgYVsxXSkgcmV0dXJuICExO1xuICAgICAgICAgIGkgPSBhWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlQ29udGVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiAhKHQgJiYgKDQgIT09IHQubGVuZ3RoIHx8IHRbMF0gPCAwIHx8IGUuZGF0YS53aWR0aCA8IHRbMF0gfHwgdFsxXSA8IDAgfHwgZS5kYXRhLmhlaWdodCA8IHRbMV0gfHwgdFsyXSA8IDAgfHwgZS5kYXRhLndpZHRoIDwgdFsyXSB8fCB0WzNdIDwgMCB8fCBlLmRhdGEuaGVpZ2h0IDwgdFszXSB8fCB0WzJdIDwgdFswXSB8fCB0WzNdIDwgdFsxXSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXBkYXRlSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBlLnZlcnNpb24gPSB0aGlzLmltYWdlc1t0XS52ZXJzaW9uICsgMSwgdGhpcy5pbWFnZXNbdF0gPSBlLCB0aGlzLnVwZGF0ZWRJbWFnZXNbdF0gPSAhMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZUltYWdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmltYWdlc1t0XTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW1hZ2VzW3RdLCBkZWxldGUgdGhpcy5wYXR0ZXJuc1t0XSwgZS51c2VySW1hZ2UgJiYgZS51c2VySW1hZ2Uub25SZW1vdmUgJiYgZS51c2VySW1hZ2Uub25SZW1vdmUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxpc3RJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmltYWdlcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRJbWFnZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9ICEwO1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2FkZWQoKSkgZm9yICh2YXIgbyA9IDAsIHIgPSB0OyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzW3Jbb11dIHx8IChpID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNMb2FkZWQoKSB8fCBpID8gdGhpcy5fbm90aWZ5KHQsIGUpIDogdGhpcy5yZXF1ZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGlkczogdCxcbiAgICAgICAgICBjYWxsYmFjazogZVxuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBmb3IgKHZhciBvID0ge30sIHIgPSAwLCBhID0gZTsgciA8IGEubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IGFbcl07XG4gICAgICAgICAgdGhpcy5pbWFnZXNbbl0gfHwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwic3R5bGVpbWFnZW1pc3NpbmdcIiwge1xuICAgICAgICAgICAgaWQ6IG5cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLmltYWdlc1tuXTtcbiAgICAgICAgICBzID8gb1tuXSA9IHtcbiAgICAgICAgICAgIGRhdGE6IHMuZGF0YS5jbG9uZSgpLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzogcy5waXhlbFJhdGlvLFxuICAgICAgICAgICAgc2RmOiBzLnNkZixcbiAgICAgICAgICAgIHZlcnNpb246IHMudmVyc2lvbixcbiAgICAgICAgICAgIHN0cmV0Y2hYOiBzLnN0cmV0Y2hYLFxuICAgICAgICAgICAgc3RyZXRjaFk6IHMuc3RyZXRjaFksXG4gICAgICAgICAgICBjb250ZW50OiBzLmNvbnRlbnQsXG4gICAgICAgICAgICBoYXNSZW5kZXJDYWxsYmFjazogQm9vbGVhbihzLnVzZXJJbWFnZSAmJiBzLnVzZXJJbWFnZS5yZW5kZXIpXG4gICAgICAgICAgfSA6IHQud2Fybk9uY2UoJ0ltYWdlIFwiJyArIG4gKyAnXCIgY291bGQgbm90IGJlIGxvYWRlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBhZGRlZCB0aGUgaW1hZ2Ugd2l0aCBtYXAuYWRkSW1hZ2UoKSBvciBhIFwic3ByaXRlXCIgcHJvcGVydHkgaW4geW91ciBzdHlsZS4gWW91IGNhbiBwcm92aWRlIG1pc3NpbmcgaW1hZ2VzIGJ5IGxpc3RlbmluZyBmb3IgdGhlIFwic3R5bGVpbWFnZW1pc3NpbmdcIiBtYXAgZXZlbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpKG51bGwsIG8pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UGl4ZWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuYXRsYXNJbWFnZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHQuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRQYXR0ZXJuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBhdHRlcm5zW2VdLFxuICAgICAgICAgICAgbyA9IHRoaXMuZ2V0SW1hZ2UoZSk7XG4gICAgICAgIGlmICghbykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChpICYmIGkucG9zaXRpb24udmVyc2lvbiA9PT0gby52ZXJzaW9uKSByZXR1cm4gaS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKGkpIGkucG9zaXRpb24udmVyc2lvbiA9IG8udmVyc2lvbjtlbHNlIHtcbiAgICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAgIHc6IG8uZGF0YS53aWR0aCArIDIsXG4gICAgICAgICAgICBoOiBvLmRhdGEuaGVpZ2h0ICsgMixcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYSA9IG5ldyB0LkltYWdlUG9zaXRpb24ociwgbyk7XG4gICAgICAgICAgdGhpcy5wYXR0ZXJuc1tlXSA9IHtcbiAgICAgICAgICAgIGJpbjogcixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlUGF0dGVybkF0bGFzKCksIHRoaXMucGF0dGVybnNbZV0ucG9zaXRpb247XG4gICAgICB9LCBpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSBlLmdsO1xuICAgICAgICB0aGlzLmF0bGFzVGV4dHVyZSA/IHRoaXMuZGlydHkgJiYgKHRoaXMuYXRsYXNUZXh0dXJlLnVwZGF0ZSh0aGlzLmF0bGFzSW1hZ2UpLCB0aGlzLmRpcnR5ID0gITEpIDogdGhpcy5hdGxhc1RleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGUsIHRoaXMuYXRsYXNJbWFnZSwgaS5SR0JBKSwgdGhpcy5hdGxhc1RleHR1cmUuYmluZChpLkxJTkVBUiwgaS5DTEFNUF9UT19FREdFKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVQYXR0ZXJuQXRsYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhdHRlcm5zKSB7XG4gICAgICAgICAgZS5wdXNoKHRoaXMucGF0dGVybnNbaV0uYmluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvID0gdC5wb3RwYWNrKGUpLFxuICAgICAgICAgICAgciA9IG8udyxcbiAgICAgICAgICAgIGEgPSBvLmgsXG4gICAgICAgICAgICBuID0gdGhpcy5hdGxhc0ltYWdlO1xuXG4gICAgICAgIGZvciAodmFyIHMgaW4gbi5yZXNpemUoe1xuICAgICAgICAgIHdpZHRoOiByIHx8IDEsXG4gICAgICAgICAgaGVpZ2h0OiBhIHx8IDFcbiAgICAgICAgfSksIHRoaXMucGF0dGVybnMpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXMucGF0dGVybnNbc10uYmluLFxuICAgICAgICAgICAgICBjID0gbC54ICsgMSxcbiAgICAgICAgICAgICAgdSA9IGwueSArIDEsXG4gICAgICAgICAgICAgIGggPSB0aGlzLmltYWdlc1tzXS5kYXRhLFxuICAgICAgICAgICAgICBwID0gaC53aWR0aCxcbiAgICAgICAgICAgICAgZCA9IGguaGVpZ2h0O1xuICAgICAgICAgIHQuUkdCQUltYWdlLmNvcHkoaCwgbiwge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBjLFxuICAgICAgICAgICAgeTogdVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgICAgaGVpZ2h0OiBkXG4gICAgICAgICAgfSksIHQuUkdCQUltYWdlLmNvcHkoaCwgbiwge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IGQgLSAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogYyxcbiAgICAgICAgICAgIHk6IHUgLSAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgICB9KSwgdC5SR0JBSW1hZ2UuY29weShoLCBuLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IGMsXG4gICAgICAgICAgICB5OiB1ICsgZFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgfSksIHQuUkdCQUltYWdlLmNvcHkoaCwgbiwge1xuICAgICAgICAgICAgeDogcCAtIDEsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogYyAtIDEsXG4gICAgICAgICAgICB5OiB1XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IGRcbiAgICAgICAgICB9KSwgdC5SR0JBSW1hZ2UuY29weShoLCBuLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IGMgKyBwLFxuICAgICAgICAgICAgeTogdVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5ID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5iZWdpbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrRGlzcGF0Y2hlZFRoaXNGcmFtZSA9IHt9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuZGlzcGF0Y2hSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgaSA9IHQ7IGUgPCBpLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgdmFyIG8gPSBpW2VdO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrRGlzcGF0Y2hlZFRoaXNGcmFtZVtvXSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0Rpc3BhdGNoZWRUaGlzRnJhbWVbb10gPSAhMDtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5pbWFnZXNbb107XG4gICAgICAgICAgICBoKHIpICYmIHRoaXMudXBkYXRlSW1hZ2Uobywgcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgZCA9IG0sXG4gICAgICAgIF8gPSBtLFxuICAgICAgICBmID0gMWUyMDtcblxuICAgIGZ1bmN0aW9uIG0odCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdGhpcy5mb250U2l6ZSA9IHQgfHwgMjQsIHRoaXMuYnVmZmVyID0gdm9pZCAwID09PSBlID8gMyA6IGUsIHRoaXMuY3V0b2ZmID0gbyB8fCAuMjUsIHRoaXMuZm9udEZhbWlseSA9IHIgfHwgXCJzYW5zLXNlcmlmXCIsIHRoaXMuZm9udFdlaWdodCA9IGEgfHwgXCJub3JtYWxcIiwgdGhpcy5yYWRpdXMgPSBpIHx8IDg7XG4gICAgICB2YXIgbiA9IHRoaXMuc2l6ZSA9IHRoaXMuZm9udFNpemUgKyAyICogdGhpcy5idWZmZXI7XG4gICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gbiwgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHRoaXMuY3R4LmZvbnQgPSB0aGlzLmZvbnRXZWlnaHQgKyBcIiBcIiArIHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250RmFtaWx5LCB0aGlzLmN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCB0aGlzLmN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCIsIHRoaXMuZ3JpZE91dGVyID0gbmV3IEZsb2F0NjRBcnJheShuICogbiksIHRoaXMuZ3JpZElubmVyID0gbmV3IEZsb2F0NjRBcnJheShuICogbiksIHRoaXMuZiA9IG5ldyBGbG9hdDY0QXJyYXkobiksIHRoaXMuZCA9IG5ldyBGbG9hdDY0QXJyYXkobiksIHRoaXMueiA9IG5ldyBGbG9hdDY0QXJyYXkobiArIDEpLCB0aGlzLnYgPSBuZXcgSW50MTZBcnJheShuKSwgdGhpcy5taWRkbGUgPSBNYXRoLnJvdW5kKG4gLyAyICogKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkdlY2tvL1wiKSA+PSAwID8gMS4yIDogMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGcodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBlOyBzKyspIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBpOyBsKyspIHtcbiAgICAgICAgICBvW2xdID0gdFtsICogZSArIHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2KG8sIHIsIGEsIG4sIGkpLCBsID0gMDsgbCA8IGk7IGwrKykge1xuICAgICAgICAgIHRbbCAqIGUgKyBzXSA9IHJbbF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsID0gMDsgbCA8IGk7IGwrKykge1xuICAgICAgICBmb3IgKHMgPSAwOyBzIDwgZTsgcysrKSB7XG4gICAgICAgICAgb1tzXSA9IHRbbCAqIGUgKyBzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodihvLCByLCBhLCBuLCBlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHtcbiAgICAgICAgICB0W2wgKiBlICsgc10gPSBNYXRoLnNxcnQocltzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2KHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIGlbMF0gPSAwLCBvWzBdID0gLWYsIG9bMV0gPSArZjtcblxuICAgICAgZm9yICh2YXIgYSA9IDEsIG4gPSAwOyBhIDwgcjsgYSsrKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAodFthXSArIGEgKiBhIC0gKHRbaVtuXV0gKyBpW25dICogaVtuXSkpIC8gKDIgKiBhIC0gMiAqIGlbbl0pOyBzIDw9IG9bbl07KSB7XG4gICAgICAgICAgbi0tLCBzID0gKHRbYV0gKyBhICogYSAtICh0W2lbbl1dICsgaVtuXSAqIGlbbl0pKSAvICgyICogYSAtIDIgKiBpW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlbKytuXSA9IGEsIG9bbl0gPSBzLCBvW24gKyAxXSA9ICtmO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGEgPSAwLCBuID0gMDsgYSA8IHI7IGErKykge1xuICAgICAgICBmb3IgKDsgb1tuICsgMV0gPCBhOykge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGVbYV0gPSAoYSAtIGlbbl0pICogKGEgLSBpW25dKSArIHRbaVtuXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zaXplLCB0aGlzLnNpemUpLCB0aGlzLmN0eC5maWxsVGV4dCh0LCB0aGlzLmJ1ZmZlciwgdGhpcy5taWRkbGUpO1xuXG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc2l6ZSwgdGhpcy5zaXplKSwgaSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLnNpemUgKiB0aGlzLnNpemUpLCBvID0gMDsgbyA8IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTsgbysrKSB7XG4gICAgICAgIHZhciByID0gZS5kYXRhWzQgKiBvICsgM10gLyAyNTU7XG4gICAgICAgIHRoaXMuZ3JpZE91dGVyW29dID0gMSA9PT0gciA/IDAgOiAwID09PSByID8gZiA6IE1hdGgucG93KE1hdGgubWF4KDAsIC41IC0gciksIDIpLCB0aGlzLmdyaWRJbm5lcltvXSA9IDEgPT09IHIgPyBmIDogMCA9PT0gciA/IDAgOiBNYXRoLnBvdyhNYXRoLm1heCgwLCByIC0gLjUpLCAyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChnKHRoaXMuZ3JpZE91dGVyLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgdGhpcy5mLCB0aGlzLmQsIHRoaXMudiwgdGhpcy56KSwgZyh0aGlzLmdyaWRJbm5lciwgdGhpcy5zaXplLCB0aGlzLnNpemUsIHRoaXMuZiwgdGhpcy5kLCB0aGlzLnYsIHRoaXMueiksIG8gPSAwOyBvIDwgdGhpcy5zaXplICogdGhpcy5zaXplOyBvKyspIHtcbiAgICAgICAgaVtvXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgyNTUgLSAyNTUgKiAoKHRoaXMuZ3JpZE91dGVyW29dIC0gdGhpcy5ncmlkSW5uZXJbb10pIC8gdGhpcy5yYWRpdXMgKyB0aGlzLmN1dG9mZikpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH0sIGQuZGVmYXVsdCA9IF87XG5cbiAgICB2YXIgeSA9IGZ1bmN0aW9uIHkodCwgZSkge1xuICAgICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHQsIHRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ID0gZSwgdGhpcy5lbnRyaWVzID0ge307XG4gICAgfTtcblxuICAgIHkucHJvdG90eXBlLnNldFVSTCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVybCA9IHQ7XG4gICAgfSwgeS5wcm90b3R5cGUuZ2V0R2x5cGhzID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICByID0gW107XG5cbiAgICAgIGZvciAodmFyIGEgaW4gZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgcyA9IGVbYV07IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgci5wdXNoKHtcbiAgICAgICAgICAgIHN0YWNrOiBhLFxuICAgICAgICAgICAgaWQ6IHNbbl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0LmFzeW5jQWxsKHIsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdC5zdGFjayxcbiAgICAgICAgICAgIHIgPSB0LmlkLFxuICAgICAgICAgICAgYSA9IG8uZW50cmllc1tpXTtcbiAgICAgICAgYSB8fCAoYSA9IG8uZW50cmllc1tpXSA9IHtcbiAgICAgICAgICBnbHlwaHM6IHt9LFxuICAgICAgICAgIHJlcXVlc3RzOiB7fSxcbiAgICAgICAgICByYW5nZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbiA9IGEuZ2x5cGhzW3JdO1xuXG4gICAgICAgIGlmICh2b2lkIDAgPT09IG4pIHtcbiAgICAgICAgICBpZiAobiA9IG8uX3RpbnlTREYoYSwgaSwgcikpIHJldHVybiBhLmdseXBoc1tyXSA9IG4sIHZvaWQgZShudWxsLCB7XG4gICAgICAgICAgICBzdGFjazogaSxcbiAgICAgICAgICAgIGlkOiByLFxuICAgICAgICAgICAgZ2x5cGg6IG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcyA9IE1hdGguZmxvb3IociAvIDI1Nik7XG4gICAgICAgICAgaWYgKDI1NiAqIHMgPiA2NTUzNSkgZShuZXcgRXJyb3IoXCJnbHlwaHMgPiA2NTUzNSBub3Qgc3VwcG9ydGVkXCIpKTtlbHNlIGlmIChhLnJhbmdlc1tzXSkgZShudWxsLCB7XG4gICAgICAgICAgICBzdGFjazogaSxcbiAgICAgICAgICAgIGlkOiByLFxuICAgICAgICAgICAgZ2x5cGg6IG5cbiAgICAgICAgICB9KTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0gYS5yZXF1ZXN0c1tzXTtcbiAgICAgICAgICAgIGwgfHwgKGwgPSBhLnJlcXVlc3RzW3NdID0gW10sIHkubG9hZEdseXBoUmFuZ2UoaSwgcywgby51cmwsIG8ucmVxdWVzdE1hbmFnZXIsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBlKSB7XG4gICAgICAgICAgICAgICAgICBvLl9kb2VzQ2hhclN1cHBvcnRMb2NhbEdseXBoKCtpKSB8fCAoYS5nbHlwaHNbK2ldID0gZVsraV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGEucmFuZ2VzW3NdID0gITA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IGw7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgKDAsIG5bcl0pKHQsIGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGEucmVxdWVzdHNbc107XG4gICAgICAgICAgICB9KSksIGwucHVzaChmdW5jdGlvbiAodCwgbykge1xuICAgICAgICAgICAgICB0ID8gZSh0KSA6IG8gJiYgZShudWxsLCB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IGksXG4gICAgICAgICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgICAgICAgZ2x5cGg6IG9bcl0gfHwgbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGUobnVsbCwge1xuICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgIGlkOiByLFxuICAgICAgICAgIGdseXBoOiBuXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKHQpIGkodCk7ZWxzZSBpZiAoZSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSB7fSwgciA9IDAsIGEgPSBlOyByIDwgYS5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG4gPSBhW3JdLFxuICAgICAgICAgICAgICAgIHMgPSBuLnN0YWNrLFxuICAgICAgICAgICAgICAgIGwgPSBuLmlkLFxuICAgICAgICAgICAgICAgIGMgPSBuLmdseXBoO1xuICAgICAgICAgICAgKG9bc10gfHwgKG9bc10gPSB7fSkpW2xdID0gYyAmJiB7XG4gICAgICAgICAgICAgIGlkOiBjLmlkLFxuICAgICAgICAgICAgICBiaXRtYXA6IGMuYml0bWFwLmNsb25lKCksXG4gICAgICAgICAgICAgIG1ldHJpY3M6IGMubWV0cmljc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpKG51bGwsIG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB5LnByb3RvdHlwZS5fZG9lc0NoYXJTdXBwb3J0TG9jYWxHbHlwaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSAmJiAodC5pc0NoYXJbXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCJdKGUpIHx8IHQuaXNDaGFyW1wiSGFuZ3VsIFN5bGxhYmxlc1wiXShlKSB8fCB0LmlzQ2hhci5IaXJhZ2FuYShlKSB8fCB0LmlzQ2hhci5LYXRha2FuYShlKSk7XG4gICAgfSwgeS5wcm90b3R5cGUuX3RpbnlTREYgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSB0aGlzLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTtcblxuICAgICAgaWYgKHIgJiYgdGhpcy5fZG9lc0NoYXJTdXBwb3J0TG9jYWxHbHlwaChvKSkge1xuICAgICAgICB2YXIgYSA9IGUudGlueVNERjtcblxuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICB2YXIgbiA9IFwiNDAwXCI7XG4gICAgICAgICAgL2JvbGQvaS50ZXN0KGkpID8gbiA9IFwiOTAwXCIgOiAvbWVkaXVtL2kudGVzdChpKSA/IG4gPSBcIjUwMFwiIDogL2xpZ2h0L2kudGVzdChpKSAmJiAobiA9IFwiMjAwXCIpLCBhID0gZS50aW55U0RGID0gbmV3IHkuVGlueVNERigyNCwgMywgOCwgLjI1LCByLCBuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IG8sXG4gICAgICAgICAgYml0bWFwOiBuZXcgdC5BbHBoYUltYWdlKHtcbiAgICAgICAgICAgIHdpZHRoOiAzMCxcbiAgICAgICAgICAgIGhlaWdodDogMzBcbiAgICAgICAgICB9LCBhLmRyYXcoU3RyaW5nLmZyb21DaGFyQ29kZShvKSkpLFxuICAgICAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgICAgIHdpZHRoOiAyNCxcbiAgICAgICAgICAgIGhlaWdodDogMjQsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAtOCxcbiAgICAgICAgICAgIGFkdmFuY2U6IDI0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHkubG9hZEdseXBoUmFuZ2UgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgdmFyIG4gPSAyNTYgKiBpLFxuICAgICAgICAgIHMgPSBuICsgMjU1LFxuICAgICAgICAgIGwgPSByLnRyYW5zZm9ybVJlcXVlc3Qoci5ub3JtYWxpemVHbHlwaHNVUkwobykucmVwbGFjZShcIntmb250c3RhY2t9XCIsIGUpLnJlcGxhY2UoXCJ7cmFuZ2V9XCIsIG4gKyBcIi1cIiArIHMpLCB0LlJlc291cmNlVHlwZS5HbHlwaHMpO1xuICAgICAgdC5nZXRBcnJheUJ1ZmZlcihsLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAoZSkgYShlKTtlbHNlIGlmIChpKSB7XG4gICAgICAgICAgZm9yICh2YXIgbyA9IHt9LCByID0gMCwgbiA9IHQucGFyc2VHbHlwaFBCRihpKTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gbltyXTtcbiAgICAgICAgICAgIG9bcy5pZF0gPSBzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEobnVsbCwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHkuVGlueVNERiA9IGQ7XG5cbiAgICB2YXIgeCA9IGZ1bmN0aW9uIHgoKSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0LnN0eWxlU3BlYy5saWdodC5wb3NpdGlvbjtcbiAgICB9O1xuXG4gICAgeC5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICByZXR1cm4gdC5zcGhlcmljYWxUb0NhcnRlc2lhbihlLmV4cHJlc3Npb24uZXZhbHVhdGUoaSkpO1xuICAgIH0sIHgucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHQubnVtYmVyKGUueCwgaS54LCBvKSxcbiAgICAgICAgeTogdC5udW1iZXIoZS55LCBpLnksIG8pLFxuICAgICAgICB6OiB0Lm51bWJlcihlLnosIGkueiwgbylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBiID0gbmV3IHQuUHJvcGVydGllcyh7XG4gICAgICBhbmNob3I6IG5ldyB0LkRhdGFDb25zdGFudFByb3BlcnR5KHQuc3R5bGVTcGVjLmxpZ2h0LmFuY2hvciksXG4gICAgICBwb3NpdGlvbjogbmV3IHgoKSxcbiAgICAgIGNvbG9yOiBuZXcgdC5EYXRhQ29uc3RhbnRQcm9wZXJ0eSh0LnN0eWxlU3BlYy5saWdodC5jb2xvciksXG4gICAgICBpbnRlbnNpdHk6IG5ldyB0LkRhdGFDb25zdGFudFByb3BlcnR5KHQuc3R5bGVTcGVjLmxpZ2h0LmludGVuc2l0eSlcbiAgICB9KSxcbiAgICAgICAgdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGkpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLl90cmFuc2l0aW9uYWJsZSA9IG5ldyB0LlRyYW5zaXRpb25hYmxlKGIpLCB0aGlzLnNldExpZ2h0KGkpLCB0aGlzLl90cmFuc2l0aW9uaW5nID0gdGhpcy5fdHJhbnNpdGlvbmFibGUudW50cmFuc2l0aW9uZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uYWJsZS5zZXJpYWxpemUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldExpZ2h0ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgIXRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVMaWdodCwgZSwgaSkpIGZvciAodmFyIG8gaW4gZSkge1xuICAgICAgICAgIHZhciByID0gZVtvXTtcbiAgICAgICAgICB0LmVuZHNXaXRoKG8sIFwiLXRyYW5zaXRpb25cIikgPyB0aGlzLl90cmFuc2l0aW9uYWJsZS5zZXRUcmFuc2l0aW9uKG8uc2xpY2UoMCwgLVwiLXRyYW5zaXRpb25cIi5sZW5ndGgpLCByKSA6IHRoaXMuX3RyYW5zaXRpb25hYmxlLnNldFZhbHVlKG8sIHIpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25pbmcgPSB0aGlzLl90cmFuc2l0aW9uYWJsZS50cmFuc2l0aW9uZWQodCwgdGhpcy5fdHJhbnNpdGlvbmluZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmluZy5oYXNUcmFuc2l0aW9uKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHRoaXMuX3RyYW5zaXRpb25pbmcucG9zc2libHlFdmFsdWF0ZSh0KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiAoIW8gfHwgITEgIT09IG8udmFsaWRhdGUpICYmIHQuZW1pdFZhbGlkYXRpb25FcnJvcnModGhpcywgZS5jYWxsKHQudmFsaWRhdGVTdHlsZSwgdC5leHRlbmQoe1xuICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBnbHlwaHM6ICEwLFxuICAgICAgICAgICAgc3ByaXRlOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICB9KSkpO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIFQgPSBmdW5jdGlvbiBUKHQsIGUpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0LCB0aGlzLmhlaWdodCA9IGUsIHRoaXMubmV4dFJvdyA9IDAsIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCksIHRoaXMuZGFzaEVudHJ5ID0ge307XG4gICAgfTtcblxuICAgIFQucHJvdG90eXBlLmdldERhc2ggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0LmpvaW4oXCIsXCIpICsgU3RyaW5nKGUpO1xuICAgICAgcmV0dXJuIHRoaXMuZGFzaEVudHJ5W2ldIHx8ICh0aGlzLmRhc2hFbnRyeVtpXSA9IHRoaXMuYWRkRGFzaCh0LCBlKSksIHRoaXMuZGFzaEVudHJ5W2ldO1xuICAgIH0sIFQucHJvdG90eXBlLmdldERhc2hSYW5nZXMgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSBbXSxcbiAgICAgICAgICByID0gdC5sZW5ndGggJSAyID09IDEgPyAtdFt0Lmxlbmd0aCAtIDFdICogaSA6IDAsXG4gICAgICAgICAgYSA9IHRbMF0gKiBpLFxuICAgICAgICAgIG4gPSAhMDtcbiAgICAgIG8ucHVzaCh7XG4gICAgICAgIGxlZnQ6IHIsXG4gICAgICAgIHJpZ2h0OiBhLFxuICAgICAgICBpc0Rhc2g6IG4sXG4gICAgICAgIHplcm9MZW5ndGg6IDAgPT09IHRbMF1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBzID0gdFswXSwgbCA9IDE7IGwgPCB0Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBjID0gdFtsXTtcbiAgICAgICAgby5wdXNoKHtcbiAgICAgICAgICBsZWZ0OiByID0gcyAqIGksXG4gICAgICAgICAgcmlnaHQ6IGEgPSAocyArPSBjKSAqIGksXG4gICAgICAgICAgaXNEYXNoOiBuID0gIW4sXG4gICAgICAgICAgemVyb0xlbmd0aDogMCA9PT0gY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG87XG4gICAgfSwgVC5wcm90b3R5cGUuYWRkUm91bmREYXNoID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSBlIC8gMiwgciA9IC1pOyByIDw9IGk7IHIrKykge1xuICAgICAgICBmb3IgKHZhciBhID0gdGhpcy53aWR0aCAqICh0aGlzLm5leHRSb3cgKyBpICsgciksIG4gPSAwLCBzID0gdFtuXSwgbCA9IDA7IGwgPCB0aGlzLndpZHRoOyBsKyspIHtcbiAgICAgICAgICBsIC8gcy5yaWdodCA+IDEgJiYgKHMgPSB0Wysrbl0pO1xuICAgICAgICAgIHZhciBjID0gTWF0aC5hYnMobCAtIHMubGVmdCksXG4gICAgICAgICAgICAgIHUgPSBNYXRoLmFicyhsIC0gcy5yaWdodCksXG4gICAgICAgICAgICAgIGggPSBNYXRoLm1pbihjLCB1KSxcbiAgICAgICAgICAgICAgcCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgZCA9IHIgLyBpICogKG8gKyAxKTtcblxuICAgICAgICAgIGlmIChzLmlzRGFzaCkge1xuICAgICAgICAgICAgdmFyIF8gPSBvIC0gTWF0aC5hYnMoZCk7XG5cbiAgICAgICAgICAgIHAgPSBNYXRoLnNxcnQoaCAqIGggKyBfICogXyk7XG4gICAgICAgICAgfSBlbHNlIHAgPSBvIC0gTWF0aC5zcXJ0KGggKiBoICsgZCAqIGQpO1xuXG4gICAgICAgICAgdGhpcy5kYXRhW2EgKyBsXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcCArIDEyOCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgVC5wcm90b3R5cGUuYWRkUmVndWxhckRhc2ggPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHtcbiAgICAgICAgdmFyIGkgPSB0W2VdLFxuICAgICAgICAgICAgbyA9IHRbZSArIDFdO1xuICAgICAgICBpLnplcm9MZW5ndGggPyB0LnNwbGljZShlLCAxKSA6IG8gJiYgby5pc0Rhc2ggPT09IGkuaXNEYXNoICYmIChvLmxlZnQgPSBpLmxlZnQsIHQuc3BsaWNlKGUsIDEpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSB0WzBdLFxuICAgICAgICAgIGEgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgICByLmlzRGFzaCA9PT0gYS5pc0Rhc2ggJiYgKHIubGVmdCA9IGEubGVmdCAtIHRoaXMud2lkdGgsIGEucmlnaHQgPSByLnJpZ2h0ICsgdGhpcy53aWR0aCk7XG5cbiAgICAgIGZvciAodmFyIG4gPSB0aGlzLndpZHRoICogdGhpcy5uZXh0Um93LCBzID0gMCwgbCA9IHRbc10sIGMgPSAwOyBjIDwgdGhpcy53aWR0aDsgYysrKSB7XG4gICAgICAgIGMgLyBsLnJpZ2h0ID4gMSAmJiAobCA9IHRbKytzXSk7XG4gICAgICAgIHZhciB1ID0gTWF0aC5hYnMoYyAtIGwubGVmdCksXG4gICAgICAgICAgICBoID0gTWF0aC5hYnMoYyAtIGwucmlnaHQpLFxuICAgICAgICAgICAgcCA9IE1hdGgubWluKHUsIGgpO1xuICAgICAgICB0aGlzLmRhdGFbbiArIGNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAobC5pc0Rhc2ggPyBwIDogLXApICsgMTI4KSk7XG4gICAgICB9XG4gICAgfSwgVC5wcm90b3R5cGUuYWRkRGFzaCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IGkgPyA3IDogMCxcbiAgICAgICAgICByID0gMiAqIG8gKyAxO1xuICAgICAgaWYgKHRoaXMubmV4dFJvdyArIHIgPiB0aGlzLmhlaWdodCkgcmV0dXJuIHQud2Fybk9uY2UoXCJMaW5lQXRsYXMgb3V0IG9mIHNwYWNlXCIpLCBudWxsO1xuXG4gICAgICBmb3IgKHZhciBhID0gMCwgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGEgKz0gZVtuXTtcbiAgICAgIH1cblxuICAgICAgaWYgKDAgIT09IGEpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLndpZHRoIC8gYSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmdldERhc2hSYW5nZXMoZSwgdGhpcy53aWR0aCwgcyk7XG4gICAgICAgIGkgPyB0aGlzLmFkZFJvdW5kRGFzaChsLCBzLCBvKSA6IHRoaXMuYWRkUmVndWxhckRhc2gobCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjID0ge1xuICAgICAgICB5OiAodGhpcy5uZXh0Um93ICsgbyArIC41KSAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IDIgKiBvIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFJvdyArPSByLCB0aGlzLmRpcnR5ID0gITAsIGM7XG4gICAgfSwgVC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuZ2w7XG4gICAgICB0aGlzLnRleHR1cmUgPyAoZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSksIHRoaXMuZGlydHkgJiYgKHRoaXMuZGlydHkgPSAhMSwgZS50ZXhTdWJJbWFnZTJEKGUuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGUuQUxQSEEsIGUuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKSkpIDogKHRoaXMudGV4dHVyZSA9IGUuY3JlYXRlVGV4dHVyZSgpLCBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX1dSQVBfUywgZS5SRVBFQVQpLCBlLnRleFBhcmFtZXRlcmkoZS5URVhUVVJFXzJELCBlLlRFWFRVUkVfV1JBUF9ULCBlLlJFUEVBVCksIGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsIGUuVEVYVFVSRV9NSU5fRklMVEVSLCBlLkxJTkVBUiksIGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsIGUuVEVYVFVSRV9NQUdfRklMVEVSLCBlLkxJTkVBUiksIGUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsIDAsIGUuQUxQSEEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBlLkFMUEhBLCBlLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSkpO1xuICAgIH07XG5cbiAgICB2YXIgRSA9IGZ1bmN0aW9uIGUoaSwgbykge1xuICAgICAgdGhpcy53b3JrZXJQb29sID0gaSwgdGhpcy5hY3RvcnMgPSBbXSwgdGhpcy5jdXJyZW50QWN0b3IgPSAwLCB0aGlzLmlkID0gdC51bmlxdWVJZCgpO1xuXG4gICAgICBmb3IgKHZhciByID0gdGhpcy53b3JrZXJQb29sLmFjcXVpcmUodGhpcy5pZCksIGEgPSAwOyBhIDwgci5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbiA9IG5ldyBlLkFjdG9yKHJbYV0sIG8sIHRoaXMuaWQpO1xuICAgICAgICBuLm5hbWUgPSBcIldvcmtlciBcIiArIGEsIHRoaXMuYWN0b3JzLnB1c2gobik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEkoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBmdW5jdGlvbiByKF9yMiwgYSkge1xuICAgICAgICBpZiAoX3IyKSByZXR1cm4gbyhfcjIpO1xuXG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgdmFyIG4gPSB0LnBpY2sodC5leHRlbmQoYSwgZSksIFtcInRpbGVzXCIsIFwibWluem9vbVwiLCBcIm1heHpvb21cIiwgXCJhdHRyaWJ1dGlvblwiLCBcIm1hcGJveF9sb2dvXCIsIFwiYm91bmRzXCIsIFwic2NoZW1lXCIsIFwidGlsZVNpemVcIiwgXCJlbmNvZGluZ1wiXSk7XG4gICAgICAgICAgYS52ZWN0b3JfbGF5ZXJzICYmIChuLnZlY3RvckxheWVycyA9IGEudmVjdG9yX2xheWVycywgbi52ZWN0b3JMYXllcklkcyA9IG4udmVjdG9yTGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICAgICAgfSkpLCBuLnRpbGVzID0gaS5jYW5vbmljYWxpemVUaWxlc2V0KG4sIGUudXJsKSwgbyhudWxsLCBuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGUudXJsID8gdC5nZXRKU09OKGkudHJhbnNmb3JtUmVxdWVzdChpLm5vcm1hbGl6ZVNvdXJjZVVSTChlLnVybCksIHQuUmVzb3VyY2VUeXBlLlNvdXJjZSksIHIpIDogdC5icm93c2VyLmZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHIobnVsbCwgZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBFLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdC5hc3luY0FsbCh0aGlzLmFjdG9ycywgZnVuY3Rpb24gKHQsIG8pIHtcbiAgICAgICAgdC5zZW5kKGUsIGksIG8pO1xuICAgICAgfSwgbyA9IG8gfHwgZnVuY3Rpb24gKCkge30pO1xuICAgIH0sIEUucHJvdG90eXBlLmdldEFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFjdG9yID0gKHRoaXMuY3VycmVudEFjdG9yICsgMSkgJSB0aGlzLmFjdG9ycy5sZW5ndGgsIHRoaXMuYWN0b3JzW3RoaXMuY3VycmVudEFjdG9yXTtcbiAgICB9LCBFLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucmVtb3ZlKCk7XG4gICAgICB9KSwgdGhpcy5hY3RvcnMgPSBbXSwgdGhpcy53b3JrZXJQb29sLnJlbGVhc2UodGhpcy5pZCk7XG4gICAgfSwgRS5BY3RvciA9IHQuQWN0b3I7XG5cbiAgICB2YXIgUCA9IGZ1bmN0aW9uIFAoZSwgaSwgbykge1xuICAgICAgdGhpcy5ib3VuZHMgPSB0LkxuZ0xhdEJvdW5kcy5jb252ZXJ0KHRoaXMudmFsaWRhdGVCb3VuZHMoZSkpLCB0aGlzLm1pbnpvb20gPSBpIHx8IDAsIHRoaXMubWF4em9vbSA9IG8gfHwgMjQ7XG4gICAgfTtcblxuICAgIFAucHJvdG90eXBlLnZhbGlkYXRlQm91bmRzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpICYmIDQgPT09IHQubGVuZ3RoID8gW01hdGgubWF4KC0xODAsIHRbMF0pLCBNYXRoLm1heCgtOTAsIHRbMV0pLCBNYXRoLm1pbigxODAsIHRbMl0pLCBNYXRoLm1pbig5MCwgdFszXSldIDogWy0xODAsIC05MCwgMTgwLCA5MF07XG4gICAgfSwgUC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSBNYXRoLnBvdygyLCBlLnopLFxuICAgICAgICAgIG8gPSBNYXRoLmZsb29yKHQubWVyY2F0b3JYZnJvbUxuZyh0aGlzLmJvdW5kcy5nZXRXZXN0KCkpICogaSksXG4gICAgICAgICAgciA9IE1hdGguZmxvb3IodC5tZXJjYXRvcllmcm9tTGF0KHRoaXMuYm91bmRzLmdldE5vcnRoKCkpICogaSksXG4gICAgICAgICAgYSA9IE1hdGguY2VpbCh0Lm1lcmNhdG9yWGZyb21MbmcodGhpcy5ib3VuZHMuZ2V0RWFzdCgpKSAqIGkpLFxuICAgICAgICAgIG4gPSBNYXRoLmNlaWwodC5tZXJjYXRvcllmcm9tTGF0KHRoaXMuYm91bmRzLmdldFNvdXRoKCkpICogaSk7XG4gICAgICByZXR1cm4gZS54ID49IG8gJiYgZS54IDwgYSAmJiBlLnkgPj0gciAmJiBlLnkgPCBuO1xuICAgIH07XG5cbiAgICB2YXIgUyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgaWYgKGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGksIHRoaXMuZGlzcGF0Y2hlciA9IHIsIHRoaXMudHlwZSA9IFwidmVjdG9yXCIsIHRoaXMubWluem9vbSA9IDAsIHRoaXMubWF4em9vbSA9IDIyLCB0aGlzLnNjaGVtZSA9IFwieHl6XCIsIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPSAhMCwgdGhpcy5pc1RpbGVDbGlwcGVkID0gITAsIHRoaXMuX2xvYWRlZCA9ICExLCB0LmV4dGVuZCh0aGlzLCB0LnBpY2sobywgW1widXJsXCIsIFwic2NoZW1lXCIsIFwidGlsZVNpemVcIiwgXCJwcm9tb3RlSWRcIl0pKSwgdGhpcy5fb3B0aW9ucyA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInZlY3RvclwiXG4gICAgICAgIH0sIG8pLCB0aGlzLl9jb2xsZWN0UmVzb3VyY2VUaW1pbmcgPSBvLmNvbGxlY3RSZXNvdXJjZVRpbWluZywgNTEyICE9PSB0aGlzLnRpbGVTaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJ2ZWN0b3IgdGlsZSBzb3VyY2VzIG11c3QgaGF2ZSBhIHRpbGVTaXplIG9mIDUxMlwiKTtcbiAgICAgICAgdGhpcy5zZXRFdmVudGVkUGFyZW50KGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9ICExLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgfSkpLCB0aGlzLl90aWxlSlNPTlJlcXVlc3QgPSBJKHRoaXMuX29wdGlvbnMsIHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlciwgZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgICBlLl90aWxlSlNPTlJlcXVlc3QgPSBudWxsLCBlLl9sb2FkZWQgPSAhMCwgaSA/IGUuZmlyZShuZXcgdC5FcnJvckV2ZW50KGkpKSA6IG8gJiYgKHQuZXh0ZW5kKGUsIG8pLCBvLmJvdW5kcyAmJiAoZS50aWxlQm91bmRzID0gbmV3IFAoby5ib3VuZHMsIGUubWluem9vbSwgZS5tYXh6b29tKSksIHQucG9zdFR1cm5zdGlsZUV2ZW50KG8udGlsZXMsIGUubWFwLl9yZXF1ZXN0TWFuYWdlci5fY3VzdG9tQWNjZXNzVG9rZW4pLCB0LnBvc3RNYXBMb2FkRXZlbnQoby50aWxlcywgZS5tYXAuX2dldE1hcElkKCksIGUubWFwLl9yZXF1ZXN0TWFuYWdlci5fc2t1VG9rZW4sIGUubWFwLl9yZXF1ZXN0TWFuYWdlci5fY3VzdG9tQWNjZXNzVG9rZW4pLCBlLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwibWV0YWRhdGFcIlxuICAgICAgICAgIH0pKSwgZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcImNvbnRlbnRcIlxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy50aWxlQm91bmRzIHx8IHRoaXMudGlsZUJvdW5kcy5jb250YWlucyh0LmNhbm9uaWNhbCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRTb3VyY2VQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3RpbGVKU09OUmVxdWVzdCAmJiB0aGlzLl90aWxlSlNPTlJlcXVlc3QuY2FuY2VsKCksIHQoKSwgdGhpcy5tYXAuc3R5bGUuc291cmNlQ2FjaGVzW3RoaXMuaWRdLmNsZWFyVGlsZXMoKSwgdGhpcy5sb2FkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRUaWxlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U291cmNlUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUuX29wdGlvbnMudGlsZXMgPSB0O1xuICAgICAgICB9KSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldFVybCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U291cmNlUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUudXJsID0gdCwgZS5fb3B0aW9ucy51cmwgPSB0O1xuICAgICAgICB9KSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aWxlSlNPTlJlcXVlc3QgJiYgKHRoaXMuX3RpbGVKU09OUmVxdWVzdC5jYW5jZWwoKSwgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ID0gbnVsbCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLm5vcm1hbGl6ZVRpbGVVUkwoZS50aWxlSUQuY2Fub25pY2FsLnVybCh0aGlzLnRpbGVzLCB0aGlzLnNjaGVtZSkpLFxuICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICByZXF1ZXN0OiB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChvLCB0LlJlc291cmNlVHlwZS5UaWxlKSxcbiAgICAgICAgICB1aWQ6IGUudWlkLFxuICAgICAgICAgIHRpbGVJRDogZS50aWxlSUQsXG4gICAgICAgICAgem9vbTogZS50aWxlSUQub3ZlcnNjYWxlZFosXG4gICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUgKiBlLnRpbGVJRC5vdmVyc2NhbGVGYWN0b3IoKSxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgIHBpeGVsUmF0aW86IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogdGhpcy5tYXAuc2hvd0NvbGxpc2lvbkJveGVzLFxuICAgICAgICAgIHByb21vdGVJZDogdGhpcy5wcm9tb3RlSWRcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhKG8sIHIpIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlIGUucmVxdWVzdCwgZS5hYm9ydGVkID8gaShudWxsKSA6IG8gJiYgNDA0ICE9PSBvLnN0YXR1cyA/IGkobykgOiAociAmJiByLnJlc291cmNlVGltaW5nICYmIChlLnJlc291cmNlVGltaW5nID0gci5yZXNvdXJjZVRpbWluZyksIHRoaXMubWFwLl9yZWZyZXNoRXhwaXJlZFRpbGVzICYmIHIgJiYgZS5zZXRFeHBpcnlEYXRhKHIpLCBlLmxvYWRWZWN0b3JEYXRhKHIsIHRoaXMubWFwLnBhaW50ZXIpLCB0LmNhY2hlRW50cnlQb3NzaWJseUFkZGVkKHRoaXMuZGlzcGF0Y2hlciksIGkobnVsbCksIHZvaWQgKGUucmVsb2FkQ2FsbGJhY2sgJiYgKHRoaXMubG9hZFRpbGUoZSwgZS5yZWxvYWRDYWxsYmFjayksIGUucmVsb2FkQ2FsbGJhY2sgPSBudWxsKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9IHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZywgZS5hY3RvciAmJiBcImV4cGlyZWRcIiAhPT0gZS5zdGF0ZSA/IFwibG9hZGluZ1wiID09PSBlLnN0YXRlID8gZS5yZWxvYWRDYWxsYmFjayA9IGkgOiBlLnJlcXVlc3QgPSBlLmFjdG9yLnNlbmQoXCJyZWxvYWRUaWxlXCIsIHIsIGEuYmluZCh0aGlzKSkgOiAoZS5hY3RvciA9IHRoaXMuZGlzcGF0Y2hlci5nZXRBY3RvcigpLCBlLnJlcXVlc3QgPSBlLmFjdG9yLnNlbmQoXCJsb2FkVGlsZVwiLCByLCBhLmJpbmQodGhpcykpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucmVxdWVzdCAmJiAodC5yZXF1ZXN0LmNhbmNlbCgpLCBkZWxldGUgdC5yZXF1ZXN0KSwgdC5hY3RvciAmJiB0LmFjdG9yLnNlbmQoXCJhYm9ydFRpbGVcIiwge1xuICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgfSwgaS5wcm90b3R5cGUudW5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQudW5sb2FkVmVjdG9yRGF0YSgpLCB0LmFjdG9yICYmIHQuYWN0b3Iuc2VuZChcInJlbW92ZVRpbGVcIiwge1xuICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIEMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaShpLCBvLCByLCBhKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGksIHRoaXMuZGlzcGF0Y2hlciA9IHIsIHRoaXMuc2V0RXZlbnRlZFBhcmVudChhKSwgdGhpcy50eXBlID0gXCJyYXN0ZXJcIiwgdGhpcy5taW56b29tID0gMCwgdGhpcy5tYXh6b29tID0gMjIsIHRoaXMucm91bmRab29tID0gITAsIHRoaXMuc2NoZW1lID0gXCJ4eXpcIiwgdGhpcy50aWxlU2l6ZSA9IDUxMiwgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuX29wdGlvbnMgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgdHlwZTogXCJyYXN0ZXJcIlxuICAgICAgICB9LCBvKSwgdC5leHRlbmQodGhpcywgdC5waWNrKG8sIFtcInVybFwiLCBcInNjaGVtZVwiLCBcInRpbGVTaXplXCJdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IEkodGhpcy5fb3B0aW9ucywgdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLCBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgIGUuX3RpbGVKU09OUmVxdWVzdCA9IG51bGwsIGUuX2xvYWRlZCA9ICEwLCBpID8gZS5maXJlKG5ldyB0LkVycm9yRXZlbnQoaSkpIDogbyAmJiAodC5leHRlbmQoZSwgbyksIG8uYm91bmRzICYmIChlLnRpbGVCb3VuZHMgPSBuZXcgUChvLmJvdW5kcywgZS5taW56b29tLCBlLm1heHpvb20pKSwgdC5wb3N0VHVybnN0aWxlRXZlbnQoby50aWxlcyksIHQucG9zdE1hcExvYWRFdmVudChvLnRpbGVzLCBlLm1hcC5fZ2V0TWFwSWQoKSwgZS5tYXAuX3JlcXVlc3RNYW5hZ2VyLl9za3VUb2tlbiksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgfSkpLCBlLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwiY29udGVudFwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ICYmICh0aGlzLl90aWxlSlNPTlJlcXVlc3QuY2FuY2VsKCksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IG51bGwpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy50aWxlQm91bmRzIHx8IHRoaXMudGlsZUJvdW5kcy5jb250YWlucyh0LmNhbm9uaWNhbCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICAgIHIgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplVGlsZVVSTChlLnRpbGVJRC5jYW5vbmljYWwudXJsKHRoaXMudGlsZXMsIHRoaXMuc2NoZW1lKSwgdGhpcy50aWxlU2l6ZSk7XG5cbiAgICAgICAgZS5yZXF1ZXN0ID0gdC5nZXRJbWFnZSh0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChyLCB0LlJlc291cmNlVHlwZS5UaWxlKSwgZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlIGUucmVxdWVzdCwgZS5hYm9ydGVkKSBlLnN0YXRlID0gXCJ1bmxvYWRlZFwiLCBpKG51bGwpO2Vsc2UgaWYgKHIpIGUuc3RhdGUgPSBcImVycm9yZWRcIiwgaShyKTtlbHNlIGlmIChhKSB7XG4gICAgICAgICAgICBvLm1hcC5fcmVmcmVzaEV4cGlyZWRUaWxlcyAmJiBlLnNldEV4cGlyeURhdGEoYSksIGRlbGV0ZSBhLmNhY2hlQ29udHJvbCwgZGVsZXRlIGEuZXhwaXJlcztcbiAgICAgICAgICAgIHZhciBuID0gby5tYXAucGFpbnRlci5jb250ZXh0LFxuICAgICAgICAgICAgICAgIHMgPSBuLmdsO1xuICAgICAgICAgICAgZS50ZXh0dXJlID0gby5tYXAucGFpbnRlci5nZXRUaWxlVGV4dHVyZShhLndpZHRoKSwgZS50ZXh0dXJlID8gZS50ZXh0dXJlLnVwZGF0ZShhLCB7XG4gICAgICAgICAgICAgIHVzZU1pcG1hcDogITBcbiAgICAgICAgICAgIH0pIDogKGUudGV4dHVyZSA9IG5ldyB0LlRleHR1cmUobiwgYSwgcy5SR0JBLCB7XG4gICAgICAgICAgICAgIHVzZU1pcG1hcDogITBcbiAgICAgICAgICAgIH0pLCBlLnRleHR1cmUuYmluZChzLkxJTkVBUiwgcy5DTEFNUF9UT19FREdFLCBzLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCksIG4uZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljICYmIHMudGV4UGFyYW1ldGVyZihzLlRFWFRVUkVfMkQsIG4uZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBuLmV4dFRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpY01heCkpLCBlLnN0YXRlID0gXCJsb2FkZWRcIiwgdC5jYWNoZUVudHJ5UG9zc2libHlBZGRlZChvLmRpc3BhdGNoZXIpLCBpKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hYm9ydFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LnJlcXVlc3QgJiYgKHQucmVxdWVzdC5jYW5jZWwoKSwgZGVsZXRlIHQucmVxdWVzdCksIGUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LnRleHR1cmUgJiYgdGhpcy5tYXAucGFpbnRlci5zYXZlVGlsZVRleHR1cmUodC50ZXh0dXJlKSwgZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIHogPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaShpLCBvLCByLCBhKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzLCBpLCBvLCByLCBhKSwgdGhpcy50eXBlID0gXCJyYXN0ZXItZGVtXCIsIHRoaXMubWF4em9vbSA9IDIyLCB0aGlzLl9vcHRpb25zID0gdC5leHRlbmQoe1xuICAgICAgICAgIHR5cGU6IFwicmFzdGVyLWRlbVwiXG4gICAgICAgIH0sIG8pLCB0aGlzLmVuY29kaW5nID0gby5lbmNvZGluZyB8fCBcIm1hcGJveFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJyYXN0ZXItZGVtXCIsXG4gICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICB0aWxlczogdGhpcy50aWxlcyxcbiAgICAgICAgICBib3VuZHM6IHRoaXMuYm91bmRzLFxuICAgICAgICAgIGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLm5vcm1hbGl6ZVRpbGVVUkwoZS50aWxlSUQuY2Fub25pY2FsLnVybCh0aGlzLnRpbGVzLCB0aGlzLnNjaGVtZSksIHRoaXMudGlsZVNpemUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIodCwgbykge1xuICAgICAgICAgIHQgJiYgKGUuc3RhdGUgPSBcImVycm9yZWRcIiwgaSh0KSksIG8gJiYgKGUuZGVtID0gbywgZS5uZWVkc0hpbGxzaGFkZVByZXBhcmUgPSAhMCwgZS5zdGF0ZSA9IFwibG9hZGVkXCIsIGkobnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5yZXF1ZXN0ID0gdC5nZXRJbWFnZSh0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChvLCB0LlJlc291cmNlVHlwZS5UaWxlKSwgZnVuY3Rpb24gKG8sIGEpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlIGUucmVxdWVzdCwgZS5hYm9ydGVkKSBlLnN0YXRlID0gXCJ1bmxvYWRlZFwiLCBpKG51bGwpO2Vsc2UgaWYgKG8pIGUuc3RhdGUgPSBcImVycm9yZWRcIiwgaShvKTtlbHNlIGlmIChhKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5fcmVmcmVzaEV4cGlyZWRUaWxlcyAmJiBlLnNldEV4cGlyeURhdGEoYSksIGRlbGV0ZSBhLmNhY2hlQ29udHJvbCwgZGVsZXRlIGEuZXhwaXJlcztcbiAgICAgICAgICAgIHZhciBuID0gdC53aW5kb3cuSW1hZ2VCaXRtYXAgJiYgYSBpbnN0YW5jZW9mIHQud2luZG93LkltYWdlQml0bWFwICYmIHQub2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkgPyBhIDogdC5icm93c2VyLmdldEltYWdlRGF0YShhLCAxKSxcbiAgICAgICAgICAgICAgICBzID0ge1xuICAgICAgICAgICAgICB1aWQ6IGUudWlkLFxuICAgICAgICAgICAgICBjb29yZDogZS50aWxlSUQsXG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgcmF3SW1hZ2VEYXRhOiBuLFxuICAgICAgICAgICAgICBlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGUuYWN0b3IgJiYgXCJleHBpcmVkXCIgIT09IGUuc3RhdGUgfHwgKGUuYWN0b3IgPSB0aGlzLmRpc3BhdGNoZXIuZ2V0QWN0b3IoKSwgZS5hY3Rvci5zZW5kKFwibG9hZERFTVRpbGVcIiwgcywgci5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpLCBlLm5laWdoYm9yaW5nVGlsZXMgPSB0aGlzLl9nZXROZWlnaGJvcmluZ1RpbGVzKGUudGlsZUlEKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9nZXROZWlnaGJvcmluZ1RpbGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSBlLmNhbm9uaWNhbCxcbiAgICAgICAgICAgIG8gPSBNYXRoLnBvdygyLCBpLnopLFxuICAgICAgICAgICAgciA9IChpLnggLSAxICsgbykgJSBvLFxuICAgICAgICAgICAgYSA9IDAgPT09IGkueCA/IGUud3JhcCAtIDEgOiBlLndyYXAsXG4gICAgICAgICAgICBuID0gKGkueCArIDEgKyBvKSAlIG8sXG4gICAgICAgICAgICBzID0gaS54ICsgMSA9PT0gbyA/IGUud3JhcCArIDEgOiBlLndyYXAsXG4gICAgICAgICAgICBsID0ge307XG4gICAgICAgIHJldHVybiBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgYSwgaS56LCByLCBpLnkpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIHMsIGkueiwgbiwgaS55KS5rZXldID0ge1xuICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgIH0sIGkueSA+IDAgJiYgKGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBhLCBpLnosIHIsIGkueSAtIDEpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGUud3JhcCwgaS56LCBpLngsIGkueSAtIDEpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIHMsIGkueiwgbiwgaS55IC0gMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9KSwgaS55ICsgMSA8IG8gJiYgKGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBhLCBpLnosIHIsIGkueSArIDEpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGUud3JhcCwgaS56LCBpLngsIGkueSArIDEpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIHMsIGkueiwgbiwgaS55ICsgMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9KSwgbDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVubG9hZFRpbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0LmRlbVRleHR1cmUgJiYgdGhpcy5tYXAucGFpbnRlci5zYXZlVGlsZVRleHR1cmUodC5kZW1UZXh0dXJlKSwgdC5mYm8gJiYgKHQuZmJvLmRlc3Ryb3koKSwgZGVsZXRlIHQuZmJvKSwgdC5kZW0gJiYgZGVsZXRlIHQuZGVtLCBkZWxldGUgdC5uZWlnaGJvcmluZ1RpbGVzLCB0LnN0YXRlID0gXCJ1bmxvYWRlZFwiLCB0LmFjdG9yICYmIHQuYWN0b3Iuc2VuZChcInJlbW92ZURFTVRpbGVcIiwge1xuICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSwgaTtcbiAgICB9KEMpLFxuICAgICAgICBEID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSwgbywgciwgYSkge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuaWQgPSBpLCB0aGlzLnR5cGUgPSBcImdlb2pzb25cIiwgdGhpcy5taW56b29tID0gMCwgdGhpcy5tYXh6b29tID0gMTgsIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMuaXNUaWxlQ2xpcHBlZCA9ICEwLCB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID0gITAsIHRoaXMuX3JlbW92ZWQgPSAhMSwgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuYWN0b3IgPSByLmdldEFjdG9yKCksIHRoaXMuc2V0RXZlbnRlZFBhcmVudChhKSwgdGhpcy5fZGF0YSA9IG8uZGF0YSwgdGhpcy5fb3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCBvKSwgdGhpcy5fY29sbGVjdFJlc291cmNlVGltaW5nID0gby5jb2xsZWN0UmVzb3VyY2VUaW1pbmcsIHRoaXMuX3Jlc291cmNlVGltaW5nID0gW10sIHZvaWQgMCAhPT0gby5tYXh6b29tICYmICh0aGlzLm1heHpvb20gPSBvLm1heHpvb20pLCBvLnR5cGUgJiYgKHRoaXMudHlwZSA9IG8udHlwZSksIG8uYXR0cmlidXRpb24gJiYgKHRoaXMuYXR0cmlidXRpb24gPSBvLmF0dHJpYnV0aW9uKSwgdGhpcy5wcm9tb3RlSWQgPSBvLnByb21vdGVJZDtcbiAgICAgICAgdmFyIG4gPSB0LkVYVEVOVCAvIHRoaXMudGlsZVNpemU7XG4gICAgICAgIHRoaXMud29ya2VyT3B0aW9ucyA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgY2x1c3Rlcjogby5jbHVzdGVyIHx8ICExLFxuICAgICAgICAgIGdlb2pzb25WdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJ1ZmZlcjogKHZvaWQgMCAhPT0gby5idWZmZXIgPyBvLmJ1ZmZlciA6IDEyOCkgKiBuLFxuICAgICAgICAgICAgdG9sZXJhbmNlOiAodm9pZCAwICE9PSBvLnRvbGVyYW5jZSA/IG8udG9sZXJhbmNlIDogLjM3NSkgKiBuLFxuICAgICAgICAgICAgZXh0ZW50OiB0LkVYVEVOVCxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIGxpbmVNZXRyaWNzOiBvLmxpbmVNZXRyaWNzIHx8ICExLFxuICAgICAgICAgICAgZ2VuZXJhdGVJZDogby5nZW5lcmF0ZUlkIHx8ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdXBlcmNsdXN0ZXJPcHRpb25zOiB7XG4gICAgICAgICAgICBtYXhab29tOiB2b2lkIDAgIT09IG8uY2x1c3Rlck1heFpvb20gPyBNYXRoLm1pbihvLmNsdXN0ZXJNYXhab29tLCB0aGlzLm1heHpvb20gLSAxKSA6IHRoaXMubWF4em9vbSAtIDEsXG4gICAgICAgICAgICBtaW5Qb2ludHM6IE1hdGgubWF4KDIsIG8uY2x1c3Rlck1pblBvaW50cyB8fCAyKSxcbiAgICAgICAgICAgIGV4dGVudDogdC5FWFRFTlQsXG4gICAgICAgICAgICByYWRpdXM6IChvLmNsdXN0ZXJSYWRpdXMgfHwgNTApICogbixcbiAgICAgICAgICAgIGxvZzogITEsXG4gICAgICAgICAgICBnZW5lcmF0ZUlkOiBvLmdlbmVyYXRlSWQgfHwgITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsdXN0ZXJQcm9wZXJ0aWVzOiBvLmNsdXN0ZXJQcm9wZXJ0aWVzLFxuICAgICAgICAgIGZpbHRlcjogby5maWx0ZXJcbiAgICAgICAgfSwgby53b3JrZXJPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgfSkpLCB0aGlzLl91cGRhdGVXb3JrZXJEYXRhKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaWYgKGkpIGUuZmlyZShuZXcgdC5FcnJvckV2ZW50KGkpKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwibWV0YWRhdGFcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGUuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyAmJiBlLl9yZXNvdXJjZVRpbWluZyAmJiBlLl9yZXNvdXJjZVRpbWluZy5sZW5ndGggPiAwICYmIChvLnJlc291cmNlVGltaW5nID0gZS5fcmVzb3VyY2VUaW1pbmcsIGUuX3Jlc291cmNlVGltaW5nID0gW10pLCBlLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm1hcCA9IHQsIHRoaXMubG9hZCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPSBlLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgfSkpLCB0aGlzLl91cGRhdGVXb3JrZXJEYXRhKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUpIGkuZmlyZShuZXcgdC5FcnJvckV2ZW50KGUpKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwiY29udGVudFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaS5fY29sbGVjdFJlc291cmNlVGltaW5nICYmIGkuX3Jlc291cmNlVGltaW5nICYmIGkuX3Jlc291cmNlVGltaW5nLmxlbmd0aCA+IDAgJiYgKG8ucmVzb3VyY2VUaW1pbmcgPSBpLl9yZXNvdXJjZVRpbWluZywgaS5fcmVzb3VyY2VUaW1pbmcgPSBbXSksIGkuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwgbykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9yLnNlbmQoXCJnZW9qc29uLmdldENsdXN0ZXJFeHBhbnNpb25ab29tXCIsIHtcbiAgICAgICAgICBjbHVzdGVySWQ6IHQsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0Q2x1c3RlckNoaWxkcmVuID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3Iuc2VuZChcImdlb2pzb24uZ2V0Q2x1c3RlckNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBjbHVzdGVySWQ6IHQsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0Q2x1c3RlckxlYXZlcyA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9yLnNlbmQoXCJnZW9qc29uLmdldENsdXN0ZXJMZWF2ZXNcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICBjbHVzdGVySWQ6IHQsXG4gICAgICAgICAgbGltaXQ6IGUsXG4gICAgICAgICAgb2Zmc2V0OiBpXG4gICAgICAgIH0sIG8pLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVdvcmtlckRhdGEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9ICExO1xuICAgICAgICB2YXIgbyA9IHQuZXh0ZW5kKHt9LCB0aGlzLndvcmtlck9wdGlvbnMpLFxuICAgICAgICAgICAgciA9IHRoaXMuX2RhdGE7XG4gICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHIgPyAoby5yZXF1ZXN0ID0gdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QodC5icm93c2VyLnJlc29sdmVVUkwociksIHQuUmVzb3VyY2VUeXBlLlNvdXJjZSksIG8ucmVxdWVzdC5jb2xsZWN0UmVzb3VyY2VUaW1pbmcgPSB0aGlzLl9jb2xsZWN0UmVzb3VyY2VUaW1pbmcpIDogby5kYXRhID0gSlNPTi5zdHJpbmdpZnkociksIHRoaXMuYWN0b3Iuc2VuZCh0aGlzLnR5cGUgKyBcIi5sb2FkRGF0YVwiLCBvLCBmdW5jdGlvbiAodCwgcikge1xuICAgICAgICAgIGkuX3JlbW92ZWQgfHwgciAmJiByLmFiYW5kb25lZCB8fCAoaS5fbG9hZGVkID0gITAsIHIgJiYgci5yZXNvdXJjZVRpbWluZyAmJiByLnJlc291cmNlVGltaW5nW2kuaWRdICYmIChpLl9yZXNvdXJjZVRpbWluZyA9IHIucmVzb3VyY2VUaW1pbmdbaS5pZF0uc2xpY2UoMCkpLCBpLmFjdG9yLnNlbmQoaS50eXBlICsgXCIuY29hbGVzY2VcIiwge1xuICAgICAgICAgICAgc291cmNlOiBvLnNvdXJjZVxuICAgICAgICAgIH0sIG51bGwpLCBlKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICAgIHIgPSBlLmFjdG9yID8gXCJyZWxvYWRUaWxlXCIgOiBcImxvYWRUaWxlXCI7XG4gICAgICAgIGUuYWN0b3IgPSB0aGlzLmFjdG9yLCBlLnJlcXVlc3QgPSB0aGlzLmFjdG9yLnNlbmQociwge1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICB1aWQ6IGUudWlkLFxuICAgICAgICAgIHRpbGVJRDogZS50aWxlSUQsXG4gICAgICAgICAgem9vbTogZS50aWxlSUQub3ZlcnNjYWxlZFosXG4gICAgICAgICAgbWF4Wm9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICBwaXhlbFJhdGlvOiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICBzaG93Q29sbGlzaW9uQm94ZXM6IHRoaXMubWFwLnNob3dDb2xsaXNpb25Cb3hlcyxcbiAgICAgICAgICBwcm9tb3RlSWQ6IHRoaXMucHJvbW90ZUlkXG4gICAgICAgIH0sIGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSBlLnJlcXVlc3QsIGUudW5sb2FkVmVjdG9yRGF0YSgpLCBlLmFib3J0ZWQgPyBpKG51bGwpIDogdCA/IGkodCkgOiAoZS5sb2FkVmVjdG9yRGF0YShhLCBvLm1hcC5wYWludGVyLCBcInJlbG9hZFRpbGVcIiA9PT0gciksIGkobnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucmVxdWVzdCAmJiAodC5yZXF1ZXN0LmNhbmNlbCgpLCBkZWxldGUgdC5yZXF1ZXN0KSwgdC5hYm9ydGVkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS51bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC51bmxvYWRWZWN0b3JEYXRhKCksIHRoaXMuYWN0b3Iuc2VuZChcInJlbW92ZVRpbGVcIiwge1xuICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVkID0gITAsIHRoaXMuYWN0b3Iuc2VuZChcInJlbW92ZVNvdXJjZVwiLCB7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLCB7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIGRhdGE6IHRoaXMuX2RhdGFcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgQSA9IHQuY3JlYXRlTGF5b3V0KFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBjb21wb25lbnRzOiAyXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX3RleHR1cmVfcG9zXCIsXG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBjb21wb25lbnRzOiAyXG4gICAgfV0pLFxuICAgICAgICBNID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkodCwgaSwgbywgcikge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuaWQgPSB0LCB0aGlzLmRpc3BhdGNoZXIgPSBvLCB0aGlzLmNvb3JkaW5hdGVzID0gaS5jb29yZGluYXRlcywgdGhpcy50eXBlID0gXCJpbWFnZVwiLCB0aGlzLm1pbnpvb20gPSAwLCB0aGlzLm1heHpvb20gPSAyMiwgdGhpcy50aWxlU2l6ZSA9IDUxMiwgdGhpcy50aWxlcyA9IHt9LCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5zZXRFdmVudGVkUGFyZW50KHIpLCB0aGlzLm9wdGlvbnMgPSBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiXG4gICAgICAgIH0pKSwgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXJsLCB0LmdldEltYWdlKHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KHRoaXMudXJsLCB0LlJlc291cmNlVHlwZS5JbWFnZSksIGZ1bmN0aW9uIChyLCBhKSB7XG4gICAgICAgICAgby5fbG9hZGVkID0gITAsIHIgPyBvLmZpcmUobmV3IHQuRXJyb3JFdmVudChyKSkgOiBhICYmIChvLmltYWdlID0gYSwgZSAmJiAoby5jb29yZGluYXRlcyA9IGUpLCBpICYmIGkoKSwgby5fZmluaXNoTG9hZGluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UgJiYgdC51cmwgPyAodGhpcy5vcHRpb25zLnVybCA9IHQudXJsLCB0aGlzLmxvYWQodC5jb29yZGluYXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUudGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH0pLCB0aGlzKSA6IHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZmluaXNoTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXAgJiYgKHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy5jb29yZGluYXRlcyksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcIm1ldGFkYXRhXCJcbiAgICAgICAgfSkpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzID0gZTtcbiAgICAgICAgdmFyIG8gPSBlLm1hcCh0Lk1lcmNhdG9yQ29vcmRpbmF0ZS5mcm9tTG5nTGF0KTtcbiAgICAgICAgdGhpcy50aWxlSUQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxIC8gMCwgbyA9IDEgLyAwLCByID0gLTEgLyAwLCBhID0gLTEgLyAwLCBuID0gMCwgcyA9IGU7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHNbbl07XG4gICAgICAgICAgICBpID0gTWF0aC5taW4oaSwgbC54KSwgbyA9IE1hdGgubWluKG8sIGwueSksIHIgPSBNYXRoLm1heChyLCBsLngpLCBhID0gTWF0aC5tYXgoYSwgbC55KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYyA9IE1hdGgubWF4KHIgLSBpLCBhIC0gbyksXG4gICAgICAgICAgICAgIHUgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKC1NYXRoLmxvZyhjKSAvIE1hdGguTE4yKSksXG4gICAgICAgICAgICAgIGggPSBNYXRoLnBvdygyLCB1KTtcbiAgICAgICAgICByZXR1cm4gbmV3IHQuQ2Fub25pY2FsVGlsZUlEKHUsIE1hdGguZmxvb3IoKGkgKyByKSAvIDIgKiBoKSwgTWF0aC5mbG9vcigobyArIGEpIC8gMiAqIGgpKTtcbiAgICAgICAgfShvKSwgdGhpcy5taW56b29tID0gdGhpcy5tYXh6b29tID0gdGhpcy50aWxlSUQuejtcbiAgICAgICAgdmFyIHIgPSBvLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpLnRpbGVJRC5nZXRUaWxlUG9pbnQodCkuX3JvdW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzQXJyYXkgPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDRpOCgpLCB0aGlzLl9ib3VuZHNBcnJheS5lbXBsYWNlQmFjayhyWzBdLngsIHJbMF0ueSwgMCwgMCksIHRoaXMuX2JvdW5kc0FycmF5LmVtcGxhY2VCYWNrKHJbMV0ueCwgclsxXS55LCB0LkVYVEVOVCwgMCksIHRoaXMuX2JvdW5kc0FycmF5LmVtcGxhY2VCYWNrKHJbM10ueCwgclszXS55LCAwLCB0LkVYVEVOVCksIHRoaXMuX2JvdW5kc0FycmF5LmVtcGxhY2VCYWNrKHJbMl0ueCwgclsyXS55LCB0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLmJvdW5kc0J1ZmZlciAmJiAodGhpcy5ib3VuZHNCdWZmZXIuZGVzdHJveSgpLCBkZWxldGUgdGhpcy5ib3VuZHNCdWZmZXIpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJjb250ZW50XCJcbiAgICAgICAgfSkpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKDAgIT09IE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aCAmJiB0aGlzLmltYWdlKSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLm1hcC5wYWludGVyLmNvbnRleHQsXG4gICAgICAgICAgICAgIGkgPSBlLmdsO1xuXG4gICAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLmJvdW5kc0J1ZmZlciB8fCAodGhpcy5ib3VuZHNCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLl9ib3VuZHNBcnJheSwgQS5tZW1iZXJzKSksIHRoaXMuYm91bmRzU2VnbWVudHMgfHwgKHRoaXMuYm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKSksIHRoaXMudGV4dHVyZSB8fCAodGhpcy50ZXh0dXJlID0gbmV3IHQuVGV4dHVyZShlLCB0aGlzLmltYWdlLCBpLlJHQkEpLCB0aGlzLnRleHR1cmUuYmluZChpLkxJTkVBUiwgaS5DTEFNUF9UT19FREdFKSksIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy50aWxlc1tvXTtcbiAgICAgICAgICAgIFwibG9hZGVkXCIgIT09IHIuc3RhdGUgJiYgKHIuc3RhdGUgPSBcImxvYWRlZFwiLCByLnRleHR1cmUgPSB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLnRpbGVJRCAmJiB0aGlzLnRpbGVJRC5lcXVhbHModC50aWxlSUQuY2Fub25pY2FsKSA/ICh0aGlzLnRpbGVzW1N0cmluZyh0LnRpbGVJRC53cmFwKV0gPSB0LCB0LmJ1Y2tldHMgPSB7fSwgZShudWxsKSkgOiAodC5zdGF0ZSA9IFwiZXJyb3JlZFwiLCBlKG51bGwpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgTCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKHQsIGksIG8sIHIpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMsIHQsIGksIG8sIHIpLCB0aGlzLnJvdW5kWm9vbSA9ICEwLCB0aGlzLnR5cGUgPSBcInZpZGVvXCIsIHRoaXMub3B0aW9ucyA9IGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gITE7XG4gICAgICAgIHZhciBpID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnVybHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBvID0gMCwgciA9IGkudXJsczsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB0aGlzLnVybHMucHVzaCh0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChyW29dLCB0LlJlc291cmNlVHlwZS5Tb3VyY2UpLnVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0LmdldFZpZGVvKHRoaXMudXJscywgZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgICBlLl9sb2FkZWQgPSAhMCwgaSA/IGUuZmlyZShuZXcgdC5FcnJvckV2ZW50KGkpKSA6IG8gJiYgKGUudmlkZW8gPSBvLCBlLnZpZGVvLmxvb3AgPSAhMCwgZS52aWRlby5hZGRFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLm1hcC50cmlnZ2VyUmVwYWludCgpO1xuICAgICAgICAgIH0pLCBlLm1hcCAmJiBlLnZpZGVvLnBsYXkoKSwgZS5fZmluaXNoTG9hZGluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWRlbyAmJiB0aGlzLnZpZGVvLnBhdXNlKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8ucGxheSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLnZpZGVvLnNlZWthYmxlO1xuICAgICAgICAgIGUgPCBpLnN0YXJ0KDApIHx8IGUgPiBpLmVuZCgwKSA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyB0aGlzLmlkLCBudWxsLCBcIlBsYXliYWNrIGZvciB0aGlzIHZpZGVvIGNhbiBiZSBzZXQgb25seSBiZXR3ZWVuIHRoZSBcIiArIGkuc3RhcnQoMCkgKyBcIiBhbmQgXCIgKyBpLmVuZCgwKSArIFwiLXNlY29uZCBtYXJrLlwiKSkpIDogdGhpcy52aWRlby5jdXJyZW50VGltZSA9IGU7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFZpZGVvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWRlbztcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgfHwgKHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCksIHRoaXMudmlkZW8gJiYgKHRoaXMudmlkZW8ucGxheSgpLCB0aGlzLnNldENvb3JkaW5hdGVzKHRoaXMuY29vcmRpbmF0ZXMpKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISgwID09PSBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKS5sZW5ndGggfHwgdGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMubWFwLnBhaW50ZXIuY29udGV4dCxcbiAgICAgICAgICAgICAgaSA9IGUuZ2w7XG5cbiAgICAgICAgICBmb3IgKHZhciBvIGluIHRoaXMuYm91bmRzQnVmZmVyIHx8ICh0aGlzLmJvdW5kc0J1ZmZlciA9IGUuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuX2JvdW5kc0FycmF5LCBBLm1lbWJlcnMpKSwgdGhpcy5ib3VuZHNTZWdtZW50cyB8fCAodGhpcy5ib3VuZHNTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDIpKSwgdGhpcy50ZXh0dXJlID8gdGhpcy52aWRlby5wYXVzZWQgfHwgKHRoaXMudGV4dHVyZS5iaW5kKGkuTElORUFSLCBpLkNMQU1QX1RPX0VER0UpLCBpLnRleFN1YkltYWdlMkQoaS5URVhUVVJFXzJELCAwLCAwLCAwLCBpLlJHQkEsIGkuVU5TSUdORURfQllURSwgdGhpcy52aWRlbykpIDogKHRoaXMudGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwgdGhpcy52aWRlbywgaS5SR0JBKSwgdGhpcy50ZXh0dXJlLmJpbmQoaS5MSU5FQVIsIGkuQ0xBTVBfVE9fRURHRSkpLCB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMudGlsZXNbb107XG4gICAgICAgICAgICBcImxvYWRlZFwiICE9PSByLnN0YXRlICYmIChyLnN0YXRlID0gXCJsb2FkZWRcIiwgci50ZXh0dXJlID0gdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgICAgICAgdXJsczogdGhpcy51cmxzLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWRlbyAmJiAhdGhpcy52aWRlby5wYXVzZWQ7XG4gICAgICB9LCBpO1xuICAgIH0oTSksXG4gICAgICAgIFIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaShpLCBvLCByLCBhKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzLCBpLCBvLCByLCBhKSwgby5jb29yZGluYXRlcyA/IEFycmF5LmlzQXJyYXkoby5jb29yZGluYXRlcykgJiYgNCA9PT0gby5jb29yZGluYXRlcy5sZW5ndGggJiYgIW8uY29vcmRpbmF0ZXMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh0KSB8fCAyICE9PSB0Lmxlbmd0aCB8fCB0LnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiICE9IHR5cGVvZiB0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSB8fCB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgdC5WYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzLlwiICsgaSwgbnVsbCwgJ1wiY29vcmRpbmF0ZXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5IG9mIDQgbG9uZ2l0dWRlL2xhdGl0dWRlIGFycmF5IHBhaXJzJykpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcImNvb3JkaW5hdGVzXCInKSkpLCBvLmFuaW1hdGUgJiYgXCJib29sZWFuXCIgIT0gdHlwZW9mIG8uYW5pbWF0ZSAmJiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgdC5WYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzLlwiICsgaSwgbnVsbCwgJ29wdGlvbmFsIFwiYW5pbWF0ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBib29sZWFuIHZhbHVlJykpKSwgby5jYW52YXMgPyBcInN0cmluZ1wiID09IHR5cGVvZiBvLmNhbnZhcyB8fCBvLmNhbnZhcyBpbnN0YW5jZW9mIHQud2luZG93LkhUTUxDYW52YXNFbGVtZW50IHx8IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnXCJjYW52YXNcIiBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIElEIG9mIHRoZSBjYW52YXMgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQsIG9yIGFuIEhUTUxDYW52YXNFbGVtZW50IGluc3RhbmNlJykpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcImNhbnZhc1wiJykpKSwgdGhpcy5vcHRpb25zID0gbywgdGhpcy5hbmltYXRlID0gdm9pZCAwID09PSBvLmFuaW1hdGUgfHwgby5hbmltYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMCwgdGhpcy5jYW52YXMgfHwgKHRoaXMuY2FudmFzID0gdGhpcy5vcHRpb25zLmNhbnZhcyBpbnN0YW5jZW9mIHQud2luZG93LkhUTUxDYW52YXNFbGVtZW50ID8gdGhpcy5vcHRpb25zLmNhbnZhcyA6IHQud2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5jYW52YXMpKSwgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCwgdGhpcy5faGFzSW52YWxpZERpbWVuc2lvbnMoKSA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkNhbnZhcyBkaW1lbnNpb25zIGNhbm5vdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cIikpKSA6ICh0aGlzLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fcGxheWluZyA9ICEwLCB0aGlzLm1hcC50cmlnZ2VyUmVwYWludCgpO1xuICAgICAgICB9LCB0aGlzLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX3BsYXlpbmcgJiYgKHRoaXMucHJlcGFyZSgpLCB0aGlzLl9wbGF5aW5nID0gITEpO1xuICAgICAgICB9LCB0aGlzLl9maW5pc2hMb2FkaW5nKCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCksIHRoaXMuY2FudmFzICYmIHRoaXMuYW5pbWF0ZSAmJiB0aGlzLnBsYXkoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9ICExO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy53aWR0aCAhPT0gdGhpcy53aWR0aCAmJiAodGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoLCBlID0gITApLCB0aGlzLmNhbnZhcy5oZWlnaHQgIT09IHRoaXMuaGVpZ2h0ICYmICh0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCwgZSA9ICEwKSwgIXRoaXMuX2hhc0ludmFsaWREaW1lbnNpb25zKCkgJiYgMCAhPT0gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLm1hcC5wYWludGVyLmNvbnRleHQsXG4gICAgICAgICAgICAgIG8gPSBpLmdsO1xuXG4gICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLmJvdW5kc0J1ZmZlciB8fCAodGhpcy5ib3VuZHNCdWZmZXIgPSBpLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLl9ib3VuZHNBcnJheSwgQS5tZW1iZXJzKSksIHRoaXMuYm91bmRzU2VnbWVudHMgfHwgKHRoaXMuYm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKSksIHRoaXMudGV4dHVyZSA/IChlIHx8IHRoaXMuX3BsYXlpbmcpICYmIHRoaXMudGV4dHVyZS51cGRhdGUodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgIHByZW11bHRpcGx5OiAhMFxuICAgICAgICAgIH0pIDogdGhpcy50ZXh0dXJlID0gbmV3IHQuVGV4dHVyZShpLCB0aGlzLmNhbnZhcywgby5SR0JBLCB7XG4gICAgICAgICAgICBwcmVtdWx0aXBseTogITBcbiAgICAgICAgICB9KSwgdGhpcy50aWxlcykge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnRpbGVzW3JdO1xuICAgICAgICAgICAgXCJsb2FkZWRcIiAhPT0gYS5zdGF0ZSAmJiAoYS5zdGF0ZSA9IFwibG9hZGVkXCIsIGEudGV4dHVyZSA9IHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJjYW52YXNcIixcbiAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1xuICAgICAgICB9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faGFzSW52YWxpZERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkge1xuICAgICAgICAgIHZhciBpID0gZVt0XTtcbiAgICAgICAgICBpZiAoaXNOYU4oaSkgfHwgaSA8PSAwKSByZXR1cm4gITA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpO1xuICAgIH0oTSksXG4gICAgICAgIGsgPSB7XG4gICAgICB2ZWN0b3I6IFMsXG4gICAgICByYXN0ZXI6IEMsXG4gICAgICBcInJhc3Rlci1kZW1cIjogeixcbiAgICAgIGdlb2pzb246IEQsXG4gICAgICB2aWRlbzogTCxcbiAgICAgIGltYWdlOiBNLFxuICAgICAgY2FudmFzOiBSXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEIoZSwgaSkge1xuICAgICAgdmFyIG8gPSB0LmlkZW50aXR5KFtdKTtcbiAgICAgIHJldHVybiB0LnRyYW5zbGF0ZShvLCBvLCBbMSwgMSwgMF0pLCB0LnNjYWxlKG8sIG8sIFsuNSAqIGUud2lkdGgsIC41ICogZS5oZWlnaHQsIDFdKSwgdC5tdWx0aXBseShvLCBvLCBlLmNhbGN1bGF0ZVBvc01hdHJpeChpLnRvVW53cmFwcGVkKCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgaWYgKHQpIGZvciAodmFyIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IGVbcltvXV07XG4gICAgICAgICAgaWYgKGEgJiYgYS5zb3VyY2UgPT09IGkgJiYgXCJmaWxsLWV4dHJ1c2lvblwiID09PSBhLnR5cGUpIHJldHVybiAhMDtcbiAgICAgICAgfSBlbHNlIGZvciAodmFyIG4gaW4gZSkge1xuICAgICAgICAgIHZhciBzID0gZVtuXTtcbiAgICAgICAgICBpZiAocy5zb3VyY2UgPT09IGkgJiYgXCJmaWxsLWV4dHJ1c2lvblwiID09PSBzLnR5cGUpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9KHIgJiYgci5sYXllcnMsIGUsIHQuaWQpLFxuICAgICAgICAgIHMgPSBhLm1heFBpdGNoU2NhbGVGYWN0b3IoKSxcbiAgICAgICAgICBsID0gdC50aWxlc0luKG8sIHMsIG4pO1xuXG4gICAgICBsLnNvcnQoRik7XG5cbiAgICAgIGZvciAodmFyIGMgPSBbXSwgdSA9IDAsIGggPSBsOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICB2YXIgcCA9IGhbdV07XG4gICAgICAgIGMucHVzaCh7XG4gICAgICAgICAgd3JhcHBlZFRpbGVJRDogcC50aWxlSUQud3JhcHBlZCgpLmtleSxcbiAgICAgICAgICBxdWVyeVJlc3VsdHM6IHAudGlsZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZSwgaSwgdC5fc3RhdGUsIHAucXVlcnlHZW9tZXRyeSwgcC5jYW1lcmFRdWVyeUdlb21ldHJ5LCBwLnNjYWxlLCByLCBhLCBzLCBCKHQudHJhbnNmb3JtLCBwLnRpbGVJRCkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSB7fSwgaSA9IHt9LCBvID0gMCwgciA9IHQ7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dLFxuICAgICAgICAgICAgICBuID0gYS5xdWVyeVJlc3VsdHMsXG4gICAgICAgICAgICAgIHMgPSBhLndyYXBwZWRUaWxlSUQsXG4gICAgICAgICAgICAgIGwgPSBpW3NdID0gaVtzXSB8fCB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGMgaW4gbikge1xuICAgICAgICAgICAgZm9yICh2YXIgdSA9IG5bY10sIGggPSBsW2NdID0gbFtjXSB8fCB7fSwgcCA9IGVbY10gPSBlW2NdIHx8IFtdLCBkID0gMCwgXyA9IHU7IGQgPCBfLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBmID0gX1tkXTtcbiAgICAgICAgICAgICAgaFtmLmZlYXR1cmVJbmRleF0gfHwgKGhbZi5mZWF0dXJlSW5kZXhdID0gITAsIHAucHVzaChmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KGMpO1xuXG4gICAgICBmb3IgKHZhciBfIGluIGQpIHtcbiAgICAgICAgZFtfXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGkgPSBlLmZlYXR1cmUsXG4gICAgICAgICAgICAgIG8gPSB0LmdldEZlYXR1cmVTdGF0ZShpLmxheWVyW1wic291cmNlLWxheWVyXCJdLCBpLmlkKTtcbiAgICAgICAgICBpLnNvdXJjZSA9IGkubGF5ZXIuc291cmNlLCBpLmxheWVyW1wic291cmNlLWxheWVyXCJdICYmIChpLnNvdXJjZUxheWVyID0gaS5sYXllcltcInNvdXJjZS1sYXllclwiXSksIGkuc3RhdGUgPSBvO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRih0LCBlKSB7XG4gICAgICB2YXIgaSA9IHQudGlsZUlELFxuICAgICAgICAgIG8gPSBlLnRpbGVJRDtcbiAgICAgIHJldHVybiBpLm92ZXJzY2FsZWRaIC0gby5vdmVyc2NhbGVkWiB8fCBpLmNhbm9uaWNhbC55IC0gby5jYW5vbmljYWwueSB8fCBpLndyYXAgLSBvLndyYXAgfHwgaS5jYW5vbmljYWwueCAtIG8uY2Fub25pY2FsLng7XG4gICAgfVxuXG4gICAgdmFyIFUgPSBmdW5jdGlvbiBVKHQsIGUpIHtcbiAgICAgIHRoaXMubWF4ID0gdCwgdGhpcy5vblJlbW92ZSA9IGUsIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgVS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0IGluIHRoaXMuZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgaSA9IHRoaXMuZGF0YVt0XTsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICB2YXIgbyA9IGlbZV07XG4gICAgICAgICAgby50aW1lb3V0ICYmIGNsZWFyVGltZW91dChvLnRpbWVvdXQpLCB0aGlzLm9uUmVtb3ZlKG8udmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGEgPSB7fSwgdGhpcy5vcmRlciA9IFtdLCB0aGlzO1xuICAgIH0sIFUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMsXG4gICAgICAgICAgciA9IHQud3JhcHBlZCgpLmtleTtcbiAgICAgIHZvaWQgMCA9PT0gdGhpcy5kYXRhW3JdICYmICh0aGlzLmRhdGFbcl0gPSBbXSk7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgIHRpbWVvdXQ6IHZvaWQgMFxuICAgICAgfTtcblxuICAgICAgaWYgKHZvaWQgMCAhPT0gaSAmJiAoYS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG8ucmVtb3ZlKHQsIGEpO1xuICAgICAgfSwgaSkpLCB0aGlzLmRhdGFbcl0ucHVzaChhKSwgdGhpcy5vcmRlci5wdXNoKHIpLCB0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fZ2V0QW5kUmVtb3ZlQnlLZXkodGhpcy5vcmRlclswXSk7XG5cbiAgICAgICAgbiAmJiB0aGlzLm9uUmVtb3ZlKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBVLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQud3JhcHBlZCgpLmtleSBpbiB0aGlzLmRhdGE7XG4gICAgfSwgVS5wcm90b3R5cGUuZ2V0QW5kUmVtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh0KSA/IHRoaXMuX2dldEFuZFJlbW92ZUJ5S2V5KHQud3JhcHBlZCgpLmtleSkgOiBudWxsO1xuICAgIH0sIFUucHJvdG90eXBlLl9nZXRBbmRSZW1vdmVCeUtleSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuZGF0YVt0XS5zaGlmdCgpO1xuICAgICAgcmV0dXJuIGUudGltZW91dCAmJiBjbGVhclRpbWVvdXQoZS50aW1lb3V0KSwgMCA9PT0gdGhpcy5kYXRhW3RdLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5kYXRhW3RdLCB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2YodCksIDEpLCBlLnZhbHVlO1xuICAgIH0sIFUucHJvdG90eXBlLmdldEJ5S2V5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhW3RdO1xuICAgICAgcmV0dXJuIGUgPyBlWzBdLnZhbHVlIDogbnVsbDtcbiAgICB9LCBVLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHQpID8gdGhpcy5kYXRhW3Qud3JhcHBlZCgpLmtleV1bMF0udmFsdWUgOiBudWxsO1xuICAgIH0sIFUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHQpKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBpID0gdC53cmFwcGVkKCkua2V5LFxuICAgICAgICAgIG8gPSB2b2lkIDAgPT09IGUgPyAwIDogdGhpcy5kYXRhW2ldLmluZGV4T2YoZSksXG4gICAgICAgICAgciA9IHRoaXMuZGF0YVtpXVtvXTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbaV0uc3BsaWNlKG8sIDEpLCByLnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHIudGltZW91dCksIDAgPT09IHRoaXMuZGF0YVtpXS5sZW5ndGggJiYgZGVsZXRlIHRoaXMuZGF0YVtpXSwgdGhpcy5vblJlbW92ZShyLnZhbHVlKSwgdGhpcy5vcmRlci5zcGxpY2UodGhpcy5vcmRlci5pbmRleE9mKGkpLCAxKSwgdGhpcztcbiAgICB9LCBVLnByb3RvdHlwZS5zZXRNYXhTaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodGhpcy5tYXggPSB0OyB0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4Oykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2dldEFuZFJlbW92ZUJ5S2V5KHRoaXMub3JkZXJbMF0pO1xuXG4gICAgICAgIGUgJiYgdGhpcy5vblJlbW92ZShlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgVS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSAwLCByID0gdGhpcy5kYXRhW2ldOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgIHZhciBhID0gcltvXTtcbiAgICAgICAgICB0KGEudmFsdWUpIHx8IGUucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuID0gMCwgcyA9IGU7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBsID0gc1tuXTtcbiAgICAgICAgdGhpcy5yZW1vdmUobC52YWx1ZS50aWxlSUQsIGwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgTiA9IGZ1bmN0aW9uIE4odCwgZSwgaSkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gdDtcbiAgICAgIHZhciBvID0gdC5nbDtcbiAgICAgIHRoaXMuYnVmZmVyID0gby5jcmVhdGVCdWZmZXIoKSwgdGhpcy5keW5hbWljRHJhdyA9IEJvb2xlYW4oaSksIHRoaXMuY29udGV4dC51bmJpbmRWQU8oKSwgdC5iaW5kRWxlbWVudEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpLCBvLmJ1ZmZlckRhdGEoby5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZS5hcnJheUJ1ZmZlciwgdGhpcy5keW5hbWljRHJhdyA/IG8uRFlOQU1JQ19EUkFXIDogby5TVEFUSUNfRFJBVyksIHRoaXMuZHluYW1pY0RyYXcgfHwgZGVsZXRlIGUuYXJyYXlCdWZmZXI7XG4gICAgfTtcblxuICAgIE4ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYmluZEVsZW1lbnRCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICB9LCBOLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5jb250ZXh0LnVuYmluZFZBTygpLCB0aGlzLmJpbmQoKSwgZS5idWZmZXJTdWJEYXRhKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDAsIHQuYXJyYXlCdWZmZXIpO1xuICAgIH0sIE4ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJ1ZmZlciAmJiAodGhpcy5jb250ZXh0LmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlciksIGRlbGV0ZSB0aGlzLmJ1ZmZlcik7XG4gICAgfTtcblxuICAgIHZhciBaID0ge1xuICAgICAgSW50ODogXCJCWVRFXCIsXG4gICAgICBVaW50ODogXCJVTlNJR05FRF9CWVRFXCIsXG4gICAgICBJbnQxNjogXCJTSE9SVFwiLFxuICAgICAgVWludDE2OiBcIlVOU0lHTkVEX1NIT1JUXCIsXG4gICAgICBJbnQzMjogXCJJTlRcIixcbiAgICAgIFVpbnQzMjogXCJVTlNJR05FRF9JTlRcIixcbiAgICAgIEZsb2F0MzI6IFwiRkxPQVRcIlxuICAgIH0sXG4gICAgICAgIHEgPSBmdW5jdGlvbiBxKHQsIGUsIGksIG8pIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gZS5sZW5ndGgsIHRoaXMuYXR0cmlidXRlcyA9IGksIHRoaXMuaXRlbVNpemUgPSBlLmJ5dGVzUGVyRWxlbWVudCwgdGhpcy5keW5hbWljRHJhdyA9IG8sIHRoaXMuY29udGV4dCA9IHQ7XG4gICAgICB2YXIgciA9IHQuZ2w7XG4gICAgICB0aGlzLmJ1ZmZlciA9IHIuY3JlYXRlQnVmZmVyKCksIHQuYmluZFZlcnRleEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpLCByLmJ1ZmZlckRhdGEoci5BUlJBWV9CVUZGRVIsIGUuYXJyYXlCdWZmZXIsIHRoaXMuZHluYW1pY0RyYXcgPyByLkRZTkFNSUNfRFJBVyA6IHIuU1RBVElDX0RSQVcpLCB0aGlzLmR5bmFtaWNEcmF3IHx8IGRlbGV0ZSBlLmFycmF5QnVmZmVyO1xuICAgIH07XG5cbiAgICBxLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb250ZXh0LmJpbmRWZXJ0ZXhCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICB9LCBxLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5iaW5kKCksIGUuYnVmZmVyU3ViRGF0YShlLkFSUkFZX0JVRkZFUiwgMCwgdC5hcnJheUJ1ZmZlcik7XG4gICAgfSwgcS5wcm90b3R5cGUuZW5hYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbyA9IGUuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZV07XG4gICAgICAgIHZvaWQgMCAhPT0gbyAmJiB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG8pO1xuICAgICAgfVxuICAgIH0sIHEucHJvdG90eXBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5hdHRyaWJ1dGVzW29dLFxuICAgICAgICAgICAgYSA9IGUuYXR0cmlidXRlc1tyLm5hbWVdO1xuICAgICAgICB2b2lkIDAgIT09IGEgJiYgdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGEsIHIuY29tcG9uZW50cywgdFtaW3IudHlwZV1dLCAhMSwgdGhpcy5pdGVtU2l6ZSwgci5vZmZzZXQgKyB0aGlzLml0ZW1TaXplICogKGkgfHwgMCkpO1xuICAgICAgfVxuICAgIH0sIHEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJ1ZmZlciAmJiAodGhpcy5jb250ZXh0LmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlciksIGRlbGV0ZSB0aGlzLmJ1ZmZlcik7XG4gICAgfTtcblxuICAgIHZhciBqID0gZnVuY3Rpb24gaih0KSB7XG4gICAgICB0aGlzLmdsID0gdC5nbCwgdGhpcy5kZWZhdWx0ID0gdGhpcy5nZXREZWZhdWx0KCksIHRoaXMuY3VycmVudCA9IHRoaXMuZGVmYXVsdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgIH07XG5cbiAgICBqLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH0sIGoucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7fSwgai5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHQ7XG4gICAgfSwgai5wcm90b3R5cGUuc2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMuZGVmYXVsdCk7XG4gICAgfTtcblxuICAgIHZhciBWID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQuQ29sb3IudHJhbnNwYXJlbnQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgKHQuciAhPT0gZS5yIHx8IHQuZyAhPT0gZS5nIHx8IHQuYiAhPT0gZS5iIHx8IHQuYSAhPT0gZS5hIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmNsZWFyQ29sb3IodC5yLCB0LmcsIHQuYiwgdC5hKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGk7XG4gICAgfShqKSxcbiAgICAgICAgRyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5jbGVhckRlcHRoKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBXID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmNsZWFyU3RlbmNpbCh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgWCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbITAsICEwLCAhMCwgITBdO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdFsyXSAhPT0gZVsyXSB8fCB0WzNdICE9PSBlWzNdIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmNvbG9yTWFzayh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgSCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuZGVwdGhNYXNrKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBLID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuc3RlbmNpbE1hc2sodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIFkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZ1bmM6IHRoaXMuZ2wuQUxXQVlTLFxuICAgICAgICAgIHJlZjogMCxcbiAgICAgICAgICBtYXNrOiAyNTVcbiAgICAgICAgfTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAodC5mdW5jICE9PSBlLmZ1bmMgfHwgdC5yZWYgIT09IGUucmVmIHx8IHQubWFzayAhPT0gZS5tYXNrIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLnN0ZW5jaWxGdW5jKHQuZnVuYywgdC5yZWYsIHQubWFzayksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIEogPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZ2w7XG4gICAgICAgIHJldHVybiBbdC5LRUVQLCB0LktFRVAsIHQuS0VFUF07XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgKHRbMF0gIT09IGVbMF0gfHwgdFsxXSAhPT0gZVsxXSB8fCB0WzJdICE9PSBlWzJdIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLnN0ZW5jaWxPcCh0WzBdLCB0WzFdLCB0WzJdKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgUSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICB0ID8gZS5lbmFibGUoZS5TVEVOQ0lMX1RFU1QpIDogZS5kaXNhYmxlKGUuU1RFTkNJTF9URVNUKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgICQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuZGVwdGhSYW5nZSh0WzBdLCB0WzFdKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgdHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgdCA/IGUuZW5hYmxlKGUuREVQVEhfVEVTVCkgOiBlLmRpc2FibGUoZS5ERVBUSF9URVNUKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGV0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuTEVTUztcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuZGVwdGhGdW5jKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBpdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICB0ID8gZS5lbmFibGUoZS5CTEVORCkgOiBlLmRpc2FibGUoZS5CTEVORCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBvdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5nbDtcbiAgICAgICAgcmV0dXJuIFt0Lk9ORSwgdC5aRVJPXTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAodFswXSAhPT0gZVswXSB8fCB0WzFdICE9PSBlWzFdIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmJsZW5kRnVuYyh0WzBdLCB0WzFdKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC5Db2xvci50cmFuc3BhcmVudDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAodC5yICE9PSBlLnIgfHwgdC5nICE9PSBlLmcgfHwgdC5iICE9PSBlLmIgfHwgdC5hICE9PSBlLmEgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuYmxlbmRDb2xvcih0LnIsIHQuZywgdC5iLCB0LmEpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgaTtcbiAgICB9KGopLFxuICAgICAgICBhdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsLkZVTkNfQUREO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5ibGVuZEVxdWF0aW9uKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICB0ID8gZS5lbmFibGUoZS5DVUxMX0ZBQ0UpIDogZS5kaXNhYmxlKGUuQ1VMTF9GQUNFKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuQkFDSztcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY3VsbEZhY2UodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGx0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuQ0NXO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5mcm9udEZhY2UodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLnVzZVByb2dyYW0odCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHV0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTA7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmFjdGl2ZVRleHR1cmUodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGh0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdsO1xuICAgICAgICByZXR1cm4gWzAsIDAsIHQuZHJhd2luZ0J1ZmZlcldpZHRoLCB0LmRyYXdpbmdCdWZmZXJIZWlnaHRdO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdFsyXSAhPT0gZVsyXSB8fCB0WzNdICE9PSBlWzNdIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLnZpZXdwb3J0KHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBwdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgZHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLmJpbmRSZW5kZXJidWZmZXIoZS5SRU5ERVJCVUZGRVIsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgX3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBmdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBtdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgZ3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlKSwgdGhpcy52YW8gPSBlLmV4dFZlcnRleEFycmF5T2JqZWN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMudmFvICYmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMudmFvLmJpbmRWZXJ0ZXhBcnJheU9FUyh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgdnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLnBpeGVsU3RvcmVpKGUuVU5QQUNLX0FMSUdOTUVOVCwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICB5dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLnBpeGVsU3RvcmVpKGUuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHh0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUucGl4ZWxTdG9yZWkoZS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgaSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSksIHRoaXMuY29udGV4dCA9IGUsIHRoaXMucGFyZW50ID0gaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHd0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5iaW5kRnJhbWVidWZmZXIuc2V0KHRoaXMucGFyZW50KTtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLCBlLkNPTE9SX0FUVEFDSE1FTlQwLCBlLlRFWFRVUkVfMkQsIHQsIDApLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShidCksXG4gICAgICAgIFR0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmJpbmRGcmFtZWJ1ZmZlci5zZXQodGhpcy5wYXJlbnQpO1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGUuRlJBTUVCVUZGRVIsIGUuREVQVEhfQVRUQUNITUVOVCwgZS5SRU5ERVJCVUZGRVIsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShidCksXG4gICAgICAgIEV0ID0gZnVuY3Rpb24gRXQodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5jb250ZXh0ID0gdCwgdGhpcy53aWR0aCA9IGUsIHRoaXMuaGVpZ2h0ID0gaTtcbiAgICAgIHZhciByID0gdGhpcy5mcmFtZWJ1ZmZlciA9IHQuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIHRoaXMuY29sb3JBdHRhY2htZW50ID0gbmV3IHd0KHQsIHIpLCBvICYmICh0aGlzLmRlcHRoQXR0YWNobWVudCA9IG5ldyBUdCh0LCByKSk7XG4gICAgfTtcblxuICAgIEV0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNvbnRleHQuZ2wsXG4gICAgICAgICAgZSA9IHRoaXMuY29sb3JBdHRhY2htZW50LmdldCgpO1xuXG4gICAgICBpZiAoZSAmJiB0LmRlbGV0ZVRleHR1cmUoZSksIHRoaXMuZGVwdGhBdHRhY2htZW50KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXB0aEF0dGFjaG1lbnQuZ2V0KCk7XG4gICAgICAgIGkgJiYgdC5kZWxldGVSZW5kZXJidWZmZXIoaSk7XG4gICAgICB9XG5cbiAgICAgIHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgfTtcblxuICAgIHZhciBJdCA9IGZ1bmN0aW9uIEl0KHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuZnVuYyA9IHQsIHRoaXMubWFzayA9IGUsIHRoaXMucmFuZ2UgPSBpO1xuICAgIH07XG5cbiAgICBJdC5SZWFkT25seSA9ICExLCBJdC5SZWFkV3JpdGUgPSAhMCwgSXQuZGlzYWJsZWQgPSBuZXcgSXQoNTE5LCBJdC5SZWFkT25seSwgWzAsIDFdKTtcblxuICAgIHZhciBQdCA9IGZ1bmN0aW9uIFB0KHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMudGVzdCA9IHQsIHRoaXMucmVmID0gZSwgdGhpcy5tYXNrID0gaSwgdGhpcy5mYWlsID0gbywgdGhpcy5kZXB0aEZhaWwgPSByLCB0aGlzLnBhc3MgPSBhO1xuICAgIH07XG5cbiAgICBQdC5kaXNhYmxlZCA9IG5ldyBQdCh7XG4gICAgICBmdW5jOiA1MTksXG4gICAgICBtYXNrOiAwXG4gICAgfSwgMCwgMCwgNzY4MCwgNzY4MCwgNzY4MCk7XG5cbiAgICB2YXIgU3QgPSBmdW5jdGlvbiBTdCh0LCBlLCBpKSB7XG4gICAgICB0aGlzLmJsZW5kRnVuY3Rpb24gPSB0LCB0aGlzLmJsZW5kQ29sb3IgPSBlLCB0aGlzLm1hc2sgPSBpO1xuICAgIH07XG5cbiAgICBTdC5kaXNhYmxlZCA9IG5ldyBTdChTdC5SZXBsYWNlID0gWzEsIDBdLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBbITEsICExLCAhMSwgITFdKSwgU3QudW5ibGVuZGVkID0gbmV3IFN0KFN0LlJlcGxhY2UsIHQuQ29sb3IudHJhbnNwYXJlbnQsIFshMCwgITAsICEwLCAhMF0pLCBTdC5hbHBoYUJsZW5kZWQgPSBuZXcgU3QoWzEsIDc3MV0sIHQuQ29sb3IudHJhbnNwYXJlbnQsIFshMCwgITAsICEwLCAhMF0pO1xuXG4gICAgdmFyIEN0ID0gZnVuY3Rpb24gQ3QodCwgZSwgaSkge1xuICAgICAgdGhpcy5lbmFibGUgPSB0LCB0aGlzLm1vZGUgPSBlLCB0aGlzLmZyb250RmFjZSA9IGk7XG4gICAgfTtcblxuICAgIEN0LmRpc2FibGVkID0gbmV3IEN0KCExLCAxMDI5LCAyMzA1KSwgQ3QuYmFja0NDVyA9IG5ldyBDdCghMCwgMTAyOSwgMjMwNSk7XG5cbiAgICB2YXIgenQgPSBmdW5jdGlvbiB6dCh0KSB7XG4gICAgICB0aGlzLmdsID0gdCwgdGhpcy5leHRWZXJ0ZXhBcnJheU9iamVjdCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksIHRoaXMuY2xlYXJDb2xvciA9IG5ldyBWKHRoaXMpLCB0aGlzLmNsZWFyRGVwdGggPSBuZXcgRyh0aGlzKSwgdGhpcy5jbGVhclN0ZW5jaWwgPSBuZXcgVyh0aGlzKSwgdGhpcy5jb2xvck1hc2sgPSBuZXcgWCh0aGlzKSwgdGhpcy5kZXB0aE1hc2sgPSBuZXcgSCh0aGlzKSwgdGhpcy5zdGVuY2lsTWFzayA9IG5ldyBLKHRoaXMpLCB0aGlzLnN0ZW5jaWxGdW5jID0gbmV3IFkodGhpcyksIHRoaXMuc3RlbmNpbE9wID0gbmV3IEoodGhpcyksIHRoaXMuc3RlbmNpbFRlc3QgPSBuZXcgUSh0aGlzKSwgdGhpcy5kZXB0aFJhbmdlID0gbmV3ICQodGhpcyksIHRoaXMuZGVwdGhUZXN0ID0gbmV3IHR0KHRoaXMpLCB0aGlzLmRlcHRoRnVuYyA9IG5ldyBldCh0aGlzKSwgdGhpcy5ibGVuZCA9IG5ldyBpdCh0aGlzKSwgdGhpcy5ibGVuZEZ1bmMgPSBuZXcgb3QodGhpcyksIHRoaXMuYmxlbmRDb2xvciA9IG5ldyBydCh0aGlzKSwgdGhpcy5ibGVuZEVxdWF0aW9uID0gbmV3IGF0KHRoaXMpLCB0aGlzLmN1bGxGYWNlID0gbmV3IG50KHRoaXMpLCB0aGlzLmN1bGxGYWNlU2lkZSA9IG5ldyBzdCh0aGlzKSwgdGhpcy5mcm9udEZhY2UgPSBuZXcgbHQodGhpcyksIHRoaXMucHJvZ3JhbSA9IG5ldyBjdCh0aGlzKSwgdGhpcy5hY3RpdmVUZXh0dXJlID0gbmV3IHV0KHRoaXMpLCB0aGlzLnZpZXdwb3J0ID0gbmV3IGh0KHRoaXMpLCB0aGlzLmJpbmRGcmFtZWJ1ZmZlciA9IG5ldyBwdCh0aGlzKSwgdGhpcy5iaW5kUmVuZGVyYnVmZmVyID0gbmV3IGR0KHRoaXMpLCB0aGlzLmJpbmRUZXh0dXJlID0gbmV3IF90KHRoaXMpLCB0aGlzLmJpbmRWZXJ0ZXhCdWZmZXIgPSBuZXcgZnQodGhpcyksIHRoaXMuYmluZEVsZW1lbnRCdWZmZXIgPSBuZXcgbXQodGhpcyksIHRoaXMuYmluZFZlcnRleEFycmF5T0VTID0gdGhpcy5leHRWZXJ0ZXhBcnJheU9iamVjdCAmJiBuZXcgZ3QodGhpcyksIHRoaXMucGl4ZWxTdG9yZVVucGFjayA9IG5ldyB2dCh0aGlzKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYSA9IG5ldyB5dCh0aGlzKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrRmxpcFkgPSBuZXcgeHQodGhpcyksIHRoaXMuZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljID0gdC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikgfHwgdC5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpIHx8IHQuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSwgdGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMgJiYgKHRoaXMuZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljTWF4ID0gdC5nZXRQYXJhbWV0ZXIodGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKSksIHRoaXMuZXh0VGV4dHVyZUhhbGZGbG9hdCA9IHQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSwgdGhpcy5leHRUZXh0dXJlSGFsZkZsb2F0ICYmICh0LmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpLCB0aGlzLmV4dFJlbmRlclRvVGV4dHVyZUhhbGZGbG9hdCA9IHQuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKSwgdGhpcy5leHRUaW1lclF1ZXJ5ID0gdC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIiksIHRoaXMubWF4VGV4dHVyZVNpemUgPSB0LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIH07XG5cbiAgICB6dC5wcm90b3R5cGUuc2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudW5iaW5kVkFPKCksIHRoaXMuY2xlYXJDb2xvci5zZXREZWZhdWx0KCksIHRoaXMuY2xlYXJEZXB0aC5zZXREZWZhdWx0KCksIHRoaXMuY2xlYXJTdGVuY2lsLnNldERlZmF1bHQoKSwgdGhpcy5jb2xvck1hc2suc2V0RGVmYXVsdCgpLCB0aGlzLmRlcHRoTWFzay5zZXREZWZhdWx0KCksIHRoaXMuc3RlbmNpbE1hc2suc2V0RGVmYXVsdCgpLCB0aGlzLnN0ZW5jaWxGdW5jLnNldERlZmF1bHQoKSwgdGhpcy5zdGVuY2lsT3Auc2V0RGVmYXVsdCgpLCB0aGlzLnN0ZW5jaWxUZXN0LnNldERlZmF1bHQoKSwgdGhpcy5kZXB0aFJhbmdlLnNldERlZmF1bHQoKSwgdGhpcy5kZXB0aFRlc3Quc2V0RGVmYXVsdCgpLCB0aGlzLmRlcHRoRnVuYy5zZXREZWZhdWx0KCksIHRoaXMuYmxlbmQuc2V0RGVmYXVsdCgpLCB0aGlzLmJsZW5kRnVuYy5zZXREZWZhdWx0KCksIHRoaXMuYmxlbmRDb2xvci5zZXREZWZhdWx0KCksIHRoaXMuYmxlbmRFcXVhdGlvbi5zZXREZWZhdWx0KCksIHRoaXMuY3VsbEZhY2Uuc2V0RGVmYXVsdCgpLCB0aGlzLmN1bGxGYWNlU2lkZS5zZXREZWZhdWx0KCksIHRoaXMuZnJvbnRGYWNlLnNldERlZmF1bHQoKSwgdGhpcy5wcm9ncmFtLnNldERlZmF1bHQoKSwgdGhpcy5hY3RpdmVUZXh0dXJlLnNldERlZmF1bHQoKSwgdGhpcy5iaW5kRnJhbWVidWZmZXIuc2V0RGVmYXVsdCgpLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2suc2V0RGVmYXVsdCgpLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLnNldERlZmF1bHQoKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrRmxpcFkuc2V0RGVmYXVsdCgpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb2xvci5kaXJ0eSA9ICEwLCB0aGlzLmNsZWFyRGVwdGguZGlydHkgPSAhMCwgdGhpcy5jbGVhclN0ZW5jaWwuZGlydHkgPSAhMCwgdGhpcy5jb2xvck1hc2suZGlydHkgPSAhMCwgdGhpcy5kZXB0aE1hc2suZGlydHkgPSAhMCwgdGhpcy5zdGVuY2lsTWFzay5kaXJ0eSA9ICEwLCB0aGlzLnN0ZW5jaWxGdW5jLmRpcnR5ID0gITAsIHRoaXMuc3RlbmNpbE9wLmRpcnR5ID0gITAsIHRoaXMuc3RlbmNpbFRlc3QuZGlydHkgPSAhMCwgdGhpcy5kZXB0aFJhbmdlLmRpcnR5ID0gITAsIHRoaXMuZGVwdGhUZXN0LmRpcnR5ID0gITAsIHRoaXMuZGVwdGhGdW5jLmRpcnR5ID0gITAsIHRoaXMuYmxlbmQuZGlydHkgPSAhMCwgdGhpcy5ibGVuZEZ1bmMuZGlydHkgPSAhMCwgdGhpcy5ibGVuZENvbG9yLmRpcnR5ID0gITAsIHRoaXMuYmxlbmRFcXVhdGlvbi5kaXJ0eSA9ICEwLCB0aGlzLmN1bGxGYWNlLmRpcnR5ID0gITAsIHRoaXMuY3VsbEZhY2VTaWRlLmRpcnR5ID0gITAsIHRoaXMuZnJvbnRGYWNlLmRpcnR5ID0gITAsIHRoaXMucHJvZ3JhbS5kaXJ0eSA9ICEwLCB0aGlzLmFjdGl2ZVRleHR1cmUuZGlydHkgPSAhMCwgdGhpcy52aWV3cG9ydC5kaXJ0eSA9ICEwLCB0aGlzLmJpbmRGcmFtZWJ1ZmZlci5kaXJ0eSA9ICEwLCB0aGlzLmJpbmRSZW5kZXJidWZmZXIuZGlydHkgPSAhMCwgdGhpcy5iaW5kVGV4dHVyZS5kaXJ0eSA9ICEwLCB0aGlzLmJpbmRWZXJ0ZXhCdWZmZXIuZGlydHkgPSAhMCwgdGhpcy5iaW5kRWxlbWVudEJ1ZmZlci5kaXJ0eSA9ICEwLCB0aGlzLmV4dFZlcnRleEFycmF5T2JqZWN0ICYmICh0aGlzLmJpbmRWZXJ0ZXhBcnJheU9FUy5kaXJ0eSA9ICEwKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrLmRpcnR5ID0gITAsIHRoaXMucGl4ZWxTdG9yZVVucGFja1ByZW11bHRpcGx5QWxwaGEuZGlydHkgPSAhMCwgdGhpcy5waXhlbFN0b3JlVW5wYWNrRmxpcFkuZGlydHkgPSAhMDtcbiAgICB9LCB6dC5wcm90b3R5cGUuY3JlYXRlSW5kZXhCdWZmZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIG5ldyBOKHRoaXMsIHQsIGUpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIG5ldyBxKHRoaXMsIHQsIGUsIGkpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5jcmVhdGVSZW5kZXJidWZmZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLmdsLFxuICAgICAgICAgIHIgPSBvLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgcmV0dXJuIHRoaXMuYmluZFJlbmRlcmJ1ZmZlci5zZXQociksIG8ucmVuZGVyYnVmZmVyU3RvcmFnZShvLlJFTkRFUkJVRkZFUiwgdCwgZSwgaSksIHRoaXMuYmluZFJlbmRlcmJ1ZmZlci5zZXQobnVsbCksIHI7XG4gICAgfSwgenQucHJvdG90eXBlLmNyZWF0ZUZyYW1lYnVmZmVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBuZXcgRXQodGhpcywgdCwgZSwgaSk7XG4gICAgfSwgenQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdC5jb2xvcixcbiAgICAgICAgICBpID0gdC5kZXB0aCxcbiAgICAgICAgICBvID0gdGhpcy5nbCxcbiAgICAgICAgICByID0gMDtcbiAgICAgIGUgJiYgKHIgfD0gby5DT0xPUl9CVUZGRVJfQklULCB0aGlzLmNsZWFyQ29sb3Iuc2V0KGUpLCB0aGlzLmNvbG9yTWFzay5zZXQoWyEwLCAhMCwgITAsICEwXSkpLCB2b2lkIDAgIT09IGkgJiYgKHIgfD0gby5ERVBUSF9CVUZGRVJfQklULCB0aGlzLmRlcHRoUmFuZ2Uuc2V0KFswLCAxXSksIHRoaXMuY2xlYXJEZXB0aC5zZXQoaSksIHRoaXMuZGVwdGhNYXNrLnNldCghMCkpLCBvLmNsZWFyKHIpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5zZXRDdWxsRmFjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAhMSA9PT0gdC5lbmFibGUgPyB0aGlzLmN1bGxGYWNlLnNldCghMSkgOiAodGhpcy5jdWxsRmFjZS5zZXQoITApLCB0aGlzLmN1bGxGYWNlU2lkZS5zZXQodC5tb2RlKSwgdGhpcy5mcm9udEZhY2Uuc2V0KHQuZnJvbnRGYWNlKSk7XG4gICAgfSwgenQucHJvdG90eXBlLnNldERlcHRoTW9kZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LmZ1bmMgIT09IHRoaXMuZ2wuQUxXQVlTIHx8IHQubWFzayA/ICh0aGlzLmRlcHRoVGVzdC5zZXQoITApLCB0aGlzLmRlcHRoRnVuYy5zZXQodC5mdW5jKSwgdGhpcy5kZXB0aE1hc2suc2V0KHQubWFzayksIHRoaXMuZGVwdGhSYW5nZS5zZXQodC5yYW5nZSkpIDogdGhpcy5kZXB0aFRlc3Quc2V0KCExKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0U3RlbmNpbE1vZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdC50ZXN0LmZ1bmMgIT09IHRoaXMuZ2wuQUxXQVlTIHx8IHQubWFzayA/ICh0aGlzLnN0ZW5jaWxUZXN0LnNldCghMCksIHRoaXMuc3RlbmNpbE1hc2suc2V0KHQubWFzayksIHRoaXMuc3RlbmNpbE9wLnNldChbdC5mYWlsLCB0LmRlcHRoRmFpbCwgdC5wYXNzXSksIHRoaXMuc3RlbmNpbEZ1bmMuc2V0KHtcbiAgICAgICAgZnVuYzogdC50ZXN0LmZ1bmMsXG4gICAgICAgIHJlZjogdC5yZWYsXG4gICAgICAgIG1hc2s6IHQudGVzdC5tYXNrXG4gICAgICB9KSkgOiB0aGlzLnN0ZW5jaWxUZXN0LnNldCghMSk7XG4gICAgfSwgenQucHJvdG90eXBlLnNldENvbG9yTW9kZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0LmRlZXBFcXVhbChlLmJsZW5kRnVuY3Rpb24sIFN0LlJlcGxhY2UpID8gdGhpcy5ibGVuZC5zZXQoITEpIDogKHRoaXMuYmxlbmQuc2V0KCEwKSwgdGhpcy5ibGVuZEZ1bmMuc2V0KGUuYmxlbmRGdW5jdGlvbiksIHRoaXMuYmxlbmRDb2xvci5zZXQoZS5ibGVuZENvbG9yKSksIHRoaXMuY29sb3JNYXNrLnNldChlLm1hc2spO1xuICAgIH0sIHp0LnByb3RvdHlwZS51bmJpbmRWQU8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmV4dFZlcnRleEFycmF5T2JqZWN0ICYmIHRoaXMuYmluZFZlcnRleEFycmF5T0VTLnNldChudWxsKTtcbiAgICB9O1xuXG4gICAgdmFyIER0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSwgbywgcikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGksIHRoaXMuZGlzcGF0Y2hlciA9IHIsIHRoaXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcIm1ldGFkYXRhXCIgPT09IHQuc291cmNlRGF0YVR5cGUgJiYgKGEuX3NvdXJjZUxvYWRlZCA9ICEwKSwgYS5fc291cmNlTG9hZGVkICYmICFhLl9wYXVzZWQgJiYgXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcImNvbnRlbnRcIiA9PT0gdC5zb3VyY2VEYXRhVHlwZSAmJiAoYS5yZWxvYWQoKSwgYS50cmFuc2Zvcm0gJiYgYS51cGRhdGUoYS50cmFuc2Zvcm0pKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5fc291cmNlRXJyb3JlZCA9ICEwO1xuICAgICAgICB9KSwgdGhpcy5fc291cmNlID0gZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICB2YXIgYSA9IG5ldyBrW2kudHlwZV0oZSwgaSwgbywgcik7XG4gICAgICAgICAgaWYgKGEuaWQgIT09IGUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFNvdXJjZSBpZCB0byBiZSBcIiArIGUgKyBcIiBpbnN0ZWFkIG9mIFwiICsgYS5pZCk7XG4gICAgICAgICAgcmV0dXJuIHQuYmluZEFsbChbXCJsb2FkXCIsIFwiYWJvcnRcIiwgXCJ1bmxvYWRcIiwgXCJzZXJpYWxpemVcIiwgXCJwcmVwYXJlXCJdLCBhKSwgYTtcbiAgICAgICAgfShpLCBvLCByLCB0aGlzKSwgdGhpcy5fdGlsZXMgPSB7fSwgdGhpcy5fY2FjaGUgPSBuZXcgVSgwLCB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcykpLCB0aGlzLl90aW1lcnMgPSB7fSwgdGhpcy5fY2FjaGVUaW1lcnMgPSB7fSwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IG51bGwsIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzID0ge30sIHRoaXMuX2NvdmVyZWRUaWxlcyA9IHt9LCB0aGlzLl9zdGF0ZSA9IG5ldyB0LlNvdXJjZUZlYXR1cmVTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IHQgPyB0Ll9tYXhUaWxlQ2FjaGVTaXplIDogbnVsbCwgdGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5vbkFkZCAmJiB0aGlzLl9zb3VyY2Uub25BZGQodCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2Uub25SZW1vdmUgJiYgdGhpcy5fc291cmNlLm9uUmVtb3ZlKHQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlRXJyb3JlZCkgcmV0dXJuICEwO1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZUxvYWRlZCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZS5sb2FkZWQoKSkgcmV0dXJuICExO1xuXG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgICAgIGlmIChcImxvYWRlZFwiICE9PSBlLnN0YXRlICYmIFwiZXJyb3JlZFwiICE9PSBlLnN0YXRlKSByZXR1cm4gITE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuX3Nob3VsZFJlbG9hZE9uUmVzdW1lO1xuICAgICAgICAgIHRoaXMuX3BhdXNlZCA9ICExLCB0aGlzLl9zaG91bGRSZWxvYWRPblJlc3VtZSA9ICExLCB0ICYmIHRoaXMucmVsb2FkKCksIHRoaXMudHJhbnNmb3JtICYmIHRoaXMudXBkYXRlKHRoaXMudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX2xvYWRUaWxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb2FkVGlsZSh0LCBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZS51bmxvYWRUaWxlKSByZXR1cm4gdGhpcy5fc291cmNlLnVubG9hZFRpbGUodCwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2Fib3J0VGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UuYWJvcnRUaWxlKSByZXR1cm4gdGhpcy5fc291cmNlLmFib3J0VGlsZSh0LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc2VyaWFsaXplKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLl9zb3VyY2UucHJlcGFyZSAmJiB0aGlzLl9zb3VyY2UucHJlcGFyZSgpLCB0aGlzLl9zdGF0ZS5jb2FsZXNjZUNoYW5nZXModGhpcy5fdGlsZXMsIHRoaXMubWFwID8gdGhpcy5tYXAucGFpbnRlciA6IG51bGwpLCB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fdGlsZXNbZV07XG4gICAgICAgICAgaS51cGxvYWQodCksIGkucHJlcGFyZSh0aGlzLm1hcC5zdHlsZS5pbWFnZU1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlcyh0aGlzLl90aWxlcykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQudGlsZUlEO1xuICAgICAgICB9KS5zb3J0KEF0KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5rZXk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UmVuZGVyYWJsZUlkcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcyxcbiAgICAgICAgICAgIG8gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciByIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgdGhpcy5faXNJZFJlbmRlcmFibGUociwgZSkgJiYgby5wdXNoKHRoaXMuX3RpbGVzW3JdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlID8gby5zb3J0KGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLnRpbGVJRCxcbiAgICAgICAgICAgICAgYSA9IG8udGlsZUlELFxuICAgICAgICAgICAgICBuID0gbmV3IHQuUG9pbnQoci5jYW5vbmljYWwueCwgci5jYW5vbmljYWwueSkuX3JvdGF0ZShpLnRyYW5zZm9ybS5hbmdsZSksXG4gICAgICAgICAgICAgIHMgPSBuZXcgdC5Qb2ludChhLmNhbm9uaWNhbC54LCBhLmNhbm9uaWNhbC55KS5fcm90YXRlKGkudHJhbnNmb3JtLmFuZ2xlKTtcblxuICAgICAgICAgIHJldHVybiByLm92ZXJzY2FsZWRaIC0gYS5vdmVyc2NhbGVkWiB8fCBzLnkgLSBuLnkgfHwgcy54IC0gbi54O1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC50aWxlSUQua2V5O1xuICAgICAgICB9KSA6IG8ubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQudGlsZUlEO1xuICAgICAgICB9KS5zb3J0KEF0KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5rZXk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzUmVuZGVyYWJsZVBhcmVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5maW5kTG9hZGVkUGFyZW50KHQsIDApO1xuICAgICAgICByZXR1cm4gISFlICYmIHRoaXMuX2lzSWRSZW5kZXJhYmxlKGUudGlsZUlELmtleSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faXNJZFJlbmRlcmFibGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbdF0gJiYgdGhpcy5fdGlsZXNbdF0uaGFzRGF0YSgpICYmICF0aGlzLl9jb3ZlcmVkVGlsZXNbdF0gJiYgKGUgfHwgIXRoaXMuX3RpbGVzW3RdLmhvbGRpbmdGb3JGYWRlKCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB0aGlzLl9zaG91bGRSZWxvYWRPblJlc3VtZSA9ICEwO2Vsc2UgZm9yICh2YXIgdCBpbiB0aGlzLl9jYWNoZS5yZXNldCgpLCB0aGlzLl90aWxlcykge1xuICAgICAgICAgIFwiZXJyb3JlZFwiICE9PSB0aGlzLl90aWxlc1t0XS5zdGF0ZSAmJiB0aGlzLl9yZWxvYWRUaWxlKHQsIFwicmVsb2FkaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmVsb2FkVGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIGkgJiYgKFwibG9hZGluZ1wiICE9PSBpLnN0YXRlICYmIChpLnN0YXRlID0gZSksIHRoaXMuX2xvYWRUaWxlKGksIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCBpLCB0LCBlKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3RpbGVMb2FkZWQgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICBpZiAocikgcmV0dXJuIGUuc3RhdGUgPSBcImVycm9yZWRcIiwgdm9pZCAoNDA0ICE9PSByLnN0YXR1cyA/IHRoaXMuX3NvdXJjZS5maXJlKG5ldyB0LkVycm9yRXZlbnQociwge1xuICAgICAgICAgIHRpbGU6IGVcbiAgICAgICAgfSkpIDogdGhpcy51cGRhdGUodGhpcy50cmFuc2Zvcm0pKTtcbiAgICAgICAgZS50aW1lQWRkZWQgPSB0LmJyb3dzZXIubm93KCksIFwiZXhwaXJlZFwiID09PSBvICYmIChlLnJlZnJlc2hlZFVwb25FeHBpcmF0aW9uID0gITApLCB0aGlzLl9zZXRUaWxlUmVsb2FkVGltZXIoaSwgZSksIFwicmFzdGVyLWRlbVwiID09PSB0aGlzLmdldFNvdXJjZSgpLnR5cGUgJiYgZS5kZW0gJiYgdGhpcy5fYmFja2ZpbGxERU0oZSksIHRoaXMuX3N0YXRlLmluaXRpYWxpemVUaWxlU3RhdGUoZSwgdGhpcy5tYXAgPyB0aGlzLm1hcC5wYWludGVyIDogbnVsbCksIHRoaXMuX3NvdXJjZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgdGlsZTogZSxcbiAgICAgICAgICBjb29yZDogZS50aWxlSURcbiAgICAgICAgfSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2JhY2tmaWxsREVNID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMuZ2V0UmVuZGVyYWJsZUlkcygpLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbyA9IGVbaV07XG5cbiAgICAgICAgICBpZiAodC5uZWlnaGJvcmluZ1RpbGVzICYmIHQubmVpZ2hib3JpbmdUaWxlc1tvXSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmdldFRpbGVCeUlEKG8pO1xuICAgICAgICAgICAgYSh0LCByKSwgYShyLCB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhKHQsIGUpIHtcbiAgICAgICAgICB0Lm5lZWRzSGlsbHNoYWRlUHJlcGFyZSA9ICEwO1xuICAgICAgICAgIHZhciBpID0gZS50aWxlSUQuY2Fub25pY2FsLnggLSB0LnRpbGVJRC5jYW5vbmljYWwueCxcbiAgICAgICAgICAgICAgbyA9IGUudGlsZUlELmNhbm9uaWNhbC55IC0gdC50aWxlSUQuY2Fub25pY2FsLnksXG4gICAgICAgICAgICAgIHIgPSBNYXRoLnBvdygyLCB0LnRpbGVJRC5jYW5vbmljYWwueiksXG4gICAgICAgICAgICAgIGEgPSBlLnRpbGVJRC5rZXk7XG4gICAgICAgICAgMCA9PT0gaSAmJiAwID09PSBvIHx8IE1hdGguYWJzKG8pID4gMSB8fCAoTWF0aC5hYnMoaSkgPiAxICYmICgxID09PSBNYXRoLmFicyhpICsgcikgPyBpICs9IHIgOiAxID09PSBNYXRoLmFicyhpIC0gcikgJiYgKGkgLT0gcikpLCBlLmRlbSAmJiB0LmRlbSAmJiAodC5kZW0uYmFja2ZpbGxCb3JkZXIoZS5kZW0sIGksIG8pLCB0Lm5laWdoYm9yaW5nVGlsZXMgJiYgdC5uZWlnaGJvcmluZ1RpbGVzW2FdICYmICh0Lm5laWdoYm9yaW5nVGlsZXNbYV0uYmFja2ZpbGxlZCA9ICEwKSkpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUJ5SUQodC5rZXkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VGlsZUJ5SUQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbdF07XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmV0YWluTG9hZGVkQ2hpbGRyZW4gPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICBmb3IgKHZhciByIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLl90aWxlc1tyXTtcblxuICAgICAgICAgIGlmICghKG9bcl0gfHwgIWEuaGFzRGF0YSgpIHx8IGEudGlsZUlELm92ZXJzY2FsZWRaIDw9IGUgfHwgYS50aWxlSUQub3ZlcnNjYWxlZFogPiBpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IGEudGlsZUlEOyBhICYmIGEudGlsZUlELm92ZXJzY2FsZWRaID4gZSArIDE7KSB7XG4gICAgICAgICAgICAgIHZhciBzID0gYS50aWxlSUQuc2NhbGVkVG8oYS50aWxlSUQub3ZlcnNjYWxlZFogLSAxKTtcbiAgICAgICAgICAgICAgKGEgPSB0aGlzLl90aWxlc1tzLmtleV0pICYmIGEuaGFzRGF0YSgpICYmIChuID0gcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSBuOyBsLm92ZXJzY2FsZWRaID4gZTspIHtcbiAgICAgICAgICAgICAgaWYgKHRbKGwgPSBsLnNjYWxlZFRvKGwub3ZlcnNjYWxlZFogLSAxKSkua2V5XSkge1xuICAgICAgICAgICAgICAgIG9bbi5rZXldID0gbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuZmluZExvYWRlZFBhcmVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmICh0LmtleSBpbiB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlcykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fbG9hZGVkUGFyZW50VGlsZXNbdC5rZXldO1xuICAgICAgICAgIHJldHVybiBpICYmIGkudGlsZUlELm92ZXJzY2FsZWRaID49IGUgPyBpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG8gPSB0Lm92ZXJzY2FsZWRaIC0gMTsgbyA+PSBlOyBvLS0pIHtcbiAgICAgICAgICB2YXIgciA9IHQuc2NhbGVkVG8obyksXG4gICAgICAgICAgICAgIGEgPSB0aGlzLl9nZXRMb2FkZWRUaWxlKHIpO1xuXG4gICAgICAgICAgaWYgKGEpIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZ2V0TG9hZGVkVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdC5rZXldO1xuICAgICAgICByZXR1cm4gZSAmJiBlLmhhc0RhdGEoKSA/IGUgOiB0aGlzLl9jYWNoZS5nZXRCeUtleSh0LndyYXBwZWQoKS5rZXkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXBkYXRlQ2FjaGVTaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNlaWwodC53aWR0aCAvIHRoaXMuX3NvdXJjZS50aWxlU2l6ZSkgKyAxLFxuICAgICAgICAgICAgaSA9IE1hdGguY2VpbCh0LmhlaWdodCAvIHRoaXMuX3NvdXJjZS50aWxlU2l6ZSkgKyAxLFxuICAgICAgICAgICAgbyA9IE1hdGguZmxvb3IoZSAqIGkgKiA1KSxcbiAgICAgICAgICAgIHIgPSBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLl9tYXhUaWxlQ2FjaGVTaXplID8gTWF0aC5taW4odGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSwgbykgOiBvO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnNldE1heFNpemUocik7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYW5kbGVXcmFwSnVtcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gTWF0aC5yb3VuZCgodCAtICh2b2lkIDAgPT09IHRoaXMuX3ByZXZMbmcgPyB0IDogdGhpcy5fcHJldkxuZykpIC8gMzYwKTtcblxuICAgICAgICBpZiAodGhpcy5fcHJldkxuZyA9IHQsIGUpIHtcbiAgICAgICAgICB2YXIgaSA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLl90aWxlc1tvXTtcbiAgICAgICAgICAgIHIudGlsZUlEID0gci50aWxlSUQudW53cmFwVG8oci50aWxlSUQud3JhcCArIGUpLCBpW3IudGlsZUlELmtleV0gPSByO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5fdGlsZXMgPSBpLCB0aGlzLl90aW1lcnMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcnNbYV0pLCBkZWxldGUgdGhpcy5fdGltZXJzW2FdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbGVSZWxvYWRUaW1lcihuLCB0aGlzLl90aWxlc1tuXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtID0gZSwgdGhpcy5fc291cmNlTG9hZGVkICYmICF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlU2l6ZShlKSwgdGhpcy5oYW5kbGVXcmFwSnVtcCh0aGlzLnRyYW5zZm9ybS5jZW50ZXIubG5nKSwgdGhpcy5fY292ZXJlZFRpbGVzID0ge30sIHRoaXMudXNlZCA/IHRoaXMuX3NvdXJjZS50aWxlSUQgPyByID0gZS5nZXRWaXNpYmxlVW53cmFwcGVkQ29vcmRpbmF0ZXModGhpcy5fc291cmNlLnRpbGVJRCkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLmNhbm9uaWNhbC56LCBlLndyYXAsIGUuY2Fub25pY2FsLnosIGUuY2Fub25pY2FsLngsIGUuY2Fub25pY2FsLnkpO1xuICAgICAgICAgIH0pIDogKHIgPSBlLmNvdmVyaW5nVGlsZXMoe1xuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMuX3NvdXJjZS50aWxlU2l6ZSxcbiAgICAgICAgICAgIG1pbnpvb206IHRoaXMuX3NvdXJjZS5taW56b29tLFxuICAgICAgICAgICAgbWF4em9vbTogdGhpcy5fc291cmNlLm1heHpvb20sXG4gICAgICAgICAgICByb3VuZFpvb206IHRoaXMuX3NvdXJjZS5yb3VuZFpvb20sXG4gICAgICAgICAgICByZXBhcnNlT3ZlcnNjYWxlZDogdGhpcy5fc291cmNlLnJlcGFyc2VPdmVyc2NhbGVkXG4gICAgICAgICAgfSksIHRoaXMuX3NvdXJjZS5oYXNUaWxlICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvLl9zb3VyY2UuaGFzVGlsZSh0KTtcbiAgICAgICAgICB9KSkpIDogciA9IFtdO1xuXG4gICAgICAgICAgdmFyIGEgPSBlLmNvdmVyaW5nWm9vbUxldmVsKHRoaXMuX3NvdXJjZSksXG4gICAgICAgICAgICAgIG4gPSBNYXRoLm1heChhIC0gaS5tYXhPdmVyem9vbWluZywgdGhpcy5fc291cmNlLm1pbnpvb20pLFxuICAgICAgICAgICAgICBzID0gTWF0aC5tYXgoYSArIGkubWF4VW5kZXJ6b29taW5nLCB0aGlzLl9zb3VyY2UubWluem9vbSksXG4gICAgICAgICAgICAgIGwgPSB0aGlzLl91cGRhdGVSZXRhaW5lZFRpbGVzKHIsIGEpO1xuXG4gICAgICAgICAgaWYgKE10KHRoaXMuX3NvdXJjZS50eXBlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHt9LCB1ID0ge30sIGggPSAwLCBwID0gT2JqZWN0LmtleXMobCk7IGggPCBwLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gcFtoXSxcbiAgICAgICAgICAgICAgICAgIF8gPSBsW2RdLFxuICAgICAgICAgICAgICAgICAgZiA9IHRoaXMuX3RpbGVzW2RdO1xuXG4gICAgICAgICAgICAgIGlmIChmICYmICEoZi5mYWRlRW5kVGltZSAmJiBmLmZhZGVFbmRUaW1lIDw9IHQuYnJvd3Nlci5ub3coKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZmluZExvYWRlZFBhcmVudChfLCBuKTtcbiAgICAgICAgICAgICAgICBtICYmICh0aGlzLl9hZGRUaWxlKG0udGlsZUlEKSwgY1ttLnRpbGVJRC5rZXldID0gbS50aWxlSUQpLCB1W2RdID0gXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBnIGluIHRoaXMuX3JldGFpbkxvYWRlZENoaWxkcmVuKHUsIGEsIHMsIGwpLCBjKSB7XG4gICAgICAgICAgICAgIGxbZ10gfHwgKHRoaXMuX2NvdmVyZWRUaWxlc1tnXSA9ICEwLCBsW2ddID0gY1tnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgdiBpbiBsKSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlc1t2XS5jbGVhckZhZGVIb2xkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgeSA9IDAsIHggPSB0LmtleXNEaWZmZXJlbmNlKHRoaXMuX3RpbGVzLCBsKTsgeSA8IHgubGVuZ3RoOyB5ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBiID0geFt5XSxcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5fdGlsZXNbYl07XG4gICAgICAgICAgICB3Lmhhc1N5bWJvbEJ1Y2tldHMgJiYgIXcuaG9sZGluZ0ZvckZhZGUoKSA/IHcuc2V0SG9sZER1cmF0aW9uKHRoaXMubWFwLl9mYWRlRHVyYXRpb24pIDogdy5oYXNTeW1ib2xCdWNrZXRzICYmICF3LnN5bWJvbEZhZGVGaW5pc2hlZCgpIHx8IHRoaXMuX3JlbW92ZVRpbGUoYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlTG9hZGVkUGFyZW50VGlsZUNhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbGVhc2VTeW1ib2xGYWRlVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB0aGlzLl90aWxlc1t0XS5ob2xkaW5nRm9yRmFkZSgpICYmIHRoaXMuX3JlbW92ZVRpbGUodCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVSZXRhaW5lZFRpbGVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IHt9LCByID0ge30sIGEgPSBNYXRoLm1heChlIC0gaS5tYXhPdmVyem9vbWluZywgdGhpcy5fc291cmNlLm1pbnpvb20pLCBuID0gTWF0aC5tYXgoZSArIGkubWF4VW5kZXJ6b29taW5nLCB0aGlzLl9zb3VyY2UubWluem9vbSksIHMgPSB7fSwgbCA9IDAsIGMgPSB0OyBsIDwgYy5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICAgIHZhciB1ID0gY1tsXSxcbiAgICAgICAgICAgICAgaCA9IHRoaXMuX2FkZFRpbGUodSk7XG5cbiAgICAgICAgICBvW3Uua2V5XSA9IHUsIGguaGFzRGF0YSgpIHx8IGUgPCB0aGlzLl9zb3VyY2UubWF4em9vbSAmJiAoc1t1LmtleV0gPSB1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JldGFpbkxvYWRlZENoaWxkcmVuKHMsIGUsIG4sIG8pO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwLCBkID0gdDsgcCA8IGQubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgICB2YXIgXyA9IGRbcF0sXG4gICAgICAgICAgICAgIGYgPSB0aGlzLl90aWxlc1tfLmtleV07XG5cbiAgICAgICAgICBpZiAoIWYuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgICBpZiAoZSArIDEgPiB0aGlzLl9zb3VyY2UubWF4em9vbSkge1xuICAgICAgICAgICAgICB2YXIgbSA9IF8uY2hpbGRyZW4odGhpcy5fc291cmNlLm1heHpvb20pWzBdLFxuICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2V0VGlsZShtKTtcblxuICAgICAgICAgICAgICBpZiAoZyAmJiBnLmhhc0RhdGEoKSkge1xuICAgICAgICAgICAgICAgIG9bbS5rZXldID0gbTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBfLmNoaWxkcmVuKHRoaXMuX3NvdXJjZS5tYXh6b29tKTtcblxuICAgICAgICAgICAgICBpZiAob1t2WzBdLmtleV0gJiYgb1t2WzFdLmtleV0gJiYgb1t2WzJdLmtleV0gJiYgb1t2WzNdLmtleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gZi53YXNSZXF1ZXN0ZWQoKSwgeCA9IF8ub3ZlcnNjYWxlZFogLSAxOyB4ID49IGE7IC0teCkge1xuICAgICAgICAgICAgICB2YXIgYiA9IF8uc2NhbGVkVG8oeCk7XG5cbiAgICAgICAgICAgICAgaWYgKHJbYi5rZXldKSBicmVhaztcbiAgICAgICAgICAgICAgaWYgKHJbYi5rZXldID0gITAsICEoZiA9IHRoaXMuZ2V0VGlsZShiKSkgJiYgeSAmJiAoZiA9IHRoaXMuX2FkZFRpbGUoYikpLCBmICYmIChvW2Iua2V5XSA9IGIsIHkgPSBmLndhc1JlcXVlc3RlZCgpLCBmLmhhc0RhdGEoKSkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZUxvYWRlZFBhcmVudFRpbGVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlcyA9IHt9LCB0aGlzLl90aWxlcykge1xuICAgICAgICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IHZvaWQgMCwgbyA9IHRoaXMuX3RpbGVzW3RdLnRpbGVJRDsgby5vdmVyc2NhbGVkWiA+IDA7KSB7XG4gICAgICAgICAgICBpZiAoby5rZXkgaW4gdGhpcy5fbG9hZGVkUGFyZW50VGlsZXMpIHtcbiAgICAgICAgICAgICAgaSA9IHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzW28ua2V5XTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHVzaChvLmtleSk7XG4gICAgICAgICAgICB2YXIgciA9IG8uc2NhbGVkVG8oby5vdmVyc2NhbGVkWiAtIDEpO1xuICAgICAgICAgICAgaWYgKGkgPSB0aGlzLl9nZXRMb2FkZWRUaWxlKHIpKSBicmVhaztcbiAgICAgICAgICAgIG8gPSByO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gZTsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzW25bYV1dID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9hZGRUaWxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl90aWxlc1tlLmtleV07XG4gICAgICAgIGlmIChpKSByZXR1cm4gaTtcbiAgICAgICAgKGkgPSB0aGlzLl9jYWNoZS5nZXRBbmRSZW1vdmUoZSkpICYmICh0aGlzLl9zZXRUaWxlUmVsb2FkVGltZXIoZS5rZXksIGkpLCBpLnRpbGVJRCA9IGUsIHRoaXMuX3N0YXRlLmluaXRpYWxpemVUaWxlU3RhdGUoaSwgdGhpcy5tYXAgPyB0aGlzLm1hcC5wYWludGVyIDogbnVsbCksIHRoaXMuX2NhY2hlVGltZXJzW2Uua2V5XSAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX2NhY2hlVGltZXJzW2Uua2V5XSksIGRlbGV0ZSB0aGlzLl9jYWNoZVRpbWVyc1tlLmtleV0sIHRoaXMuX3NldFRpbGVSZWxvYWRUaW1lcihlLmtleSwgaSkpKTtcbiAgICAgICAgdmFyIG8gPSBCb29sZWFuKGkpO1xuICAgICAgICByZXR1cm4gbyB8fCAoaSA9IG5ldyB0LlRpbGUoZSwgdGhpcy5fc291cmNlLnRpbGVTaXplICogZS5vdmVyc2NhbGVGYWN0b3IoKSksIHRoaXMuX2xvYWRUaWxlKGksIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCBpLCBlLmtleSwgaS5zdGF0ZSkpKSwgaSA/IChpLnVzZXMrKywgdGhpcy5fdGlsZXNbZS5rZXldID0gaSwgbyB8fCB0aGlzLl9zb3VyY2UuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICB0aWxlOiBpLFxuICAgICAgICAgIGNvb3JkOiBpLnRpbGVJRCxcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIGkpIDogbnVsbDtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9zZXRUaWxlUmVsb2FkVGltZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIHQgaW4gdGhpcy5fdGltZXJzICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZXJzW3RdKSwgZGVsZXRlIHRoaXMuX3RpbWVyc1t0XSk7XG4gICAgICAgIHZhciBvID0gZS5nZXRFeHBpcnlUaW1lb3V0KCk7XG4gICAgICAgIG8gJiYgKHRoaXMuX3RpbWVyc1t0XSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkuX3JlbG9hZFRpbGUodCwgXCJleHBpcmVkXCIpLCBkZWxldGUgaS5fdGltZXJzW3RdO1xuICAgICAgICB9LCBvKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmVtb3ZlVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIGUgJiYgKGUudXNlcy0tLCBkZWxldGUgdGhpcy5fdGlsZXNbdF0sIHRoaXMuX3RpbWVyc1t0XSAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyc1t0XSksIGRlbGV0ZSB0aGlzLl90aW1lcnNbdF0pLCBlLnVzZXMgPiAwIHx8IChlLmhhc0RhdGEoKSAmJiBcInJlbG9hZGluZ1wiICE9PSBlLnN0YXRlID8gdGhpcy5fY2FjaGUuYWRkKGUudGlsZUlELCBlLCBlLmdldEV4cGlyeVRpbWVvdXQoKSkgOiAoZS5hYm9ydGVkID0gITAsIHRoaXMuX2Fib3J0VGlsZShlKSwgdGhpcy5fdW5sb2FkVGlsZShlKSkpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmNsZWFyVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fc2hvdWxkUmVsb2FkT25SZXN1bWUgPSAhMSwgdGhpcy5fcGF1c2VkID0gITEsIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlVGlsZSh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlLnJlc2V0KCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS50aWxlc0luID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IFtdLFxuICAgICAgICAgICAgbiA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW4pIHJldHVybiBhO1xuXG4gICAgICAgIGZvciAodmFyIHMgPSBvID8gbi5nZXRDYW1lcmFRdWVyeUdlb21ldHJ5KGUpIDogZSwgbCA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG4ucG9pbnRDb29yZGluYXRlKHQpO1xuICAgICAgICB9KSwgYyA9IHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG4ucG9pbnRDb29yZGluYXRlKHQpO1xuICAgICAgICB9KSwgdSA9IHRoaXMuZ2V0SWRzKCksIGggPSAxIC8gMCwgcCA9IDEgLyAwLCBkID0gLTEgLyAwLCBfID0gLTEgLyAwLCBmID0gMCwgbSA9IGM7IGYgPCBtLmxlbmd0aDsgZiArPSAxKSB7XG4gICAgICAgICAgdmFyIGcgPSBtW2ZdO1xuICAgICAgICAgIGggPSBNYXRoLm1pbihoLCBnLngpLCBwID0gTWF0aC5taW4ocCwgZy55KSwgZCA9IE1hdGgubWF4KGQsIGcueCksIF8gPSBNYXRoLm1heChfLCBnLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdiA9IGZ1bmN0aW9uIHYoZSkge1xuICAgICAgICAgIHZhciBvID0gci5fdGlsZXNbdVtlXV07XG5cbiAgICAgICAgICBpZiAoIW8uaG9sZGluZ0ZvckZhZGUoKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBvLnRpbGVJRCxcbiAgICAgICAgICAgICAgICBmID0gTWF0aC5wb3coMiwgbi56b29tIC0gby50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgICAgICAgIG0gPSBpICogby5xdWVyeVBhZGRpbmcgKiB0LkVYVEVOVCAvIG8udGlsZVNpemUgLyBmLFxuICAgICAgICAgICAgICAgIGcgPSBbcy5nZXRUaWxlUG9pbnQobmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKGgsIHApKSwgcy5nZXRUaWxlUG9pbnQobmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKGQsIF8pKV07XG5cbiAgICAgICAgICAgIGlmIChnWzBdLnggLSBtIDwgdC5FWFRFTlQgJiYgZ1swXS55IC0gbSA8IHQuRVhURU5UICYmIGdbMV0ueCArIG0gPj0gMCAmJiBnWzFdLnkgKyBtID49IDApIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLmdldFRpbGVQb2ludCh0KTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICB5ID0gYy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5nZXRUaWxlUG9pbnQodCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbGU6IG8sXG4gICAgICAgICAgICAgICAgdGlsZUlEOiBzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5R2VvbWV0cnk6IHYsXG4gICAgICAgICAgICAgICAgY2FtZXJhUXVlcnlHZW9tZXRyeTogeSxcbiAgICAgICAgICAgICAgICBzY2FsZTogZlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHkgPSAwOyB5IDwgdS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgIHYoeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFZpc2libGVDb29yZGluYXRlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSB0aGlzLCBpID0gdGhpcy5nZXRSZW5kZXJhYmxlSWRzKHQpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBlLl90aWxlc1t0XS50aWxlSUQ7XG4gICAgICAgIH0pLCBvID0gMCwgciA9IGk7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dO1xuICAgICAgICAgIGEucG9zTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KGEudG9VbndyYXBwZWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UuaGFzVHJhbnNpdGlvbigpKSByZXR1cm4gITA7XG4gICAgICAgIGlmIChNdCh0aGlzLl9zb3VyY2UudHlwZSkpIGZvciAodmFyIGUgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbGVzW2VdO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGkuZmFkZUVuZFRpbWUgJiYgaS5mYWRlRW5kVGltZSA+PSB0LmJyb3dzZXIubm93KCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS51cGRhdGVTdGF0ZSh0ID0gdCB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsIGUsIGkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUucmVtb3ZlRmVhdHVyZVN0YXRlKHQgPSB0IHx8IFwiX2dlb2pzb25UaWxlTGF5ZXJcIiwgZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0U3RhdGUodCA9IHQgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLCBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIG8gJiYgby5zZXREZXBlbmRlbmNpZXMoZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWxvYWRUaWxlc0ZvckRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB0aGlzLl90aWxlc1tpXS5oYXNEZXBlbmRlbmN5KHQsIGUpICYmIHRoaXMuX3JlbG9hZFRpbGUoaSwgXCJyZWxvYWRpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gIWkuaGFzRGVwZW5kZW5jeSh0LCBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKTtcblxuICAgIGZ1bmN0aW9uIEF0KHQsIGUpIHtcbiAgICAgIHZhciBpID0gTWF0aC5hYnMoMiAqIHQud3JhcCkgLSArKHQud3JhcCA8IDApLFxuICAgICAgICAgIG8gPSBNYXRoLmFicygyICogZS53cmFwKSAtICsoZS53cmFwIDwgMCk7XG4gICAgICByZXR1cm4gdC5vdmVyc2NhbGVkWiAtIGUub3ZlcnNjYWxlZFogfHwgbyAtIGkgfHwgZS5jYW5vbmljYWwueSAtIHQuY2Fub25pY2FsLnkgfHwgZS5jYW5vbmljYWwueCAtIHQuY2Fub25pY2FsLng7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTXQodCkge1xuICAgICAgcmV0dXJuIFwicmFzdGVyXCIgPT09IHQgfHwgXCJpbWFnZVwiID09PSB0IHx8IFwidmlkZW9cIiA9PT0gdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMdCgpIHtcbiAgICAgIHJldHVybiBuZXcgdC53aW5kb3cuV29ya2VyKEtyLndvcmtlclVybCk7XG4gICAgfVxuXG4gICAgRHQubWF4T3Zlcnpvb21pbmcgPSAxMCwgRHQubWF4VW5kZXJ6b29taW5nID0gMztcblxuICAgIHZhciBSdCA9IFwibWFwYm94Z2xfcHJlbG9hZGVkX3dvcmtlcl9wb29sXCIsXG4gICAgICAgIGt0ID0gZnVuY3Rpb24ga3QoKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHt9O1xuICAgIH07XG5cbiAgICBrdC5wcm90b3R5cGUuYWNxdWlyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VycykgZm9yICh0aGlzLndvcmtlcnMgPSBbXTsgdGhpcy53b3JrZXJzLmxlbmd0aCA8IGt0LndvcmtlckNvdW50Oykge1xuICAgICAgICB0aGlzLndvcmtlcnMucHVzaChuZXcgTHQoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVbdF0gPSAhMCwgdGhpcy53b3JrZXJzLnNsaWNlKCk7XG4gICAgfSwga3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlW3RdLCAwID09PSB0aGlzLm51bUFjdGl2ZSgpICYmICh0aGlzLndvcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnRlcm1pbmF0ZSgpO1xuICAgICAgfSksIHRoaXMud29ya2VycyA9IG51bGwpO1xuICAgIH0sIGt0LnByb3RvdHlwZS5pc1ByZWxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuYWN0aXZlW1J0XTtcbiAgICB9LCBrdC5wcm90b3R5cGUubnVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlKS5sZW5ndGg7XG4gICAgfTtcbiAgICB2YXIgQnQsXG4gICAgICAgIE90ID0gTWF0aC5mbG9vcih0LmJyb3dzZXIuaGFyZHdhcmVDb25jdXJyZW5jeSAvIDIpO1xuXG4gICAgZnVuY3Rpb24gRnQoKSB7XG4gICAgICByZXR1cm4gQnQgfHwgKEJ0ID0gbmV3IGt0KCkpLCBCdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVdChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciByIGluIGUpIHtcbiAgICAgICAgXCJyZWZcIiAhPT0gciAmJiAob1tyXSA9IGVbcl0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZWZQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCBpbiBpICYmIChvW3RdID0gaVt0XSk7XG4gICAgICB9KSwgbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOdCh0KSB7XG4gICAgICB0ID0gdC5zbGljZSgpO1xuXG4gICAgICBmb3IgKHZhciBlID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVbdFtpXS5pZF0gPSB0W2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgXCJyZWZcIiBpbiB0W29dICYmICh0W29dID0gVXQodFtvXSwgZVt0W29dLnJlZl0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAga3Qud29ya2VyQ291bnQgPSBNYXRoLm1heChNYXRoLm1pbihPdCwgNiksIDEpO1xuICAgIHZhciBadCA9IHtcbiAgICAgIHNldFN0eWxlOiBcInNldFN0eWxlXCIsXG4gICAgICBhZGRMYXllcjogXCJhZGRMYXllclwiLFxuICAgICAgcmVtb3ZlTGF5ZXI6IFwicmVtb3ZlTGF5ZXJcIixcbiAgICAgIHNldFBhaW50UHJvcGVydHk6IFwic2V0UGFpbnRQcm9wZXJ0eVwiLFxuICAgICAgc2V0TGF5b3V0UHJvcGVydHk6IFwic2V0TGF5b3V0UHJvcGVydHlcIixcbiAgICAgIHNldEZpbHRlcjogXCJzZXRGaWx0ZXJcIixcbiAgICAgIGFkZFNvdXJjZTogXCJhZGRTb3VyY2VcIixcbiAgICAgIHJlbW92ZVNvdXJjZTogXCJyZW1vdmVTb3VyY2VcIixcbiAgICAgIHNldEdlb0pTT05Tb3VyY2VEYXRhOiBcInNldEdlb0pTT05Tb3VyY2VEYXRhXCIsXG4gICAgICBzZXRMYXllclpvb21SYW5nZTogXCJzZXRMYXllclpvb21SYW5nZVwiLFxuICAgICAgc2V0TGF5ZXJQcm9wZXJ0eTogXCJzZXRMYXllclByb3BlcnR5XCIsXG4gICAgICBzZXRDZW50ZXI6IFwic2V0Q2VudGVyXCIsXG4gICAgICBzZXRab29tOiBcInNldFpvb21cIixcbiAgICAgIHNldEJlYXJpbmc6IFwic2V0QmVhcmluZ1wiLFxuICAgICAgc2V0UGl0Y2g6IFwic2V0UGl0Y2hcIixcbiAgICAgIHNldFNwcml0ZTogXCJzZXRTcHJpdGVcIixcbiAgICAgIHNldEdseXBoczogXCJzZXRHbHlwaHNcIixcbiAgICAgIHNldFRyYW5zaXRpb246IFwic2V0VHJhbnNpdGlvblwiLFxuICAgICAgc2V0TGlnaHQ6IFwic2V0TGlnaHRcIlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBxdCh0LCBlLCBpKSB7XG4gICAgICBpLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBadC5hZGRTb3VyY2UsXG4gICAgICAgIGFyZ3M6IFt0LCBlW3RdXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ganQodCwgZSwgaSkge1xuICAgICAgZS5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlU291cmNlLFxuICAgICAgICBhcmdzOiBbdF1cbiAgICAgIH0pLCBpW3RdID0gITA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnQodCwgZSwgaSwgbykge1xuICAgICAganQodCwgaSwgbyksIHF0KHQsIGUsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEd0KGUsIGksIG8pIHtcbiAgICAgIHZhciByO1xuXG4gICAgICBmb3IgKHIgaW4gZVtvXSkge1xuICAgICAgICBpZiAoZVtvXS5oYXNPd25Qcm9wZXJ0eShyKSAmJiBcImRhdGFcIiAhPT0gciAmJiAhdC5kZWVwRXF1YWwoZVtvXVtyXSwgaVtvXVtyXSkpIHJldHVybiAhMTtcbiAgICAgIH1cblxuICAgICAgZm9yIChyIGluIGlbb10pIHtcbiAgICAgICAgaWYgKGlbb10uaGFzT3duUHJvcGVydHkocikgJiYgXCJkYXRhXCIgIT09IHIgJiYgIXQuZGVlcEVxdWFsKGVbb11bcl0sIGlbb11bcl0pKSByZXR1cm4gITE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXdChlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcztcblxuICAgICAgZm9yIChzIGluIGkgPSBpIHx8IHt9LCBlID0gZSB8fCB7fSkge1xuICAgICAgICBlLmhhc093blByb3BlcnR5KHMpICYmICh0LmRlZXBFcXVhbChlW3NdLCBpW3NdKSB8fCBvLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IG4sXG4gICAgICAgICAgYXJnczogW3IsIHMsIGlbc10sIGFdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChzIGluIGkpIHtcbiAgICAgICAgaS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAhZS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAodC5kZWVwRXF1YWwoZVtzXSwgaVtzXSkgfHwgby5wdXNoKHtcbiAgICAgICAgICBjb21tYW5kOiBuLFxuICAgICAgICAgIGFyZ3M6IFtyLCBzLCBpW3NdLCBhXVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWHQodCkge1xuICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSHQodCwgZSkge1xuICAgICAgcmV0dXJuIHRbZS5pZF0gPSBlLCB0O1xuICAgIH1cblxuICAgIHZhciBLdCA9IGZ1bmN0aW9uIEt0KHQsIGUpIHtcbiAgICAgIHRoaXMucmVzZXQodCwgZSk7XG4gICAgfTtcblxuICAgIEt0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHQgfHwgW10sIHRoaXMuX2Rpc3RhbmNlcyA9IFswXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9kaXN0YW5jZXNbaV0gPSB0aGlzLl9kaXN0YW5jZXNbaSAtIDFdICsgdGhpcy5wb2ludHNbaV0uZGlzdCh0aGlzLnBvaW50c1tpIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2Rpc3RhbmNlc1t0aGlzLl9kaXN0YW5jZXMubGVuZ3RoIC0gMV0sIHRoaXMucGFkZGluZyA9IE1hdGgubWluKGUgfHwgMCwgLjUgKiB0aGlzLmxlbmd0aCksIHRoaXMucGFkZGVkTGVuZ3RoID0gdGhpcy5sZW5ndGggLSAyICogdGhpcy5wYWRkaW5nO1xuICAgIH0sIEt0LnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgxID09PSB0aGlzLnBvaW50cy5sZW5ndGgpIHJldHVybiB0aGlzLnBvaW50c1swXTtcbiAgICAgIGUgPSB0LmNsYW1wKGUsIDAsIDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbyA9IHRoaXMuX2Rpc3RhbmNlc1tpXSwgciA9IGUgKiB0aGlzLnBhZGRlZExlbmd0aCArIHRoaXMucGFkZGluZzsgbyA8IHIgJiYgaSA8IHRoaXMuX2Rpc3RhbmNlcy5sZW5ndGg7KSB7XG4gICAgICAgIG8gPSB0aGlzLl9kaXN0YW5jZXNbKytpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGEgPSBpIC0gMSxcbiAgICAgICAgICBuID0gdGhpcy5fZGlzdGFuY2VzW2FdLFxuICAgICAgICAgIHMgPSBvIC0gbixcbiAgICAgICAgICBsID0gcyA+IDAgPyAociAtIG4pIC8gcyA6IDA7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludHNbYV0ubXVsdCgxIC0gbCkuYWRkKHRoaXMucG9pbnRzW2ldLm11bHQobCkpO1xuICAgIH07XG5cbiAgICB2YXIgWXQgPSBmdW5jdGlvbiBZdCh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuYm94Q2VsbHMgPSBbXSxcbiAgICAgICAgICByID0gdGhpcy5jaXJjbGVDZWxscyA9IFtdO1xuICAgICAgdGhpcy54Q2VsbENvdW50ID0gTWF0aC5jZWlsKHQgLyBpKSwgdGhpcy55Q2VsbENvdW50ID0gTWF0aC5jZWlsKGUgLyBpKTtcblxuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLnhDZWxsQ291bnQgKiB0aGlzLnlDZWxsQ291bnQ7IGErKykge1xuICAgICAgICBvLnB1c2goW10pLCByLnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNpcmNsZUtleXMgPSBbXSwgdGhpcy5ib3hLZXlzID0gW10sIHRoaXMuYmJveGVzID0gW10sIHRoaXMuY2lyY2xlcyA9IFtdLCB0aGlzLndpZHRoID0gdCwgdGhpcy5oZWlnaHQgPSBlLCB0aGlzLnhTY2FsZSA9IHRoaXMueENlbGxDb3VudCAvIHQsIHRoaXMueVNjYWxlID0gdGhpcy55Q2VsbENvdW50IC8gZSwgdGhpcy5ib3hVaWQgPSAwLCB0aGlzLmNpcmNsZVVpZCA9IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEp0KGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gdC5jcmVhdGUoKTtcbiAgICAgIHJldHVybiBpID8gKHQuc2NhbGUobiwgbiwgWzEgLyBhLCAxIC8gYSwgMV0pLCBvIHx8IHQucm90YXRlWihuLCBuLCByLmFuZ2xlKSkgOiB0Lm11bHRpcGx5KG4sIHIubGFiZWxQbGFuZU1hdHJpeCwgZSksIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUXQoZSwgaSwgbywgciwgYSkge1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgdmFyIG4gPSB0LmNsb25lKGUpO1xuICAgICAgICByZXR1cm4gdC5zY2FsZShuLCBuLCBbYSwgYSwgMV0pLCBvIHx8IHQucm90YXRlWihuLCBuLCAtci5hbmdsZSksIG47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByLmdsQ29vcmRNYXRyaXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJHQoZSwgaSkge1xuICAgICAgdmFyIG8gPSBbZS54LCBlLnksIDAsIDFdO1xuICAgICAgdWUobywgbywgaSk7XG4gICAgICB2YXIgciA9IG9bM107XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogbmV3IHQuUG9pbnQob1swXSAvIHIsIG9bMV0gLyByKSxcbiAgICAgICAgc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhOiByXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlKHQsIGUpIHtcbiAgICAgIHJldHVybiAuNSArIHQgLyBlICogLjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWUodCwgZSkge1xuICAgICAgdmFyIGkgPSB0WzBdIC8gdFszXSxcbiAgICAgICAgICBvID0gdFsxXSAvIHRbM107XG4gICAgICByZXR1cm4gaSA+PSAtZVswXSAmJiBpIDw9IGVbMF0gJiYgbyA+PSAtZVsxXSAmJiBvIDw9IGVbMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWUoZSwgaSwgbywgciwgYSwgbiwgcywgbCkge1xuICAgICAgdmFyIGMgPSByID8gZS50ZXh0U2l6ZURhdGEgOiBlLmljb25TaXplRGF0YSxcbiAgICAgICAgICB1ID0gdC5ldmFsdWF0ZVNpemVGb3Jab29tKGMsIG8udHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAgIGggPSBbMjU2IC8gby53aWR0aCAqIDIgKyAxLCAyNTYgLyBvLmhlaWdodCAqIDIgKyAxXSxcbiAgICAgICAgICBwID0gciA/IGUudGV4dC5keW5hbWljTGF5b3V0VmVydGV4QXJyYXkgOiBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEFycmF5O1xuICAgICAgcC5jbGVhcigpO1xuXG4gICAgICBmb3IgKHZhciBkID0gZS5saW5lVmVydGV4QXJyYXksIF8gPSByID8gZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5IDogZS5pY29uLnBsYWNlZFN5bWJvbEFycmF5LCBmID0gby50cmFuc2Zvcm0ud2lkdGggLyBvLnRyYW5zZm9ybS5oZWlnaHQsIG0gPSAhMSwgZyA9IDA7IGcgPCBfLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIHZhciB2ID0gXy5nZXQoZyk7XG5cbiAgICAgICAgaWYgKHYuaGlkZGVuIHx8IHYud3JpdGluZ01vZGUgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgJiYgIW0pIGNlKHYubnVtR2x5cGhzLCBwKTtlbHNlIHtcbiAgICAgICAgICBtID0gITE7XG4gICAgICAgICAgdmFyIHkgPSBbdi5hbmNob3JYLCB2LmFuY2hvclksIDAsIDFdO1xuXG4gICAgICAgICAgaWYgKHQudHJhbnNmb3JtTWF0NCh5LCB5LCBpKSwgZWUoeSwgaCkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGUoby50cmFuc2Zvcm0uY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSwgeVszXSksXG4gICAgICAgICAgICAgICAgYiA9IHQuZXZhbHVhdGVTaXplRm9yRmVhdHVyZShjLCB1LCB2KSxcbiAgICAgICAgICAgICAgICB3ID0gcyA/IGIgLyB4IDogYiAqIHgsXG4gICAgICAgICAgICAgICAgVCA9IG5ldyB0LlBvaW50KHYuYW5jaG9yWCwgdi5hbmNob3JZKSxcbiAgICAgICAgICAgICAgICBFID0gJHQoVCwgYSkucG9pbnQsXG4gICAgICAgICAgICAgICAgSSA9IHt9LFxuICAgICAgICAgICAgICAgIFAgPSBhZSh2LCB3LCAhMSwgbCwgaSwgYSwgbiwgZS5nbHlwaE9mZnNldEFycmF5LCBkLCBwLCBFLCBULCBJLCBmKTtcbiAgICAgICAgICAgIG0gPSBQLnVzZVZlcnRpY2FsLCAoUC5ub3RFbm91Z2hSb29tIHx8IG0gfHwgUC5uZWVkc0ZsaXBwaW5nICYmIGFlKHYsIHcsICEwLCBsLCBpLCBhLCBuLCBlLmdseXBoT2Zmc2V0QXJyYXksIGQsIHAsIEUsIFQsIEksIGYpLm5vdEVub3VnaFJvb20pICYmIGNlKHYubnVtR2x5cGhzLCBwKTtcbiAgICAgICAgICB9IGVsc2UgY2Uodi5udW1HbHlwaHMsIHApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIgPyBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHApIDogZS5pY29uLmR5bmFtaWNMYXlvdXRWZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZSh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1KSB7XG4gICAgICB2YXIgaCA9IHMuZ2x5cGhTdGFydEluZGV4ICsgcy5udW1HbHlwaHMsXG4gICAgICAgICAgcCA9IHMubGluZVN0YXJ0SW5kZXgsXG4gICAgICAgICAgZCA9IHMubGluZVN0YXJ0SW5kZXggKyBzLmxpbmVMZW5ndGgsXG4gICAgICAgICAgXyA9IGUuZ2V0b2Zmc2V0WChzLmdseXBoU3RhcnRJbmRleCksXG4gICAgICAgICAgZiA9IGUuZ2V0b2Zmc2V0WChoIC0gMSksXG4gICAgICAgICAgbSA9IHNlKHQgKiBfLCBpLCBvLCByLCBhLCBuLCBzLnNlZ21lbnQsIHAsIGQsIGwsIGMsIHUpO1xuXG4gICAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGcgPSBzZSh0ICogZiwgaSwgbywgciwgYSwgbiwgcy5zZWdtZW50LCBwLCBkLCBsLCBjLCB1KTtcbiAgICAgIHJldHVybiBnID8ge1xuICAgICAgICBmaXJzdDogbSxcbiAgICAgICAgbGFzdDogZ1xuICAgICAgfSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmUoZSwgaSwgbywgcikge1xuICAgICAgcmV0dXJuIGUgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCAmJiBNYXRoLmFicyhvLnkgLSBpLnkpID4gTWF0aC5hYnMoby54IC0gaS54KSAqIHIgPyB7XG4gICAgICAgIHVzZVZlcnRpY2FsOiAhMFxuICAgICAgfSA6IChlID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gaS55IDwgby55IDogaS54ID4gby54KSA/IHtcbiAgICAgICAgbmVlZHNGbGlwcGluZzogITBcbiAgICAgIH0gOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFlKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHAsIGQsIF8pIHtcbiAgICAgIHZhciBmLFxuICAgICAgICAgIG0gPSBpIC8gMjQsXG4gICAgICAgICAgZyA9IGUubGluZU9mZnNldFggKiBtLFxuICAgICAgICAgIHYgPSBlLmxpbmVPZmZzZXRZICogbTtcblxuICAgICAgaWYgKGUubnVtR2x5cGhzID4gMSkge1xuICAgICAgICB2YXIgeSA9IGUuZ2x5cGhTdGFydEluZGV4ICsgZS5udW1HbHlwaHMsXG4gICAgICAgICAgICB4ID0gZS5saW5lU3RhcnRJbmRleCxcbiAgICAgICAgICAgIGIgPSBlLmxpbmVTdGFydEluZGV4ICsgZS5saW5lTGVuZ3RoLFxuICAgICAgICAgICAgdyA9IG9lKG0sIGwsIGcsIHYsIG8sIGgsIHAsIGUsIGMsIG4sIGQpO1xuICAgICAgICBpZiAoIXcpIHJldHVybiB7XG4gICAgICAgICAgbm90RW5vdWdoUm9vbTogITBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFQgPSAkdCh3LmZpcnN0LnBvaW50LCBzKS5wb2ludCxcbiAgICAgICAgICAgIEUgPSAkdCh3Lmxhc3QucG9pbnQsIHMpLnBvaW50O1xuXG4gICAgICAgIGlmIChyICYmICFvKSB7XG4gICAgICAgICAgdmFyIEkgPSByZShlLndyaXRpbmdNb2RlLCBULCBFLCBfKTtcbiAgICAgICAgICBpZiAoSSkgcmV0dXJuIEk7XG4gICAgICAgIH1cblxuICAgICAgICBmID0gW3cuZmlyc3RdO1xuXG4gICAgICAgIGZvciAodmFyIFAgPSBlLmdseXBoU3RhcnRJbmRleCArIDE7IFAgPCB5IC0gMTsgUCsrKSB7XG4gICAgICAgICAgZi5wdXNoKHNlKG0gKiBsLmdldG9mZnNldFgoUCksIGcsIHYsIG8sIGgsIHAsIGUuc2VnbWVudCwgeCwgYiwgYywgbiwgZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZi5wdXNoKHcubGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAociAmJiAhbykge1xuICAgICAgICAgIHZhciBTID0gJHQocCwgYSkucG9pbnQsXG4gICAgICAgICAgICAgIEMgPSBlLmxpbmVTdGFydEluZGV4ICsgZS5zZWdtZW50ICsgMSxcbiAgICAgICAgICAgICAgeiA9IG5ldyB0LlBvaW50KGMuZ2V0eChDKSwgYy5nZXR5KEMpKSxcbiAgICAgICAgICAgICAgRCA9ICR0KHosIGEpLFxuICAgICAgICAgICAgICBBID0gRC5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEgPiAwID8gRC5wb2ludCA6IG5lKHAsIHosIFMsIDEsIGEpLFxuICAgICAgICAgICAgICBNID0gcmUoZS53cml0aW5nTW9kZSwgUywgQSwgXyk7XG4gICAgICAgICAgaWYgKE0pIHJldHVybiBNO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEwgPSBzZShtICogbC5nZXRvZmZzZXRYKGUuZ2x5cGhTdGFydEluZGV4KSwgZywgdiwgbywgaCwgcCwgZS5zZWdtZW50LCBlLmxpbmVTdGFydEluZGV4LCBlLmxpbmVTdGFydEluZGV4ICsgZS5saW5lTGVuZ3RoLCBjLCBuLCBkKTtcbiAgICAgICAgaWYgKCFMKSByZXR1cm4ge1xuICAgICAgICAgIG5vdEVub3VnaFJvb206ICEwXG4gICAgICAgIH07XG4gICAgICAgIGYgPSBbTF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIFIgPSAwLCBrID0gZjsgUiA8IGsubGVuZ3RoOyBSICs9IDEpIHtcbiAgICAgICAgdmFyIEIgPSBrW1JdO1xuICAgICAgICB0LmFkZER5bmFtaWNBdHRyaWJ1dGVzKHUsIEIucG9pbnQsIEIuYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmUodCwgZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSAkdCh0LmFkZCh0LnN1YihlKS5fdW5pdCgpKSwgcikucG9pbnQsXG4gICAgICAgICAgbiA9IGkuc3ViKGEpO1xuICAgICAgcmV0dXJuIGkuYWRkKG4uX211bHQobyAvIG4ubWFnKCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZShlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwKSB7XG4gICAgICB2YXIgZCA9IHIgPyBlIC0gaSA6IGUgKyBpLFxuICAgICAgICAgIF8gPSBkID4gMCA/IDEgOiAtMSxcbiAgICAgICAgICBmID0gMDtcblxuICAgICAgciAmJiAoXyAqPSAtMSwgZiA9IE1hdGguUEkpLCBfIDwgMCAmJiAoZiArPSBNYXRoLlBJKTtcblxuICAgICAgZm9yICh2YXIgbSA9IF8gPiAwID8gbCArIHMgOiBsICsgcyArIDEsIGcgPSBhLCB2ID0gYSwgeSA9IDAsIHggPSAwLCBiID0gTWF0aC5hYnMoZCksIHcgPSBbXTsgeSArIHggPD0gYjspIHtcbiAgICAgICAgaWYgKChtICs9IF8pIDwgbCB8fCBtID49IGMpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmICh2ID0gZywgdy5wdXNoKGcpLCB2b2lkIDAgPT09IChnID0gcFttXSkpIHtcbiAgICAgICAgICB2YXIgVCA9IG5ldyB0LlBvaW50KHUuZ2V0eChtKSwgdS5nZXR5KG0pKSxcbiAgICAgICAgICAgICAgRSA9ICR0KFQsIGgpO1xuICAgICAgICAgIGlmIChFLnNpZ25lZERpc3RhbmNlRnJvbUNhbWVyYSA+IDApIGcgPSBwW21dID0gRS5wb2ludDtlbHNlIHtcbiAgICAgICAgICAgIHZhciBJID0gbSAtIF87XG4gICAgICAgICAgICBnID0gbmUoMCA9PT0geSA/IG4gOiBuZXcgdC5Qb2ludCh1LmdldHgoSSksIHUuZ2V0eShJKSksIFQsIHYsIGIgLSB5ICsgMSwgaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeSArPSB4LCB4ID0gdi5kaXN0KGcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IChiIC0geSkgLyB4LFxuICAgICAgICAgIFMgPSBnLnN1Yih2KSxcbiAgICAgICAgICBDID0gUy5tdWx0KFApLl9hZGQodik7XG5cbiAgICAgIEMuX2FkZChTLl91bml0KCkuX3BlcnAoKS5fbXVsdChvICogXykpO1xuXG4gICAgICB2YXIgeiA9IGYgKyBNYXRoLmF0YW4yKGcueSAtIHYueSwgZy54IC0gdi54KTtcbiAgICAgIHJldHVybiB3LnB1c2goQyksIHtcbiAgICAgICAgcG9pbnQ6IEMsXG4gICAgICAgIGFuZ2xlOiB6LFxuICAgICAgICBwYXRoOiB3XG4gICAgICB9O1xuICAgIH1cblxuICAgIFl0LnByb3RvdHlwZS5rZXlzTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm94S2V5cy5sZW5ndGggKyB0aGlzLmNpcmNsZUtleXMubGVuZ3RoO1xuICAgIH0sIFl0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgdGhpcy5fZm9yRWFjaENlbGwoZSwgaSwgbywgciwgdGhpcy5faW5zZXJ0Qm94Q2VsbCwgdGhpcy5ib3hVaWQrKyksIHRoaXMuYm94S2V5cy5wdXNoKHQpLCB0aGlzLmJib3hlcy5wdXNoKGUpLCB0aGlzLmJib3hlcy5wdXNoKGkpLCB0aGlzLmJib3hlcy5wdXNoKG8pLCB0aGlzLmJib3hlcy5wdXNoKHIpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5pbnNlcnRDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5fZm9yRWFjaENlbGwoZSAtIG8sIGkgLSBvLCBlICsgbywgaSArIG8sIHRoaXMuX2luc2VydENpcmNsZUNlbGwsIHRoaXMuY2lyY2xlVWlkKyspLCB0aGlzLmNpcmNsZUtleXMucHVzaCh0KSwgdGhpcy5jaXJjbGVzLnB1c2goZSksIHRoaXMuY2lyY2xlcy5wdXNoKGkpLCB0aGlzLmNpcmNsZXMucHVzaChvKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX2luc2VydEJveENlbGwgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdGhpcy5ib3hDZWxsc1tyXS5wdXNoKGEpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5faW5zZXJ0Q2lyY2xlQ2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB0aGlzLmNpcmNsZUNlbGxzW3JdLnB1c2goYSk7XG4gICAgfSwgWXQucHJvdG90eXBlLl9xdWVyeSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICBpZiAoaSA8IDAgfHwgdCA+IHRoaXMud2lkdGggfHwgbyA8IDAgfHwgZSA+IHRoaXMuaGVpZ2h0KSByZXR1cm4gIXIgJiYgW107XG4gICAgICB2YXIgbiA9IFtdO1xuXG4gICAgICBpZiAodCA8PSAwICYmIGUgPD0gMCAmJiB0aGlzLndpZHRoIDw9IGkgJiYgdGhpcy5oZWlnaHQgPD0gbykge1xuICAgICAgICBpZiAocikgcmV0dXJuICEwO1xuXG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5ib3hLZXlzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgbi5wdXNoKHtcbiAgICAgICAgICAgIGtleTogdGhpcy5ib3hLZXlzW3NdLFxuICAgICAgICAgICAgeDE6IHRoaXMuYmJveGVzWzQgKiBzXSxcbiAgICAgICAgICAgIHkxOiB0aGlzLmJib3hlc1s0ICogcyArIDFdLFxuICAgICAgICAgICAgeDI6IHRoaXMuYmJveGVzWzQgKiBzICsgMl0sXG4gICAgICAgICAgICB5MjogdGhpcy5iYm94ZXNbNCAqIHMgKyAzXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmNpcmNsZUtleXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuY2lyY2xlc1szICogbF0sXG4gICAgICAgICAgICAgIHUgPSB0aGlzLmNpcmNsZXNbMyAqIGwgKyAxXSxcbiAgICAgICAgICAgICAgaCA9IHRoaXMuY2lyY2xlc1szICogbCArIDJdO1xuICAgICAgICAgIG4ucHVzaCh7XG4gICAgICAgICAgICBrZXk6IHRoaXMuY2lyY2xlS2V5c1tsXSxcbiAgICAgICAgICAgIHgxOiBjIC0gaCxcbiAgICAgICAgICAgIHkxOiB1IC0gaCxcbiAgICAgICAgICAgIHgyOiBjICsgaCxcbiAgICAgICAgICAgIHkyOiB1ICsgaFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPyBuLmZpbHRlcihhKSA6IG47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9mb3JFYWNoQ2VsbCh0LCBlLCBpLCBvLCB0aGlzLl9xdWVyeUNlbGwsIG4sIHtcbiAgICAgICAgaGl0VGVzdDogcixcbiAgICAgICAgc2VlblVpZHM6IHtcbiAgICAgICAgICBib3g6IHt9LFxuICAgICAgICAgIGNpcmNsZToge31cbiAgICAgICAgfVxuICAgICAgfSwgYSksIHIgPyBuLmxlbmd0aCA+IDAgOiBuO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fcXVlcnlDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSB0IC0gaSxcbiAgICAgICAgICBuID0gdCArIGksXG4gICAgICAgICAgcyA9IGUgLSBpLFxuICAgICAgICAgIGwgPSBlICsgaTtcbiAgICAgIGlmIChuIDwgMCB8fCBhID4gdGhpcy53aWR0aCB8fCBsIDwgMCB8fCBzID4gdGhpcy5oZWlnaHQpIHJldHVybiAhbyAmJiBbXTtcbiAgICAgIHZhciBjID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fZm9yRWFjaENlbGwoYSwgcywgbiwgbCwgdGhpcy5fcXVlcnlDZWxsQ2lyY2xlLCBjLCB7XG4gICAgICAgIGhpdFRlc3Q6IG8sXG4gICAgICAgIGNpcmNsZToge1xuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICByYWRpdXM6IGlcbiAgICAgICAgfSxcbiAgICAgICAgc2VlblVpZHM6IHtcbiAgICAgICAgICBib3g6IHt9LFxuICAgICAgICAgIGNpcmNsZToge31cbiAgICAgICAgfVxuICAgICAgfSwgciksIG8gPyBjLmxlbmd0aCA+IDAgOiBjO1xuICAgIH0sIFl0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVlcnkodCwgZSwgaSwgbywgITEsIHIpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyeSh0LCBlLCBpLCBvLCAhMCwgcik7XG4gICAgfSwgWXQucHJvdG90eXBlLmhpdFRlc3RDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q2lyY2xlKHQsIGUsIGksICEwLCBvKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5Q2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzKSB7XG4gICAgICB2YXIgbCA9IG4uc2VlblVpZHMsXG4gICAgICAgICAgYyA9IHRoaXMuYm94Q2VsbHNbcl07XG4gICAgICBpZiAobnVsbCAhPT0gYykgZm9yICh2YXIgdSA9IHRoaXMuYmJveGVzLCBoID0gMCwgcCA9IGM7IGggPCBwLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgIHZhciBkID0gcFtoXTtcblxuICAgICAgICBpZiAoIWwuYm94W2RdKSB7XG4gICAgICAgICAgbC5ib3hbZF0gPSAhMDtcblxuICAgICAgICAgIHZhciBfID0gNCAqIGQ7XG5cbiAgICAgICAgICBpZiAodCA8PSB1W18gKyAyXSAmJiBlIDw9IHVbXyArIDNdICYmIGkgPj0gdVtfICsgMF0gJiYgbyA+PSB1W18gKyAxXSAmJiAoIXMgfHwgcyh0aGlzLmJveEtleXNbZF0pKSkge1xuICAgICAgICAgICAgaWYgKG4uaGl0VGVzdCkgcmV0dXJuIGEucHVzaCghMCksICEwO1xuICAgICAgICAgICAgYS5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiB0aGlzLmJveEtleXNbZF0sXG4gICAgICAgICAgICAgIHgxOiB1W19dLFxuICAgICAgICAgICAgICB5MTogdVtfICsgMV0sXG4gICAgICAgICAgICAgIHgyOiB1W18gKyAyXSxcbiAgICAgICAgICAgICAgeTI6IHVbXyArIDNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmID0gdGhpcy5jaXJjbGVDZWxsc1tyXTtcbiAgICAgIGlmIChudWxsICE9PSBmKSBmb3IgKHZhciBtID0gdGhpcy5jaXJjbGVzLCBnID0gMCwgdiA9IGY7IGcgPCB2Lmxlbmd0aDsgZyArPSAxKSB7XG4gICAgICAgIHZhciB5ID0gdltnXTtcblxuICAgICAgICBpZiAoIWwuY2lyY2xlW3ldKSB7XG4gICAgICAgICAgbC5jaXJjbGVbeV0gPSAhMDtcbiAgICAgICAgICB2YXIgeCA9IDMgKiB5O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZUFuZFJlY3RDb2xsaWRlKG1beF0sIG1beCArIDFdLCBtW3ggKyAyXSwgdCwgZSwgaSwgbykgJiYgKCFzIHx8IHModGhpcy5jaXJjbGVLZXlzW3ldKSkpIHtcbiAgICAgICAgICAgIGlmIChuLmhpdFRlc3QpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgICAgIHZhciBiID0gbVt4XSxcbiAgICAgICAgICAgICAgICB3ID0gbVt4ICsgMV0sXG4gICAgICAgICAgICAgICAgVCA9IG1beCArIDJdO1xuICAgICAgICAgICAgYS5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiB0aGlzLmNpcmNsZUtleXNbeV0sXG4gICAgICAgICAgICAgIHgxOiBiIC0gVCxcbiAgICAgICAgICAgICAgeTE6IHcgLSBULFxuICAgICAgICAgICAgICB4MjogYiArIFQsXG4gICAgICAgICAgICAgIHkyOiB3ICsgVFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgWXQucHJvdG90eXBlLl9xdWVyeUNlbGxDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgdmFyIGwgPSBuLmNpcmNsZSxcbiAgICAgICAgICBjID0gbi5zZWVuVWlkcyxcbiAgICAgICAgICB1ID0gdGhpcy5ib3hDZWxsc1tyXTtcbiAgICAgIGlmIChudWxsICE9PSB1KSBmb3IgKHZhciBoID0gdGhpcy5iYm94ZXMsIHAgPSAwLCBkID0gdTsgcCA8IGQubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgdmFyIF8gPSBkW3BdO1xuXG4gICAgICAgIGlmICghYy5ib3hbX10pIHtcbiAgICAgICAgICBjLmJveFtfXSA9ICEwO1xuICAgICAgICAgIHZhciBmID0gNCAqIF87XG4gICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZUFuZFJlY3RDb2xsaWRlKGwueCwgbC55LCBsLnJhZGl1cywgaFtmICsgMF0sIGhbZiArIDFdLCBoW2YgKyAyXSwgaFtmICsgM10pICYmICghcyB8fCBzKHRoaXMuYm94S2V5c1tfXSkpKSByZXR1cm4gYS5wdXNoKCEwKSwgITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtID0gdGhpcy5jaXJjbGVDZWxsc1tyXTtcbiAgICAgIGlmIChudWxsICE9PSBtKSBmb3IgKHZhciBnID0gdGhpcy5jaXJjbGVzLCB2ID0gMCwgeSA9IG07IHYgPCB5Lmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgIHZhciB4ID0geVt2XTtcblxuICAgICAgICBpZiAoIWMuY2lyY2xlW3hdKSB7XG4gICAgICAgICAgYy5jaXJjbGVbeF0gPSAhMDtcbiAgICAgICAgICB2YXIgYiA9IDMgKiB4O1xuICAgICAgICAgIGlmICh0aGlzLl9jaXJjbGVzQ29sbGlkZShnW2JdLCBnW2IgKyAxXSwgZ1tiICsgMl0sIGwueCwgbC55LCBsLnJhZGl1cykgJiYgKCFzIHx8IHModGhpcy5jaXJjbGVLZXlzW3hdKSkpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFl0LnByb3RvdHlwZS5fZm9yRWFjaENlbGwgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgZm9yICh2YXIgbCA9IHRoaXMuX2NvbnZlcnRUb1hDZWxsQ29vcmQodCksIGMgPSB0aGlzLl9jb252ZXJ0VG9ZQ2VsbENvb3JkKGUpLCB1ID0gdGhpcy5fY29udmVydFRvWENlbGxDb29yZChpKSwgaCA9IHRoaXMuX2NvbnZlcnRUb1lDZWxsQ29vcmQobyksIHAgPSBsOyBwIDw9IHU7IHArKykge1xuICAgICAgICBmb3IgKHZhciBkID0gYzsgZCA8PSBoOyBkKyspIHtcbiAgICAgICAgICBpZiAoci5jYWxsKHRoaXMsIHQsIGUsIGksIG8sIHRoaXMueENlbGxDb3VudCAqIGQgKyBwLCBhLCBuLCBzKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgWXQucHJvdG90eXBlLl9jb252ZXJ0VG9YQ2VsbENvb3JkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnhDZWxsQ291bnQgLSAxLCBNYXRoLmZsb29yKHQgKiB0aGlzLnhTY2FsZSkpKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX2NvbnZlcnRUb1lDZWxsQ29vcmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMueUNlbGxDb3VudCAtIDEsIE1hdGguZmxvb3IodCAqIHRoaXMueVNjYWxlKSkpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fY2lyY2xlc0NvbGxpZGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdmFyIG4gPSBvIC0gdCxcbiAgICAgICAgICBzID0gciAtIGUsXG4gICAgICAgICAgbCA9IGkgKyBhO1xuICAgICAgcmV0dXJuIGwgKiBsID4gbiAqIG4gKyBzICogcztcbiAgICB9LCBZdC5wcm90b3R5cGUuX2NpcmNsZUFuZFJlY3RDb2xsaWRlID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gKGEgLSBvKSAvIDIsXG4gICAgICAgICAgbCA9IE1hdGguYWJzKHQgLSAobyArIHMpKTtcbiAgICAgIGlmIChsID4gcyArIGkpIHJldHVybiAhMTtcbiAgICAgIHZhciBjID0gKG4gLSByKSAvIDIsXG4gICAgICAgICAgdSA9IE1hdGguYWJzKGUgLSAociArIGMpKTtcbiAgICAgIGlmICh1ID4gYyArIGkpIHJldHVybiAhMTtcbiAgICAgIGlmIChsIDw9IHMgfHwgdSA8PSBjKSByZXR1cm4gITA7XG4gICAgICB2YXIgaCA9IGwgLSBzLFxuICAgICAgICAgIHAgPSB1IC0gYztcbiAgICAgIHJldHVybiBoICogaCArIHAgKiBwIDw9IGkgKiBpO1xuICAgIH07XG4gICAgdmFyIGxlID0gbmV3IEZsb2F0MzJBcnJheShbLTEgLyAwLCAtMSAvIDAsIDAsIC0xIC8gMCwgLTEgLyAwLCAwLCAtMSAvIDAsIC0xIC8gMCwgMCwgLTEgLyAwLCAtMSAvIDAsIDBdKTtcblxuICAgIGZ1bmN0aW9uIGNlKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgICAgIHZhciBvID0gZS5sZW5ndGg7XG4gICAgICAgIGUucmVzaXplKG8gKyA0KSwgZS5mbG9hdDMyLnNldChsZSwgMyAqIG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVlKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gZVswXSxcbiAgICAgICAgICByID0gZVsxXTtcbiAgICAgIHJldHVybiB0WzBdID0gaVswXSAqIG8gKyBpWzRdICogciArIGlbMTJdLCB0WzFdID0gaVsxXSAqIG8gKyBpWzVdICogciArIGlbMTNdLCB0WzNdID0gaVszXSAqIG8gKyBpWzddICogciArIGlbMTVdLCB0O1xuICAgIH1cblxuICAgIHZhciBoZSA9IGZ1bmN0aW9uIGhlKHQsIGUsIGkpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IG5ldyBZdCh0LndpZHRoICsgMjAwLCB0LmhlaWdodCArIDIwMCwgMjUpKSwgdm9pZCAwID09PSBpICYmIChpID0gbmV3IFl0KHQud2lkdGggKyAyMDAsIHQuaGVpZ2h0ICsgMjAwLCAyNSkpLCB0aGlzLnRyYW5zZm9ybSA9IHQsIHRoaXMuZ3JpZCA9IGUsIHRoaXMuaWdub3JlZEdyaWQgPSBpLCB0aGlzLnBpdGNoZmFjdG9yID0gTWF0aC5jb3ModC5fcGl0Y2gpICogdC5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLCB0aGlzLnNjcmVlblJpZ2h0Qm91bmRhcnkgPSB0LndpZHRoICsgMTAwLCB0aGlzLnNjcmVlbkJvdHRvbUJvdW5kYXJ5ID0gdC5oZWlnaHQgKyAxMDAsIHRoaXMuZ3JpZFJpZ2h0Qm91bmRhcnkgPSB0LndpZHRoICsgMjAwLCB0aGlzLmdyaWRCb3R0b21Cb3VuZGFyeSA9IHQuaGVpZ2h0ICsgMjAwO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwZShlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gaSAqICh0LkVYVEVOVCAvIChlLnRpbGVTaXplICogTWF0aC5wb3coMiwgbyAtIGUudGlsZUlELm92ZXJzY2FsZWRaKSkpO1xuICAgIH1cblxuICAgIGhlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkJveCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9IHRoaXMucHJvamVjdEFuZEdldFBlcnNwZWN0aXZlUmF0aW8obywgdC5hbmNob3JQb2ludFgsIHQuYW5jaG9yUG9pbnRZKSxcbiAgICAgICAgICBuID0gaSAqIGEucGVyc3BlY3RpdmVSYXRpbyxcbiAgICAgICAgICBzID0gdC54MSAqIG4gKyBhLnBvaW50LngsXG4gICAgICAgICAgbCA9IHQueTEgKiBuICsgYS5wb2ludC55LFxuICAgICAgICAgIGMgPSB0LngyICogbiArIGEucG9pbnQueCxcbiAgICAgICAgICB1ID0gdC55MiAqIG4gKyBhLnBvaW50Lnk7XG4gICAgICByZXR1cm4gIXRoaXMuaXNJbnNpZGVHcmlkKHMsIGwsIGMsIHUpIHx8ICFlICYmIHRoaXMuZ3JpZC5oaXRUZXN0KHMsIGwsIGMsIHUsIHIpID8ge1xuICAgICAgICBib3g6IFtdLFxuICAgICAgICBvZmZzY3JlZW46ICExXG4gICAgICB9IDoge1xuICAgICAgICBib3g6IFtzLCBsLCBjLCB1XSxcbiAgICAgICAgb2Zmc2NyZWVuOiB0aGlzLmlzT2Zmc2NyZWVuKHMsIGwsIGMsIHUpXG4gICAgICB9O1xuICAgIH0sIGhlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkNpcmNsZXMgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCwgZCkge1xuICAgICAgdmFyIF8gPSBbXSxcbiAgICAgICAgICBmID0gbmV3IHQuUG9pbnQoaS5hbmNob3JYLCBpLmFuY2hvclkpLFxuICAgICAgICAgIG0gPSAkdChmLCBuKSxcbiAgICAgICAgICBnID0gdGUodGhpcy50cmFuc2Zvcm0uY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSwgbS5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEpLFxuICAgICAgICAgIHYgPSAodSA/IGEgLyBnIDogYSAqIGcpIC8gdC5PTkVfRU0sXG4gICAgICAgICAgeSA9ICR0KGYsIHMpLnBvaW50LFxuICAgICAgICAgIHggPSBvZSh2LCByLCBpLmxpbmVPZmZzZXRYICogdiwgaS5saW5lT2Zmc2V0WSAqIHYsICExLCB5LCBmLCBpLCBvLCBzLCB7fSksXG4gICAgICAgICAgYiA9ICExLFxuICAgICAgICAgIHcgPSAhMSxcbiAgICAgICAgICBUID0gITA7XG5cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIGZvciAodmFyIEUgPSAuNSAqIHAgKiBnICsgZCwgSSA9IG5ldyB0LlBvaW50KC0xMDAsIC0xMDApLCBQID0gbmV3IHQuUG9pbnQodGhpcy5zY3JlZW5SaWdodEJvdW5kYXJ5LCB0aGlzLnNjcmVlbkJvdHRvbUJvdW5kYXJ5KSwgUyA9IG5ldyBLdCgpLCBDID0geC5maXJzdCwgeiA9IHgubGFzdCwgRCA9IFtdLCBBID0gQy5wYXRoLmxlbmd0aCAtIDE7IEEgPj0gMTsgQS0tKSB7XG4gICAgICAgICAgRC5wdXNoKEMucGF0aFtBXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBNID0gMTsgTSA8IHoucGF0aC5sZW5ndGg7IE0rKykge1xuICAgICAgICAgIEQucHVzaCh6LnBhdGhbTV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEwgPSAyLjUgKiBFO1xuXG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgdmFyIFIgPSBELm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuICR0KHQsIGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIEQgPSBSLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnNpZ25lZERpc3RhbmNlRnJvbUNhbWVyYSA8PSAwO1xuICAgICAgICAgIH0pID8gW10gOiBSLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQucG9pbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgayA9IFtdO1xuXG4gICAgICAgIGlmIChELmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBCID0gRFswXS5jbG9uZSgpLCBPID0gRFswXS5jbG9uZSgpLCBGID0gMTsgRiA8IEQubGVuZ3RoOyBGKyspIHtcbiAgICAgICAgICAgIEIueCA9IE1hdGgubWluKEIueCwgRFtGXS54KSwgQi55ID0gTWF0aC5taW4oQi55LCBEW0ZdLnkpLCBPLnggPSBNYXRoLm1heChPLngsIERbRl0ueCksIE8ueSA9IE1hdGgubWF4KE8ueSwgRFtGXS55KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrID0gQi54ID49IEkueCAmJiBPLnggPD0gUC54ICYmIEIueSA+PSBJLnkgJiYgTy55IDw9IFAueSA/IFtEXSA6IE8ueCA8IEkueCB8fCBCLnggPiBQLnggfHwgTy55IDwgSS55IHx8IEIueSA+IFAueSA/IFtdIDogdC5jbGlwTGluZShbRF0sIEkueCwgSS55LCBQLngsIFAueSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBVID0gMCwgTiA9IGs7IFUgPCBOLmxlbmd0aDsgVSArPSAxKSB7XG4gICAgICAgICAgdmFyIFo7XG4gICAgICAgICAgUy5yZXNldChOW1VdLCAuMjUgKiBFKSwgWiA9IFMubGVuZ3RoIDw9IC41ICogRSA/IDEgOiBNYXRoLmNlaWwoUy5wYWRkZWRMZW5ndGggLyBMKSArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IFo7IHErKykge1xuICAgICAgICAgICAgdmFyIGogPSBxIC8gTWF0aC5tYXgoWiAtIDEsIDEpLFxuICAgICAgICAgICAgICAgIFYgPSBTLmxlcnAoaiksXG4gICAgICAgICAgICAgICAgRyA9IFYueCArIDEwMCxcbiAgICAgICAgICAgICAgICBXID0gVi55ICsgMTAwO1xuXG4gICAgICAgICAgICBfLnB1c2goRywgVywgRSwgMCk7XG5cbiAgICAgICAgICAgIHZhciBYID0gRyAtIEUsXG4gICAgICAgICAgICAgICAgSCA9IFcgLSBFLFxuICAgICAgICAgICAgICAgIEsgPSBHICsgRSxcbiAgICAgICAgICAgICAgICBZID0gVyArIEU7XG4gICAgICAgICAgICBpZiAoVCA9IFQgJiYgdGhpcy5pc09mZnNjcmVlbihYLCBILCBLLCBZKSwgdyA9IHcgfHwgdGhpcy5pc0luc2lkZUdyaWQoWCwgSCwgSywgWSksICFlICYmIHRoaXMuZ3JpZC5oaXRUZXN0Q2lyY2xlKEcsIFcsIEUsIGgpICYmIChiID0gITAsICFjKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY2lyY2xlczogW10sXG4gICAgICAgICAgICAgIG9mZnNjcmVlbjogITEsXG4gICAgICAgICAgICAgIGNvbGxpc2lvbkRldGVjdGVkOiBiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaXJjbGVzOiAhYyAmJiBiIHx8ICF3ID8gW10gOiBfLFxuICAgICAgICBvZmZzY3JlZW46IFQsXG4gICAgICAgIGNvbGxpc2lvbkRldGVjdGVkOiBiXG4gICAgICB9O1xuICAgIH0sIGhlLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkU3ltYm9scyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoMCA9PT0gZS5sZW5ndGggfHwgMCA9PT0gdGhpcy5ncmlkLmtleXNMZW5ndGgoKSAmJiAwID09PSB0aGlzLmlnbm9yZWRHcmlkLmtleXNMZW5ndGgoKSkgcmV0dXJuIHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gW10sIG8gPSAxIC8gMCwgciA9IDEgLyAwLCBhID0gLTEgLyAwLCBuID0gLTEgLyAwLCBzID0gMCwgbCA9IGU7IHMgPCBsLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIHZhciBjID0gbFtzXSxcbiAgICAgICAgICAgIHUgPSBuZXcgdC5Qb2ludChjLnggKyAxMDAsIGMueSArIDEwMCk7XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCB1LngpLCByID0gTWF0aC5taW4ociwgdS55KSwgYSA9IE1hdGgubWF4KGEsIHUueCksIG4gPSBNYXRoLm1heChuLCB1LnkpLCBpLnB1c2godSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGggPSB7fSwgcCA9IHt9LCBkID0gMCwgXyA9IHRoaXMuZ3JpZC5xdWVyeShvLCByLCBhLCBuKS5jb25jYXQodGhpcy5pZ25vcmVkR3JpZC5xdWVyeShvLCByLCBhLCBuKSk7IGQgPCBfLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgIHZhciBmID0gX1tkXSxcbiAgICAgICAgICAgIG0gPSBmLmtleTtcblxuICAgICAgICBpZiAodm9pZCAwID09PSBoW20uYnVja2V0SW5zdGFuY2VJZF0gJiYgKGhbbS5idWNrZXRJbnN0YW5jZUlkXSA9IHt9KSwgIWhbbS5idWNrZXRJbnN0YW5jZUlkXVttLmZlYXR1cmVJbmRleF0pIHtcbiAgICAgICAgICB2YXIgZyA9IFtuZXcgdC5Qb2ludChmLngxLCBmLnkxKSwgbmV3IHQuUG9pbnQoZi54MiwgZi55MSksIG5ldyB0LlBvaW50KGYueDIsIGYueTIpLCBuZXcgdC5Qb2ludChmLngxLCBmLnkyKV07XG4gICAgICAgICAgdC5wb2x5Z29uSW50ZXJzZWN0c1BvbHlnb24oaSwgZykgJiYgKGhbbS5idWNrZXRJbnN0YW5jZUlkXVttLmZlYXR1cmVJbmRleF0gPSAhMCwgdm9pZCAwID09PSBwW20uYnVja2V0SW5zdGFuY2VJZF0gJiYgKHBbbS5idWNrZXRJbnN0YW5jZUlkXSA9IFtdKSwgcFttLmJ1Y2tldEluc3RhbmNlSWRdLnB1c2gobS5mZWF0dXJlSW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LCBoZS5wcm90b3R5cGUuaW5zZXJ0Q29sbGlzaW9uQm94ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIChlID8gdGhpcy5pZ25vcmVkR3JpZCA6IHRoaXMuZ3JpZCkuaW5zZXJ0KHtcbiAgICAgICAgYnVja2V0SW5zdGFuY2VJZDogaSxcbiAgICAgICAgZmVhdHVyZUluZGV4OiBvLFxuICAgICAgICBjb2xsaXNpb25Hcm91cElEOiByXG4gICAgICB9LCB0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKTtcbiAgICB9LCBoZS5wcm90b3R5cGUuaW5zZXJ0Q29sbGlzaW9uQ2lyY2xlcyA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICBmb3IgKHZhciBhID0gZSA/IHRoaXMuaWdub3JlZEdyaWQgOiB0aGlzLmdyaWQsIG4gPSB7XG4gICAgICAgIGJ1Y2tldEluc3RhbmNlSWQ6IGksXG4gICAgICAgIGZlYXR1cmVJbmRleDogbyxcbiAgICAgICAgY29sbGlzaW9uR3JvdXBJRDogclxuICAgICAgfSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSA0KSB7XG4gICAgICAgIGEuaW5zZXJ0Q2lyY2xlKG4sIHRbc10sIHRbcyArIDFdLCB0W3MgKyAyXSk7XG4gICAgICB9XG4gICAgfSwgaGUucHJvdG90eXBlLnByb2plY3RBbmRHZXRQZXJzcGVjdGl2ZVJhdGlvID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gW2ksIG8sIDAsIDFdO1xuICAgICAgcmV0dXJuIHVlKHIsIHIsIGUpLCB7XG4gICAgICAgIHBvaW50OiBuZXcgdC5Qb2ludCgoclswXSAvIHJbM10gKyAxKSAvIDIgKiB0aGlzLnRyYW5zZm9ybS53aWR0aCArIDEwMCwgKC1yWzFdIC8gclszXSArIDEpIC8gMiAqIHRoaXMudHJhbnNmb3JtLmhlaWdodCArIDEwMCksXG4gICAgICAgIHBlcnNwZWN0aXZlUmF0aW86IC41ICsgdGhpcy50cmFuc2Zvcm0uY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSAvIHJbM10gKiAuNVxuICAgICAgfTtcbiAgICB9LCBoZS5wcm90b3R5cGUuaXNPZmZzY3JlZW4gPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIGkgPCAxMDAgfHwgdCA+PSB0aGlzLnNjcmVlblJpZ2h0Qm91bmRhcnkgfHwgbyA8IDEwMCB8fCBlID4gdGhpcy5zY3JlZW5Cb3R0b21Cb3VuZGFyeTtcbiAgICB9LCBoZS5wcm90b3R5cGUuaXNJbnNpZGVHcmlkID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgIHJldHVybiBpID49IDAgJiYgdCA8IHRoaXMuZ3JpZFJpZ2h0Qm91bmRhcnkgJiYgbyA+PSAwICYmIGUgPCB0aGlzLmdyaWRCb3R0b21Cb3VuZGFyeTtcbiAgICB9LCBoZS5wcm90b3R5cGUuZ2V0Vmlld3BvcnRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHQuaWRlbnRpdHkoW10pO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKGUsIGUsIFstMTAwLCAtMTAwLCAwXSksIGU7XG4gICAgfTtcblxuICAgIHZhciBkZSA9IGZ1bmN0aW9uIGRlKHQsIGUsIGksIG8pIHtcbiAgICAgIHRoaXMub3BhY2l0eSA9IHQgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0Lm9wYWNpdHkgKyAodC5wbGFjZWQgPyBlIDogLWUpKSkgOiBvICYmIGkgPyAxIDogMCwgdGhpcy5wbGFjZWQgPSBpO1xuICAgIH07XG5cbiAgICBkZS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5vcGFjaXR5ICYmICF0aGlzLnBsYWNlZDtcbiAgICB9O1xuXG4gICAgdmFyIF9lID0gZnVuY3Rpb24gX2UodCwgZSwgaSwgbywgcikge1xuICAgICAgdGhpcy50ZXh0ID0gbmV3IGRlKHQgPyB0LnRleHQgOiBudWxsLCBlLCBpLCByKSwgdGhpcy5pY29uID0gbmV3IGRlKHQgPyB0Lmljb24gOiBudWxsLCBlLCBvLCByKTtcbiAgICB9O1xuXG4gICAgX2UucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5pc0hpZGRlbigpICYmIHRoaXMuaWNvbi5pc0hpZGRlbigpO1xuICAgIH07XG5cbiAgICB2YXIgZmUgPSBmdW5jdGlvbiBmZSh0LCBlLCBpKSB7XG4gICAgICB0aGlzLnRleHQgPSB0LCB0aGlzLmljb24gPSBlLCB0aGlzLnNraXBGYWRlID0gaTtcbiAgICB9LFxuICAgICAgICBtZSA9IGZ1bmN0aW9uIG1lKCkge1xuICAgICAgdGhpcy5pbnZQcm9qTWF0cml4ID0gdC5jcmVhdGUoKSwgdGhpcy52aWV3cG9ydE1hdHJpeCA9IHQuY3JlYXRlKCksIHRoaXMuY2lyY2xlcyA9IFtdO1xuICAgIH0sXG4gICAgICAgIGdlID0gZnVuY3Rpb24gZ2UodCwgZSwgaSwgbywgcikge1xuICAgICAgdGhpcy5idWNrZXRJbnN0YW5jZUlkID0gdCwgdGhpcy5mZWF0dXJlSW5kZXggPSBlLCB0aGlzLnNvdXJjZUxheWVySW5kZXggPSBpLCB0aGlzLmJ1Y2tldEluZGV4ID0gbywgdGhpcy50aWxlSUQgPSByO1xuICAgIH0sXG4gICAgICAgIHZlID0gZnVuY3Rpb24gdmUodCkge1xuICAgICAgdGhpcy5jcm9zc1NvdXJjZUNvbGxpc2lvbnMgPSB0LCB0aGlzLm1heEdyb3VwSUQgPSAwLCB0aGlzLmNvbGxpc2lvbkdyb3VwcyA9IHt9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB5ZShlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHQuZ2V0QW5jaG9yQWxpZ25tZW50KGUpLFxuICAgICAgICAgIHMgPSAtKG4uaG9yaXpvbnRhbEFsaWduIC0gLjUpICogaSxcbiAgICAgICAgICBsID0gLShuLnZlcnRpY2FsQWxpZ24gLSAuNSkgKiBvLFxuICAgICAgICAgIGMgPSB0LmV2YWx1YXRlVmFyaWFibGVPZmZzZXQoZSwgcik7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQocyArIGNbMF0gKiBhLCBsICsgY1sxXSAqIGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHhlKGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gZS54MSxcbiAgICAgICAgICBsID0gZS54MixcbiAgICAgICAgICBjID0gZS55MSxcbiAgICAgICAgICB1ID0gZS55MixcbiAgICAgICAgICBoID0gZS5hbmNob3JQb2ludFgsXG4gICAgICAgICAgcCA9IGUuYW5jaG9yUG9pbnRZLFxuICAgICAgICAgIGQgPSBuZXcgdC5Qb2ludChpLCBvKTtcbiAgICAgIHJldHVybiByICYmIGQuX3JvdGF0ZShhID8gbiA6IC1uKSwge1xuICAgICAgICB4MTogcyArIGQueCxcbiAgICAgICAgeTE6IGMgKyBkLnksXG4gICAgICAgIHgyOiBsICsgZC54LFxuICAgICAgICB5MjogdSArIGQueSxcbiAgICAgICAgYW5jaG9yUG9pbnRYOiBoLFxuICAgICAgICBhbmNob3JQb2ludFk6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5jcm9zc1NvdXJjZUNvbGxpc2lvbnMpIHJldHVybiB7XG4gICAgICAgIElEOiAwLFxuICAgICAgICBwcmVkaWNhdGU6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5jb2xsaXNpb25Hcm91cHNbdF0pIHtcbiAgICAgICAgdmFyIGUgPSArK3RoaXMubWF4R3JvdXBJRDtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHNbdF0gPSB7XG4gICAgICAgICAgSUQ6IGUsXG4gICAgICAgICAgcHJlZGljYXRlOiBmdW5jdGlvbiBwcmVkaWNhdGUodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuY29sbGlzaW9uR3JvdXBJRCA9PT0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbkdyb3Vwc1t0XTtcbiAgICB9O1xuXG4gICAgdmFyIGJlID0gZnVuY3Rpb24gYmUodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0LmNsb25lKCksIHRoaXMuY29sbGlzaW9uSW5kZXggPSBuZXcgaGUodGhpcy50cmFuc2Zvcm0pLCB0aGlzLnBsYWNlbWVudHMgPSB7fSwgdGhpcy5vcGFjaXRpZXMgPSB7fSwgdGhpcy52YXJpYWJsZU9mZnNldHMgPSB7fSwgdGhpcy5zdGFsZSA9ICExLCB0aGlzLmNvbW1pdFRpbWUgPSAwLCB0aGlzLmZhZGVEdXJhdGlvbiA9IGUsIHRoaXMucmV0YWluZWRRdWVyeURhdGEgPSB7fSwgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBuZXcgdmUoaSksIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzID0ge30sIHRoaXMucHJldlBsYWNlbWVudCA9IG8sIG8gJiYgKG8ucHJldlBsYWNlbWVudCA9IHZvaWQgMCksIHRoaXMucGxhY2VkT3JpZW50YXRpb25zID0ge307XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdlKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHQuZW1wbGFjZUJhY2soZSA/IDEgOiAwLCBpID8gMSA6IDAsIG8gfHwgMCwgciB8fCAwKSwgdC5lbXBsYWNlQmFjayhlID8gMSA6IDAsIGkgPyAxIDogMCwgbyB8fCAwLCByIHx8IDApLCB0LmVtcGxhY2VCYWNrKGUgPyAxIDogMCwgaSA/IDEgOiAwLCBvIHx8IDAsIHIgfHwgMCksIHQuZW1wbGFjZUJhY2soZSA/IDEgOiAwLCBpID8gMSA6IDAsIG8gfHwgMCwgciB8fCAwKTtcbiAgICB9XG5cbiAgICBiZS5wcm90b3R5cGUuZ2V0QnVja2V0UGFydHMgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSBvLmdldEJ1Y2tldChpKSxcbiAgICAgICAgICBuID0gby5sYXRlc3RGZWF0dXJlSW5kZXg7XG5cbiAgICAgIGlmIChhICYmIG4gJiYgaS5pZCA9PT0gYS5sYXllcklkc1swXSkge1xuICAgICAgICB2YXIgcyA9IG8uY29sbGlzaW9uQm94QXJyYXksXG4gICAgICAgICAgICBsID0gYS5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgICAgYyA9IE1hdGgucG93KDIsIHRoaXMudHJhbnNmb3JtLnpvb20gLSBvLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgICAgICB1ID0gby50aWxlU2l6ZSAvIHQuRVhURU5ULFxuICAgICAgICAgICAgaCA9IHRoaXMudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChvLnRpbGVJRC50b1Vud3JhcHBlZCgpKSxcbiAgICAgICAgICAgIHAgPSBcIm1hcFwiID09PSBsLmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpLFxuICAgICAgICAgICAgZCA9IFwibWFwXCIgPT09IGwuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgICBfID0gcGUobywgMSwgdGhpcy50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgICBmID0gSnQoaCwgcCwgZCwgdGhpcy50cmFuc2Zvcm0sIF8pLFxuICAgICAgICAgICAgbSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICB2YXIgZyA9IFF0KGgsIHAsIGQsIHRoaXMudHJhbnNmb3JtLCBfKTtcbiAgICAgICAgICBtID0gdC5tdWx0aXBseShbXSwgdGhpcy50cmFuc2Zvcm0ubGFiZWxQbGFuZU1hdHJpeCwgZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJldGFpbmVkUXVlcnlEYXRhW2EuYnVja2V0SW5zdGFuY2VJZF0gPSBuZXcgZ2UoYS5idWNrZXRJbnN0YW5jZUlkLCBuLCBhLnNvdXJjZUxheWVySW5kZXgsIGEuaW5kZXgsIG8udGlsZUlEKTtcbiAgICAgICAgdmFyIHYgPSB7XG4gICAgICAgICAgYnVja2V0OiBhLFxuICAgICAgICAgIGxheW91dDogbCxcbiAgICAgICAgICBwb3NNYXRyaXg6IGgsXG4gICAgICAgICAgdGV4dExhYmVsUGxhbmVNYXRyaXg6IGYsXG4gICAgICAgICAgbGFiZWxUb1NjcmVlbk1hdHJpeDogbSxcbiAgICAgICAgICBzY2FsZTogYyxcbiAgICAgICAgICB0ZXh0UGl4ZWxSYXRpbzogdSxcbiAgICAgICAgICBob2xkaW5nRm9yRmFkZTogby5ob2xkaW5nRm9yRmFkZSgpLFxuICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiBzLFxuICAgICAgICAgIHBhcnRpYWxseUV2YWx1YXRlZFRleHRTaXplOiB0LmV2YWx1YXRlU2l6ZUZvclpvb20oYS50ZXh0U2l6ZURhdGEsIHRoaXMudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAgIGNvbGxpc2lvbkdyb3VwOiB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5nZXQoYS5zb3VyY2VJRClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHIpIGZvciAodmFyIHkgPSAwLCB4ID0gYS5zb3J0S2V5UmFuZ2VzOyB5IDwgeC5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgICAgIHZhciBiID0geFt5XTtcbiAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgc29ydEtleTogYi5zb3J0S2V5LFxuICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2VTdGFydDogYi5zeW1ib2xJbnN0YW5jZVN0YXJ0LFxuICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2VFbmQ6IGIuc3ltYm9sSW5zdGFuY2VFbmQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB2XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBlLnB1c2goe1xuICAgICAgICAgIHN5bWJvbEluc3RhbmNlU3RhcnQ6IDAsXG4gICAgICAgICAgc3ltYm9sSW5zdGFuY2VFbmQ6IGEuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aCxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiB2XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGJlLnByb3RvdHlwZS5hdHRlbXB0QW5jaG9yUGxhY2VtZW50ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHAsIGQsIF8pIHtcbiAgICAgIHZhciBmLFxuICAgICAgICAgIG0gPSBbaC50ZXh0T2Zmc2V0MCwgaC50ZXh0T2Zmc2V0MV0sXG4gICAgICAgICAgZyA9IHllKHQsIGksIG8sIG0sIHIpLFxuICAgICAgICAgIHYgPSB0aGlzLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KHhlKGUsIGcueCwgZy55LCBhLCBuLCB0aGlzLnRyYW5zZm9ybS5hbmdsZSksIHUsIHMsIGwsIGMucHJlZGljYXRlKTtcbiAgICAgIGlmICghXyB8fCAwICE9PSB0aGlzLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KHhlKF8sIGcueCwgZy55LCBhLCBuLCB0aGlzLnRyYW5zZm9ybS5hbmdsZSksIHUsIHMsIGwsIGMucHJlZGljYXRlKS5ib3gubGVuZ3RoKSByZXR1cm4gdi5ib3gubGVuZ3RoID4gMCA/ICh0aGlzLnByZXZQbGFjZW1lbnQgJiYgdGhpcy5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXSAmJiB0aGlzLnByZXZQbGFjZW1lbnQucGxhY2VtZW50c1toLmNyb3NzVGlsZUlEXSAmJiB0aGlzLnByZXZQbGFjZW1lbnQucGxhY2VtZW50c1toLmNyb3NzVGlsZUlEXS50ZXh0ICYmIChmID0gdGhpcy5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXS5hbmNob3IpLCB0aGlzLnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXSA9IHtcbiAgICAgICAgdGV4dE9mZnNldDogbSxcbiAgICAgICAgd2lkdGg6IGksXG4gICAgICAgIGhlaWdodDogbyxcbiAgICAgICAgYW5jaG9yOiB0LFxuICAgICAgICB0ZXh0Qm94U2NhbGU6IHIsXG4gICAgICAgIHByZXZBbmNob3I6IGZcbiAgICAgIH0sIHRoaXMubWFya1VzZWRKdXN0aWZpY2F0aW9uKHAsIHQsIGgsIGQpLCBwLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgKHRoaXMubWFya1VzZWRPcmllbnRhdGlvbihwLCBkLCBoKSwgdGhpcy5wbGFjZWRPcmllbnRhdGlvbnNbaC5jcm9zc1RpbGVJRF0gPSBkKSwge1xuICAgICAgICBzaGlmdDogZyxcbiAgICAgICAgcGxhY2VkR2x5cGhCb3hlczogdlxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgfSwgYmUucHJvdG90eXBlLnBsYWNlTGF5ZXJCdWNrZXRQYXJ0ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgICBhID0gZS5wYXJhbWV0ZXJzLFxuICAgICAgICAgIG4gPSBhLmJ1Y2tldCxcbiAgICAgICAgICBzID0gYS5sYXlvdXQsXG4gICAgICAgICAgbCA9IGEucG9zTWF0cml4LFxuICAgICAgICAgIGMgPSBhLnRleHRMYWJlbFBsYW5lTWF0cml4LFxuICAgICAgICAgIHUgPSBhLmxhYmVsVG9TY3JlZW5NYXRyaXgsXG4gICAgICAgICAgaCA9IGEudGV4dFBpeGVsUmF0aW8sXG4gICAgICAgICAgcCA9IGEuaG9sZGluZ0ZvckZhZGUsXG4gICAgICAgICAgZCA9IGEuY29sbGlzaW9uQm94QXJyYXksXG4gICAgICAgICAgXyA9IGEucGFydGlhbGx5RXZhbHVhdGVkVGV4dFNpemUsXG4gICAgICAgICAgZiA9IGEuY29sbGlzaW9uR3JvdXAsXG4gICAgICAgICAgbSA9IHMuZ2V0KFwidGV4dC1vcHRpb25hbFwiKSxcbiAgICAgICAgICBnID0gcy5nZXQoXCJpY29uLW9wdGlvbmFsXCIpLFxuICAgICAgICAgIHYgPSBzLmdldChcInRleHQtYWxsb3ctb3ZlcmxhcFwiKSxcbiAgICAgICAgICB5ID0gcy5nZXQoXCJpY29uLWFsbG93LW92ZXJsYXBcIiksXG4gICAgICAgICAgeCA9IFwibWFwXCIgPT09IHMuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgYiA9IFwibWFwXCIgPT09IHMuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgdyA9IFwibm9uZVwiICE9PSBzLmdldChcImljb24tdGV4dC1maXRcIiksXG4gICAgICAgICAgVCA9IFwidmlld3BvcnQteVwiID09PSBzLmdldChcInN5bWJvbC16LW9yZGVyXCIpLFxuICAgICAgICAgIEUgPSB2ICYmICh5IHx8ICFuLmhhc0ljb25EYXRhKCkgfHwgZyksXG4gICAgICAgICAgSSA9IHkgJiYgKHYgfHwgIW4uaGFzVGV4dERhdGEoKSB8fCBtKTtcbiAgICAgICFuLmNvbGxpc2lvbkFycmF5cyAmJiBkICYmIG4uZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyhkKTtcblxuICAgICAgdmFyIFAgPSBmdW5jdGlvbiBQKGUsIGEpIHtcbiAgICAgICAgaWYgKCFpW2UuY3Jvc3NUaWxlSURdKSBpZiAocCkgci5wbGFjZW1lbnRzW2UuY3Jvc3NUaWxlSURdID0gbmV3IGZlKCExLCAhMSwgITEpO2Vsc2Uge1xuICAgICAgICAgIHZhciBkLFxuICAgICAgICAgICAgICBUID0gITEsXG4gICAgICAgICAgICAgIFAgPSAhMSxcbiAgICAgICAgICAgICAgUyA9ICEwLFxuICAgICAgICAgICAgICBDID0gbnVsbCxcbiAgICAgICAgICAgICAgeiA9IHtcbiAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNjcmVlbjogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIEQgPSB7XG4gICAgICAgICAgICBib3g6IG51bGwsXG4gICAgICAgICAgICBvZmZzY3JlZW46IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBBID0gbnVsbCxcbiAgICAgICAgICAgICAgTSA9IG51bGwsXG4gICAgICAgICAgICAgIEwgPSAwLFxuICAgICAgICAgICAgICBSID0gMCxcbiAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgYS50ZXh0RmVhdHVyZUluZGV4ID8gTCA9IGEudGV4dEZlYXR1cmVJbmRleCA6IGUudXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXMgJiYgKEwgPSBlLmZlYXR1cmVJbmRleCksIGEudmVydGljYWxUZXh0RmVhdHVyZUluZGV4ICYmIChSID0gYS52ZXJ0aWNhbFRleHRGZWF0dXJlSW5kZXgpO1xuICAgICAgICAgIHZhciBCID0gYS50ZXh0Qm94O1xuXG4gICAgICAgICAgaWYgKEIpIHtcbiAgICAgICAgICAgIHZhciBPID0gZnVuY3Rpb24gTyhpKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgICAgIGlmIChuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgIWkgJiYgci5wcmV2UGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSByLnByZXZQbGFjZW1lbnQucGxhY2VkT3JpZW50YXRpb25zW2UuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgICAgIGEgJiYgKHIucGxhY2VkT3JpZW50YXRpb25zW2UuY3Jvc3NUaWxlSURdID0gYSwgci5tYXJrVXNlZE9yaWVudGF0aW9uKG4sIG8gPSBhLCBlKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRiA9IGZ1bmN0aW9uIEYoaSwgbykge1xuICAgICAgICAgICAgICBpZiAobi5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIGUubnVtVmVydGljYWxHbHlwaFZlcnRpY2VzID4gMCAmJiBhLnZlcnRpY2FsVGV4dEJveCkgZm9yICh2YXIgciA9IDAsIHMgPSBuLndyaXRpbmdNb2RlczsgciA8IHMubGVuZ3RoICYmIChzW3JdID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gKHogPSBvKCksIEQgPSB6KSA6IHogPSBpKCksICEoeiAmJiB6LmJveCAmJiB6LmJveC5sZW5ndGgpKTsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICB9IGVsc2UgeiA9IGkoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBVID0gcy5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKTtcblxuICAgICAgICAgICAgICBpZiAoci5wcmV2UGxhY2VtZW50ICYmIHIucHJldlBsYWNlbWVudC52YXJpYWJsZU9mZnNldHNbZS5jcm9zc1RpbGVJRF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IHIucHJldlBsYWNlbWVudC52YXJpYWJsZU9mZnNldHNbZS5jcm9zc1RpbGVJRF07XG4gICAgICAgICAgICAgICAgVS5pbmRleE9mKE4uYW5jaG9yKSA+IDAgJiYgKFUgPSBVLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgIT09IE4uYW5jaG9yO1xuICAgICAgICAgICAgICAgIH0pKS51bnNoaWZ0KE4uYW5jaG9yKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBaID0gZnVuY3Rpb24gWih0LCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHQueDIgLSB0LngxLCBzID0gdC55MiAtIHQueTEsIGMgPSBlLnRleHRCb3hTY2FsZSwgdSA9IHcgJiYgIXkgPyBpIDogbnVsbCwgcCA9IHtcbiAgICAgICAgICAgICAgICAgIGJveDogW10sXG4gICAgICAgICAgICAgICAgICBvZmZzY3JlZW46ICExXG4gICAgICAgICAgICAgICAgfSwgZCA9IHYgPyAyICogVS5sZW5ndGggOiBVLmxlbmd0aCwgXyA9IDA7IF8gPCBkOyArK18pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtID0gci5hdHRlbXB0QW5jaG9yUGxhY2VtZW50KFVbXyAlIFUubGVuZ3RoXSwgdCwgYSwgcywgYywgeCwgYiwgaCwgbCwgZiwgXyA+PSBVLmxlbmd0aCwgZSwgbiwgbywgdSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtICYmIChwID0gbS5wbGFjZWRHbHlwaEJveGVzKSAmJiBwLmJveCAmJiBwLmJveC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgVCA9ICEwLCBDID0gbS5zaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgRihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFooQiwgYS5pY29uQm94LCB0LldyaXRpbmdNb2RlLmhvcml6b250YWwpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhLnZlcnRpY2FsVGV4dEJveDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmICEoeiAmJiB6LmJveCAmJiB6LmJveC5sZW5ndGgpICYmIGUubnVtVmVydGljYWxHbHlwaFZlcnRpY2VzID4gMCAmJiBpID8gWihpLCBhLnZlcnRpY2FsSWNvbkJveCwgdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCkgOiB7XG4gICAgICAgICAgICAgICAgICBib3g6IG51bGwsXG4gICAgICAgICAgICAgICAgICBvZmZzY3JlZW46IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KSwgeiAmJiAoVCA9IHouYm94LCBTID0gei5vZmZzY3JlZW4pO1xuICAgICAgICAgICAgICB2YXIgcSA9IE8oeiAmJiB6LmJveCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFUICYmIHIucHJldlBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBqID0gci5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1tlLmNyb3NzVGlsZUlEXTtcbiAgICAgICAgICAgICAgICBqICYmIChyLnZhcmlhYmxlT2Zmc2V0c1tlLmNyb3NzVGlsZUlEXSA9IGosIHIubWFya1VzZWRKdXN0aWZpY2F0aW9uKG4sIGouYW5jaG9yLCBlLCBxKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBWID0gZnVuY3Rpb24gVih0LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSByLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KHQsIHYsIGgsIGwsIGYucHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbyAmJiBvLmJveCAmJiBvLmJveC5sZW5ndGggJiYgKHIubWFya1VzZWRPcmllbnRhdGlvbihuLCBpLCBlKSwgci5wbGFjZWRPcmllbnRhdGlvbnNbZS5jcm9zc1RpbGVJRF0gPSBpKSwgbztcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVihCLCB0LldyaXRpbmdNb2RlLmhvcml6b250YWwpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhLnZlcnRpY2FsVGV4dEJveDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIGUubnVtVmVydGljYWxHbHlwaFZlcnRpY2VzID4gMCAmJiBpID8gVihpLCB0LldyaXRpbmdNb2RlLnZlcnRpY2FsKSA6IHtcbiAgICAgICAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbjogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pLCBPKHogJiYgei5ib3ggJiYgei5ib3gubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoVCA9IChkID0geikgJiYgZC5ib3ggJiYgZC5ib3gubGVuZ3RoID4gMCwgUyA9IGQgJiYgZC5vZmZzY3JlZW4sIGUudXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXMpIHtcbiAgICAgICAgICAgIHZhciBHID0gbi50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChlLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCksXG4gICAgICAgICAgICAgICAgVyA9IHQuZXZhbHVhdGVTaXplRm9yRmVhdHVyZShuLnRleHRTaXplRGF0YSwgXywgRyksXG4gICAgICAgICAgICAgICAgWCA9IHMuZ2V0KFwidGV4dC1wYWRkaW5nXCIpO1xuICAgICAgICAgICAgQSA9IHIuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25DaXJjbGVzKHYsIEcsIG4ubGluZVZlcnRleEFycmF5LCBuLmdseXBoT2Zmc2V0QXJyYXksIFcsIGwsIGMsIHUsIG8sIGIsIGYucHJlZGljYXRlLCBlLmNvbGxpc2lvbkNpcmNsZURpYW1ldGVyLCBYKSwgVCA9IHYgfHwgQS5jaXJjbGVzLmxlbmd0aCA+IDAgJiYgIUEuY29sbGlzaW9uRGV0ZWN0ZWQsIFMgPSBTICYmIEEub2Zmc2NyZWVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhLmljb25GZWF0dXJlSW5kZXggJiYgKGsgPSBhLmljb25GZWF0dXJlSW5kZXgpLCBhLmljb25Cb3gpIHtcbiAgICAgICAgICAgIHZhciBIID0gZnVuY3Rpb24gSCh0KSB7XG4gICAgICAgICAgICAgIHZhciBlID0gdyAmJiBDID8geGUodCwgQy54LCBDLnksIHgsIGIsIHIudHJhbnNmb3JtLmFuZ2xlKSA6IHQ7XG4gICAgICAgICAgICAgIHJldHVybiByLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KGUsIHksIGgsIGwsIGYucHJlZGljYXRlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFAgPSBEICYmIEQuYm94ICYmIEQuYm94Lmxlbmd0aCAmJiBhLnZlcnRpY2FsSWNvbkJveCA/IChNID0gSChhLnZlcnRpY2FsSWNvbkJveCkpLmJveC5sZW5ndGggPiAwIDogKE0gPSBIKGEuaWNvbkJveCkpLmJveC5sZW5ndGggPiAwLCBTID0gUyAmJiBNLm9mZnNjcmVlbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSyA9IG0gfHwgMCA9PT0gZS5udW1Ib3Jpem9udGFsR2x5cGhWZXJ0aWNlcyAmJiAwID09PSBlLm51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlcyxcbiAgICAgICAgICAgICAgWSA9IGcgfHwgMCA9PT0gZS5udW1JY29uVmVydGljZXM7XG5cbiAgICAgICAgICBpZiAoSyB8fCBZID8gWSA/IEsgfHwgKFAgPSBQICYmIFQpIDogVCA9IFAgJiYgVCA6IFAgPSBUID0gUCAmJiBULCBUICYmIGQgJiYgZC5ib3ggJiYgci5jb2xsaXNpb25JbmRleC5pbnNlcnRDb2xsaXNpb25Cb3goZC5ib3gsIHMuZ2V0KFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCIpLCBuLmJ1Y2tldEluc3RhbmNlSWQsIEQgJiYgRC5ib3ggJiYgUiA/IFIgOiBMLCBmLklEKSwgUCAmJiBNICYmIHIuY29sbGlzaW9uSW5kZXguaW5zZXJ0Q29sbGlzaW9uQm94KE0uYm94LCBzLmdldChcImljb24taWdub3JlLXBsYWNlbWVudFwiKSwgbi5idWNrZXRJbnN0YW5jZUlkLCBrLCBmLklEKSwgQSAmJiAoVCAmJiByLmNvbGxpc2lvbkluZGV4Lmluc2VydENvbGxpc2lvbkNpcmNsZXMoQS5jaXJjbGVzLCBzLmdldChcInRleHQtaWdub3JlLXBsYWNlbWVudFwiKSwgbi5idWNrZXRJbnN0YW5jZUlkLCBMLCBmLklEKSwgbykpIHtcbiAgICAgICAgICAgIHZhciBKID0gbi5idWNrZXRJbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgIFEgPSByLmNvbGxpc2lvbkNpcmNsZUFycmF5c1tKXTtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gUSAmJiAoUSA9IHIuY29sbGlzaW9uQ2lyY2xlQXJyYXlzW0pdID0gbmV3IG1lKCkpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciAkID0gMDsgJCA8IEEuY2lyY2xlcy5sZW5ndGg7ICQgKz0gNCkge1xuICAgICAgICAgICAgICBRLmNpcmNsZXMucHVzaChBLmNpcmNsZXNbJCArIDBdKSwgUS5jaXJjbGVzLnB1c2goQS5jaXJjbGVzWyQgKyAxXSksIFEuY2lyY2xlcy5wdXNoKEEuY2lyY2xlc1skICsgMl0pLCBRLmNpcmNsZXMucHVzaChBLmNvbGxpc2lvbkRldGVjdGVkID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucGxhY2VtZW50c1tlLmNyb3NzVGlsZUlEXSA9IG5ldyBmZShUIHx8IEUsIFAgfHwgSSwgUyB8fCBuLmp1c3RSZWxvYWRlZCksIGlbZS5jcm9zc1RpbGVJRF0gPSAhMDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKFQpIGZvciAodmFyIFMgPSBuLmdldFNvcnRlZFN5bWJvbEluZGV4ZXModGhpcy50cmFuc2Zvcm0uYW5nbGUpLCBDID0gUy5sZW5ndGggLSAxOyBDID49IDA7IC0tQykge1xuICAgICAgICB2YXIgeiA9IFNbQ107XG4gICAgICAgIFAobi5zeW1ib2xJbnN0YW5jZXMuZ2V0KHopLCBuLmNvbGxpc2lvbkFycmF5c1t6XSk7XG4gICAgICB9IGVsc2UgZm9yICh2YXIgRCA9IGUuc3ltYm9sSW5zdGFuY2VTdGFydDsgRCA8IGUuc3ltYm9sSW5zdGFuY2VFbmQ7IEQrKykge1xuICAgICAgICBQKG4uc3ltYm9sSW5zdGFuY2VzLmdldChEKSwgbi5jb2xsaXNpb25BcnJheXNbRF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobyAmJiBuLmJ1Y2tldEluc3RhbmNlSWQgaW4gdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXMpIHtcbiAgICAgICAgdmFyIEEgPSB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5c1tuLmJ1Y2tldEluc3RhbmNlSWRdO1xuICAgICAgICB0LmludmVydChBLmludlByb2pNYXRyaXgsIGwpLCBBLnZpZXdwb3J0TWF0cml4ID0gdGhpcy5jb2xsaXNpb25JbmRleC5nZXRWaWV3cG9ydE1hdHJpeCgpO1xuICAgICAgfVxuXG4gICAgICBuLmp1c3RSZWxvYWRlZCA9ICExO1xuICAgIH0sIGJlLnByb3RvdHlwZS5tYXJrVXNlZEp1c3RpZmljYXRpb24gPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgdmFyIGE7XG4gICAgICBhID0gciA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCA/IG8udmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXggOiB7XG4gICAgICAgIGxlZnQ6IG8ubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCxcbiAgICAgICAgY2VudGVyOiBvLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCxcbiAgICAgICAgcmlnaHQ6IG8ucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhcbiAgICAgIH1bdC5nZXRBbmNob3JKdXN0aWZpY2F0aW9uKGkpXTtcblxuICAgICAgZm9yICh2YXIgbiA9IDAsIHMgPSBbby5sZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBvLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleF07IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBsID0gc1tuXTtcbiAgICAgICAgbCA+PSAwICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGwpLmNyb3NzVGlsZUlEID0gYSA+PSAwICYmIGwgIT09IGEgPyAwIDogby5jcm9zc1RpbGVJRCk7XG4gICAgICB9XG4gICAgfSwgYmUucHJvdG90eXBlLm1hcmtVc2VkT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgZm9yICh2YXIgciA9IGkgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCB8fCBpID09PSB0LldyaXRpbmdNb2RlLmhvcml6b250YWxPbmx5ID8gaSA6IDAsIGEgPSBpID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gaSA6IDAsIG4gPSAwLCBzID0gW28ubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby5jZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIG8ucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhdOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICBlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KHNbbl0pLnBsYWNlZE9yaWVudGF0aW9uID0gcjtcbiAgICAgIH1cblxuICAgICAgby52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleCAmJiAoZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChvLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4KS5wbGFjZWRPcmllbnRhdGlvbiA9IGEpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5jb21taXRUaW1lID0gdCwgdGhpcy56b29tQXRMYXN0UmVjZW5jeUNoZWNrID0gdGhpcy50cmFuc2Zvcm0uem9vbTtcbiAgICAgIHZhciBlID0gdGhpcy5wcmV2UGxhY2VtZW50LFxuICAgICAgICAgIGkgPSAhMTtcbiAgICAgIHRoaXMucHJldlpvb21BZGp1c3RtZW50ID0gZSA/IGUuem9vbUFkanVzdG1lbnQodGhpcy50cmFuc2Zvcm0uem9vbSkgOiAwO1xuICAgICAgdmFyIG8gPSBlID8gZS5zeW1ib2xGYWRlQ2hhbmdlKHQpIDogMSxcbiAgICAgICAgICByID0gZSA/IGUub3BhY2l0aWVzIDoge30sXG4gICAgICAgICAgYSA9IGUgPyBlLnZhcmlhYmxlT2Zmc2V0cyA6IHt9LFxuICAgICAgICAgIG4gPSBlID8gZS5wbGFjZWRPcmllbnRhdGlvbnMgOiB7fTtcblxuICAgICAgZm9yICh2YXIgcyBpbiB0aGlzLnBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLnBsYWNlbWVudHNbc10sXG4gICAgICAgICAgICBjID0gcltzXTtcbiAgICAgICAgYyA/ICh0aGlzLm9wYWNpdGllc1tzXSA9IG5ldyBfZShjLCBvLCBsLnRleHQsIGwuaWNvbiksIGkgPSBpIHx8IGwudGV4dCAhPT0gYy50ZXh0LnBsYWNlZCB8fCBsLmljb24gIT09IGMuaWNvbi5wbGFjZWQpIDogKHRoaXMub3BhY2l0aWVzW3NdID0gbmV3IF9lKG51bGwsIG8sIGwudGV4dCwgbC5pY29uLCBsLnNraXBGYWRlKSwgaSA9IGkgfHwgbC50ZXh0IHx8IGwuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHUgaW4gcikge1xuICAgICAgICB2YXIgaCA9IHJbdV07XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wYWNpdGllc1t1XSkge1xuICAgICAgICAgIHZhciBwID0gbmV3IF9lKGgsIG8sICExLCAhMSk7XG4gICAgICAgICAgcC5pc0hpZGRlbigpIHx8ICh0aGlzLm9wYWNpdGllc1t1XSA9IHAsIGkgPSBpIHx8IGgudGV4dC5wbGFjZWQgfHwgaC5pY29uLnBsYWNlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZCBpbiBhKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVPZmZzZXRzW2RdIHx8ICF0aGlzLm9wYWNpdGllc1tkXSB8fCB0aGlzLm9wYWNpdGllc1tkXS5pc0hpZGRlbigpIHx8ICh0aGlzLnZhcmlhYmxlT2Zmc2V0c1tkXSA9IGFbZF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfIGluIG4pIHtcbiAgICAgICAgdGhpcy5wbGFjZWRPcmllbnRhdGlvbnNbX10gfHwgIXRoaXMub3BhY2l0aWVzW19dIHx8IHRoaXMub3BhY2l0aWVzW19dLmlzSGlkZGVuKCkgfHwgKHRoaXMucGxhY2VkT3JpZW50YXRpb25zW19dID0gbltfXSk7XG4gICAgICB9XG5cbiAgICAgIGkgPyB0aGlzLmxhc3RQbGFjZW1lbnRDaGFuZ2VUaW1lID0gdCA6IFwibnVtYmVyXCIgIT0gdHlwZW9mIHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgJiYgKHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgPSBlID8gZS5sYXN0UGxhY2VtZW50Q2hhbmdlVGltZSA6IHQpO1xuICAgIH0sIGJlLnByb3RvdHlwZS51cGRhdGVMYXllck9wYWNpdGllcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0ge30sIG8gPSAwLCByID0gZTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSByW29dLFxuICAgICAgICAgICAgbiA9IGEuZ2V0QnVja2V0KHQpO1xuICAgICAgICBuICYmIGEubGF0ZXN0RmVhdHVyZUluZGV4ICYmIHQuaWQgPT09IG4ubGF5ZXJJZHNbMF0gJiYgdGhpcy51cGRhdGVCdWNrZXRPcGFjaXRpZXMobiwgaSwgYS5jb2xsaXNpb25Cb3hBcnJheSk7XG4gICAgICB9XG4gICAgfSwgYmUucHJvdG90eXBlLnVwZGF0ZUJ1Y2tldE9wYWNpdGllcyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXM7XG4gICAgICBlLmhhc1RleHREYXRhKCkgJiYgZS50ZXh0Lm9wYWNpdHlWZXJ0ZXhBcnJheS5jbGVhcigpLCBlLmhhc0ljb25EYXRhKCkgJiYgZS5pY29uLm9wYWNpdHlWZXJ0ZXhBcnJheS5jbGVhcigpLCBlLmhhc0ljb25Db2xsaXNpb25Cb3hEYXRhKCkgJiYgZS5pY29uQ29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5LmNsZWFyKCksIGUuaGFzVGV4dENvbGxpc2lvbkJveERhdGEoKSAmJiBlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXkuY2xlYXIoKTtcbiAgICAgIHZhciBhID0gZS5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgIG4gPSBuZXcgX2UobnVsbCwgMCwgITEsICExLCAhMCksXG4gICAgICAgICAgcyA9IGEuZ2V0KFwidGV4dC1hbGxvdy1vdmVybGFwXCIpLFxuICAgICAgICAgIGwgPSBhLmdldChcImljb24tYWxsb3ctb3ZlcmxhcFwiKSxcbiAgICAgICAgICBjID0gYS5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKSxcbiAgICAgICAgICB1ID0gXCJtYXBcIiA9PT0gYS5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSxcbiAgICAgICAgICBoID0gXCJtYXBcIiA9PT0gYS5nZXQoXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiKSxcbiAgICAgICAgICBwID0gXCJub25lXCIgIT09IGEuZ2V0KFwiaWNvbi10ZXh0LWZpdFwiKSxcbiAgICAgICAgICBkID0gbmV3IF9lKG51bGwsIDAsIHMgJiYgKGwgfHwgIWUuaGFzSWNvbkRhdGEoKSB8fCBhLmdldChcImljb24tb3B0aW9uYWxcIikpLCBsICYmIChzIHx8ICFlLmhhc1RleHREYXRhKCkgfHwgYS5nZXQoXCJ0ZXh0LW9wdGlvbmFsXCIpKSwgITApO1xuICAgICAgIWUuY29sbGlzaW9uQXJyYXlzICYmIG8gJiYgKGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEoKSB8fCBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhKCkpICYmIGUuZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyhvKTtcblxuICAgICAgZm9yICh2YXIgXyA9IGZ1bmN0aW9uIF8odCwgZSwgaSkge1xuICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUgLyA0OyBvKyspIHtcbiAgICAgICAgICB0Lm9wYWNpdHlWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayhpKTtcbiAgICAgICAgfVxuICAgICAgfSwgZiA9IGZ1bmN0aW9uIGYobykge1xuICAgICAgICB2YXIgYSA9IGUuc3ltYm9sSW5zdGFuY2VzLmdldChvKSxcbiAgICAgICAgICAgIHMgPSBhLm51bUhvcml6b250YWxHbHlwaFZlcnRpY2VzLFxuICAgICAgICAgICAgbCA9IGEubnVtVmVydGljYWxHbHlwaFZlcnRpY2VzLFxuICAgICAgICAgICAgZiA9IGEuY3Jvc3NUaWxlSUQsXG4gICAgICAgICAgICBtID0gci5vcGFjaXRpZXNbZl07XG4gICAgICAgIGlbZl0gPyBtID0gbiA6IG0gfHwgKHIub3BhY2l0aWVzW2ZdID0gbSA9IGQpLCBpW2ZdID0gITA7XG4gICAgICAgIHZhciBnID0gYS5udW1JY29uVmVydGljZXMgPiAwLFxuICAgICAgICAgICAgdiA9IHIucGxhY2VkT3JpZW50YXRpb25zW2EuY3Jvc3NUaWxlSURdLFxuICAgICAgICAgICAgeSA9IHYgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwsXG4gICAgICAgICAgICB4ID0gdiA9PT0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsIHx8IHYgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbE9ubHk7XG5cbiAgICAgICAgaWYgKHMgPiAwIHx8IGwgPiAwKSB7XG4gICAgICAgICAgdmFyIGIgPSBEZShtLnRleHQpO1xuICAgICAgICAgIF8oZS50ZXh0LCBzLCB5ID8gQWUgOiBiKSwgXyhlLnRleHQsIGwsIHggPyBBZSA6IGIpO1xuICAgICAgICAgIHZhciB3ID0gbS50ZXh0LmlzSGlkZGVuKCk7XG4gICAgICAgICAgW2EucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGEuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBhLmxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQgPj0gMCAmJiAoZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldCh0KS5oaWRkZW4gPSB3IHx8IHkgPyAxIDogMCk7XG4gICAgICAgICAgfSksIGEudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXggPj0gMCAmJiAoZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChhLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4KS5oaWRkZW4gPSB3IHx8IHggPyAxIDogMCk7XG4gICAgICAgICAgdmFyIFQgPSByLnZhcmlhYmxlT2Zmc2V0c1thLmNyb3NzVGlsZUlEXTtcbiAgICAgICAgICBUICYmIHIubWFya1VzZWRKdXN0aWZpY2F0aW9uKGUsIFQuYW5jaG9yLCBhLCB2KTtcbiAgICAgICAgICB2YXIgRSA9IHIucGxhY2VkT3JpZW50YXRpb25zW2EuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgIEUgJiYgKHIubWFya1VzZWRKdXN0aWZpY2F0aW9uKGUsIFwibGVmdFwiLCBhLCBFKSwgci5tYXJrVXNlZE9yaWVudGF0aW9uKGUsIEUsIGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgdmFyIEkgPSBEZShtLmljb24pLFxuICAgICAgICAgICAgICBQID0gIShwICYmIGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggJiYgeSk7XG4gICAgICAgICAgYS5wbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiAoXyhlLmljb24sIGEubnVtSWNvblZlcnRpY2VzLCBQID8gSSA6IEFlKSwgZS5pY29uLnBsYWNlZFN5bWJvbEFycmF5LmdldChhLnBsYWNlZEljb25TeW1ib2xJbmRleCkuaGlkZGVuID0gbS5pY29uLmlzSGlkZGVuKCkpLCBhLnZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4ID49IDAgJiYgKF8oZS5pY29uLCBhLm51bVZlcnRpY2FsSWNvblZlcnRpY2VzLCBQID8gQWUgOiBJKSwgZS5pY29uLnBsYWNlZFN5bWJvbEFycmF5LmdldChhLnZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4KS5oaWRkZW4gPSBtLmljb24uaXNIaWRkZW4oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5oYXNJY29uQ29sbGlzaW9uQm94RGF0YSgpIHx8IGUuaGFzVGV4dENvbGxpc2lvbkJveERhdGEoKSkge1xuICAgICAgICAgIHZhciBTID0gZS5jb2xsaXNpb25BcnJheXNbb107XG5cbiAgICAgICAgICBpZiAoUykge1xuICAgICAgICAgICAgdmFyIEMgPSBuZXcgdC5Qb2ludCgwLCAwKTtcblxuICAgICAgICAgICAgaWYgKFMudGV4dEJveCB8fCBTLnZlcnRpY2FsVGV4dEJveCkge1xuICAgICAgICAgICAgICB2YXIgeiA9ICEwO1xuXG4gICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIEQgPSByLnZhcmlhYmxlT2Zmc2V0c1tmXTtcbiAgICAgICAgICAgICAgICBEID8gKEMgPSB5ZShELmFuY2hvciwgRC53aWR0aCwgRC5oZWlnaHQsIEQudGV4dE9mZnNldCwgRC50ZXh0Qm94U2NhbGUpLCB1ICYmIEMuX3JvdGF0ZShoID8gci50cmFuc2Zvcm0uYW5nbGUgOiAtci50cmFuc2Zvcm0uYW5nbGUpKSA6IHogPSAhMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIFMudGV4dEJveCAmJiB3ZShlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXksIG0udGV4dC5wbGFjZWQsICF6IHx8IHksIEMueCwgQy55KSwgUy52ZXJ0aWNhbFRleHRCb3ggJiYgd2UoZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5LCBtLnRleHQucGxhY2VkLCAheiB8fCB4LCBDLngsIEMueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBBID0gQm9vbGVhbigheCAmJiBTLnZlcnRpY2FsSWNvbkJveCk7XG4gICAgICAgICAgICBTLmljb25Cb3ggJiYgd2UoZS5pY29uQ29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5LCBtLmljb24ucGxhY2VkLCBBLCBwID8gQy54IDogMCwgcCA/IEMueSA6IDApLCBTLnZlcnRpY2FsSWNvbkJveCAmJiB3ZShlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXksIG0uaWNvbi5wbGFjZWQsICFBLCBwID8gQy54IDogMCwgcCA/IEMueSA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgbSA9IDA7IG0gPCBlLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICBmKG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5zb3J0RmVhdHVyZXModGhpcy50cmFuc2Zvcm0uYW5nbGUpLCB0aGlzLnJldGFpbmVkUXVlcnlEYXRhW2UuYnVja2V0SW5zdGFuY2VJZF0gJiYgKHRoaXMucmV0YWluZWRRdWVyeURhdGFbZS5idWNrZXRJbnN0YW5jZUlkXS5mZWF0dXJlU29ydE9yZGVyID0gZS5mZWF0dXJlU29ydE9yZGVyKSwgZS5oYXNUZXh0RGF0YSgpICYmIGUudGV4dC5vcGFjaXR5VmVydGV4QnVmZmVyICYmIGUudGV4dC5vcGFjaXR5VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEoZS50ZXh0Lm9wYWNpdHlWZXJ0ZXhBcnJheSksIGUuaGFzSWNvbkRhdGEoKSAmJiBlLmljb24ub3BhY2l0eVZlcnRleEJ1ZmZlciAmJiBlLmljb24ub3BhY2l0eVZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGUuaWNvbi5vcGFjaXR5VmVydGV4QXJyYXkpLCBlLmhhc0ljb25Db2xsaXNpb25Cb3hEYXRhKCkgJiYgZS5pY29uQ29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEJ1ZmZlciAmJiBlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QnVmZmVyLnVwZGF0ZURhdGEoZS5pY29uQ29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5KSwgZS5oYXNUZXh0Q29sbGlzaW9uQm94RGF0YSgpICYmIGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIgJiYgZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSksIGUuYnVja2V0SW5zdGFuY2VJZCBpbiB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5cykge1xuICAgICAgICB2YXIgZyA9IHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzW2UuYnVja2V0SW5zdGFuY2VJZF07XG4gICAgICAgIGUucGxhY2VtZW50SW52UHJvak1hdHJpeCA9IGcuaW52UHJvak1hdHJpeCwgZS5wbGFjZW1lbnRWaWV3cG9ydE1hdHJpeCA9IGcudmlld3BvcnRNYXRyaXgsIGUuY29sbGlzaW9uQ2lyY2xlQXJyYXkgPSBnLmNpcmNsZXMsIGRlbGV0ZSB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5c1tlLmJ1Y2tldEluc3RhbmNlSWRdO1xuICAgICAgfVxuICAgIH0sIGJlLnByb3RvdHlwZS5zeW1ib2xGYWRlQ2hhbmdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmZhZGVEdXJhdGlvbiA/IDEgOiAodCAtIHRoaXMuY29tbWl0VGltZSkgLyB0aGlzLmZhZGVEdXJhdGlvbiArIHRoaXMucHJldlpvb21BZGp1c3RtZW50O1xuICAgIH0sIGJlLnByb3RvdHlwZS56b29tQWRqdXN0bWVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHRoaXMudHJhbnNmb3JtLnpvb20gLSB0KSAvIDEuNSk7XG4gICAgfSwgYmUucHJvdG90eXBlLmhhc1RyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YWxlIHx8IHQgLSB0aGlzLmxhc3RQbGFjZW1lbnRDaGFuZ2VUaW1lIDwgdGhpcy5mYWRlRHVyYXRpb247XG4gICAgfSwgYmUucHJvdG90eXBlLnN0aWxsUmVjZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy56b29tQXRMYXN0UmVjZW5jeUNoZWNrID09PSBlID8gMSAtIHRoaXMuem9vbUFkanVzdG1lbnQoZSkgOiAxO1xuICAgICAgcmV0dXJuIHRoaXMuem9vbUF0TGFzdFJlY2VuY3lDaGVjayA9IGUsIHRoaXMuY29tbWl0VGltZSArIHRoaXMuZmFkZUR1cmF0aW9uICogaSA+IHQ7XG4gICAgfSwgYmUucHJvdG90eXBlLnNldFN0YWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdGFsZSA9ICEwO1xuICAgIH07XG4gICAgdmFyIFRlID0gTWF0aC5wb3coMiwgMjUpLFxuICAgICAgICBFZSA9IE1hdGgucG93KDIsIDI0KSxcbiAgICAgICAgSWUgPSBNYXRoLnBvdygyLCAxNyksXG4gICAgICAgIFBlID0gTWF0aC5wb3coMiwgMTYpLFxuICAgICAgICBTZSA9IE1hdGgucG93KDIsIDkpLFxuICAgICAgICBDZSA9IE1hdGgucG93KDIsIDgpLFxuICAgICAgICB6ZSA9IE1hdGgucG93KDIsIDEpO1xuXG4gICAgZnVuY3Rpb24gRGUodCkge1xuICAgICAgaWYgKDAgPT09IHQub3BhY2l0eSAmJiAhdC5wbGFjZWQpIHJldHVybiAwO1xuICAgICAgaWYgKDEgPT09IHQub3BhY2l0eSAmJiB0LnBsYWNlZCkgcmV0dXJuIDQyOTQ5NjcyOTU7XG4gICAgICB2YXIgZSA9IHQucGxhY2VkID8gMSA6IDAsXG4gICAgICAgICAgaSA9IE1hdGguZmxvb3IoMTI3ICogdC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBpICogVGUgKyBlICogRWUgKyBpICogSWUgKyBlICogUGUgKyBpICogU2UgKyBlICogQ2UgKyBpICogemUgKyBlO1xuICAgIH1cblxuICAgIHZhciBBZSA9IDAsXG4gICAgICAgIE1lID0gZnVuY3Rpb24gTWUodCkge1xuICAgICAgdGhpcy5fc29ydEFjcm9zc1RpbGVzID0gXCJ2aWV3cG9ydC15XCIgIT09IHQubGF5b3V0LmdldChcInN5bWJvbC16LW9yZGVyXCIpICYmIHZvaWQgMCAhPT0gdC5sYXlvdXQuZ2V0KFwic3ltYm9sLXNvcnQta2V5XCIpLmNvbnN0YW50T3IoMSksIHRoaXMuX2N1cnJlbnRUaWxlSW5kZXggPSAwLCB0aGlzLl9jdXJyZW50UGFydEluZGV4ID0gMCwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcyA9IHt9LCB0aGlzLl9idWNrZXRQYXJ0cyA9IFtdO1xuICAgIH07XG5cbiAgICBNZS5wcm90b3R5cGUuY29udGludWVQbGFjZW1lbnQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgZm9yICh2YXIgYSA9IHRoaXMuX2J1Y2tldFBhcnRzOyB0aGlzLl9jdXJyZW50VGlsZUluZGV4IDwgdC5sZW5ndGg7KSB7XG4gICAgICAgIGlmIChlLmdldEJ1Y2tldFBhcnRzKGEsIG8sIHRbdGhpcy5fY3VycmVudFRpbGVJbmRleF0sIHRoaXMuX3NvcnRBY3Jvc3NUaWxlcyksIHRoaXMuX2N1cnJlbnRUaWxlSW5kZXgrKywgcigpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodGhpcy5fc29ydEFjcm9zc1RpbGVzICYmICh0aGlzLl9zb3J0QWNyb3NzVGlsZXMgPSAhMSwgYS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KSk7IHRoaXMuX2N1cnJlbnRQYXJ0SW5kZXggPCBhLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKGUucGxhY2VMYXllckJ1Y2tldFBhcnQoYVt0aGlzLl9jdXJyZW50UGFydEluZGV4XSwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcywgaSksIHRoaXMuX2N1cnJlbnRQYXJ0SW5kZXgrKywgcigpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuXG4gICAgdmFyIExlID0gZnVuY3Rpb24gTGUodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdGhpcy5wbGFjZW1lbnQgPSBuZXcgYmUodCwgciwgYSwgbiksIHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA9IGUubGVuZ3RoIC0gMSwgdGhpcy5fZm9yY2VGdWxsUGxhY2VtZW50ID0gaSwgdGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzID0gbywgdGhpcy5fZG9uZSA9ICExO1xuICAgIH07XG5cbiAgICBMZS5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RvbmU7XG4gICAgfSwgTGUucHJvdG90eXBlLmNvbnRpbnVlUGxhY2VtZW50ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLCBhID0gdC5icm93c2VyLm5vdygpLCBuID0gZnVuY3Rpb24gbigpIHtcbiAgICAgICAgdmFyIGUgPSB0LmJyb3dzZXIubm93KCkgLSBhO1xuICAgICAgICByZXR1cm4gIXIuX2ZvcmNlRnVsbFBsYWNlbWVudCAmJiBlID4gMjtcbiAgICAgIH07IHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA+PSAwOykge1xuICAgICAgICB2YXIgcyA9IGlbZVt0aGlzLl9jdXJyZW50UGxhY2VtZW50SW5kZXhdXSxcbiAgICAgICAgICAgIGwgPSB0aGlzLnBsYWNlbWVudC5jb2xsaXNpb25JbmRleC50cmFuc2Zvcm0uem9vbTtcblxuICAgICAgICBpZiAoXCJzeW1ib2xcIiA9PT0gcy50eXBlICYmICghcy5taW56b29tIHx8IHMubWluem9vbSA8PSBsKSAmJiAoIXMubWF4em9vbSB8fCBzLm1heHpvb20gPiBsKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pblByb2dyZXNzTGF5ZXIgfHwgKHRoaXMuX2luUHJvZ3Jlc3NMYXllciA9IG5ldyBNZShzKSksIHRoaXMuX2luUHJvZ3Jlc3NMYXllci5jb250aW51ZVBsYWNlbWVudChvW3Muc291cmNlXSwgdGhpcy5wbGFjZW1lbnQsIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcywgcywgbikpIHJldHVybjtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faW5Qcm9ncmVzc0xheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFBsYWNlbWVudEluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RvbmUgPSAhMDtcbiAgICB9LCBMZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYWNlbWVudC5jb21taXQodCksIHRoaXMucGxhY2VtZW50O1xuICAgIH07XG5cbiAgICB2YXIgUmUgPSA1MTIgLyB0LkVYVEVOVCAvIDIsXG4gICAgICAgIGtlID0gZnVuY3Rpb24ga2UodCwgZSwgaSkge1xuICAgICAgdGhpcy50aWxlSUQgPSB0LCB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXMgPSB7fSwgdGhpcy5idWNrZXRJbnN0YW5jZUlkID0gaTtcblxuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciByID0gZS5nZXQobyksXG4gICAgICAgICAgICBhID0gci5rZXk7XG4gICAgICAgIHRoaXMuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1thXSB8fCAodGhpcy5pbmRleGVkU3ltYm9sSW5zdGFuY2VzW2FdID0gW10pLCB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXNbYV0ucHVzaCh7XG4gICAgICAgICAgY3Jvc3NUaWxlSUQ6IHIuY3Jvc3NUaWxlSUQsXG4gICAgICAgICAgY29vcmQ6IHRoaXMuZ2V0U2NhbGVkQ29vcmRpbmF0ZXMociwgdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGtlLnByb3RvdHlwZS5nZXRTY2FsZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IFJlIC8gTWF0aC5wb3coMiwgaS5jYW5vbmljYWwueiAtIHRoaXMudGlsZUlELmNhbm9uaWNhbC56KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoKGkuY2Fub25pY2FsLnggKiB0LkVYVEVOVCArIGUuYW5jaG9yWCkgKiBvKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcigoaS5jYW5vbmljYWwueSAqIHQuRVhURU5UICsgZS5hbmNob3JZKSAqIG8pXG4gICAgICB9O1xuICAgIH0sIGtlLnByb3RvdHlwZS5maW5kTWF0Y2hlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy50aWxlSUQuY2Fub25pY2FsLnogPCBlLmNhbm9uaWNhbC56ID8gMSA6IE1hdGgucG93KDIsIHRoaXMudGlsZUlELmNhbm9uaWNhbC56IC0gZS5jYW5vbmljYWwueiksIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgYSA9IHQuZ2V0KHIpO1xuXG4gICAgICAgIGlmICghYS5jcm9zc1RpbGVJRCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5pbmRleGVkU3ltYm9sSW5zdGFuY2VzW2Eua2V5XTtcbiAgICAgICAgICBpZiAobikgZm9yICh2YXIgcyA9IHRoaXMuZ2V0U2NhbGVkQ29vcmRpbmF0ZXMoYSwgZSksIGwgPSAwLCBjID0gbjsgbCA8IGMubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB1ID0gY1tsXTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHUuY29vcmQueCAtIHMueCkgPD0gbyAmJiBNYXRoLmFicyh1LmNvb3JkLnkgLSBzLnkpIDw9IG8gJiYgIWlbdS5jcm9zc1RpbGVJRF0pIHtcbiAgICAgICAgICAgICAgaVt1LmNyb3NzVGlsZUlEXSA9ICEwLCBhLmNyb3NzVGlsZUlEID0gdS5jcm9zc1RpbGVJRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBCZSA9IGZ1bmN0aW9uIEJlKCkge1xuICAgICAgdGhpcy5tYXhDcm9zc1RpbGVJRCA9IDA7XG4gICAgfTtcblxuICAgIEJlLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiArK3RoaXMubWF4Q3Jvc3NUaWxlSUQ7XG4gICAgfTtcblxuICAgIHZhciBPZSA9IGZ1bmN0aW9uIE9lKCkge1xuICAgICAgdGhpcy5pbmRleGVzID0ge30sIHRoaXMudXNlZENyb3NzVGlsZUlEcyA9IHt9LCB0aGlzLmxuZyA9IDA7XG4gICAgfTtcblxuICAgIE9lLnByb3RvdHlwZS5oYW5kbGVXcmFwSnVtcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE1hdGgucm91bmQoKHQgLSB0aGlzLmxuZykgLyAzNjApO1xuICAgICAgaWYgKDAgIT09IGUpIGZvciAodmFyIGkgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5pbmRleGVzW2ldLFxuICAgICAgICAgICAgciA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGEgaW4gbykge1xuICAgICAgICAgIHZhciBuID0gb1thXTtcbiAgICAgICAgICBuLnRpbGVJRCA9IG4udGlsZUlELnVud3JhcFRvKG4udGlsZUlELndyYXAgKyBlKSwgcltuLnRpbGVJRC5rZXldID0gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kZXhlc1tpXSA9IHI7XG4gICAgICB9XG4gICAgICB0aGlzLmxuZyA9IHQ7XG4gICAgfSwgT2UucHJvdG90eXBlLmFkZEJ1Y2tldCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdICYmIHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0uYnVja2V0SW5zdGFuY2VJZCA9PT0gZS5idWNrZXRJbnN0YW5jZUlkKSByZXR1cm4gITE7XG4gICAgICAgIHRoaXMucmVtb3ZlQnVja2V0Q3Jvc3NUaWxlSURzKHQub3ZlcnNjYWxlZFosIHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGUuc3ltYm9sSW5zdGFuY2VzLmdldChvKS5jcm9zc1RpbGVJRCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXNlZENyb3NzVGlsZUlEc1t0Lm92ZXJzY2FsZWRaXSB8fCAodGhpcy51c2VkQ3Jvc3NUaWxlSURzW3Qub3ZlcnNjYWxlZFpdID0ge30pO1xuICAgICAgdmFyIHIgPSB0aGlzLnVzZWRDcm9zc1RpbGVJRHNbdC5vdmVyc2NhbGVkWl07XG5cbiAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5pbmRleGVzW2FdO1xuICAgICAgICBpZiAoTnVtYmVyKGEpID4gdC5vdmVyc2NhbGVkWikgZm9yICh2YXIgcyBpbiBuKSB7XG4gICAgICAgICAgdmFyIGwgPSBuW3NdO1xuICAgICAgICAgIGwudGlsZUlELmlzQ2hpbGRPZih0KSAmJiBsLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYyA9IG5bdC5zY2FsZWRUbyhOdW1iZXIoYSkpLmtleV07XG4gICAgICAgICAgYyAmJiBjLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHZhciBoID0gZS5zeW1ib2xJbnN0YW5jZXMuZ2V0KHUpO1xuICAgICAgICBoLmNyb3NzVGlsZUlEIHx8IChoLmNyb3NzVGlsZUlEID0gaS5nZW5lcmF0ZSgpLCByW2guY3Jvc3NUaWxlSURdID0gITApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdm9pZCAwID09PSB0aGlzLmluZGV4ZXNbdC5vdmVyc2NhbGVkWl0gJiYgKHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXSA9IHt9KSwgdGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdW3Qua2V5XSA9IG5ldyBrZSh0LCBlLnN5bWJvbEluc3RhbmNlcywgZS5idWNrZXRJbnN0YW5jZUlkKSwgITA7XG4gICAgfSwgT2UucHJvdG90eXBlLnJlbW92ZUJ1Y2tldENyb3NzVGlsZUlEcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGUuaW5kZXhlZFN5bWJvbEluc3RhbmNlcykge1xuICAgICAgICBmb3IgKHZhciBvID0gMCwgciA9IGUuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1tpXTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy51c2VkQ3Jvc3NUaWxlSURzW3RdW3Jbb10uY3Jvc3NUaWxlSURdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgT2UucHJvdG90eXBlLnJlbW92ZVN0YWxlQnVja2V0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICExO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuaW5kZXhlc1tpXTtcblxuICAgICAgICBmb3IgKHZhciByIGluIG8pIHtcbiAgICAgICAgICB0W29bcl0uYnVja2V0SW5zdGFuY2VJZF0gfHwgKHRoaXMucmVtb3ZlQnVja2V0Q3Jvc3NUaWxlSURzKGksIG9bcl0pLCBkZWxldGUgb1tyXSwgZSA9ICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgdmFyIEZlID0gZnVuY3Rpb24gRmUoKSB7XG4gICAgICB0aGlzLmxheWVySW5kZXhlcyA9IHt9LCB0aGlzLmNyb3NzVGlsZUlEcyA9IG5ldyBCZSgpLCB0aGlzLm1heEJ1Y2tldEluc3RhbmNlSWQgPSAwLCB0aGlzLmJ1Y2tldHNJbkN1cnJlbnRQbGFjZW1lbnQgPSB7fTtcbiAgICB9O1xuXG4gICAgRmUucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5sYXllckluZGV4ZXNbdC5pZF07XG4gICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB0aGlzLmxheWVySW5kZXhlc1t0LmlkXSA9IG5ldyBPZSgpKTtcbiAgICAgIHZhciByID0gITEsXG4gICAgICAgICAgYSA9IHt9O1xuICAgICAgby5oYW5kbGVXcmFwSnVtcChpKTtcblxuICAgICAgZm9yICh2YXIgbiA9IDAsIHMgPSBlOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgbCA9IHNbbl0sXG4gICAgICAgICAgICBjID0gbC5nZXRCdWNrZXQodCk7XG4gICAgICAgIGMgJiYgdC5pZCA9PT0gYy5sYXllcklkc1swXSAmJiAoYy5idWNrZXRJbnN0YW5jZUlkIHx8IChjLmJ1Y2tldEluc3RhbmNlSWQgPSArK3RoaXMubWF4QnVja2V0SW5zdGFuY2VJZCksIG8uYWRkQnVja2V0KGwudGlsZUlELCBjLCB0aGlzLmNyb3NzVGlsZUlEcykgJiYgKHIgPSAhMCksIGFbYy5idWNrZXRJbnN0YW5jZUlkXSA9ICEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG8ucmVtb3ZlU3RhbGVCdWNrZXRzKGEpICYmIChyID0gITApLCByO1xuICAgIH0sIEZlLnByb3RvdHlwZS5wcnVuZVVudXNlZExheWVycyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBlW3RdID0gITA7XG4gICAgICB9KSwgdGhpcy5sYXllckluZGV4ZXMpIHtcbiAgICAgICAgZVtpXSB8fCBkZWxldGUgdGhpcy5sYXllckluZGV4ZXNbaV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBVZSA9IGZ1bmN0aW9uIFVlKGUsIGkpIHtcbiAgICAgIHJldHVybiB0LmVtaXRWYWxpZGF0aW9uRXJyb3JzKGUsIGkgJiYgaS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwic291cmNlLmNhbnZhc1wiICE9PSB0LmlkZW50aWZpZXI7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICAgICAgTmUgPSB0LnBpY2soWnQsIFtcImFkZExheWVyXCIsIFwicmVtb3ZlTGF5ZXJcIiwgXCJzZXRQYWludFByb3BlcnR5XCIsIFwic2V0TGF5b3V0UHJvcGVydHlcIiwgXCJzZXRGaWx0ZXJcIiwgXCJhZGRTb3VyY2VcIiwgXCJyZW1vdmVTb3VyY2VcIiwgXCJzZXRMYXllclpvb21SYW5nZVwiLCBcInNldExpZ2h0XCIsIFwic2V0VHJhbnNpdGlvblwiLCBcInNldEdlb0pTT05Tb3VyY2VEYXRhXCJdKSxcbiAgICAgICAgWmUgPSB0LnBpY2soWnQsIFtcInNldENlbnRlclwiLCBcInNldFpvb21cIiwgXCJzZXRCZWFyaW5nXCIsIFwic2V0UGl0Y2hcIl0pLFxuICAgICAgICBxZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgaSA9IHQuc3R5bGVTcGVjLiR2ZXJzaW9uO1xuXG4gICAgICBmb3IgKHZhciBvIGluIHQuc3R5bGVTcGVjLiRyb290KSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgICAgYSA9IHQuc3R5bGVTcGVjLiRyb290W29dO1xuICAgICAgICBpZiAoYS5yZXF1aXJlZCkgbnVsbCAhPSAociA9IFwidmVyc2lvblwiID09PSBvID8gaSA6IFwiYXJyYXlcIiA9PT0gYS50eXBlID8gW10gOiB7fSkgJiYgKGVbb10gPSByKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfSgpLFxuICAgICAgICBqZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKG8sIHIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIGUuY2FsbCh0aGlzKSwgdGhpcy5tYXAgPSBvLCB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgRShGdCgpLCB0aGlzKSwgdGhpcy5pbWFnZU1hbmFnZXIgPSBuZXcgcCgpLCB0aGlzLmltYWdlTWFuYWdlci5zZXRFdmVudGVkUGFyZW50KHRoaXMpLCB0aGlzLmdseXBoTWFuYWdlciA9IG5ldyB5KG8uX3JlcXVlc3RNYW5hZ2VyLCByLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSksIHRoaXMubGluZUF0bGFzID0gbmV3IFQoMjU2LCA1MTIpLCB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4ID0gbmV3IEZlKCksIHRoaXMuX2xheWVycyA9IHt9LCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzID0ge30sIHRoaXMuX29yZGVyID0gW10sIHRoaXMuc291cmNlQ2FjaGVzID0ge30sIHRoaXMuem9vbUhpc3RvcnkgPSBuZXcgdC5ab29tSGlzdG9yeSgpLCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzID0gW10sIHRoaXMuX3Jlc2V0VXBkYXRlcygpLCB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0UmVmZXJyZXJcIiwgdC5nZXRSZWZlcnJlcigpKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICB0aGlzLl9ydGxUZXh0UGx1Z2luQ2FsbGJhY2sgPSBpLnJlZ2lzdGVyRm9yUGx1Z2luU3RhdGVDaGFuZ2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBuLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic3luY1JUTFBsdWdpblN0YXRlXCIsIHtcbiAgICAgICAgICAgIHBsdWdpblN0YXR1czogZS5wbHVnaW5TdGF0dXMsXG4gICAgICAgICAgICBwbHVnaW5VUkw6IGUucGx1Z2luVVJMXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIGlmICh0LnRyaWdnZXJQbHVnaW5Db21wbGV0aW9uRXZlbnQoZSksIGkgJiYgaS5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0pKSBmb3IgKHZhciBvIGluIG4uc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICAgIG4uc291cmNlQ2FjaGVzW29dLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdGhpcy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcIm1ldGFkYXRhXCIgPT09IHQuc291cmNlRGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBlID0gYS5zb3VyY2VDYWNoZXNbdC5zb3VyY2VJZF07XG5cbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gZS5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgICAgaWYgKGkgJiYgaS52ZWN0b3JMYXllcklkcykgZm9yICh2YXIgbyBpbiBhLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGEuX2xheWVyc1tvXTtcbiAgICAgICAgICAgICAgICByLnNvdXJjZSA9PT0gaS5pZCAmJiBhLl92YWxpZGF0ZUxheWVyKHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZFVSTCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcztcbiAgICAgICAgdm9pZCAwID09PSBpICYmIChpID0ge30pLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByID0gXCJib29sZWFuXCIgPT0gdHlwZW9mIGkudmFsaWRhdGUgPyBpLnZhbGlkYXRlIDogIXQuaXNNYXBib3hVUkwoZSk7XG4gICAgICAgIGUgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplU3R5bGVVUkwoZSwgaS5hY2Nlc3NUb2tlbik7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChlLCB0LlJlc291cmNlVHlwZS5TdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHQuZ2V0SlNPTihhLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIG8uX3JlcXVlc3QgPSBudWxsLCBlID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpIDogaSAmJiBvLl9sb2FkKGksIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRKU09OID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSB7fSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzdHlsZVwiXG4gICAgICAgIH0pKSwgdGhpcy5fcmVxdWVzdCA9IHQuYnJvd3Nlci5mcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgby5fcmVxdWVzdCA9IG51bGwsIG8uX2xvYWQoZSwgITEgIT09IGkudmFsaWRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgfSkpLCB0aGlzLl9sb2FkKHFlLCAhMSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGlmICghaSB8fCAhVWUodGhpcywgdC52YWxpZGF0ZVN0eWxlKGUpKSkge1xuICAgICAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5fbG9hZGVkID0gITAsIHRoaXMuc3R5bGVzaGVldCA9IGUsIGUuc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2UobywgZS5zb3VyY2VzW29dLCB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5zcHJpdGUgPyB0aGlzLl9sb2FkU3ByaXRlKGUuc3ByaXRlKSA6IHRoaXMuaW1hZ2VNYW5hZ2VyLnNldExvYWRlZCghMCksIHRoaXMuZ2x5cGhNYW5hZ2VyLnNldFVSTChlLmdseXBocyk7XG4gICAgICAgICAgdmFyIHIgPSBOdCh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcbiAgICAgICAgICB0aGlzLl9vcmRlciA9IHIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzID0ge30sIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gcjsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gblthXTtcbiAgICAgICAgICAgIChzID0gdC5jcmVhdGVTdHlsZUxheWVyKHMpKS5zZXRFdmVudGVkUGFyZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogcy5pZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzW3MuaWRdID0gcywgdGhpcy5fc2VyaWFsaXplZExheWVyc1tzLmlkXSA9IHMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcInNldExheWVyc1wiLCB0aGlzLl9zZXJpYWxpemVMYXllcnModGhpcy5fb3JkZXIpKSwgdGhpcy5saWdodCA9IG5ldyB3KHRoaXMuc3R5bGVzaGVldC5saWdodCksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwic3R5bGUubG9hZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9sb2FkU3ByaXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHZhciByLFxuICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICBzID0gdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxID8gXCJAMnhcIiA6IFwiXCIsXG4gICAgICAgICAgICAgIGwgPSB0LmdldEpTT04oaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU3ByaXRlVVJMKGUsIHMsIFwiLmpzb25cIiksIHQuUmVzb3VyY2VUeXBlLlNwcml0ZUpTT04pLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgbCA9IG51bGwsIG4gfHwgKG4gPSB0LCByID0gZSwgdSgpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYyA9IHQuZ2V0SW1hZ2UoaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU3ByaXRlVVJMKGUsIHMsIFwiLnBuZ1wiKSwgdC5SZXNvdXJjZVR5cGUuU3ByaXRlSW1hZ2UpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgYyA9IG51bGwsIG4gfHwgKG4gPSB0LCBhID0gZSwgdSgpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgICBpZiAobikgbyhuKTtlbHNlIGlmIChyICYmIGEpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGEpLFxuICAgICAgICAgICAgICAgICAgaSA9IHt9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gcikge1xuICAgICAgICAgICAgICAgIHZhciBsID0gcltzXSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IGwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHUgPSBsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaCA9IGwueCxcbiAgICAgICAgICAgICAgICAgICAgcCA9IGwueSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGwuc2RmLFxuICAgICAgICAgICAgICAgICAgICBfID0gbC5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICBmID0gbC5zdHJldGNoWCxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGwuc3RyZXRjaFksXG4gICAgICAgICAgICAgICAgICAgIGcgPSBsLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHYgPSBuZXcgdC5SR0JBSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGMsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IHVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0LlJHQkFJbWFnZS5jb3B5KGUsIHYsIHtcbiAgICAgICAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICAgICAgICB5OiBwXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogYyxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdVxuICAgICAgICAgICAgICAgIH0pLCBpW3NdID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdixcbiAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IF8sXG4gICAgICAgICAgICAgICAgICBzZGY6IGQsXG4gICAgICAgICAgICAgICAgICBzdHJldGNoWDogZixcbiAgICAgICAgICAgICAgICAgIHN0cmV0Y2hZOiBtLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvKG51bGwsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgbCAmJiAobC5jYW5jZWwoKSwgbCA9IG51bGwpLCBjICYmIChjLmNhbmNlbCgpLCBjID0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfShlLCB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIsIGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICAgICAgaWYgKGkuX3Nwcml0ZVJlcXVlc3QgPSBudWxsLCBlKSBpLmZpcmUobmV3IHQuRXJyb3JFdmVudChlKSk7ZWxzZSBpZiAobykgZm9yICh2YXIgciBpbiBvKSB7XG4gICAgICAgICAgICBpLmltYWdlTWFuYWdlci5hZGRJbWFnZShyLCBvW3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaS5pbWFnZU1hbmFnZXIuc2V0TG9hZGVkKCEwKSwgaS5fYXZhaWxhYmxlSW1hZ2VzID0gaS5pbWFnZU1hbmFnZXIubGlzdEltYWdlcygpLCBpLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0SW1hZ2VzXCIsIGkuX2F2YWlsYWJsZUltYWdlcyksIGkuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5zb3VyY2VDYWNoZXNbZS5zb3VyY2VdO1xuXG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFyIG8gPSBlLnNvdXJjZUxheWVyO1xuXG4gICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIHZhciByID0gaS5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIChcImdlb2pzb25cIiA9PT0gci50eXBlIHx8IHIudmVjdG9yTGF5ZXJJZHMgJiYgLTEgPT09IHIudmVjdG9yTGF5ZXJJZHMuaW5kZXhPZihvKSkgJiYgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdTb3VyY2UgbGF5ZXIgXCInICsgbyArICdcIiBkb2VzIG5vdCBleGlzdCBvbiBzb3VyY2UgXCInICsgci5pZCArICdcIiBhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgZS5pZCArICdcIicpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl91cGRhdGVkU291cmNlcykubGVuZ3RoKSByZXR1cm4gITE7XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VDYWNoZXNbdF0ubG9hZGVkKCkpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIXRoaXMuaW1hZ2VNYW5hZ2VyLmlzTG9hZGVkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fc2VyaWFsaXplTGF5ZXJzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBpID0gMCwgbyA9IHQ7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9sYXllcnNbb1tpXV07XG4gICAgICAgICAgXCJjdXN0b21cIiAhPT0gci50eXBlICYmIGUucHVzaChyLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpZ2h0ICYmIHRoaXMubGlnaHQuaGFzVHJhbnNpdGlvbigpKSByZXR1cm4gITA7XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlc1t0XS5oYXNUcmFuc2l0aW9uKCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tlXS5oYXNUcmFuc2l0aW9uKCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9jaGVja0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHRocm93IG5ldyBFcnJvcihcIlN0eWxlIGlzIG5vdCBkb25lIGxvYWRpbmdcIik7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9jaGFuZ2VkO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmtleXModGhpcy5fdXBkYXRlZExheWVycyksXG4gICAgICAgICAgICAgICAgciA9IE9iamVjdC5rZXlzKHRoaXMuX3JlbW92ZWRMYXllcnMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhIGluIChvLmxlbmd0aCB8fCByLmxlbmd0aCkgJiYgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKG8sIHIpLCB0aGlzLl91cGRhdGVkU291cmNlcykge1xuICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2FdO1xuICAgICAgICAgICAgICBcInJlbG9hZFwiID09PSBuID8gdGhpcy5fcmVsb2FkU291cmNlKGEpIDogXCJjbGVhclwiID09PSBuICYmIHRoaXMuX2NsZWFyU291cmNlKGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX3VwZGF0ZVRpbGVzRm9yQ2hhbmdlZEltYWdlcygpLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbc10udXBkYXRlVHJhbnNpdGlvbnMoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGlnaHQudXBkYXRlVHJhbnNpdGlvbnMoZSksIHRoaXMuX3Jlc2V0VXBkYXRlcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBjIGluIHRoaXMuc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXMuc291cmNlQ2FjaGVzW2NdO1xuICAgICAgICAgICAgbFtjXSA9IHUudXNlZCwgdS51c2VkID0gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaCA9IDAsIHAgPSB0aGlzLl9vcmRlcjsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5fbGF5ZXJzW3BbaF1dO1xuICAgICAgICAgICAgZC5yZWNhbGN1bGF0ZShlLCB0aGlzLl9hdmFpbGFibGVJbWFnZXMpLCAhZC5pc0hpZGRlbihlLnpvb20pICYmIGQuc291cmNlICYmICh0aGlzLnNvdXJjZUNhY2hlc1tkLnNvdXJjZV0udXNlZCA9ICEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfIGluIGwpIHtcbiAgICAgICAgICAgIHZhciBmID0gdGhpcy5zb3VyY2VDYWNoZXNbX107XG4gICAgICAgICAgICBsW19dICE9PSBmLnVzZWQgJiYgZi5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUlkOiBfXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saWdodC5yZWNhbGN1bGF0ZShlKSwgdGhpcy56ID0gZS56b29tLCBpICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVRpbGVzRm9yQ2hhbmdlZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VkSW1hZ2VzKTtcblxuICAgICAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMuc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlc1tlXS5yZWxvYWRUaWxlc0ZvckRlcGVuZGVuY2llcyhbXCJpY29uc1wiLCBcInBhdHRlcm5zXCJdLCB0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkSW1hZ2VzID0ge307XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVXb3JrZXJMYXllcnMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwidXBkYXRlTGF5ZXJzXCIsIHtcbiAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0KSxcbiAgICAgICAgICByZW1vdmVkSWRzOiBlXG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3Jlc2V0VXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9ICExLCB0aGlzLl91cGRhdGVkTGF5ZXJzID0ge30sIHRoaXMuX3JlbW92ZWRMYXllcnMgPSB7fSwgdGhpcy5fdXBkYXRlZFNvdXJjZXMgPSB7fSwgdGhpcy5fdXBkYXRlZFBhaW50UHJvcHMgPSB7fSwgdGhpcy5fY2hhbmdlZEltYWdlcyA9IHt9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja0xvYWRlZCgpLCBVZSh0aGlzLCB0LnZhbGlkYXRlU3R5bGUoZSkpKSByZXR1cm4gITE7XG4gICAgICAgIChlID0gdC5jbG9uZSQxKGUpKS5sYXllcnMgPSBOdChlLmxheWVycyk7XG5cbiAgICAgICAgdmFyIG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuIFt7XG4gICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgIGFyZ3M6IFtpXVxuICAgICAgICAgIH1dO1xuICAgICAgICAgIHZhciBvID0gW107XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChlLnZlcnNpb24sIGkudmVyc2lvbikpIHJldHVybiBbe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgYXJnczogW2ldXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHQuZGVlcEVxdWFsKGUuY2VudGVyLCBpLmNlbnRlcikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0Q2VudGVyLFxuICAgICAgICAgICAgICBhcmdzOiBbaS5jZW50ZXJdXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS56b29tLCBpLnpvb20pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldFpvb20sXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLnpvb21dXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5iZWFyaW5nLCBpLmJlYXJpbmcpIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldEJlYXJpbmcsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLmJlYXJpbmddXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5waXRjaCwgaS5waXRjaCkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0UGl0Y2gsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLnBpdGNoXVxuICAgICAgICAgICAgfSksIHQuZGVlcEVxdWFsKGUuc3ByaXRlLCBpLnNwcml0ZSkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0U3ByaXRlLFxuICAgICAgICAgICAgICBhcmdzOiBbaS5zcHJpdGVdXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5nbHlwaHMsIGkuZ2x5cGhzKSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRHbHlwaHMsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLmdseXBoc11cbiAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLnRyYW5zaXRpb24sIGkudHJhbnNpdGlvbikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0VHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgYXJnczogW2kudHJhbnNpdGlvbl1cbiAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLmxpZ2h0LCBpLmxpZ2h0KSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRMaWdodCxcbiAgICAgICAgICAgICAgYXJnczogW2kubGlnaHRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByID0ge30sXG4gICAgICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgIWZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgICAgICAgIHZhciBhO1xuXG4gICAgICAgICAgICAgIGZvciAoYSBpbiBpID0gaSB8fCB7fSwgZSA9IGUgfHwge30pIHtcbiAgICAgICAgICAgICAgICBlLmhhc093blByb3BlcnR5KGEpICYmIChpLmhhc093blByb3BlcnR5KGEpIHx8IGp0KGEsIG8sIHIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoYSBpbiBpKSB7XG4gICAgICAgICAgICAgICAgaS5oYXNPd25Qcm9wZXJ0eShhKSAmJiAoZS5oYXNPd25Qcm9wZXJ0eShhKSA/IHQuZGVlcEVxdWFsKGVbYV0sIGlbYV0pIHx8IChcImdlb2pzb25cIiA9PT0gZVthXS50eXBlICYmIFwiZ2VvanNvblwiID09PSBpW2FdLnR5cGUgJiYgR3QoZSwgaSwgYSkgPyBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbYSwgaVthXS5kYXRhXVxuICAgICAgICAgICAgICAgIH0pIDogVnQoYSwgaSwgbywgcikpIDogcXQoYSwgaSwgbykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KGUuc291cmNlcywgaS5zb3VyY2VzLCBhLCByKTtcbiAgICAgICAgICAgIHZhciBuID0gW107XG4gICAgICAgICAgICBlLmxheWVycyAmJiBlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJbdC5zb3VyY2VdID8gby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdC5pZF1cbiAgICAgICAgICAgICAgfSkgOiBuLnB1c2godCk7XG4gICAgICAgICAgICB9KSwgbyA9IG8uY29uY2F0KGEpLCBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgICAgICBpID0gaSB8fCBbXTtcblxuICAgICAgICAgICAgICB2YXIgcixcbiAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgICAgIGggPSAoZSA9IGUgfHwgW10pLm1hcChYdCksXG4gICAgICAgICAgICAgICAgICBwID0gaS5tYXAoWHQpLFxuICAgICAgICAgICAgICAgICAgZCA9IGUucmVkdWNlKEh0LCB7fSksXG4gICAgICAgICAgICAgICAgICBfID0gaS5yZWR1Y2UoSHQsIHt9KSxcbiAgICAgICAgICAgICAgICAgIGYgPSBoLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICBtID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IGgubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICBfLmhhc093blByb3BlcnR5KG4gPSBoW3JdKSA/IGErKyA6IChvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbl1cbiAgICAgICAgICAgICAgICB9KSwgZi5zcGxpY2UoZi5pbmRleE9mKG4sIGEpLCAxKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IHAubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICBmW2YubGVuZ3RoIC0gMSAtIHJdICE9PSAobiA9IHBbcC5sZW5ndGggLSAxIC0gcl0pICYmIChkLmhhc093blByb3BlcnR5KG4pID8gKG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuXVxuICAgICAgICAgICAgICAgIH0pLCBmLnNwbGljZShmLmxhc3RJbmRleE9mKG4sIGYubGVuZ3RoIC0gYSksIDEpKSA6IGErKywgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LmFkZExheWVyLFxuICAgICAgICAgICAgICAgICAgYXJnczogW19bbl0sIGMgPSBmW2YubGVuZ3RoIC0gcl1dXG4gICAgICAgICAgICAgICAgfSksIGYuc3BsaWNlKGYubGVuZ3RoIC0gciwgMCwgbiksIG1bbl0gPSAhMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgcC5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIGlmIChzID0gZFtuID0gcFtyXV0sIGwgPSBfW25dLCAhbVtuXSAmJiAhdC5kZWVwRXF1YWwocywgbCkpIGlmICh0LmRlZXBFcXVhbChzLnNvdXJjZSwgbC5zb3VyY2UpICYmIHQuZGVlcEVxdWFsKHNbXCJzb3VyY2UtbGF5ZXJcIl0sIGxbXCJzb3VyY2UtbGF5ZXJcIl0pICYmIHQuZGVlcEVxdWFsKHMudHlwZSwgbC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh1IGluIFd0KHMubGF5b3V0LCBsLmxheW91dCwgbywgbiwgbnVsbCwgWnQuc2V0TGF5b3V0UHJvcGVydHkpLCBXdChzLnBhaW50LCBsLnBhaW50LCBvLCBuLCBudWxsLCBadC5zZXRQYWludFByb3BlcnR5KSwgdC5kZWVwRXF1YWwocy5maWx0ZXIsIGwuZmlsdGVyKSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuLCBsLmZpbHRlcl1cbiAgICAgICAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChzLm1pbnpvb20sIGwubWluem9vbSkgJiYgdC5kZWVwRXF1YWwocy5tYXh6b29tLCBsLm1heHpvb20pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldExheWVyWm9vbVJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgbC5taW56b29tLCBsLm1heHpvb21dXG4gICAgICAgICAgICAgICAgICB9KSwgcykge1xuICAgICAgICAgICAgICAgICAgICBzLmhhc093blByb3BlcnR5KHUpICYmIFwibGF5b3V0XCIgIT09IHUgJiYgXCJwYWludFwiICE9PSB1ICYmIFwiZmlsdGVyXCIgIT09IHUgJiYgXCJtZXRhZGF0YVwiICE9PSB1ICYmIFwibWluem9vbVwiICE9PSB1ICYmIFwibWF4em9vbVwiICE9PSB1ICYmICgwID09PSB1LmluZGV4T2YoXCJwYWludC5cIikgPyBXdChzW3VdLCBsW3VdLCBvLCBuLCB1LnNsaWNlKDYpLCBadC5zZXRQYWludFByb3BlcnR5KSA6IHQuZGVlcEVxdWFsKHNbdV0sIGxbdV0pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgdSwgbFt1XV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHUgaW4gbCkge1xuICAgICAgICAgICAgICAgICAgICBsLmhhc093blByb3BlcnR5KHUpICYmICFzLmhhc093blByb3BlcnR5KHUpICYmIFwibGF5b3V0XCIgIT09IHUgJiYgXCJwYWludFwiICE9PSB1ICYmIFwiZmlsdGVyXCIgIT09IHUgJiYgXCJtZXRhZGF0YVwiICE9PSB1ICYmIFwibWluem9vbVwiICE9PSB1ICYmIFwibWF4em9vbVwiICE9PSB1ICYmICgwID09PSB1LmluZGV4T2YoXCJwYWludC5cIikgPyBXdChzW3VdLCBsW3VdLCBvLCBuLCB1LnNsaWNlKDYpLCBadC5zZXRQYWludFByb3BlcnR5KSA6IHQuZGVlcEVxdWFsKHNbdV0sIGxbdV0pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgdSwgbFt1XV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbl1cbiAgICAgICAgICAgICAgICB9KSwgYyA9IGZbZi5sYXN0SW5kZXhPZihuKSArIDFdLCBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuYWRkTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbCwgY11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShuLCBpLmxheWVycywgbyk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjpcIiwgdCksIG8gPSBbe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgYXJnczogW2ldXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSh0aGlzLnNlcmlhbGl6ZSgpLCBlKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gISh0LmNvbW1hbmQgaW4gWmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoMCA9PT0gby5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgdmFyIHIgPSBvLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhKHQuY29tbWFuZCBpbiBOZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoci5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkOiBcIiArIHIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuY29tbWFuZDtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgXCJzZXRUcmFuc2l0aW9uXCIgIT09IHQuY29tbWFuZCAmJiBpW3QuY29tbWFuZF0uYXBwbHkoaSwgdC5hcmdzKTtcbiAgICAgICAgfSksIHRoaXMuc3R5bGVzaGVldCA9IGUsICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAodGhpcy5nZXRJbWFnZShlKSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkFuIGltYWdlIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKSkpO1xuICAgICAgICB0aGlzLmltYWdlTWFuYWdlci5hZGRJbWFnZShlLCBpKSwgdGhpcy5fYWZ0ZXJJbWFnZVVwZGF0ZWQoZSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVJbWFnZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnVwZGF0ZUltYWdlKHQsIGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZU1hbmFnZXIuZ2V0SW1hZ2UodCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRJbWFnZShlKSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIk5vIGltYWdlIHdpdGggdGhpcyBuYW1lIGV4aXN0cy5cIikpKTtcbiAgICAgICAgdGhpcy5pbWFnZU1hbmFnZXIucmVtb3ZlSW1hZ2UoZSksIHRoaXMuX2FmdGVySW1hZ2VVcGRhdGVkKGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2FmdGVySW1hZ2VVcGRhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzID0gdGhpcy5pbWFnZU1hbmFnZXIubGlzdEltYWdlcygpLCB0aGlzLl9jaGFuZ2VkSW1hZ2VzW2VdID0gITAsIHRoaXMuX2NoYW5nZWQgPSAhMCwgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcInNldEltYWdlc1wiLCB0aGlzLl9hdmFpbGFibGVJbWFnZXMpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzdHlsZVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxpc3RJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja0xvYWRlZCgpLCB0aGlzLmltYWdlTWFuYWdlci5saXN0SW1hZ2VzKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCksIHZvaWQgMCAhPT0gdGhpcy5zb3VyY2VDYWNoZXNbZV0pIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGFscmVhZHkgYSBzb3VyY2Ugd2l0aCB0aGlzIElEXCIpO1xuICAgICAgICBpZiAoIWkudHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgcHJvcGVydHkgbXVzdCBiZSBkZWZpbmVkLCBidXQgb25seSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBnaXZlbjogXCIgKyBPYmplY3Qua2V5cyhpKS5qb2luKFwiLCBcIikgKyBcIi5cIik7XG5cbiAgICAgICAgaWYgKCEoW1widmVjdG9yXCIsIFwicmFzdGVyXCIsIFwiZ2VvanNvblwiLCBcInZpZGVvXCIsIFwiaW1hZ2VcIl0uaW5kZXhPZihpLnR5cGUpID49IDAgJiYgdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLnNvdXJjZSwgXCJzb3VyY2VzLlwiICsgZSwgaSwgbnVsbCwgbykpKSB7XG4gICAgICAgICAgdGhpcy5tYXAgJiYgdGhpcy5tYXAuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyAmJiAoaS5jb2xsZWN0UmVzb3VyY2VUaW1pbmcgPSAhMCk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLnNvdXJjZUNhY2hlc1tlXSA9IG5ldyBEdChlLCBpLCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICAgIGEuc3R5bGUgPSB0aGlzLCBhLnNldEV2ZW50ZWRQYXJlbnQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNTb3VyY2VMb2FkZWQ6IHIubG9hZGVkKCksXG4gICAgICAgICAgICAgIHNvdXJjZTogYS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgc291cmNlSWQ6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksIGEub25BZGQodGhpcy5tYXApLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja0xvYWRlZCgpLCB2b2lkIDAgPT09IHRoaXMuc291cmNlQ2FjaGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCB0aGlzIElEXCIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tpXS5zb3VyY2UgPT09IGUpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ1NvdXJjZSBcIicgKyBlICsgJ1wiIGNhbm5vdCBiZSByZW1vdmVkIHdoaWxlIGxheWVyIFwiJyArIGkgKyAnXCIgaXMgdXNpbmcgaXQuJykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvID0gdGhpcy5zb3VyY2VDYWNoZXNbZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZUNhY2hlc1tlXSwgZGVsZXRlIHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2VdLCBvLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiLFxuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgIHNvdXJjZUlkOiBlXG4gICAgICAgIH0pKSwgby5zZXRFdmVudGVkUGFyZW50KG51bGwpLCBvLmNsZWFyVGlsZXMoKSwgby5vblJlbW92ZSAmJiBvLm9uUmVtb3ZlKHRoaXMubWFwKSwgdGhpcy5fY2hhbmdlZCA9ICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0R2VvSlNPTlNvdXJjZURhdGEgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpLCB0aGlzLnNvdXJjZUNhY2hlc1t0XS5nZXRTb3VyY2UoKS5zZXREYXRhKGUpLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZXNbdF0gJiYgdGhpcy5zb3VyY2VDYWNoZXNbdF0uZ2V0U291cmNlKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIHIgPSBlLmlkO1xuICAgICAgICBpZiAodGhpcy5nZXRMYXllcihyKSkgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdMYXllciB3aXRoIGlkIFwiJyArIHIgKyAnXCIgYWxyZWFkeSBleGlzdHMgb24gdGhpcyBtYXAnKSkpO2Vsc2Uge1xuICAgICAgICAgIHZhciBhO1xuXG4gICAgICAgICAgaWYgKFwiY3VzdG9tXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgaWYgKFVlKHRoaXMsIHQudmFsaWRhdGVDdXN0b21TdHlsZUxheWVyKGUpKSkgcmV0dXJuO1xuICAgICAgICAgICAgYSA9IHQuY3JlYXRlU3R5bGVMYXllcihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUuc291cmNlICYmICh0aGlzLmFkZFNvdXJjZShyLCBlLnNvdXJjZSksIGUgPSB0LmNsb25lJDEoZSksIGUgPSB0LmV4dGVuZChlLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogclxuICAgICAgICAgICAgfSkpLCB0aGlzLl92YWxpZGF0ZSh0LnZhbGlkYXRlU3R5bGUubGF5ZXIsIFwibGF5ZXJzLlwiICsgciwgZSwge1xuICAgICAgICAgICAgICBhcnJheUluZGV4OiAtMVxuICAgICAgICAgICAgfSwgbykpIHJldHVybjtcbiAgICAgICAgICAgIGEgPSB0LmNyZWF0ZVN0eWxlTGF5ZXIoZSksIHRoaXMuX3ZhbGlkYXRlTGF5ZXIoYSksIGEuc2V0RXZlbnRlZFBhcmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbYS5pZF0gPSBhLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuID0gaSA/IHRoaXMuX29yZGVyLmluZGV4T2YoaSkgOiB0aGlzLl9vcmRlci5sZW5ndGg7XG4gICAgICAgICAgaWYgKGkgJiYgLTEgPT09IG4pIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignTGF5ZXIgd2l0aCBpZCBcIicgKyBpICsgJ1wiIGRvZXMgbm90IGV4aXN0IG9uIHRoaXMgbWFwLicpKSk7ZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3JkZXIuc3BsaWNlKG4sIDAsIHIpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICEwLCB0aGlzLl9sYXllcnNbcl0gPSBhLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW3JdICYmIGEuc291cmNlICYmIFwiY3VzdG9tXCIgIT09IGEudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX3JlbW92ZWRMYXllcnNbcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW1vdmVkTGF5ZXJzW3JdLCBzLnR5cGUgIT09IGEudHlwZSA/IHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2Euc291cmNlXSA9IFwiY2xlYXJcIiA6ICh0aGlzLl91cGRhdGVkU291cmNlc1thLnNvdXJjZV0gPSBcInJlbG9hZFwiLCB0aGlzLnNvdXJjZUNhY2hlc1thLnNvdXJjZV0ucGF1c2UoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKGEpLCBhLm9uQWRkICYmIGEub25BZGQodGhpcy5tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrTG9hZGVkKCksIHRoaXMuX2NoYW5nZWQgPSAhMCwgdGhpcy5fbGF5ZXJzW2VdKSB7XG4gICAgICAgICAgaWYgKGUgIT09IGkpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcblxuICAgICAgICAgICAgdGhpcy5fb3JkZXIuc3BsaWNlKG8sIDEpO1xuXG4gICAgICAgICAgICB2YXIgciA9IGkgPyB0aGlzLl9vcmRlci5pbmRleE9mKGkpIDogdGhpcy5fb3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaSAmJiAtMSA9PT0gciA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignTGF5ZXIgd2l0aCBpZCBcIicgKyBpICsgJ1wiIGRvZXMgbm90IGV4aXN0IG9uIHRoaXMgbWFwLicpKSkgOiAodGhpcy5fb3JkZXIuc3BsaWNlKHIsIDAsIGUpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBtb3ZlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgaSA9IHRoaXMuX2xheWVyc1tlXTtcblxuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGkuc2V0RXZlbnRlZFBhcmVudChudWxsKTtcblxuICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcblxuICAgICAgICAgIHRoaXMuX29yZGVyLnNwbGljZShvLCAxKSwgdGhpcy5fbGF5ZXJPcmRlckNoYW5nZWQgPSAhMCwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW2VdID0gaSwgZGVsZXRlIHRoaXMuX2xheWVyc1tlXSwgZGVsZXRlIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbZV0sIGRlbGV0ZSB0aGlzLl91cGRhdGVkTGF5ZXJzW2VdLCBkZWxldGUgdGhpcy5fdXBkYXRlZFBhaW50UHJvcHNbZV0sIGkub25SZW1vdmUgJiYgaS5vblJlbW92ZSh0aGlzLm1hcCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSByZW1vdmVkLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW3RdO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCBpbiB0aGlzLl9sYXllcnM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICByID8gci5taW56b29tID09PSBpICYmIHIubWF4em9vbSA9PT0gbyB8fCAobnVsbCAhPSBpICYmIChyLm1pbnpvb20gPSBpKSwgbnVsbCAhPSBvICYmIChyLm1heHpvb20gPSBvKSwgdGhpcy5fdXBkYXRlTGF5ZXIocikpIDogdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIGxheWVyICdcIiArIGUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlIGFuZCBjYW5ub3QgaGF2ZSB6b29tIGV4dGVudC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldExheWVyKGUpO1xuXG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChyLmZpbHRlciwgaSkpIHJldHVybiBudWxsID09IGkgPyAoci5maWx0ZXIgPSB2b2lkIDAsIHZvaWQgdGhpcy5fdXBkYXRlTGF5ZXIocikpIDogdm9pZCAodGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLmZpbHRlciwgXCJsYXllcnMuXCIgKyByLmlkICsgXCIuZmlsdGVyXCIsIGksIG51bGwsIG8pIHx8IChyLmZpbHRlciA9IHQuY2xvbmUkMShpKSwgdGhpcy5fdXBkYXRlTGF5ZXIocikpKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIGZpbHRlcmVkLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHQuY2xvbmUkMSh0aGlzLmdldExheWVyKGUpLmZpbHRlcik7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICBhID8gdC5kZWVwRXF1YWwoYS5nZXRMYXlvdXRQcm9wZXJ0eShpKSwgbykgfHwgKGEuc2V0TGF5b3V0UHJvcGVydHkoaSwgbywgciksIHRoaXMuX3VwZGF0ZUxheWVyKGEpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHN0eWxlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICBpZiAobykgcmV0dXJuIG8uZ2V0TGF5b3V0UHJvcGVydHkoaSk7XG4gICAgICAgIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZS5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRMYXllcihlKTtcbiAgICAgICAgYSA/IHQuZGVlcEVxdWFsKGEuZ2V0UGFpbnRQcm9wZXJ0eShpKSwgbykgfHwgKGEuc2V0UGFpbnRQcm9wZXJ0eShpLCBvLCByKSAmJiB0aGlzLl91cGRhdGVMYXllcihhKSwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wc1tlXSA9ICEwKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHN0eWxlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcih0KS5nZXRQYWludFByb3BlcnR5KGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbyA9IGUuc291cmNlLFxuICAgICAgICAgICAgciA9IGUuc291cmNlTGF5ZXIsXG4gICAgICAgICAgICBhID0gdGhpcy5zb3VyY2VDYWNoZXNbb107XG5cbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSkge1xuICAgICAgICAgIHZhciBuID0gYS5nZXRTb3VyY2UoKS50eXBlO1xuICAgICAgICAgIFwiZ2VvanNvblwiID09PSBuICYmIHIgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJHZW9KU09OIHNvdXJjZXMgY2Fubm90IGhhdmUgYSBzb3VyY2VMYXllciBwYXJhbWV0ZXIuXCIpKSkgOiBcInZlY3RvclwiICE9PSBuIHx8IHIgPyAodm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCBhLnNldEZlYXR1cmVTdGF0ZShyLCBlLmlkLCBpKSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlICdcIiArIG8gKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbyA9IGUuc291cmNlLFxuICAgICAgICAgICAgciA9IHRoaXMuc291cmNlQ2FjaGVzW29dO1xuXG4gICAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICB2YXIgYSA9IHIuZ2V0U291cmNlKCkudHlwZSxcbiAgICAgICAgICAgICAgbiA9IFwidmVjdG9yXCIgPT09IGEgPyBlLnNvdXJjZUxheWVyIDogdm9pZCAwO1xuICAgICAgICAgIFwidmVjdG9yXCIgIT09IGEgfHwgbiA/IGkgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZS5pZCAmJiBcIm51bWJlclwiICE9IHR5cGVvZiBlLmlkID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiQSBmZWF0dXJlIGlkIGlzIHJlcXVpcmVkIHRvIHJlbW92ZSBpdHMgc3BlY2lmaWMgc3RhdGUgcHJvcGVydHkuXCIpKSkgOiByLnJlbW92ZUZlYXR1cmVTdGF0ZShuLCBlLmlkLCBpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2VMYXllciBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgdmVjdG9yIHNvdXJjZSB0eXBlcy5cIikpKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgJ1wiICsgbyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUuXCIpKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuXG4gICAgICAgIHZhciBpID0gZS5zb3VyY2UsXG4gICAgICAgICAgICBvID0gZS5zb3VyY2VMYXllcixcbiAgICAgICAgICAgIHIgPSB0aGlzLnNvdXJjZUNhY2hlc1tpXTtcblxuICAgICAgICBpZiAodm9pZCAwICE9PSByKSB7XG4gICAgICAgICAgaWYgKFwidmVjdG9yXCIgIT09IHIuZ2V0U291cmNlKCkudHlwZSB8fCBvKSByZXR1cm4gdm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCByLmdldEZlYXR1cmVTdGF0ZShvLCBlLmlkKTtcbiAgICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlICdcIiArIGkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKHtcbiAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGRlbGF5OiAwXG4gICAgICAgIH0sIHRoaXMuc3R5bGVzaGVldCAmJiB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbik7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LmZpbHRlck9iamVjdCh7XG4gICAgICAgICAgdmVyc2lvbjogdGhpcy5zdHlsZXNoZWV0LnZlcnNpb24sXG4gICAgICAgICAgbmFtZTogdGhpcy5zdHlsZXNoZWV0Lm5hbWUsXG4gICAgICAgICAgbWV0YWRhdGE6IHRoaXMuc3R5bGVzaGVldC5tZXRhZGF0YSxcbiAgICAgICAgICBsaWdodDogdGhpcy5zdHlsZXNoZWV0LmxpZ2h0LFxuICAgICAgICAgIGNlbnRlcjogdGhpcy5zdHlsZXNoZWV0LmNlbnRlcixcbiAgICAgICAgICB6b29tOiB0aGlzLnN0eWxlc2hlZXQuem9vbSxcbiAgICAgICAgICBiZWFyaW5nOiB0aGlzLnN0eWxlc2hlZXQuYmVhcmluZyxcbiAgICAgICAgICBwaXRjaDogdGhpcy5zdHlsZXNoZWV0LnBpdGNoLFxuICAgICAgICAgIHNwcml0ZTogdGhpcy5zdHlsZXNoZWV0LnNwcml0ZSxcbiAgICAgICAgICBnbHlwaHM6IHRoaXMuc3R5bGVzaGVldC5nbHlwaHMsXG4gICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24sXG4gICAgICAgICAgc291cmNlczogdC5tYXBPYmplY3QodGhpcy5zb3VyY2VDYWNoZXMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0aGlzLl9vcmRlcilcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSB0O1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVMYXllciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZWRMYXllcnNbdC5pZF0gPSAhMCwgdC5zb3VyY2UgJiYgIXRoaXMuX3VwZGF0ZWRTb3VyY2VzW3Quc291cmNlXSAmJiBcInJhc3RlclwiICE9PSB0aGlzLnNvdXJjZUNhY2hlc1t0LnNvdXJjZV0uZ2V0U291cmNlKCkudHlwZSAmJiAodGhpcy5fdXBkYXRlZFNvdXJjZXNbdC5zb3VyY2VdID0gXCJyZWxvYWRcIiwgdGhpcy5zb3VyY2VDYWNoZXNbdC5zb3VyY2VdLnBhdXNlKCkpLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZmxhdHRlbkFuZFNvcnRSZW5kZXJlZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMsIGkgPSBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJmaWxsLWV4dHJ1c2lvblwiID09PSBlLl9sYXllcnNbdF0udHlwZTtcbiAgICAgICAgfSwgbyA9IHt9LCByID0gW10sIGEgPSB0aGlzLl9vcmRlci5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5fb3JkZXJbYV07XG5cbiAgICAgICAgICBpZiAoaShuKSkge1xuICAgICAgICAgICAgb1tuXSA9IGE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwLCBsID0gdDsgcyA8IGwubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBsW3NdW25dO1xuICAgICAgICAgICAgICBpZiAoYykgZm9yICh2YXIgdSA9IDAsIGggPSBjOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgICAgIHIucHVzaChoW3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiBlLmludGVyc2VjdGlvblogLSB0LmludGVyc2VjdGlvblo7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSBbXSwgZCA9IHRoaXMuX29yZGVyLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgdmFyIF8gPSB0aGlzLl9vcmRlcltkXTtcbiAgICAgICAgICBpZiAoaShfKSkgZm9yICh2YXIgZiA9IHIubGVuZ3RoIC0gMTsgZiA+PSAwOyBmLS0pIHtcbiAgICAgICAgICAgIHZhciBtID0gcltmXS5mZWF0dXJlO1xuICAgICAgICAgICAgaWYgKG9bbS5sYXllci5pZF0gPCBkKSBicmVhaztcbiAgICAgICAgICAgIHAucHVzaChtKSwgci5wb3AoKTtcbiAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgZyA9IDAsIHYgPSB0OyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHkgPSB2W2ddW19dO1xuICAgICAgICAgICAgaWYgKHkpIGZvciAodmFyIHggPSAwLCBiID0geTsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgcC5wdXNoKGJbeF0uZmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICBpICYmIGkuZmlsdGVyICYmIHRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVTdHlsZS5maWx0ZXIsIFwicXVlcnlSZW5kZXJlZEZlYXR1cmVzLmZpbHRlclwiLCBpLmZpbHRlciwgbnVsbCwgaSk7XG4gICAgICAgIHZhciByID0ge307XG5cbiAgICAgICAgaWYgKGkgJiYgaS5sYXllcnMpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaS5sYXllcnMpKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwicGFyYW1ldGVycy5sYXllcnMgbXVzdCBiZSBhbiBBcnJheS5cIikpKSwgW107XG5cbiAgICAgICAgICBmb3IgKHZhciBhID0gMCwgbiA9IGkubGF5ZXJzOyBhIDwgbi5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuW2FdLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLl9sYXllcnNbc107XG4gICAgICAgICAgICBpZiAoIWwpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgcyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBxdWVyaWVkIGZvciBmZWF0dXJlcy5cIikpKSwgW107XG4gICAgICAgICAgICByW2wuc291cmNlXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgdSBpbiBpLmF2YWlsYWJsZUltYWdlcyA9IHRoaXMuX2F2YWlsYWJsZUltYWdlcywgdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICBpLmxheWVycyAmJiAhclt1XSB8fCBjLnB1c2goTyh0aGlzLnNvdXJjZUNhY2hlc1t1XSwgdGhpcy5fbGF5ZXJzLCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzLCBlLCBpLCBvKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnQgJiYgYy5wdXNoKGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IHt9LCBsID0gYS5xdWVyeVJlbmRlcmVkU3ltYm9scyhvKSwgYyA9IFtdLCB1ID0gMCwgaCA9IE9iamVjdC5rZXlzKGwpLm1hcChOdW1iZXIpOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgYy5wdXNoKG5baFt1XV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMuc29ydChGKTtcblxuICAgICAgICAgIGZvciAodmFyIHAgPSBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBfW2RdLFxuICAgICAgICAgICAgICAgIG8gPSBpLmZlYXR1cmVJbmRleC5sb29rdXBTeW1ib2xGZWF0dXJlcyhsW2kuYnVja2V0SW5zdGFuY2VJZF0sIGUsIGkuYnVja2V0SW5kZXgsIGkuc291cmNlTGF5ZXJJbmRleCwgci5maWx0ZXIsIHIubGF5ZXJzLCByLmF2YWlsYWJsZUltYWdlcywgdCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4gbykge1xuICAgICAgICAgICAgICB2YXIgbiA9IHNbYV0gPSBzW2FdIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgYyA9IG9bYV07XG4gICAgICAgICAgICAgIGMuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gaS5mZWF0dXJlU29ydE9yZGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gby5pbmRleE9mKHQuZmVhdHVyZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLmluZGV4T2YoZS5mZWF0dXJlSW5kZXgpIC0gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZS5mZWF0dXJlSW5kZXggLSB0LmZlYXR1cmVJbmRleDtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSBjOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgICAgIG4ucHVzaChoW3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGQgPSAwLCBfID0gYzsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgIHAoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoZSkge1xuICAgICAgICAgICAgc1tlXS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIHZhciByID0gby5mZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgYSA9IGlbdFtlXS5zb3VyY2VdLmdldEZlYXR1cmVTdGF0ZShyLmxheWVyW1wic291cmNlLWxheWVyXCJdLCByLmlkKTtcbiAgICAgICAgICAgICAgci5zb3VyY2UgPSByLmxheWVyLnNvdXJjZSwgci5sYXllcltcInNvdXJjZS1sYXllclwiXSAmJiAoci5zb3VyY2VMYXllciA9IHIubGF5ZXJbXCJzb3VyY2UtbGF5ZXJcIl0pLCByLnN0YXRlID0gYTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBtIGluIHMpIHtcbiAgICAgICAgICAgIGYobSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0odGhpcy5fbGF5ZXJzLCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzLCB0aGlzLnNvdXJjZUNhY2hlcywgZSwgaSwgdGhpcy5wbGFjZW1lbnQuY29sbGlzaW9uSW5kZXgsIHRoaXMucGxhY2VtZW50LnJldGFpbmVkUXVlcnlEYXRhKSksIHRoaXMuX2ZsYXR0ZW5BbmRTb3J0UmVuZGVyZWRGZWF0dXJlcyhjKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpICYmIGkuZmlsdGVyICYmIHRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVTdHlsZS5maWx0ZXIsIFwicXVlcnlTb3VyY2VGZWF0dXJlcy5maWx0ZXJcIiwgaS5maWx0ZXIsIG51bGwsIGkpO1xuICAgICAgICB2YXIgbyA9IHRoaXMuc291cmNlQ2FjaGVzW2VdO1xuICAgICAgICByZXR1cm4gbyA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHQuZ2V0UmVuZGVyYWJsZUlkcygpLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZ2V0VGlsZUJ5SUQoZSk7XG4gICAgICAgICAgfSksIG8gPSBbXSwgciA9IHt9LCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBuID0gaVthXSxcbiAgICAgICAgICAgICAgICBzID0gbi50aWxlSUQuY2Fub25pY2FsLmtleTtcbiAgICAgICAgICAgIHJbc10gfHwgKHJbc10gPSAhMCwgbi5xdWVyeVNvdXJjZUZlYXR1cmVzKG8sIGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfShvLCBpKSA6IFtdO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkU291cmNlVHlwZSA9IGZ1bmN0aW9uICh0LCBlLCBvKSB7XG4gICAgICAgIHJldHVybiBpLmdldFNvdXJjZVR5cGUodCkgPyBvKG5ldyBFcnJvcignQSBzb3VyY2UgdHlwZSBjYWxsZWQgXCInICsgdCArICdcIiBhbHJlYWR5IGV4aXN0cy4nKSkgOiAoaS5zZXRTb3VyY2VUeXBlKHQsIGUpLCBlLndvcmtlclNvdXJjZVVSTCA/IHZvaWQgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcImxvYWRXb3JrZXJTb3VyY2VcIiwge1xuICAgICAgICAgIG5hbWU6IHQsXG4gICAgICAgICAgdXJsOiBlLndvcmtlclNvdXJjZVVSTFxuICAgICAgICB9LCBvKSA6IG8obnVsbCwgbnVsbCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZ2h0LmdldExpZ2h0KCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMaWdodCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxpZ2h0LmdldExpZ2h0KCksXG4gICAgICAgICAgICByID0gITE7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiBlKSB7XG4gICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChlW2FdLCBvW2FdKSkge1xuICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgIG5vdzogdC5icm93c2VyLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdC5leHRlbmQoe1xuICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICBkZWxheTogMFxuICAgICAgICAgICAgfSwgdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24pXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpZ2h0LnNldExpZ2h0KGUsIGkpLCB0aGlzLmxpZ2h0LnVwZGF0ZVRyYW5zaXRpb25zKG4pO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhICYmIChhID0ge30pLCAoIWEgfHwgITEgIT09IGEudmFsaWRhdGUpICYmIFVlKHRoaXMsIGUuY2FsbCh0LnZhbGlkYXRlU3R5bGUsIHQuZXh0ZW5kKHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgc3R5bGU6IHRoaXMuc2VyaWFsaXplKCksXG4gICAgICAgICAgdmFsdWU6IG8sXG4gICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICB9LCByKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLl9yZXF1ZXN0ICYmICh0aGlzLl9yZXF1ZXN0LmNhbmNlbCgpLCB0aGlzLl9yZXF1ZXN0ID0gbnVsbCksIHRoaXMuX3Nwcml0ZVJlcXVlc3QgJiYgKHRoaXMuX3Nwcml0ZVJlcXVlc3QuY2FuY2VsKCksIHRoaXMuX3Nwcml0ZVJlcXVlc3QgPSBudWxsKSwgdC5ldmVudGVkLm9mZihcInBsdWdpblN0YXRlQ2hhbmdlXCIsIHRoaXMuX3J0bFRleHRQbHVnaW5DYWxsYmFjayksIHRoaXMuX2xheWVycykge1xuICAgICAgICAgIHRoaXMuX2xheWVyc1tlXS5zZXRFdmVudGVkUGFyZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW2ldLmNsZWFyVGlsZXMoKSwgdGhpcy5zb3VyY2VDYWNoZXNbaV0uc2V0RXZlbnRlZFBhcmVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnNldEV2ZW50ZWRQYXJlbnQobnVsbCksIHRoaXMuc2V0RXZlbnRlZFBhcmVudChudWxsKSwgdGhpcy5kaXNwYXRjaGVyLnJlbW92ZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2NsZWFyU291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VDYWNoZXNbdF0uY2xlYXJUaWxlcygpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbG9hZFNvdXJjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW3RdLnJlc3VtZSgpLCB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZWxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVTb3VyY2VzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW2VdLnVwZGF0ZSh0KTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX2dlbmVyYXRlQ29sbGlzaW9uQm94ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9yZWxvYWRTb3VyY2UodCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVQbGFjZW1lbnQgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMSk7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9ICExLCBzID0gITEsIGwgPSB7fSwgYyA9IDAsIHUgPSB0aGlzLl9vcmRlcjsgYyA8IHUubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuX2xheWVyc1t1W2NdXTtcblxuICAgICAgICAgIGlmIChcInN5bWJvbFwiID09PSBoLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbFtoLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnNvdXJjZUNhY2hlc1toLnNvdXJjZV07XG4gICAgICAgICAgICAgIGxbaC5zb3VyY2VdID0gcC5nZXRSZW5kZXJhYmxlSWRzKCEwKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5nZXRUaWxlQnlJRCh0KTtcbiAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnRpbGVJRC5vdmVyc2NhbGVkWiAtIHQudGlsZUlELm92ZXJzY2FsZWRaIHx8ICh0LnRpbGVJRC5pc0xlc3NUaGFuKGUudGlsZUlEKSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY3Jvc3NUaWxlU3ltYm9sSW5kZXguYWRkTGF5ZXIoaCwgbFtoLnNvdXJjZV0sIGUuY2VudGVyLmxuZyk7XG4gICAgICAgICAgICBuID0gbiB8fCBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4LnBydW5lVW51c2VkTGF5ZXJzKHRoaXMuX29yZGVyKSwgKChhID0gYSB8fCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCB8fCAwID09PSBvKSB8fCAhdGhpcy5wYXVzZWFibGVQbGFjZW1lbnQgfHwgdGhpcy5wYXVzZWFibGVQbGFjZW1lbnQuaXNEb25lKCkgJiYgIXRoaXMucGxhY2VtZW50LnN0aWxsUmVjZW50KHQuYnJvd3Nlci5ub3coKSwgZS56b29tKSkgJiYgKHRoaXMucGF1c2VhYmxlUGxhY2VtZW50ID0gbmV3IExlKGUsIHRoaXMuX29yZGVyLCBhLCBpLCBvLCByLCB0aGlzLnBsYWNlbWVudCksIHRoaXMuX2xheWVyT3JkZXJDaGFuZ2VkID0gITEpLCB0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSA/IHRoaXMucGxhY2VtZW50LnNldFN0YWxlKCkgOiAodGhpcy5wYXVzZWFibGVQbGFjZW1lbnQuY29udGludWVQbGFjZW1lbnQodGhpcy5fb3JkZXIsIHRoaXMuX2xheWVycywgbCksIHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmlzRG9uZSgpICYmICh0aGlzLnBsYWNlbWVudCA9IHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmNvbW1pdCh0LmJyb3dzZXIubm93KCkpLCBzID0gITApLCBuICYmIHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LnBsYWNlbWVudC5zZXRTdGFsZSgpKSwgcyB8fCBuKSBmb3IgKHZhciBfID0gMCwgZiA9IHRoaXMuX29yZGVyOyBfIDwgZi5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICAgIHZhciBtID0gdGhpcy5fbGF5ZXJzW2ZbX11dO1xuICAgICAgICAgIFwic3ltYm9sXCIgPT09IG0udHlwZSAmJiB0aGlzLnBsYWNlbWVudC51cGRhdGVMYXllck9wYWNpdGllcyhtLCBsW20uc291cmNlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSB8fCB0aGlzLnBsYWNlbWVudC5oYXNUcmFuc2l0aW9ucyh0LmJyb3dzZXIubm93KCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbGVhc2VTeW1ib2xGYWRlVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZWxlYXNlU3ltYm9sRmFkZVRpbGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLmdldEltYWdlcyhlLmljb25zLCBpKSwgdGhpcy5fdXBkYXRlVGlsZXNGb3JDaGFuZ2VkSW1hZ2VzKCk7XG4gICAgICAgIHZhciBvID0gdGhpcy5zb3VyY2VDYWNoZXNbZS5zb3VyY2VdO1xuICAgICAgICBvICYmIG8uc2V0RGVwZW5kZW5jaWVzKGUudGlsZUlELmtleSwgZS50eXBlLCBlLmljb25zKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHRoaXMuZ2x5cGhNYW5hZ2VyLmdldEdseXBocyhlLnN0YWNrcywgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB0Lm1ha2VSZXF1ZXN0KGksIG8pO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCk7XG5cbiAgICBqZS5nZXRTb3VyY2VUeXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBrW3RdO1xuICAgIH0sIGplLnNldFNvdXJjZVR5cGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAga1t0XSA9IGU7XG4gICAgfSwgamUucmVnaXN0ZXJGb3JQbHVnaW5TdGF0ZUNoYW5nZSA9IHQucmVnaXN0ZXJGb3JQbHVnaW5TdGF0ZUNoYW5nZTtcblxuICAgIHZhciBWZSA9IHQuY3JlYXRlTGF5b3V0KFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBjb21wb25lbnRzOiAyXG4gICAgfV0pLFxuICAgICAgICBHZSA9IGdpKFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jaWYgIWRlZmluZWQobG93cClcXG4jZGVmaW5lIGxvd3BcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQobWVkaXVtcClcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQoaGlnaHApXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcbiNlbmRpZlwiLCBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNpZiAhZGVmaW5lZChsb3dwKVxcbiNkZWZpbmUgbG93cFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChtZWRpdW1wKVxcbiNkZWZpbmUgbWVkaXVtcFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChoaWdocClcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuI2VuZGlmXFxudmVjMiB1bnBhY2tfZmxvYXQoY29uc3QgZmxvYXQgcGFja2VkVmFsdWUpIHtpbnQgcGFja2VkSW50VmFsdWU9aW50KHBhY2tlZFZhbHVlKTtpbnQgdjA9cGFja2VkSW50VmFsdWUvMjU2O3JldHVybiB2ZWMyKHYwLHBhY2tlZEludFZhbHVlLXYwKjI1Nik7fXZlYzIgdW5wYWNrX29wYWNpdHkoY29uc3QgZmxvYXQgcGFja2VkT3BhY2l0eSkge2ludCBpbnRPcGFjaXR5PWludChwYWNrZWRPcGFjaXR5KS8yO3JldHVybiB2ZWMyKGZsb2F0KGludE9wYWNpdHkpLzEyNy4wLG1vZChwYWNrZWRPcGFjaXR5LDIuMCkpO312ZWM0IGRlY29kZV9jb2xvcihjb25zdCB2ZWMyIGVuY29kZWRDb2xvcikge3JldHVybiB2ZWM0KHVucGFja19mbG9hdChlbmNvZGVkQ29sb3JbMF0pLzI1NS4wLHVucGFja19mbG9hdChlbmNvZGVkQ29sb3JbMV0pLzI1NS4wXFxuKTt9ZmxvYXQgdW5wYWNrX21peF92ZWMyKGNvbnN0IHZlYzIgcGFja2VkVmFsdWUsY29uc3QgZmxvYXQgdCkge3JldHVybiBtaXgocGFja2VkVmFsdWVbMF0scGFja2VkVmFsdWVbMV0sdCk7fXZlYzQgdW5wYWNrX21peF9jb2xvcihjb25zdCB2ZWM0IHBhY2tlZENvbG9ycyxjb25zdCBmbG9hdCB0KSB7dmVjNCBtaW5Db2xvcj1kZWNvZGVfY29sb3IodmVjMihwYWNrZWRDb2xvcnNbMF0scGFja2VkQ29sb3JzWzFdKSk7dmVjNCBtYXhDb2xvcj1kZWNvZGVfY29sb3IodmVjMihwYWNrZWRDb2xvcnNbMl0scGFja2VkQ29sb3JzWzNdKSk7cmV0dXJuIG1peChtaW5Db2xvcixtYXhDb2xvcix0KTt9dmVjMiBnZXRfcGF0dGVybl9wb3MoY29uc3QgdmVjMiBwaXhlbF9jb29yZF91cHBlcixjb25zdCB2ZWMyIHBpeGVsX2Nvb3JkX2xvd2VyLGNvbnN0IHZlYzIgcGF0dGVybl9zaXplLGNvbnN0IGZsb2F0IHRpbGVfdW5pdHNfdG9fcGl4ZWxzLGNvbnN0IHZlYzIgcG9zKSB7dmVjMiBvZmZzZXQ9bW9kKG1vZChtb2QocGl4ZWxfY29vcmRfdXBwZXIscGF0dGVybl9zaXplKSoyNTYuMCxwYXR0ZXJuX3NpemUpKjI1Ni4wK3BpeGVsX2Nvb3JkX2xvd2VyLHBhdHRlcm5fc2l6ZSk7cmV0dXJuICh0aWxlX3VuaXRzX3RvX3BpeGVscypwb3Mrb2Zmc2V0KS9wYXR0ZXJuX3NpemU7fVwiKSxcbiAgICAgICAgV2UgPSBnaShcInVuaWZvcm0gdmVjNCB1X2NvbG9yO3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3ZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dV9jb2xvcip1X29wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO31cIiksXG4gICAgICAgIFhlID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfbWl4O3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dm9pZCBtYWluKCkge3ZlYzIgaW1hZ2Vjb29yZD1tb2Qodl9wb3NfYSwxLjApO3ZlYzIgcG9zPW1peCh1X3BhdHRlcm5fdGxfYS91X3RleHNpemUsdV9wYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHVfcGF0dGVybl90bF9iL3VfdGV4c2l6ZSx1X3BhdHRlcm5fYnJfYi91X3RleHNpemUsaW1hZ2Vjb29yZF9iKTt2ZWM0IGNvbG9yMj10ZXh0dXJlMkQodV9pbWFnZSxwb3MyKTtnbF9GcmFnQ29sb3I9bWl4KGNvbG9yMSxjb2xvcjIsdV9taXgpKnVfb3BhY2l0eTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9hO3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9iO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX3VwcGVyO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX2xvd2VyO3VuaWZvcm0gZmxvYXQgdV9zY2FsZV9hO3VuaWZvcm0gZmxvYXQgdV9zY2FsZV9iO3VuaWZvcm0gZmxvYXQgdV90aWxlX3VuaXRzX3RvX3BpeGVsczthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZfcG9zX2E9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix1X3NjYWxlX2EqdV9wYXR0ZXJuX3NpemVfYSx1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzLGFfcG9zKTt2X3Bvc19iPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsdV9zY2FsZV9iKnVfcGF0dGVybl9zaXplX2IsdV90aWxlX3VuaXRzX3RvX3BpeGVscyxhX3Bvcyk7fVwiKSxcbiAgICAgICAgSGUgPSBnaShcInZhcnlpbmcgdmVjMyB2X2RhdGE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHN0cm9rZV93aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBzdHJva2Vfb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IHN0cm9rZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgc3Ryb2tlX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBzdHJva2Vfb3BhY2l0eVxcbnZlYzIgZXh0cnVkZT12X2RhdGEueHk7ZmxvYXQgZXh0cnVkZV9sZW5ndGg9bGVuZ3RoKGV4dHJ1ZGUpO2xvd3AgZmxvYXQgYW50aWFsaWFzYmx1cj12X2RhdGEuejtmbG9hdCBhbnRpYWxpYXNlZF9ibHVyPS1tYXgoYmx1cixhbnRpYWxpYXNibHVyKTtmbG9hdCBvcGFjaXR5X3Q9c21vb3Roc3RlcCgwLjAsYW50aWFsaWFzZWRfYmx1cixleHRydWRlX2xlbmd0aC0xLjApO2Zsb2F0IGNvbG9yX3Q9c3Ryb2tlX3dpZHRoIDwgMC4wMSA/IDAuMCA6IHNtb290aHN0ZXAoYW50aWFsaWFzZWRfYmx1ciwwLjAsZXh0cnVkZV9sZW5ndGgtcmFkaXVzLyhyYWRpdXMrc3Ryb2tlX3dpZHRoKSk7Z2xfRnJhZ0NvbG9yPW9wYWNpdHlfdCptaXgoY29sb3Iqb3BhY2l0eSxzdHJva2VfY29sb3Iqc3Ryb2tlX29wYWNpdHksY29sb3JfdCk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIGJvb2wgdV9zY2FsZV93aXRoX21hcDt1bmlmb3JtIGJvb2wgdV9waXRjaF93aXRoX21hcDt1bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzMgdl9kYXRhO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IHN0cm9rZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBzdHJva2Vfd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgc3Ryb2tlX29wYWNpdHlcXG52b2lkIG1haW4odm9pZCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBzdHJva2Vfd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHN0cm9rZV9vcGFjaXR5XFxudmVjMiBleHRydWRlPXZlYzIobW9kKGFfcG9zLDIuMCkqMi4wLTEuMCk7dmVjMiBjaXJjbGVfY2VudGVyPWZsb29yKGFfcG9zKjAuNSk7aWYgKHVfcGl0Y2hfd2l0aF9tYXApIHt2ZWMyIGNvcm5lcl9wb3NpdGlvbj1jaXJjbGVfY2VudGVyO2lmICh1X3NjYWxlX3dpdGhfbWFwKSB7Y29ybmVyX3Bvc2l0aW9uKz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGU7fSBlbHNlIHt2ZWM0IHByb2plY3RlZF9jZW50ZXI9dV9tYXRyaXgqdmVjNChjaXJjbGVfY2VudGVyLDAsMSk7Y29ybmVyX3Bvc2l0aW9uKz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGUqKHByb2plY3RlZF9jZW50ZXIudy91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UpO31nbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGNvcm5lcl9wb3NpdGlvbiwwLDEpO30gZWxzZSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChjaXJjbGVfY2VudGVyLDAsMSk7aWYgKHVfc2NhbGVfd2l0aF9tYXApIHtnbF9Qb3NpdGlvbi54eSs9ZXh0cnVkZSoocmFkaXVzK3N0cm9rZV93aWR0aCkqdV9leHRydWRlX3NjYWxlKnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt9IGVsc2Uge2dsX1Bvc2l0aW9uLnh5Kz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGUqZ2xfUG9zaXRpb24udzt9fWxvd3AgZmxvYXQgYW50aWFsaWFzYmx1cj0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vKHJhZGl1cytzdHJva2Vfd2lkdGgpO3ZfZGF0YT12ZWMzKGV4dHJ1ZGUueCxleHRydWRlLnksYW50aWFsaWFzYmx1cik7fVwiKSxcbiAgICAgICAgS2UgPSBnaShcInZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dmVjNCgxLjApO31cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgICBZZSA9IGdpKFwidW5pZm9ybSBoaWdocCBmbG9hdCB1X2ludGVuc2l0eTt2YXJ5aW5nIHZlYzIgdl9leHRydWRlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI2RlZmluZSBHQVVTU19DT0VGIDAuMzk4OTQyMjgwNDAxNDMyN1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCBmbG9hdCB3ZWlnaHRcXG5mbG9hdCBkPS0wLjUqMy4wKjMuMCpkb3Qodl9leHRydWRlLHZfZXh0cnVkZSk7ZmxvYXQgdmFsPXdlaWdodCp1X2ludGVuc2l0eSpHQVVTU19DT0VGKmV4cChkKTtnbF9GcmFnQ29sb3I9dmVjNCh2YWwsMS4wLDEuMCwxLjApO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBmbG9hdCB1X2V4dHJ1ZGVfc2NhbGU7dW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7dW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9leHRydWRlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbmNvbnN0IGhpZ2hwIGZsb2F0IFpFUk89MS4wLzI1NS4wLzE2LjA7XFxuI2RlZmluZSBHQVVTU19DT0VGIDAuMzk4OTQyMjgwNDAxNDMyN1xcbnZvaWQgbWFpbih2b2lkKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG52ZWMyIHVuc2NhbGVkX2V4dHJ1ZGU9dmVjMihtb2QoYV9wb3MsMi4wKSoyLjAtMS4wKTtmbG9hdCBTPXNxcnQoLTIuMCpsb2coWkVSTy93ZWlnaHQvdV9pbnRlbnNpdHkvR0FVU1NfQ09FRikpLzMuMDt2X2V4dHJ1ZGU9Uyp1bnNjYWxlZF9leHRydWRlO3ZlYzIgZXh0cnVkZT12X2V4dHJ1ZGUqcmFkaXVzKnVfZXh0cnVkZV9zY2FsZTt2ZWM0IHBvcz12ZWM0KGZsb29yKGFfcG9zKjAuNSkrZXh0cnVkZSwwLDEpO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnBvczt9XCIpLFxuICAgICAgICBKZSA9IGdpKFwidW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2NvbG9yX3JhbXA7dW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7dmFyeWluZyB2ZWMyIHZfcG9zO3ZvaWQgbWFpbigpIHtmbG9hdCB0PXRleHR1cmUyRCh1X2ltYWdlLHZfcG9zKS5yO3ZlYzQgY29sb3I9dGV4dHVyZTJEKHVfY29sb3JfcmFtcCx2ZWMyKHQsMC41KSk7Z2xfRnJhZ0NvbG9yPWNvbG9yKnVfb3BhY2l0eTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMC4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3dvcmxkO2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3Bvcyp1X3dvcmxkLDAsMSk7dl9wb3MueD1hX3Bvcy54O3ZfcG9zLnk9MS4wLWFfcG9zLnk7fVwiKSxcbiAgICAgICAgUWUgPSBnaShcInZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge2Zsb2F0IGFscGhhPTAuNTtnbF9GcmFnQ29sb3I9dmVjNCgxLjAsMC4wLDAuMCwxLjApKmFscGhhO2lmICh2X3BsYWNlZCA+IDAuNSkge2dsX0ZyYWdDb2xvcj12ZWM0KDAuMCwwLjAsMS4wLDAuNSkqYWxwaGE7fWlmICh2X25vdFVzZWQgPiAwLjUpIHtnbF9GcmFnQ29sb3IqPS4xO319XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV9hbmNob3JfcG9zO2F0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTthdHRyaWJ1dGUgdmVjMiBhX3BsYWNlZDthdHRyaWJ1dGUgdmVjMiBhX3NoaWZ0O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge3ZlYzQgcHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX2FuY2hvcl9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgY29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqKHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlKSwwLjAsNC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAuMCwxLjApO2dsX1Bvc2l0aW9uLnh5Kz0oYV9leHRydWRlK2Ffc2hpZnQpKnVfZXh0cnVkZV9zY2FsZSpnbF9Qb3NpdGlvbi53KmNvbGxpc2lvbl9wZXJzcGVjdGl2ZV9yYXRpbzt2X3BsYWNlZD1hX3BsYWNlZC54O3Zfbm90VXNlZD1hX3BsYWNlZC55O31cIiksXG4gICAgICAgICRlID0gZ2koXCJ2YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO3ZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7dmFyeWluZyBmbG9hdCB2X3BlcnNwZWN0aXZlX3JhdGlvO3ZhcnlpbmcgZmxvYXQgdl9jb2xsaXNpb247dm9pZCBtYWluKCkge2Zsb2F0IGFscGhhPTAuNSptaW4odl9wZXJzcGVjdGl2ZV9yYXRpbywxLjApO2Zsb2F0IHN0cm9rZV9yYWRpdXM9MC45Km1heCh2X3BlcnNwZWN0aXZlX3JhdGlvLDEuMCk7ZmxvYXQgZGlzdGFuY2VfdG9fY2VudGVyPWxlbmd0aCh2X2V4dHJ1ZGUpO2Zsb2F0IGRpc3RhbmNlX3RvX2VkZ2U9YWJzKGRpc3RhbmNlX3RvX2NlbnRlci12X3JhZGl1cyk7ZmxvYXQgb3BhY2l0eV90PXNtb290aHN0ZXAoLXN0cm9rZV9yYWRpdXMsMC4wLC1kaXN0YW5jZV90b19lZGdlKTt2ZWM0IGNvbG9yPW1peCh2ZWM0KDAuMCwwLjAsMS4wLDAuNSksdmVjNCgxLjAsMC4wLDAuMCwxLjApLHZfY29sbGlzaW9uKTtnbF9GcmFnQ29sb3I9Y29sb3IqYWxwaGEqb3BhY2l0eV90O31cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7YXR0cmlidXRlIHZlYzIgYV9mbGFnczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfaW52X21hdHJpeDt1bmlmb3JtIHZlYzIgdV92aWV3cG9ydF9zaXplO3VuaWZvcm0gZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7dmFyeWluZyB2ZWMyIHZfZXh0cnVkZTt2YXJ5aW5nIGZsb2F0IHZfcGVyc3BlY3RpdmVfcmF0aW87dmFyeWluZyBmbG9hdCB2X2NvbGxpc2lvbjt2ZWMzIHRvVGlsZVBvc2l0aW9uKHZlYzIgc2NyZWVuUG9zKSB7dmVjNCByYXlTdGFydD11X2ludl9tYXRyaXgqdmVjNChzY3JlZW5Qb3MsLTEuMCwxLjApO3ZlYzQgcmF5RW5kICA9dV9pbnZfbWF0cml4KnZlYzQoc2NyZWVuUG9zLCAxLjAsMS4wKTtyYXlTdGFydC54eXovPXJheVN0YXJ0Lnc7cmF5RW5kLnh5eiAgLz1yYXlFbmQudztoaWdocCBmbG9hdCB0PSgwLjAtcmF5U3RhcnQueikvKHJheUVuZC56LXJheVN0YXJ0LnopO3JldHVybiBtaXgocmF5U3RhcnQueHl6LHJheUVuZC54eXosdCk7fXZvaWQgbWFpbigpIHt2ZWMyIHF1YWRDZW50ZXJQb3M9YV9wb3M7ZmxvYXQgcmFkaXVzPWFfcmFkaXVzO2Zsb2F0IGNvbGxpc2lvbj1hX2ZsYWdzLng7ZmxvYXQgdmVydGV4SWR4PWFfZmxhZ3MueTt2ZWMyIHF1YWRWZXJ0ZXhPZmZzZXQ9dmVjMihtaXgoLTEuMCwxLjAsZmxvYXQodmVydGV4SWR4ID49Mi4wKSksbWl4KC0xLjAsMS4wLGZsb2F0KHZlcnRleElkeCA+PTEuMCAmJiB2ZXJ0ZXhJZHggPD0yLjApKSk7dmVjMiBxdWFkVmVydGV4RXh0ZW50PXF1YWRWZXJ0ZXhPZmZzZXQqcmFkaXVzO3ZlYzMgdGlsZVBvcz10b1RpbGVQb3NpdGlvbihxdWFkQ2VudGVyUG9zKTt2ZWM0IGNsaXBQb3M9dV9tYXRyaXgqdmVjNCh0aWxlUG9zLDEuMCk7aGlnaHAgZmxvYXQgY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZT1jbGlwUG9zLnc7aGlnaHAgZmxvYXQgY29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqKHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlKSwwLjAsNC4wKTtmbG9hdCBwYWRkaW5nX2ZhY3Rvcj0xLjI7dl9yYWRpdXM9cmFkaXVzO3ZfZXh0cnVkZT1xdWFkVmVydGV4RXh0ZW50KnBhZGRpbmdfZmFjdG9yO3ZfcGVyc3BlY3RpdmVfcmF0aW89Y29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvO3ZfY29sbGlzaW9uPWNvbGxpc2lvbjtnbF9Qb3NpdGlvbj12ZWM0KGNsaXBQb3MueHl6L2NsaXBQb3MudywxLjApK3ZlYzQocXVhZFZlcnRleEV4dGVudCpwYWRkaW5nX2ZhY3Rvci91X3ZpZXdwb3J0X3NpemUqMi4wLDAuMCwwLjApO31cIiksXG4gICAgICAgIHRpID0gZ2koXCJ1bmlmb3JtIGhpZ2hwIHZlYzQgdV9jb2xvcjt1bmlmb3JtIHNhbXBsZXIyRCB1X292ZXJsYXk7dmFyeWluZyB2ZWMyIHZfdXY7dm9pZCBtYWluKCkge3ZlYzQgb3ZlcmxheV9jb2xvcj10ZXh0dXJlMkQodV9vdmVybGF5LHZfdXYpO2dsX0ZyYWdDb2xvcj1taXgodV9jb2xvcixvdmVybGF5X2NvbG9yLG92ZXJsYXlfY29sb3IuYSk7fVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZhcnlpbmcgdmVjMiB2X3V2O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIGZsb2F0IHVfb3ZlcmxheV9zY2FsZTt2b2lkIG1haW4oKSB7dl91dj1hX3Bvcy84MTkyLjA7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3Bvcyp1X292ZXJsYXlfc2NhbGUsMCwxKTt9XCIpLFxuICAgICAgICBlaSA9IGdpKFwiI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX0ZyYWdDb2xvcj1jb2xvcipvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgICBpaSA9IGdpKFwidmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBvdXRsaW5lX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBvdXRsaW5lX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuZmxvYXQgZGlzdD1sZW5ndGgodl9wb3MtZ2xfRnJhZ0Nvb3JkLnh5KTtmbG9hdCBhbHBoYT0xLjAtc21vb3Roc3RlcCgwLjAsMS4wLGRpc3QpO2dsX0ZyYWdDb2xvcj1vdXRsaW5lX2NvbG9yKihhbHBoYSpvcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3dvcmxkO3ZhcnlpbmcgdmVjMiB2X3BvcztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvcz0oZ2xfUG9zaXRpb24ueHkvZ2xfUG9zaXRpb24udysxLjApLzIuMCp1X3dvcmxkO31cIiksXG4gICAgICAgIG9pID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dW5pZm9ybSBmbG9hdCB1X2ZhZGU7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dzt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgocGF0dGVybl90bF9hL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHBhdHRlcm5fdGxfYi91X3RleHNpemUscGF0dGVybl9icl9iL3VfdGV4c2l6ZSxpbWFnZWNvb3JkX2IpO3ZlYzQgY29sb3IyPXRleHR1cmUyRCh1X2ltYWdlLHBvczIpO2Zsb2F0IGRpc3Q9bGVuZ3RoKHZfcG9zLWdsX0ZyYWdDb29yZC54eSk7ZmxvYXQgYWxwaGE9MS4wLXNtb290aHN0ZXAoMC4wLDEuMCxkaXN0KTtnbF9GcmFnQ29sb3I9bWl4KGNvbG9yMSxjb2xvcjIsdV9mYWRlKSphbHBoYSpvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfd29ybGQ7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7dW5pZm9ybSB2ZWMzIHVfc2NhbGU7YXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dztmbG9hdCB0aWxlUmF0aW89dV9zY2FsZS54O2Zsb2F0IGZyb21TY2FsZT11X3NjYWxlLnk7ZmxvYXQgdG9TY2FsZT11X3NjYWxlLno7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZlYzIgZGlzcGxheV9zaXplX2E9KHBhdHRlcm5fYnJfYS1wYXR0ZXJuX3RsX2EpL3BpeGVsX3JhdGlvX2Zyb207dmVjMiBkaXNwbGF5X3NpemVfYj0ocGF0dGVybl9icl9iLXBhdHRlcm5fdGxfYikvcGl4ZWxfcmF0aW9fdG87dl9wb3NfYT1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLGZyb21TY2FsZSpkaXNwbGF5X3NpemVfYSx0aWxlUmF0aW8sYV9wb3MpO3ZfcG9zX2I9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix0b1NjYWxlKmRpc3BsYXlfc2l6ZV9iLHRpbGVSYXRpbyxhX3Bvcyk7dl9wb3M9KGdsX1Bvc2l0aW9uLnh5L2dsX1Bvc2l0aW9uLncrMS4wKS8yLjAqdV93b3JsZDt9XCIpLFxuICAgICAgICByaSA9IGdpKFwidW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvc19hO3ZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dzt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgocGF0dGVybl90bF9hL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHBhdHRlcm5fdGxfYi91X3RleHNpemUscGF0dGVybl9icl9iL3VfdGV4c2l6ZSxpbWFnZWNvb3JkX2IpO3ZlYzQgY29sb3IyPXRleHR1cmUyRCh1X2ltYWdlLHBvczIpO2dsX0ZyYWdDb2xvcj1taXgoY29sb3IxLGNvbG9yMix1X2ZhZGUpKm9wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF91cHBlcjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF9sb3dlcjt1bmlmb3JtIHZlYzMgdV9zY2FsZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVpvb21SYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvc19hPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsZnJvbVNjYWxlKmRpc3BsYXlfc2l6ZV9hLHRpbGVab29tUmF0aW8sYV9wb3MpO3ZfcG9zX2I9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix0b1NjYWxlKmRpc3BsYXlfc2l6ZV9iLHRpbGVab29tUmF0aW8sYV9wb3MpO31cIiksXG4gICAgICAgIGFpID0gZ2koXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjt2b2lkIG1haW4oKSB7Z2xfRnJhZ0NvbG9yPXZfY29sb3I7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzMgdV9saWdodGNvbG9yO3VuaWZvcm0gbG93cCB2ZWMzIHVfbGlnaHRwb3M7dW5pZm9ybSBsb3dwIGZsb2F0IHVfbGlnaHRpbnRlbnNpdHk7dW5pZm9ybSBmbG9hdCB1X3ZlcnRpY2FsX2dyYWRpZW50O3VuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzQgYV9ub3JtYWxfZWQ7dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgY29sb3JcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIGZsb2F0IGhlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG52ZWMzIG5vcm1hbD1hX25vcm1hbF9lZC54eXo7YmFzZT1tYXgoMC4wLGJhc2UpO2hlaWdodD1tYXgoMC4wLGhlaWdodCk7ZmxvYXQgdD1tb2Qobm9ybWFsLngsMi4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLHQgPiAwLjAgPyBoZWlnaHQgOiBiYXNlLDEpO2Zsb2F0IGNvbG9ydmFsdWU9Y29sb3IuciowLjIxMjYrY29sb3IuZyowLjcxNTIrY29sb3IuYiowLjA3MjI7dl9jb2xvcj12ZWM0KDAuMCwwLjAsMC4wLDEuMCk7dmVjNCBhbWJpZW50bGlnaHQ9dmVjNCgwLjAzLDAuMDMsMC4wMywxLjApO2NvbG9yKz1hbWJpZW50bGlnaHQ7ZmxvYXQgZGlyZWN0aW9uYWw9Y2xhbXAoZG90KG5vcm1hbC8xNjM4NC4wLHVfbGlnaHRwb3MpLDAuMCwxLjApO2RpcmVjdGlvbmFsPW1peCgoMS4wLXVfbGlnaHRpbnRlbnNpdHkpLG1heCgoMS4wLWNvbG9ydmFsdWUrdV9saWdodGludGVuc2l0eSksMS4wKSxkaXJlY3Rpb25hbCk7aWYgKG5vcm1hbC55ICE9MC4wKSB7ZGlyZWN0aW9uYWwqPSgoMS4wLXVfdmVydGljYWxfZ3JhZGllbnQpKyh1X3ZlcnRpY2FsX2dyYWRpZW50KmNsYW1wKCh0K2Jhc2UpKnBvdyhoZWlnaHQvMTUwLjAsMC41KSxtaXgoMC43LDAuOTgsMS4wLXVfbGlnaHRpbnRlbnNpdHkpLDEuMCkpKTt9dl9jb2xvci5yKz1jbGFtcChjb2xvci5yKmRpcmVjdGlvbmFsKnVfbGlnaHRjb2xvci5yLG1peCgwLjAsMC4zLDEuMC11X2xpZ2h0Y29sb3IuciksMS4wKTt2X2NvbG9yLmcrPWNsYW1wKGNvbG9yLmcqZGlyZWN0aW9uYWwqdV9saWdodGNvbG9yLmcsbWl4KDAuMCwwLjMsMS4wLXVfbGlnaHRjb2xvci5nKSwxLjApO3ZfY29sb3IuYis9Y2xhbXAoY29sb3IuYipkaXJlY3Rpb25hbCp1X2xpZ2h0Y29sb3IuYixtaXgoMC4wLDAuMywxLjAtdV9saWdodGNvbG9yLmIpLDEuMCk7dl9jb2xvcio9dV9vcGFjaXR5O31cIiksXG4gICAgICAgIG5pID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3VuaWZvcm0gZmxvYXQgdV9mYWRlO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJhc2VcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGVpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGVpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZlYzIgcGF0dGVybl90bF9hPXBhdHRlcm5fZnJvbS54eTt2ZWMyIHBhdHRlcm5fYnJfYT1wYXR0ZXJuX2Zyb20uenc7dmVjMiBwYXR0ZXJuX3RsX2I9cGF0dGVybl90by54eTt2ZWMyIHBhdHRlcm5fYnJfYj1wYXR0ZXJuX3RvLnp3O3ZlYzIgaW1hZ2Vjb29yZD1tb2Qodl9wb3NfYSwxLjApO3ZlYzIgcG9zPW1peChwYXR0ZXJuX3RsX2EvdV90ZXhzaXplLHBhdHRlcm5fYnJfYS91X3RleHNpemUsaW1hZ2Vjb29yZCk7dmVjNCBjb2xvcjE9dGV4dHVyZTJEKHVfaW1hZ2UscG9zKTt2ZWMyIGltYWdlY29vcmRfYj1tb2Qodl9wb3NfYiwxLjApO3ZlYzIgcG9zMj1taXgocGF0dGVybl90bF9iL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2IvdV90ZXhzaXplLGltYWdlY29vcmRfYik7dmVjNCBjb2xvcjI9dGV4dHVyZTJEKHVfaW1hZ2UscG9zMik7dmVjNCBtaXhlZENvbG9yPW1peChjb2xvcjEsY29sb3IyLHVfZmFkZSk7Z2xfRnJhZ0NvbG9yPW1peGVkQ29sb3Iqdl9saWdodGluZztcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX3VwcGVyO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX2xvd2VyO3VuaWZvcm0gZmxvYXQgdV9oZWlnaHRfZmFjdG9yO3VuaWZvcm0gdmVjMyB1X3NjYWxlO3VuaWZvcm0gZmxvYXQgdV92ZXJ0aWNhbF9ncmFkaWVudDt1bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O3VuaWZvcm0gdmVjMyB1X2xpZ2h0Y29sb3I7dW5pZm9ybSBsb3dwIHZlYzMgdV9saWdodHBvczt1bmlmb3JtIGxvd3AgZmxvYXQgdV9saWdodGludGVuc2l0eTthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjNCBhX25vcm1hbF9lZDt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVJhdGlvPXVfc2NhbGUueDtmbG9hdCBmcm9tU2NhbGU9dV9zY2FsZS55O2Zsb2F0IHRvU2NhbGU9dV9zY2FsZS56O3ZlYzMgbm9ybWFsPWFfbm9ybWFsX2VkLnh5ejtmbG9hdCBlZGdlZGlzdGFuY2U9YV9ub3JtYWxfZWQudzt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO2Jhc2U9bWF4KDAuMCxiYXNlKTtoZWlnaHQ9bWF4KDAuMCxoZWlnaHQpO2Zsb2F0IHQ9bW9kKG5vcm1hbC54LDIuMCk7ZmxvYXQgej10ID4gMC4wID8gaGVpZ2h0IDogYmFzZTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLHosMSk7dmVjMiBwb3M9bm9ybWFsLng9PTEuMCAmJiBub3JtYWwueT09MC4wICYmIG5vcm1hbC56PT0xNjM4NC4wXFxuPyBhX3Bvc1xcbjogdmVjMihlZGdlZGlzdGFuY2Useip1X2hlaWdodF9mYWN0b3IpO3ZfcG9zX2E9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcixmcm9tU2NhbGUqZGlzcGxheV9zaXplX2EsdGlsZVJhdGlvLHBvcyk7dl9wb3NfYj1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLHRvU2NhbGUqZGlzcGxheV9zaXplX2IsdGlsZVJhdGlvLHBvcyk7dl9saWdodGluZz12ZWM0KDAuMCwwLjAsMC4wLDEuMCk7ZmxvYXQgZGlyZWN0aW9uYWw9Y2xhbXAoZG90KG5vcm1hbC8xNjM4My4wLHVfbGlnaHRwb3MpLDAuMCwxLjApO2RpcmVjdGlvbmFsPW1peCgoMS4wLXVfbGlnaHRpbnRlbnNpdHkpLG1heCgoMC41K3VfbGlnaHRpbnRlbnNpdHkpLDEuMCksZGlyZWN0aW9uYWwpO2lmIChub3JtYWwueSAhPTAuMCkge2RpcmVjdGlvbmFsKj0oKDEuMC11X3ZlcnRpY2FsX2dyYWRpZW50KSsodV92ZXJ0aWNhbF9ncmFkaWVudCpjbGFtcCgodCtiYXNlKSpwb3coaGVpZ2h0LzE1MC4wLDAuNSksbWl4KDAuNywwLjk4LDEuMC11X2xpZ2h0aW50ZW5zaXR5KSwxLjApKSk7fXZfbGlnaHRpbmcucmdiKz1jbGFtcChkaXJlY3Rpb25hbCp1X2xpZ2h0Y29sb3IsbWl4KHZlYzMoMC4wKSx2ZWMzKDAuMyksMS4wLXVfbGlnaHRjb2xvciksdmVjMygxLjApKTt2X2xpZ2h0aW5nKj11X29wYWNpdHk7fVwiKSxcbiAgICAgICAgc2kgPSBnaShcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvczt1bmlmb3JtIHZlYzIgdV9kaW1lbnNpb247dW5pZm9ybSBmbG9hdCB1X3pvb207dW5pZm9ybSB2ZWM0IHVfdW5wYWNrO2Zsb2F0IGdldEVsZXZhdGlvbih2ZWMyIGNvb3JkLGZsb2F0IGJpYXMpIHt2ZWM0IGRhdGE9dGV4dHVyZTJEKHVfaW1hZ2UsY29vcmQpKjI1NS4wO2RhdGEuYT0tMS4wO3JldHVybiBkb3QoZGF0YSx1X3VucGFjaykvNC4wO312b2lkIG1haW4oKSB7dmVjMiBlcHNpbG9uPTEuMC91X2RpbWVuc2lvbjtmbG9hdCBhPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBiPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKDAsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBjPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKGVwc2lsb24ueCwtZXBzaWxvbi55KSwwLjApO2Zsb2F0IGQ9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoLWVwc2lsb24ueCwwKSwwLjApO2Zsb2F0IGU9Z2V0RWxldmF0aW9uKHZfcG9zLDAuMCk7ZmxvYXQgZj1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsMCksMC4wKTtmbG9hdCBnPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGg9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoMCxlcHNpbG9uLnkpLDAuMCk7ZmxvYXQgaT1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGV4YWdnZXJhdGlvbkZhY3Rvcj11X3pvb20gPCAyLjAgPyAwLjQgOiB1X3pvb20gPCA0LjUgPyAwLjM1IDogMC4zO2Zsb2F0IGV4YWdnZXJhdGlvbj11X3pvb20gPCAxNS4wID8gKHVfem9vbS0xNS4wKSpleGFnZ2VyYXRpb25GYWN0b3IgOiAwLjA7dmVjMiBkZXJpdj12ZWMyKChjK2YrZitpKS0oYStkK2QrZyksKGcraCtoK2kpLShhK2IrYitjKSkvcG93KDIuMCxleGFnZ2VyYXRpb24rKDE5LjI1NjItdV96b29tKSk7Z2xfRnJhZ0NvbG9yPWNsYW1wKHZlYzQoZGVyaXYueC8yLjArMC41LGRlcml2LnkvMi4wKzAuNSwxLjAsMS4wKSwwLjAsMS4wKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X2RpbWVuc2lvbjthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2hpZ2hwIHZlYzIgZXBzaWxvbj0xLjAvdV9kaW1lbnNpb247ZmxvYXQgc2NhbGU9KHVfZGltZW5zaW9uLngtMi4wKS91X2RpbWVuc2lvbi54O3ZfcG9zPShhX3RleHR1cmVfcG9zLzgxOTIuMCkqc2NhbGUrZXBzaWxvbjt9XCIpLFxuICAgICAgICBsaSA9IGdpKFwidW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt2YXJ5aW5nIHZlYzIgdl9wb3M7dW5pZm9ybSB2ZWMyIHVfbGF0cmFuZ2U7dW5pZm9ybSB2ZWMyIHVfbGlnaHQ7dW5pZm9ybSB2ZWM0IHVfc2hhZG93O3VuaWZvcm0gdmVjNCB1X2hpZ2hsaWdodDt1bmlmb3JtIHZlYzQgdV9hY2NlbnQ7XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5M1xcbnZvaWQgbWFpbigpIHt2ZWM0IHBpeGVsPXRleHR1cmUyRCh1X2ltYWdlLHZfcG9zKTt2ZWMyIGRlcml2PSgocGl4ZWwucmcqMi4wKS0xLjApO2Zsb2F0IHNjYWxlRmFjdG9yPWNvcyhyYWRpYW5zKCh1X2xhdHJhbmdlWzBdLXVfbGF0cmFuZ2VbMV0pKigxLjAtdl9wb3MueSkrdV9sYXRyYW5nZVsxXSkpO2Zsb2F0IHNsb3BlPWF0YW4oMS4yNSpsZW5ndGgoZGVyaXYpL3NjYWxlRmFjdG9yKTtmbG9hdCBhc3BlY3Q9ZGVyaXYueCAhPTAuMCA/IGF0YW4oZGVyaXYueSwtZGVyaXYueCkgOiBQSS8yLjAqKGRlcml2LnkgPiAwLjAgPyAxLjAgOi0xLjApO2Zsb2F0IGludGVuc2l0eT11X2xpZ2h0Lng7ZmxvYXQgYXppbXV0aD11X2xpZ2h0LnkrUEk7ZmxvYXQgYmFzZT0xLjg3NS1pbnRlbnNpdHkqMS43NTtmbG9hdCBtYXhWYWx1ZT0wLjUqUEk7ZmxvYXQgc2NhbGVkU2xvcGU9aW50ZW5zaXR5ICE9MC41ID8gKChwb3coYmFzZSxzbG9wZSktMS4wKS8ocG93KGJhc2UsbWF4VmFsdWUpLTEuMCkpKm1heFZhbHVlIDogc2xvcGU7ZmxvYXQgYWNjZW50PWNvcyhzY2FsZWRTbG9wZSk7dmVjNCBhY2NlbnRfY29sb3I9KDEuMC1hY2NlbnQpKnVfYWNjZW50KmNsYW1wKGludGVuc2l0eSoyLjAsMC4wLDEuMCk7ZmxvYXQgc2hhZGU9YWJzKG1vZCgoYXNwZWN0K2F6aW11dGgpL1BJKzAuNSwyLjApLTEuMCk7dmVjNCBzaGFkZV9jb2xvcj1taXgodV9zaGFkb3csdV9oaWdobGlnaHQsc2hhZGUpKnNpbihzY2FsZWRTbG9wZSkqY2xhbXAoaW50ZW5zaXR5KjIuMCwwLjAsMS4wKTtnbF9GcmFnQ29sb3I9YWNjZW50X2NvbG9yKigxLjAtc2hhZGVfY29sb3IuYSkrc2hhZGVfY29sb3I7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZfcG9zPWFfdGV4dHVyZV9wb3MvODE5Mi4wO31cIiksXG4gICAgICAgIGNpID0gZ2koXCJ1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWMyIHZfd2lkdGgyO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuZmxvYXQgZGlzdD1sZW5ndGgodl9ub3JtYWwpKnZfd2lkdGgyLnM7ZmxvYXQgYmx1cjI9KGJsdXIrMS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvKSp2X2dhbW1hX3NjYWxlO2Zsb2F0IGFscGhhPWNsYW1wKG1pbihkaXN0LSh2X3dpZHRoMi50LWJsdXIyKSx2X3dpZHRoMi5zLWRpc3QpL2JsdXIyLDAuMCwxLjApO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcIlxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc19ub3JtYWw7YXR0cmlidXRlIHZlYzQgYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIHZlYzIgdV91bml0c190b19waXhlbHM7dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO3ZhcnlpbmcgaGlnaHAgZmxvYXQgdl9saW5lc29mYXI7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG5mbG9hdCBBTlRJQUxJQVNJTkc9MS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvLzIuMDt2ZWMyIGFfZXh0cnVkZT1hX2RhdGEueHktMTI4LjA7ZmxvYXQgYV9kaXJlY3Rpb249bW9kKGFfZGF0YS56LDQuMCktMS4wO3ZfbGluZXNvZmFyPShmbG9vcihhX2RhdGEuei80LjApK2FfZGF0YS53KjY0LjApKjIuMDt2ZWMyIHBvcz1mbG9vcihhX3Bvc19ub3JtYWwqMC41KTttZWRpdW1wIHZlYzIgbm9ybWFsPWFfcG9zX25vcm1hbC0yLjAqcG9zO25vcm1hbC55PW5vcm1hbC55KjIuMC0xLjA7dl9ub3JtYWw9bm9ybWFsO2dhcHdpZHRoPWdhcHdpZHRoLzIuMDtmbG9hdCBoYWxmd2lkdGg9d2lkdGgvMi4wO29mZnNldD0tMS4wKm9mZnNldDtmbG9hdCBpbnNldD1nYXB3aWR0aCsoZ2Fwd2lkdGggPiAwLjAgPyBBTlRJQUxJQVNJTkcgOiAwLjApO2Zsb2F0IG91dHNldD1nYXB3aWR0aCtoYWxmd2lkdGgqKGdhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSsoaGFsZndpZHRoPT0wLjAgPyAwLjAgOiBBTlRJQUxJQVNJTkcpO21lZGl1bXAgdmVjMiBkaXN0PW91dHNldCphX2V4dHJ1ZGUqc2NhbGU7bWVkaXVtcCBmbG9hdCB1PTAuNSphX2RpcmVjdGlvbjttZWRpdW1wIGZsb2F0IHQ9MS4wLWFicyh1KTttZWRpdW1wIHZlYzIgb2Zmc2V0Mj1vZmZzZXQqYV9leHRydWRlKnNjYWxlKm5vcm1hbC55Km1hdDIodCwtdSx1LHQpO3ZlYzQgcHJvamVjdGVkX2V4dHJ1ZGU9dV9tYXRyaXgqdmVjNChkaXN0L3VfcmF0aW8sMC4wLDAuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChwb3Mrb2Zmc2V0Mi91X3JhdGlvLDAuMCwxLjApK3Byb2plY3RlZF9leHRydWRlO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmU9bGVuZ3RoKGRpc3QpO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU9bGVuZ3RoKHByb2plY3RlZF9leHRydWRlLnh5L2dsX1Bvc2l0aW9uLncqdV91bml0c190b19waXhlbHMpO3ZfZ2FtbWFfc2NhbGU9ZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZS9leHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt9XCIpLFxuICAgICAgICB1aSA9IGdpKFwidW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfd2lkdGgyO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5mbG9hdCBkaXN0PWxlbmd0aCh2X25vcm1hbCkqdl93aWR0aDIucztmbG9hdCBibHVyMj0oYmx1cisxLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8pKnZfZ2FtbWFfc2NhbGU7ZmxvYXQgYWxwaGE9Y2xhbXAobWluKGRpc3QtKHZfd2lkdGgyLnQtYmx1cjIpLHZfd2lkdGgyLnMtZGlzdCkvYmx1cjIsMC4wLDEuMCk7dmVjNCBjb2xvcj10ZXh0dXJlMkQodV9pbWFnZSx2X3V2KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuYXR0cmlidXRlIHZlYzIgYV9wb3Nfbm9ybWFsO2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgZmxvYXQgYV91dl94O2F0dHJpYnV0ZSBmbG9hdCBhX3NwbGl0X2luZGV4O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfdW5pdHNfdG9fcGl4ZWxzO3VuaWZvcm0gZmxvYXQgdV9pbWFnZV9oZWlnaHQ7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7aGlnaHAgZmxvYXQgdGV4ZWxfaGVpZ2h0PTEuMC91X2ltYWdlX2hlaWdodDtoaWdocCBmbG9hdCBoYWxmX3RleGVsX2hlaWdodD0wLjUqdGV4ZWxfaGVpZ2h0O3ZfdXY9dmVjMihhX3V2X3gsYV9zcGxpdF9pbmRleCp0ZXhlbF9oZWlnaHQtaGFsZl90ZXhlbF9oZWlnaHQpO3ZlYzIgcG9zPWZsb29yKGFfcG9zX25vcm1hbCowLjUpO21lZGl1bXAgdmVjMiBub3JtYWw9YV9wb3Nfbm9ybWFsLTIuMCpwb3M7bm9ybWFsLnk9bm9ybWFsLnkqMi4wLTEuMDt2X25vcm1hbD1ub3JtYWw7Z2Fwd2lkdGg9Z2Fwd2lkdGgvMi4wO2Zsb2F0IGhhbGZ3aWR0aD13aWR0aC8yLjA7b2Zmc2V0PS0xLjAqb2Zmc2V0O2Zsb2F0IGluc2V0PWdhcHdpZHRoKyhnYXB3aWR0aCA+IDAuMCA/IEFOVElBTElBU0lORyA6IDAuMCk7ZmxvYXQgb3V0c2V0PWdhcHdpZHRoK2hhbGZ3aWR0aCooZ2Fwd2lkdGggPiAwLjAgPyAyLjAgOiAxLjApKyhoYWxmd2lkdGg9PTAuMCA/IDAuMCA6IEFOVElBTElBU0lORyk7bWVkaXVtcCB2ZWMyIGRpc3Q9b3V0c2V0KmFfZXh0cnVkZSpzY2FsZTttZWRpdW1wIGZsb2F0IHU9MC41KmFfZGlyZWN0aW9uO21lZGl1bXAgZmxvYXQgdD0xLjAtYWJzKHUpO21lZGl1bXAgdmVjMiBvZmZzZXQyPW9mZnNldCphX2V4dHJ1ZGUqc2NhbGUqbm9ybWFsLnkqbWF0Mih0LC11LHUsdCk7dmVjNCBwcm9qZWN0ZWRfZXh0cnVkZT11X21hdHJpeCp2ZWM0KGRpc3QvdV9yYXRpbywwLjAsMC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KHBvcytvZmZzZXQyL3VfcmF0aW8sMC4wLDEuMCkrcHJvamVjdGVkX2V4dHJ1ZGU7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZT1sZW5ndGgoZGlzdCk7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZT1sZW5ndGgocHJvamVjdGVkX2V4dHJ1ZGUueHkvZ2xfUG9zaXRpb24udyp1X3VuaXRzX3RvX3BpeGVscyk7dl9nYW1tYV9zY2FsZT1leHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlL2V4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU7dl93aWR0aDI9dmVjMihvdXRzZXQsaW5zZXQpO31cIiksXG4gICAgICAgIGhpID0gZ2koXCJ1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt1bmlmb3JtIG1lZGl1bXAgdmVjMyB1X3NjYWxlO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO3ZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTt2YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVpvb21SYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO3ZlYzIgcGF0dGVybl9zaXplX2E9dmVjMihkaXNwbGF5X3NpemVfYS54KmZyb21TY2FsZS90aWxlWm9vbVJhdGlvLGRpc3BsYXlfc2l6ZV9hLnkpO3ZlYzIgcGF0dGVybl9zaXplX2I9dmVjMihkaXNwbGF5X3NpemVfYi54KnRvU2NhbGUvdGlsZVpvb21SYXRpbyxkaXNwbGF5X3NpemVfYi55KTtmbG9hdCBhc3BlY3RfYT1kaXNwbGF5X3NpemVfYS55L3Zfd2lkdGg7ZmxvYXQgYXNwZWN0X2I9ZGlzcGxheV9zaXplX2IueS92X3dpZHRoO2Zsb2F0IGRpc3Q9bGVuZ3RoKHZfbm9ybWFsKSp2X3dpZHRoMi5zO2Zsb2F0IGJsdXIyPShibHVyKzEuMC91X2RldmljZV9waXhlbF9yYXRpbykqdl9nYW1tYV9zY2FsZTtmbG9hdCBhbHBoYT1jbGFtcChtaW4oZGlzdC0odl93aWR0aDIudC1ibHVyMiksdl93aWR0aDIucy1kaXN0KS9ibHVyMiwwLjAsMS4wKTtmbG9hdCB4X2E9bW9kKHZfbGluZXNvZmFyL3BhdHRlcm5fc2l6ZV9hLngqYXNwZWN0X2EsMS4wKTtmbG9hdCB4X2I9bW9kKHZfbGluZXNvZmFyL3BhdHRlcm5fc2l6ZV9iLngqYXNwZWN0X2IsMS4wKTtmbG9hdCB5PTAuNSp2X25vcm1hbC55KzAuNTt2ZWMyIHRleGVsX3NpemU9MS4wL3VfdGV4c2l6ZTt2ZWMyIHBvc19hPW1peChwYXR0ZXJuX3RsX2EqdGV4ZWxfc2l6ZS10ZXhlbF9zaXplLHBhdHRlcm5fYnJfYSp0ZXhlbF9zaXplK3RleGVsX3NpemUsdmVjMih4X2EseSkpO3ZlYzIgcG9zX2I9bWl4KHBhdHRlcm5fdGxfYip0ZXhlbF9zaXplLXRleGVsX3NpemUscGF0dGVybl9icl9iKnRleGVsX3NpemUrdGV4ZWxfc2l6ZSx2ZWMyKHhfYix5KSk7dmVjNCBjb2xvcj1taXgodGV4dHVyZTJEKHVfaW1hZ2UscG9zX2EpLHRleHR1cmUyRCh1X2ltYWdlLHBvc19iKSx1X2ZhZGUpO2dsX0ZyYWdDb2xvcj1jb2xvciphbHBoYSpvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuI2RlZmluZSBMSU5FX0RJU1RBTkNFX1NDQUxFIDIuMFxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zX25vcm1hbDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3VuaXRzX3RvX3BpeGVsczt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO3ZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTt2YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBmbG9vcndpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7ZmxvYXQgYV9saW5lc29mYXI9KGZsb29yKGFfZGF0YS56LzQuMCkrYV9kYXRhLncqNjQuMCkqTElORV9ESVNUQU5DRV9TQ0FMRTt2ZWMyIHBvcz1mbG9vcihhX3Bvc19ub3JtYWwqMC41KTttZWRpdW1wIHZlYzIgbm9ybWFsPWFfcG9zX25vcm1hbC0yLjAqcG9zO25vcm1hbC55PW5vcm1hbC55KjIuMC0xLjA7dl9ub3JtYWw9bm9ybWFsO2dhcHdpZHRoPWdhcHdpZHRoLzIuMDtmbG9hdCBoYWxmd2lkdGg9d2lkdGgvMi4wO29mZnNldD0tMS4wKm9mZnNldDtmbG9hdCBpbnNldD1nYXB3aWR0aCsoZ2Fwd2lkdGggPiAwLjAgPyBBTlRJQUxJQVNJTkcgOiAwLjApO2Zsb2F0IG91dHNldD1nYXB3aWR0aCtoYWxmd2lkdGgqKGdhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSsoaGFsZndpZHRoPT0wLjAgPyAwLjAgOiBBTlRJQUxJQVNJTkcpO21lZGl1bXAgdmVjMiBkaXN0PW91dHNldCphX2V4dHJ1ZGUqc2NhbGU7bWVkaXVtcCBmbG9hdCB1PTAuNSphX2RpcmVjdGlvbjttZWRpdW1wIGZsb2F0IHQ9MS4wLWFicyh1KTttZWRpdW1wIHZlYzIgb2Zmc2V0Mj1vZmZzZXQqYV9leHRydWRlKnNjYWxlKm5vcm1hbC55Km1hdDIodCwtdSx1LHQpO3ZlYzQgcHJvamVjdGVkX2V4dHJ1ZGU9dV9tYXRyaXgqdmVjNChkaXN0L3VfcmF0aW8sMC4wLDAuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChwb3Mrb2Zmc2V0Mi91X3JhdGlvLDAuMCwxLjApK3Byb2plY3RlZF9leHRydWRlO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmU9bGVuZ3RoKGRpc3QpO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU9bGVuZ3RoKHByb2plY3RlZF9leHRydWRlLnh5L2dsX1Bvc2l0aW9uLncqdV91bml0c190b19waXhlbHMpO3ZfZ2FtbWFfc2NhbGU9ZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZS9leHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlO3ZfbGluZXNvZmFyPWFfbGluZXNvZmFyO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt2X3dpZHRoPWZsb29yd2lkdGg7fVwiKSxcbiAgICAgICAgcGkgPSBnaShcInVuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3VuaWZvcm0gZmxvYXQgdV9zZGZnYW1tYTt1bmlmb3JtIGZsb2F0IHVfbWl4O3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyB2ZWMyIHZfdGV4X2E7dmFyeWluZyB2ZWMyIHZfdGV4X2I7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbmZsb2F0IGRpc3Q9bGVuZ3RoKHZfbm9ybWFsKSp2X3dpZHRoMi5zO2Zsb2F0IGJsdXIyPShibHVyKzEuMC91X2RldmljZV9waXhlbF9yYXRpbykqdl9nYW1tYV9zY2FsZTtmbG9hdCBhbHBoYT1jbGFtcChtaW4oZGlzdC0odl93aWR0aDIudC1ibHVyMiksdl93aWR0aDIucy1kaXN0KS9ibHVyMiwwLjAsMS4wKTtmbG9hdCBzZGZkaXN0X2E9dGV4dHVyZTJEKHVfaW1hZ2Usdl90ZXhfYSkuYTtmbG9hdCBzZGZkaXN0X2I9dGV4dHVyZTJEKHVfaW1hZ2Usdl90ZXhfYikuYTtmbG9hdCBzZGZkaXN0PW1peChzZGZkaXN0X2Esc2RmZGlzdF9iLHVfbWl4KTthbHBoYSo9c21vb3Roc3RlcCgwLjUtdV9zZGZnYW1tYS9mbG9vcndpZHRoLDAuNSt1X3NkZmdhbW1hL2Zsb29yd2lkdGgsc2RmZGlzdCk7Z2xfRnJhZ0NvbG9yPWNvbG9yKihhbHBoYSpvcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiXFxuI2RlZmluZSBzY2FsZSAwLjAxNTg3MzAxNlxcbiNkZWZpbmUgTElORV9ESVNUQU5DRV9TQ0FMRSAyLjBcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc19ub3JtYWw7YXR0cmlidXRlIHZlYzQgYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2E7dW5pZm9ybSBmbG9hdCB1X3RleF95X2E7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2I7dW5pZm9ybSBmbG9hdCB1X3RleF95X2I7dW5pZm9ybSB2ZWMyIHVfdW5pdHNfdG9fcGl4ZWxzO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyB2ZWMyIHZfdGV4X2E7dmFyeWluZyB2ZWMyIHZfdGV4X2I7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGZsb29yd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGZsb29yd2lkdGhcXG5mbG9hdCBBTlRJQUxJQVNJTkc9MS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvLzIuMDt2ZWMyIGFfZXh0cnVkZT1hX2RhdGEueHktMTI4LjA7ZmxvYXQgYV9kaXJlY3Rpb249bW9kKGFfZGF0YS56LDQuMCktMS4wO2Zsb2F0IGFfbGluZXNvZmFyPShmbG9vcihhX2RhdGEuei80LjApK2FfZGF0YS53KjY0LjApKkxJTkVfRElTVEFOQ0VfU0NBTEU7dmVjMiBwb3M9Zmxvb3IoYV9wb3Nfbm9ybWFsKjAuNSk7bWVkaXVtcCB2ZWMyIG5vcm1hbD1hX3Bvc19ub3JtYWwtMi4wKnBvcztub3JtYWwueT1ub3JtYWwueSoyLjAtMS4wO3Zfbm9ybWFsPW5vcm1hbDtnYXB3aWR0aD1nYXB3aWR0aC8yLjA7ZmxvYXQgaGFsZndpZHRoPXdpZHRoLzIuMDtvZmZzZXQ9LTEuMCpvZmZzZXQ7ZmxvYXQgaW5zZXQ9Z2Fwd2lkdGgrKGdhcHdpZHRoID4gMC4wID8gQU5USUFMSUFTSU5HIDogMC4wKTtmbG9hdCBvdXRzZXQ9Z2Fwd2lkdGgraGFsZndpZHRoKihnYXB3aWR0aCA+IDAuMCA/IDIuMCA6IDEuMCkrKGhhbGZ3aWR0aD09MC4wID8gMC4wIDogQU5USUFMSUFTSU5HKTttZWRpdW1wIHZlYzIgZGlzdD1vdXRzZXQqYV9leHRydWRlKnNjYWxlO21lZGl1bXAgZmxvYXQgdT0wLjUqYV9kaXJlY3Rpb247bWVkaXVtcCBmbG9hdCB0PTEuMC1hYnModSk7bWVkaXVtcCB2ZWMyIG9mZnNldDI9b2Zmc2V0KmFfZXh0cnVkZSpzY2FsZSpub3JtYWwueSptYXQyKHQsLXUsdSx0KTt2ZWM0IHByb2plY3RlZF9leHRydWRlPXVfbWF0cml4KnZlYzQoZGlzdC91X3JhdGlvLDAuMCwwLjApO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQocG9zK29mZnNldDIvdV9yYXRpbywwLjAsMS4wKStwcm9qZWN0ZWRfZXh0cnVkZTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlPWxlbmd0aChkaXN0KTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlPWxlbmd0aChwcm9qZWN0ZWRfZXh0cnVkZS54eS9nbF9Qb3NpdGlvbi53KnVfdW5pdHNfdG9fcGl4ZWxzKTt2X2dhbW1hX3NjYWxlPWV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmUvZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZTt2X3RleF9hPXZlYzIoYV9saW5lc29mYXIqdV9wYXR0ZXJuc2NhbGVfYS54L2Zsb29yd2lkdGgsbm9ybWFsLnkqdV9wYXR0ZXJuc2NhbGVfYS55K3VfdGV4X3lfYSk7dl90ZXhfYj12ZWMyKGFfbGluZXNvZmFyKnVfcGF0dGVybnNjYWxlX2IueC9mbG9vcndpZHRoLG5vcm1hbC55KnVfcGF0dGVybnNjYWxlX2IueSt1X3RleF95X2IpO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt9XCIpLFxuICAgICAgICBkaSA9IGdpKFwidW5pZm9ybSBmbG9hdCB1X2ZhZGVfdDt1bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMDt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMTt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O3VuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7dW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO3VuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7dW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO3ZvaWQgbWFpbigpIHt2ZWM0IGNvbG9yMD10ZXh0dXJlMkQodV9pbWFnZTAsdl9wb3MwKTt2ZWM0IGNvbG9yMT10ZXh0dXJlMkQodV9pbWFnZTEsdl9wb3MxKTtpZiAoY29sb3IwLmEgPiAwLjApIHtjb2xvcjAucmdiPWNvbG9yMC5yZ2IvY29sb3IwLmE7fWlmIChjb2xvcjEuYSA+IDAuMCkge2NvbG9yMS5yZ2I9Y29sb3IxLnJnYi9jb2xvcjEuYTt9dmVjNCBjb2xvcj1taXgoY29sb3IwLGNvbG9yMSx1X2ZhZGVfdCk7Y29sb3IuYSo9dV9vcGFjaXR5O3ZlYzMgcmdiPWNvbG9yLnJnYjtyZ2I9dmVjMyhkb3QocmdiLHVfc3Bpbl93ZWlnaHRzLnh5eiksZG90KHJnYix1X3NwaW5fd2VpZ2h0cy56eHkpLGRvdChyZ2IsdV9zcGluX3dlaWdodHMueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDtyZ2IrPShhdmVyYWdlLXJnYikqdV9zYXR1cmF0aW9uX2ZhY3RvcjtyZ2I9KHJnYi0wLjUpKnVfY29udHJhc3RfZmFjdG9yKzAuNTt2ZWMzIHVfaGlnaF92ZWM9dmVjMyh1X2JyaWdodG5lc3NfbG93LHVfYnJpZ2h0bmVzc19sb3csdV9icmlnaHRuZXNzX2xvdyk7dmVjMyB1X2xvd192ZWM9dmVjMyh1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCk7Z2xfRnJhZ0NvbG9yPXZlYzQobWl4KHVfaGlnaF92ZWMsdV9sb3dfdmVjLHJnYikqY29sb3IuYSxjb2xvci5hKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDt1bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O3VuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3BvczA9KCgoYV90ZXh0dXJlX3Bvcy84MTkyLjApLTAuNSkvdV9idWZmZXJfc2NhbGUgKSswLjU7dl9wb3MxPSh2X3BvczAqdV9zY2FsZV9wYXJlbnQpK3VfdGxfcGFyZW50O31cIiksXG4gICAgICAgIF9pID0gZ2koXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7dmFyeWluZyB2ZWMyIHZfdGV4O3ZhcnlpbmcgZmxvYXQgdl9mYWRlX29wYWNpdHk7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxubG93cCBmbG9hdCBhbHBoYT1vcGFjaXR5KnZfZmFkZV9vcGFjaXR5O2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodV90ZXh0dXJlLHZfdGV4KSphbHBoYTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiY29uc3QgZmxvYXQgUEk9My4xNDE1OTI2NTM1ODk3OTM7YXR0cmlidXRlIHZlYzQgYV9wb3Nfb2Zmc2V0O2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgdmVjNCBhX3BpeGVsb2Zmc2V0O2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9waXRjaDt1bmlmb3JtIGJvb2wgdV9yb3RhdGVfc3ltYm9sO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9hc3BlY3RfcmF0aW87dW5pZm9ybSBmbG9hdCB1X2ZhZGVfY2hhbmdlO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt2YXJ5aW5nIHZlYzIgdl90ZXg7dmFyeWluZyBmbG9hdCB2X2ZhZGVfb3BhY2l0eTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52ZWMyIGFfcG9zPWFfcG9zX29mZnNldC54eTt2ZWMyIGFfb2Zmc2V0PWFfcG9zX29mZnNldC56dzt2ZWMyIGFfdGV4PWFfZGF0YS54eTt2ZWMyIGFfc2l6ZT1hX2RhdGEuenc7ZmxvYXQgYV9zaXplX21pbj1mbG9vcihhX3NpemVbMF0qMC41KTt2ZWMyIGFfcHhvZmZzZXQ9YV9waXhlbG9mZnNldC54eTt2ZWMyIGFfbWluRm9udFNjYWxlPWFfcGl4ZWxvZmZzZXQuencvMjU2LjA7aGlnaHAgZmxvYXQgc2VnbWVudF9hbmdsZT0tYV9wcm9qZWN0ZWRfcG9zWzJdO2Zsb2F0IHNpemU7aWYgKCF1X2lzX3NpemVfem9vbV9jb25zdGFudCAmJiAhdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpIHtzaXplPW1peChhX3NpemVfbWluLGFfc2l6ZVsxXSx1X3NpemVfdCkvMTI4LjA7fSBlbHNlIGlmICh1X2lzX3NpemVfem9vbV9jb25zdGFudCAmJiAhdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpIHtzaXplPWFfc2l6ZV9taW4vMTI4LjA7fSBlbHNlIHtzaXplPXVfc2l6ZTt9dmVjNCBwcm9qZWN0ZWRQb2ludD11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSk7aGlnaHAgZmxvYXQgY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZT1wcm9qZWN0ZWRQb2ludC53O2hpZ2hwIGZsb2F0IGRpc3RhbmNlX3JhdGlvPXVfcGl0Y2hfd2l0aF9tYXAgP1xcbmNhbWVyYV90b19hbmNob3JfZGlzdGFuY2UvdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlIDpcXG51X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UvY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZTtoaWdocCBmbG9hdCBwZXJzcGVjdGl2ZV9yYXRpbz1jbGFtcCgwLjUrMC41KmRpc3RhbmNlX3JhdGlvLDAuMCw0LjApO3NpemUqPXBlcnNwZWN0aXZlX3JhdGlvO2Zsb2F0IGZvbnRTY2FsZT11X2lzX3RleHQgPyBzaXplLzI0LjAgOiBzaXplO2hpZ2hwIGZsb2F0IHN5bWJvbF9yb3RhdGlvbj0wLjA7aWYgKHVfcm90YXRlX3N5bWJvbCkge3ZlYzQgb2Zmc2V0UHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX3Bvcyt2ZWMyKDEsMCksMCwxKTt2ZWMyIGE9cHJvamVjdGVkUG9pbnQueHkvcHJvamVjdGVkUG9pbnQudzt2ZWMyIGI9b2Zmc2V0UHJvamVjdGVkUG9pbnQueHkvb2Zmc2V0UHJvamVjdGVkUG9pbnQudztzeW1ib2xfcm90YXRpb249YXRhbigoYi55LWEueSkvdV9hc3BlY3RfcmF0aW8sYi54LWEueCk7fWhpZ2hwIGZsb2F0IGFuZ2xlX3Npbj1zaW4oc2VnbWVudF9hbmdsZStzeW1ib2xfcm90YXRpb24pO2hpZ2hwIGZsb2F0IGFuZ2xlX2Nvcz1jb3Moc2VnbWVudF9hbmdsZStzeW1ib2xfcm90YXRpb24pO21hdDIgcm90YXRpb25fbWF0cml4PW1hdDIoYW5nbGVfY29zLC0xLjAqYW5nbGVfc2luLGFuZ2xlX3NpbixhbmdsZV9jb3MpO3ZlYzQgcHJvamVjdGVkX3Bvcz11X2xhYmVsX3BsYW5lX21hdHJpeCp2ZWM0KGFfcHJvamVjdGVkX3Bvcy54eSwwLjAsMS4wKTtnbF9Qb3NpdGlvbj11X2Nvb3JkX21hdHJpeCp2ZWM0KHByb2plY3RlZF9wb3MueHkvcHJvamVjdGVkX3Bvcy53K3JvdGF0aW9uX21hdHJpeCooYV9vZmZzZXQvMzIuMCptYXgoYV9taW5Gb250U2NhbGUsZm9udFNjYWxlKSthX3B4b2Zmc2V0LzE2LjApLDAuMCwxLjApO3ZfdGV4PWFfdGV4L3VfdGV4c2l6ZTt2ZWMyIGZhZGVfb3BhY2l0eT11bnBhY2tfb3BhY2l0eShhX2ZhZGVfb3BhY2l0eSk7ZmxvYXQgZmFkZV9jaGFuZ2U9ZmFkZV9vcGFjaXR5WzFdID4gMC41ID8gdV9mYWRlX2NoYW5nZSA6LXVfZmFkZV9jaGFuZ2U7dl9mYWRlX29wYWNpdHk9bWF4KDAuMCxtaW4oMS4wLGZhZGVfb3BhY2l0eVswXStmYWRlX2NoYW5nZSkpO31cIiksXG4gICAgICAgIGZpID0gZ2koXCIjZGVmaW5lIFNERl9QWCA4LjBcXG51bmlmb3JtIGJvb2wgdV9pc19oYWxvO3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfZ2FtbWFfc2NhbGU7dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dmFyeWluZyB2ZWMyIHZfZGF0YTA7dmFyeWluZyB2ZWMzIHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxuZmxvYXQgRURHRV9HQU1NQT0wLjEwNS91X2RldmljZV9waXhlbF9yYXRpbzt2ZWMyIHRleD12X2RhdGEwLnh5O2Zsb2F0IGdhbW1hX3NjYWxlPXZfZGF0YTEueDtmbG9hdCBzaXplPXZfZGF0YTEueTtmbG9hdCBmYWRlX29wYWNpdHk9dl9kYXRhMVsyXTtmbG9hdCBmb250U2NhbGU9dV9pc190ZXh0ID8gc2l6ZS8yNC4wIDogc2l6ZTtsb3dwIHZlYzQgY29sb3I9ZmlsbF9jb2xvcjtoaWdocCBmbG9hdCBnYW1tYT1FREdFX0dBTU1BLyhmb250U2NhbGUqdV9nYW1tYV9zY2FsZSk7bG93cCBmbG9hdCBidWZmPSgyNTYuMC02NC4wKS8yNTYuMDtpZiAodV9pc19oYWxvKSB7Y29sb3I9aGFsb19jb2xvcjtnYW1tYT0oaGFsb19ibHVyKjEuMTkvU0RGX1BYK0VER0VfR0FNTUEpLyhmb250U2NhbGUqdV9nYW1tYV9zY2FsZSk7YnVmZj0oNi4wLWhhbG9fd2lkdGgvZm9udFNjYWxlKS9TREZfUFg7fWxvd3AgZmxvYXQgZGlzdD10ZXh0dXJlMkQodV90ZXh0dXJlLHRleCkuYTtoaWdocCBmbG9hdCBnYW1tYV9zY2FsZWQ9Z2FtbWEqZ2FtbWFfc2NhbGU7aGlnaHAgZmxvYXQgYWxwaGE9c21vb3Roc3RlcChidWZmLWdhbW1hX3NjYWxlZCxidWZmK2dhbW1hX3NjYWxlZCxkaXN0KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkqZmFkZV9vcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiY29uc3QgZmxvYXQgUEk9My4xNDE1OTI2NTM1ODk3OTM7YXR0cmlidXRlIHZlYzQgYV9wb3Nfb2Zmc2V0O2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgdmVjNCBhX3BpeGVsb2Zmc2V0O2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpdGNoO3VuaWZvcm0gYm9vbCB1X3JvdGF0ZV9zeW1ib2w7dW5pZm9ybSBoaWdocCBmbG9hdCB1X2FzcGVjdF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVfZmFkZV9jaGFuZ2U7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt2YXJ5aW5nIHZlYzIgdl9kYXRhMDt2YXJ5aW5nIHZlYzMgdl9kYXRhMTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBmaWxsX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG52ZWMyIGFfcG9zPWFfcG9zX29mZnNldC54eTt2ZWMyIGFfb2Zmc2V0PWFfcG9zX29mZnNldC56dzt2ZWMyIGFfdGV4PWFfZGF0YS54eTt2ZWMyIGFfc2l6ZT1hX2RhdGEuenc7ZmxvYXQgYV9zaXplX21pbj1mbG9vcihhX3NpemVbMF0qMC41KTt2ZWMyIGFfcHhvZmZzZXQ9YV9waXhlbG9mZnNldC54eTtoaWdocCBmbG9hdCBzZWdtZW50X2FuZ2xlPS1hX3Byb2plY3RlZF9wb3NbMl07ZmxvYXQgc2l6ZTtpZiAoIXVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9bWl4KGFfc2l6ZV9taW4sYV9zaXplWzFdLHVfc2l6ZV90KS8xMjguMDt9IGVsc2UgaWYgKHVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9YV9zaXplX21pbi8xMjguMDt9IGVsc2Uge3NpemU9dV9zaXplO312ZWM0IHByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgZGlzdGFuY2VfcmF0aW89dV9waXRjaF93aXRoX21hcCA/XFxuY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZS91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UgOlxcbnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlO2hpZ2hwIGZsb2F0IHBlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqZGlzdGFuY2VfcmF0aW8sMC4wLDQuMCk7c2l6ZSo9cGVyc3BlY3RpdmVfcmF0aW87ZmxvYXQgZm9udFNjYWxlPXVfaXNfdGV4dCA/IHNpemUvMjQuMCA6IHNpemU7aGlnaHAgZmxvYXQgc3ltYm9sX3JvdGF0aW9uPTAuMDtpZiAodV9yb3RhdGVfc3ltYm9sKSB7dmVjNCBvZmZzZXRQcm9qZWN0ZWRQb2ludD11X21hdHJpeCp2ZWM0KGFfcG9zK3ZlYzIoMSwwKSwwLDEpO3ZlYzIgYT1wcm9qZWN0ZWRQb2ludC54eS9wcm9qZWN0ZWRQb2ludC53O3ZlYzIgYj1vZmZzZXRQcm9qZWN0ZWRQb2ludC54eS9vZmZzZXRQcm9qZWN0ZWRQb2ludC53O3N5bWJvbF9yb3RhdGlvbj1hdGFuKChiLnktYS55KS91X2FzcGVjdF9yYXRpbyxiLngtYS54KTt9aGlnaHAgZmxvYXQgYW5nbGVfc2luPXNpbihzZWdtZW50X2FuZ2xlK3N5bWJvbF9yb3RhdGlvbik7aGlnaHAgZmxvYXQgYW5nbGVfY29zPWNvcyhzZWdtZW50X2FuZ2xlK3N5bWJvbF9yb3RhdGlvbik7bWF0MiByb3RhdGlvbl9tYXRyaXg9bWF0MihhbmdsZV9jb3MsLTEuMCphbmdsZV9zaW4sYW5nbGVfc2luLGFuZ2xlX2Nvcyk7dmVjNCBwcm9qZWN0ZWRfcG9zPXVfbGFiZWxfcGxhbmVfbWF0cml4KnZlYzQoYV9wcm9qZWN0ZWRfcG9zLnh5LDAuMCwxLjApO2dsX1Bvc2l0aW9uPXVfY29vcmRfbWF0cml4KnZlYzQocHJvamVjdGVkX3Bvcy54eS9wcm9qZWN0ZWRfcG9zLncrcm90YXRpb25fbWF0cml4KihhX29mZnNldC8zMi4wKmZvbnRTY2FsZSthX3B4b2Zmc2V0KSwwLjAsMS4wKTtmbG9hdCBnYW1tYV9zY2FsZT1nbF9Qb3NpdGlvbi53O3ZlYzIgZmFkZV9vcGFjaXR5PXVucGFja19vcGFjaXR5KGFfZmFkZV9vcGFjaXR5KTtmbG9hdCBmYWRlX2NoYW5nZT1mYWRlX29wYWNpdHlbMV0gPiAwLjUgPyB1X2ZhZGVfY2hhbmdlIDotdV9mYWRlX2NoYW5nZTtmbG9hdCBpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt2X2RhdGEwPWFfdGV4L3VfdGV4c2l6ZTt2X2RhdGExPXZlYzMoZ2FtbWFfc2NhbGUsc2l6ZSxpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5KTt9XCIpLFxuICAgICAgICBtaSA9IGdpKFwiI2RlZmluZSBTREZfUFggOC4wXFxuI2RlZmluZSBTREYgMS4wXFxuI2RlZmluZSBJQ09OIDAuMFxcbnVuaWZvcm0gYm9vbCB1X2lzX2hhbG87dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZV9pY29uO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9nYW1tYV9zY2FsZTt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxuZmxvYXQgZmFkZV9vcGFjaXR5PXZfZGF0YTFbMl07aWYgKHZfZGF0YTEudz09SUNPTikge3ZlYzIgdGV4X2ljb249dl9kYXRhMC56dztsb3dwIGZsb2F0IGFscGhhPW9wYWNpdHkqZmFkZV9vcGFjaXR5O2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodV90ZXh0dXJlX2ljb24sdGV4X2ljb24pKmFscGhhO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbnJldHVybjt9dmVjMiB0ZXg9dl9kYXRhMC54eTtmbG9hdCBFREdFX0dBTU1BPTAuMTA1L3VfZGV2aWNlX3BpeGVsX3JhdGlvO2Zsb2F0IGdhbW1hX3NjYWxlPXZfZGF0YTEueDtmbG9hdCBzaXplPXZfZGF0YTEueTtmbG9hdCBmb250U2NhbGU9c2l6ZS8yNC4wO2xvd3AgdmVjNCBjb2xvcj1maWxsX2NvbG9yO2hpZ2hwIGZsb2F0IGdhbW1hPUVER0VfR0FNTUEvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtsb3dwIGZsb2F0IGJ1ZmY9KDI1Ni4wLTY0LjApLzI1Ni4wO2lmICh1X2lzX2hhbG8pIHtjb2xvcj1oYWxvX2NvbG9yO2dhbW1hPShoYWxvX2JsdXIqMS4xOS9TREZfUFgrRURHRV9HQU1NQSkvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtidWZmPSg2LjAtaGFsb193aWR0aC9mb250U2NhbGUpL1NERl9QWDt9bG93cCBmbG9hdCBkaXN0PXRleHR1cmUyRCh1X3RleHR1cmUsdGV4KS5hO2hpZ2hwIGZsb2F0IGdhbW1hX3NjYWxlZD1nYW1tYSpnYW1tYV9zY2FsZTtoaWdocCBmbG9hdCBhbHBoYT1zbW9vdGhzdGVwKGJ1ZmYtZ2FtbWFfc2NhbGVkLGJ1ZmYrZ2FtbWFfc2NhbGVkLGRpc3QpO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSpmYWRlX29wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJjb25zdCBmbG9hdCBQST0zLjE0MTU5MjY1MzU4OTc5MzthdHRyaWJ1dGUgdmVjNCBhX3Bvc19vZmZzZXQ7YXR0cmlidXRlIHZlYzQgYV9kYXRhO2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpdGNoO3VuaWZvcm0gYm9vbCB1X3JvdGF0ZV9zeW1ib2w7dW5pZm9ybSBoaWdocCBmbG9hdCB1X2FzcGVjdF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVfZmFkZV9jaGFuZ2U7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIHZlYzIgdV90ZXhzaXplX2ljb247dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudmVjMiBhX3Bvcz1hX3Bvc19vZmZzZXQueHk7dmVjMiBhX29mZnNldD1hX3Bvc19vZmZzZXQuenc7dmVjMiBhX3RleD1hX2RhdGEueHk7dmVjMiBhX3NpemU9YV9kYXRhLnp3O2Zsb2F0IGFfc2l6ZV9taW49Zmxvb3IoYV9zaXplWzBdKjAuNSk7ZmxvYXQgaXNfc2RmPWFfc2l6ZVswXS0yLjAqYV9zaXplX21pbjtoaWdocCBmbG9hdCBzZWdtZW50X2FuZ2xlPS1hX3Byb2plY3RlZF9wb3NbMl07ZmxvYXQgc2l6ZTtpZiAoIXVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9bWl4KGFfc2l6ZV9taW4sYV9zaXplWzFdLHVfc2l6ZV90KS8xMjguMDt9IGVsc2UgaWYgKHVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9YV9zaXplX21pbi8xMjguMDt9IGVsc2Uge3NpemU9dV9zaXplO312ZWM0IHByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgZGlzdGFuY2VfcmF0aW89dV9waXRjaF93aXRoX21hcCA/XFxuY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZS91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UgOlxcbnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlO2hpZ2hwIGZsb2F0IHBlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqZGlzdGFuY2VfcmF0aW8sMC4wLDQuMCk7c2l6ZSo9cGVyc3BlY3RpdmVfcmF0aW87ZmxvYXQgZm9udFNjYWxlPXNpemUvMjQuMDtoaWdocCBmbG9hdCBzeW1ib2xfcm90YXRpb249MC4wO2lmICh1X3JvdGF0ZV9zeW1ib2wpIHt2ZWM0IG9mZnNldFByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MrdmVjMigxLDApLDAsMSk7dmVjMiBhPXByb2plY3RlZFBvaW50Lnh5L3Byb2plY3RlZFBvaW50Lnc7dmVjMiBiPW9mZnNldFByb2plY3RlZFBvaW50Lnh5L29mZnNldFByb2plY3RlZFBvaW50Lnc7c3ltYm9sX3JvdGF0aW9uPWF0YW4oKGIueS1hLnkpL3VfYXNwZWN0X3JhdGlvLGIueC1hLngpO31oaWdocCBmbG9hdCBhbmdsZV9zaW49c2luKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTtoaWdocCBmbG9hdCBhbmdsZV9jb3M9Y29zKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTttYXQyIHJvdGF0aW9uX21hdHJpeD1tYXQyKGFuZ2xlX2NvcywtMS4wKmFuZ2xlX3NpbixhbmdsZV9zaW4sYW5nbGVfY29zKTt2ZWM0IHByb2plY3RlZF9wb3M9dV9sYWJlbF9wbGFuZV9tYXRyaXgqdmVjNChhX3Byb2plY3RlZF9wb3MueHksMC4wLDEuMCk7Z2xfUG9zaXRpb249dV9jb29yZF9tYXRyaXgqdmVjNChwcm9qZWN0ZWRfcG9zLnh5L3Byb2plY3RlZF9wb3Mudytyb3RhdGlvbl9tYXRyaXgqKGFfb2Zmc2V0LzMyLjAqZm9udFNjYWxlKSwwLjAsMS4wKTtmbG9hdCBnYW1tYV9zY2FsZT1nbF9Qb3NpdGlvbi53O3ZlYzIgZmFkZV9vcGFjaXR5PXVucGFja19vcGFjaXR5KGFfZmFkZV9vcGFjaXR5KTtmbG9hdCBmYWRlX2NoYW5nZT1mYWRlX29wYWNpdHlbMV0gPiAwLjUgPyB1X2ZhZGVfY2hhbmdlIDotdV9mYWRlX2NoYW5nZTtmbG9hdCBpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt2X2RhdGEwLnh5PWFfdGV4L3VfdGV4c2l6ZTt2X2RhdGEwLnp3PWFfdGV4L3VfdGV4c2l6ZV9pY29uO3ZfZGF0YTE9dmVjNChnYW1tYV9zY2FsZSxzaXplLGludGVycG9sYXRlZF9mYWRlX29wYWNpdHksaXNfc2RmKTt9XCIpO1xuXG4gICAgZnVuY3Rpb24gZ2kodCwgZSkge1xuICAgICAgdmFyIGkgPSAvI3ByYWdtYSBtYXBib3g6IChbXFx3XSspIChbXFx3XSspIChbXFx3XSspIChbXFx3XSspL2csXG4gICAgICAgICAgbyA9IGUubWF0Y2goL2F0dHJpYnV0ZSAoW1xcd10rKSAoW1xcd10rKS9nKSxcbiAgICAgICAgICByID0gdC5tYXRjaCgvdW5pZm9ybSAoW1xcd10rKSAoW1xcd10rKShbXFxzXSopKFtcXHddKikvZyksXG4gICAgICAgICAgYSA9IGUubWF0Y2goL3VuaWZvcm0gKFtcXHddKykgKFtcXHddKykoW1xcc10qKShbXFx3XSopL2cpLFxuICAgICAgICAgIG4gPSBhID8gYS5jb25jYXQocikgOiByLFxuICAgICAgICAgIHMgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiB0ID0gdC5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHNbcl0gPSAhMCwgXCJkZWZpbmVcIiA9PT0gZSA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxudmFyeWluZyBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIjtcXG4jZWxzZVxcbnVuaWZvcm0gXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIiA6IFwiXFxuI2lmZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiO1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGV4U291cmNlOiBlID0gZS5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgdmFyIGEgPSBcImZsb2F0XCIgPT09IG8gPyBcInZlYzJcIiA6IFwidmVjNFwiLFxuICAgICAgICAgICAgICBuID0gci5tYXRjaCgvY29sb3IvKSA/IFwiY29sb3JcIiA6IGE7XG4gICAgICAgICAgcmV0dXJuIHNbcl0gPyBcImRlZmluZVwiID09PSBlID8gXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9cIiArIHIgKyBcIl90O1xcbmF0dHJpYnV0ZSBcIiArIGkgKyBcIiBcIiArIGEgKyBcIiBhX1wiICsgciArIFwiO1xcbnZhcnlpbmcgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCI7XFxuI2Vsc2VcXG51bmlmb3JtIFwiICsgaSArIFwiIFwiICsgbyArIFwiIHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcInZlYzRcIiA9PT0gbiA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxuICAgIFwiICsgciArIFwiID0gYV9cIiArIHIgKyBcIjtcXG4jZWxzZVxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcIlxcbiNpZm5kZWYgSEFTX1VOSUZPUk1fdV9cIiArIHIgKyBcIlxcbiAgICBcIiArIHIgKyBcIiA9IHVucGFja19taXhfXCIgKyBuICsgXCIoYV9cIiArIHIgKyBcIiwgdV9cIiArIHIgKyBcIl90KTtcXG4jZWxzZVxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcImRlZmluZVwiID09PSBlID8gXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9cIiArIHIgKyBcIl90O1xcbmF0dHJpYnV0ZSBcIiArIGkgKyBcIiBcIiArIGEgKyBcIiBhX1wiICsgciArIFwiO1xcbiNlbHNlXFxudW5pZm9ybSBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJ2ZWM0XCIgPT09IG4gPyBcIlxcbiNpZm5kZWYgSEFTX1VOSUZPUk1fdV9cIiArIHIgKyBcIlxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IGFfXCIgKyByICsgXCI7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1bnBhY2tfbWl4X1wiICsgbiArIFwiKGFfXCIgKyByICsgXCIsIHVfXCIgKyByICsgXCJfdCk7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiO1xuICAgICAgICB9KSxcbiAgICAgICAgc3RhdGljQXR0cmlidXRlczogbyxcbiAgICAgICAgc3RhdGljVW5pZm9ybXM6IG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHZpID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBwcmVsdWRlOiBHZSxcbiAgICAgIGJhY2tncm91bmQ6IFdlLFxuICAgICAgYmFja2dyb3VuZFBhdHRlcm46IFhlLFxuICAgICAgY2lyY2xlOiBIZSxcbiAgICAgIGNsaXBwaW5nTWFzazogS2UsXG4gICAgICBoZWF0bWFwOiBZZSxcbiAgICAgIGhlYXRtYXBUZXh0dXJlOiBKZSxcbiAgICAgIGNvbGxpc2lvbkJveDogUWUsXG4gICAgICBjb2xsaXNpb25DaXJjbGU6ICRlLFxuICAgICAgZGVidWc6IHRpLFxuICAgICAgZmlsbDogZWksXG4gICAgICBmaWxsT3V0bGluZTogaWksXG4gICAgICBmaWxsT3V0bGluZVBhdHRlcm46IG9pLFxuICAgICAgZmlsbFBhdHRlcm46IHJpLFxuICAgICAgZmlsbEV4dHJ1c2lvbjogYWksXG4gICAgICBmaWxsRXh0cnVzaW9uUGF0dGVybjogbmksXG4gICAgICBoaWxsc2hhZGVQcmVwYXJlOiBzaSxcbiAgICAgIGhpbGxzaGFkZTogbGksXG4gICAgICBsaW5lOiBjaSxcbiAgICAgIGxpbmVHcmFkaWVudDogdWksXG4gICAgICBsaW5lUGF0dGVybjogaGksXG4gICAgICBsaW5lU0RGOiBwaSxcbiAgICAgIHJhc3RlcjogZGksXG4gICAgICBzeW1ib2xJY29uOiBfaSxcbiAgICAgIHN5bWJvbFNERjogZmksXG4gICAgICBzeW1ib2xUZXh0QW5kSWNvbjogbWlcbiAgICB9KSxcbiAgICAgICAgeWkgPSBmdW5jdGlvbiB5aSgpIHtcbiAgICAgIHRoaXMuYm91bmRQcm9ncmFtID0gbnVsbCwgdGhpcy5ib3VuZExheW91dFZlcnRleEJ1ZmZlciA9IG51bGwsIHRoaXMuYm91bmRQYWludFZlcnRleEJ1ZmZlcnMgPSBbXSwgdGhpcy5ib3VuZEluZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5ib3VuZFZlcnRleE9mZnNldCA9IG51bGwsIHRoaXMuYm91bmREeW5hbWljVmVydGV4QnVmZmVyID0gbnVsbCwgdGhpcy52YW8gPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB4aSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobnVsbCAhPT0gdFtpXSkge1xuICAgICAgICAgIHZhciBvID0gdFtpXS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgZS5wdXNoKG8ucG9wKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIHlpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IHQ7XG5cbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzLmxlbmd0aCAhPT0gby5sZW5ndGgsIGMgPSAwOyAhbCAmJiBjIDwgby5sZW5ndGg7IGMrKykge1xuICAgICAgICB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzW2NdICE9PSBvW2NdICYmIChsID0gITApO1xuICAgICAgfVxuXG4gICAgICB0LmV4dFZlcnRleEFycmF5T2JqZWN0ICYmIHRoaXMudmFvICYmIHRoaXMuYm91bmRQcm9ncmFtID09PSBlICYmIHRoaXMuYm91bmRMYXlvdXRWZXJ0ZXhCdWZmZXIgPT09IGkgJiYgIWwgJiYgdGhpcy5ib3VuZEluZGV4QnVmZmVyID09PSByICYmIHRoaXMuYm91bmRWZXJ0ZXhPZmZzZXQgPT09IGEgJiYgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIgPT09IG4gJiYgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIyID09PSBzID8gKHQuYmluZFZlcnRleEFycmF5T0VTLnNldCh0aGlzLnZhbyksIG4gJiYgbi5iaW5kKCksIHIgJiYgci5keW5hbWljRHJhdyAmJiByLmJpbmQoKSwgcyAmJiBzLmJpbmQoKSkgOiB0aGlzLmZyZXNoQmluZChlLCBpLCBvLCByLCBhLCBuLCBzKTtcbiAgICB9LCB5aS5wcm90b3R5cGUuZnJlc2hCaW5kID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzLFxuICAgICAgICAgIGwgPSB0Lm51bUF0dHJpYnV0ZXMsXG4gICAgICAgICAgYyA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICB1ID0gYy5nbDtcbiAgICAgIGlmIChjLmV4dFZlcnRleEFycmF5T2JqZWN0KSB0aGlzLnZhbyAmJiB0aGlzLmRlc3Ryb3koKSwgdGhpcy52YW8gPSBjLmV4dFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZVZlcnRleEFycmF5T0VTKCksIGMuYmluZFZlcnRleEFycmF5T0VTLnNldCh0aGlzLnZhbyksIHMgPSAwLCB0aGlzLmJvdW5kUHJvZ3JhbSA9IHQsIHRoaXMuYm91bmRMYXlvdXRWZXJ0ZXhCdWZmZXIgPSBlLCB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzID0gaSwgdGhpcy5ib3VuZEluZGV4QnVmZmVyID0gbywgdGhpcy5ib3VuZFZlcnRleE9mZnNldCA9IHIsIHRoaXMuYm91bmREeW5hbWljVmVydGV4QnVmZmVyID0gYSwgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIyID0gbjtlbHNlIHtcbiAgICAgICAgcyA9IGMuY3VycmVudE51bUF0dHJpYnV0ZXMgfHwgMDtcblxuICAgICAgICBmb3IgKHZhciBoID0gbDsgaCA8IHM7IGgrKykge1xuICAgICAgICAgIHUuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLmVuYWJsZUF0dHJpYnV0ZXModSwgdCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwLCBkID0gaTsgcCA8IGQubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgZFtwXS5lbmFibGVBdHRyaWJ1dGVzKHUsIHQpO1xuICAgICAgfVxuXG4gICAgICBhICYmIGEuZW5hYmxlQXR0cmlidXRlcyh1LCB0KSwgbiAmJiBuLmVuYWJsZUF0dHJpYnV0ZXModSwgdCksIGUuYmluZCgpLCBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpO1xuXG4gICAgICBmb3IgKHZhciBfID0gMCwgZiA9IGk7IF8gPCBmLmxlbmd0aDsgXyArPSAxKSB7XG4gICAgICAgIHZhciBtID0gZltfXTtcbiAgICAgICAgbS5iaW5kKCksIG0uc2V0VmVydGV4QXR0cmliUG9pbnRlcnModSwgdCwgcik7XG4gICAgICB9XG5cbiAgICAgIGEgJiYgKGEuYmluZCgpLCBhLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpKSwgbyAmJiBvLmJpbmQoKSwgbiAmJiAobi5iaW5kKCksIG4uc2V0VmVydGV4QXR0cmliUG9pbnRlcnModSwgdCwgcikpLCBjLmN1cnJlbnROdW1BdHRyaWJ1dGVzID0gbDtcbiAgICB9LCB5aS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudmFvICYmICh0aGlzLmNvbnRleHQuZXh0VmVydGV4QXJyYXlPYmplY3QuZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pLCB0aGlzLnZhbyA9IG51bGwpO1xuICAgIH07XG5cbiAgICB2YXIgYmkgPSBmdW5jdGlvbiBiaSh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHQuZ2w7XG4gICAgICB0aGlzLnByb2dyYW0gPSBuLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgZm9yICh2YXIgcyA9IHhpKGkuc3RhdGljQXR0cmlidXRlcyksIGwgPSBvID8gby5nZXRCaW5kZXJBdHRyaWJ1dGVzKCkgOiBbXSwgYyA9IHMuY29uY2F0KGwpLCB1ID0gaS5zdGF0aWNVbmlmb3JtcyA/IHhpKGkuc3RhdGljVW5pZm9ybXMpIDogW10sIGggPSBvID8gby5nZXRCaW5kZXJVbmlmb3JtcygpIDogW10sIHAgPSBbXSwgZCA9IDAsIF8gPSB1LmNvbmNhdChoKTsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgdmFyIGYgPSBfW2RdO1xuICAgICAgICBwLmluZGV4T2YoZikgPCAwICYmIHAucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG0gPSBvID8gby5kZWZpbmVzKCkgOiBbXTtcbiAgICAgIGEgJiYgbS5wdXNoKFwiI2RlZmluZSBPVkVSRFJBV19JTlNQRUNUT1I7XCIpO1xuICAgICAgdmFyIGcgPSBtLmNvbmNhdChHZS5mcmFnbWVudFNvdXJjZSwgaS5mcmFnbWVudFNvdXJjZSkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICB2ID0gbS5jb25jYXQoR2UudmVydGV4U291cmNlLCBpLnZlcnRleFNvdXJjZSkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICB5ID0gbi5jcmVhdGVTaGFkZXIobi5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKG4uaXNDb250ZXh0TG9zdCgpKSB0aGlzLmZhaWxlZFRvQ3JlYXRlID0gITA7ZWxzZSB7XG4gICAgICAgIG4uc2hhZGVyU291cmNlKHksIGcpLCBuLmNvbXBpbGVTaGFkZXIoeSksIG4uYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgeSk7XG4gICAgICAgIHZhciB4ID0gbi5jcmVhdGVTaGFkZXIobi5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgaWYgKG4uaXNDb250ZXh0TG9zdCgpKSB0aGlzLmZhaWxlZFRvQ3JlYXRlID0gITA7ZWxzZSB7XG4gICAgICAgICAgbi5zaGFkZXJTb3VyY2UoeCwgdiksIG4uY29tcGlsZVNoYWRlcih4KSwgbi5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB4KSwgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgdmFyIGIgPSB7fTtcbiAgICAgICAgICB0aGlzLm51bUF0dHJpYnV0ZXMgPSBjLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgdGhpcy5udW1BdHRyaWJ1dGVzOyB3KyspIHtcbiAgICAgICAgICAgIGNbd10gJiYgKG4uYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdywgY1t3XSksIHRoaXMuYXR0cmlidXRlc1tjW3ddXSA9IHcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4ubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKSwgbi5kZWxldGVTaGFkZXIoeCksIG4uZGVsZXRlU2hhZGVyKHkpO1xuXG4gICAgICAgICAgZm9yICh2YXIgVCA9IDA7IFQgPCBwLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgRSA9IHBbVF07XG5cbiAgICAgICAgICAgIGlmIChFICYmICFiW0VdKSB7XG4gICAgICAgICAgICAgIHZhciBJID0gbi5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBFKTtcbiAgICAgICAgICAgICAgSSAmJiAoYltFXSA9IEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZml4ZWRVbmlmb3JtcyA9IHIodCwgYiksIHRoaXMuYmluZGVyVW5pZm9ybXMgPSBvID8gby5nZXRVbmlmb3Jtcyh0LCBiKSA6IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gMSAvIHBlKGksIDEsIGUudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICByID0gTWF0aC5wb3coMiwgaS50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgIGEgPSBpLnRpbGVTaXplICogTWF0aC5wb3coMiwgZS50cmFuc2Zvcm0udGlsZVpvb20pIC8gcixcbiAgICAgICAgICBuID0gYSAqIChpLnRpbGVJRC5jYW5vbmljYWwueCArIGkudGlsZUlELndyYXAgKiByKSxcbiAgICAgICAgICBzID0gYSAqIGkudGlsZUlELmNhbm9uaWNhbC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgdV90ZXhzaXplOiBpLmltYWdlQXRsYXNUZXh0dXJlLnNpemUsXG4gICAgICAgIHVfc2NhbGU6IFtvLCB0LmZyb21TY2FsZSwgdC50b1NjYWxlXSxcbiAgICAgICAgdV9mYWRlOiB0LnQsXG4gICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IFtuID4+IDE2LCBzID4+IDE2XSxcbiAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogWzY1NTM1ICYgbiwgNjU1MzUgJiBzXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBiaS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwLCBkLCBfLCBmKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgICBnID0gdC5nbDtcblxuICAgICAgaWYgKCF0aGlzLmZhaWxlZFRvQ3JlYXRlKSB7XG4gICAgICAgIGZvciAodmFyIHYgaW4gdC5wcm9ncmFtLnNldCh0aGlzLnByb2dyYW0pLCB0LnNldERlcHRoTW9kZShpKSwgdC5zZXRTdGVuY2lsTW9kZShvKSwgdC5zZXRDb2xvck1vZGUociksIHQuc2V0Q3VsbEZhY2UoYSksIHRoaXMuZml4ZWRVbmlmb3Jtcykge1xuICAgICAgICAgIHRoaXMuZml4ZWRVbmlmb3Jtc1t2XS5zZXQoblt2XSk7XG4gICAgICAgIH1cblxuICAgICAgICBkICYmIGQuc2V0VW5pZm9ybXModCwgdGhpcy5iaW5kZXJVbmlmb3JtcywgaCwge1xuICAgICAgICAgIHpvb206IHBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IChtID0ge30sIG1bZy5MSU5FU10gPSAyLCBtW2cuVFJJQU5HTEVTXSA9IDMsIG1bZy5MSU5FX1NUUklQXSA9IDEsIG0pW2VdLCB4ID0gMCwgYiA9IHUuZ2V0KCk7IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgdmFyIHcgPSBiW3hdLFxuICAgICAgICAgICAgICBUID0gdy52YW9zIHx8ICh3LnZhb3MgPSB7fSk7XG4gICAgICAgICAgKFRbc10gfHwgKFRbc10gPSBuZXcgeWkoKSkpLmJpbmQodCwgdGhpcywgbCwgZCA/IGQuZ2V0UGFpbnRWZXJ0ZXhCdWZmZXJzKCkgOiBbXSwgYywgdy52ZXJ0ZXhPZmZzZXQsIF8sIGYpLCBnLmRyYXdFbGVtZW50cyhlLCB3LnByaW1pdGl2ZUxlbmd0aCAqIHksIGcuVU5TSUdORURfU0hPUlQsIHcucHJpbWl0aXZlT2Zmc2V0ICogeSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBUaSA9IGZ1bmN0aW9uIFRpKGUsIGksIG8sIHIpIHtcbiAgICAgIHZhciBhID0gaS5zdHlsZS5saWdodCxcbiAgICAgICAgICBuID0gYS5wcm9wZXJ0aWVzLmdldChcInBvc2l0aW9uXCIpLFxuICAgICAgICAgIHMgPSBbbi54LCBuLnksIG4uel0sXG4gICAgICAgICAgbCA9IHQuY3JlYXRlJDEoKTtcbiAgICAgIFwidmlld3BvcnRcIiA9PT0gYS5wcm9wZXJ0aWVzLmdldChcImFuY2hvclwiKSAmJiB0LmZyb21Sb3RhdGlvbihsLCAtaS50cmFuc2Zvcm0uYW5nbGUpLCB0LnRyYW5zZm9ybU1hdDMocywgcywgbCk7XG4gICAgICB2YXIgYyA9IGEucHJvcGVydGllcy5nZXQoXCJjb2xvclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiBlLFxuICAgICAgICB1X2xpZ2h0cG9zOiBzLFxuICAgICAgICB1X2xpZ2h0aW50ZW5zaXR5OiBhLnByb3BlcnRpZXMuZ2V0KFwiaW50ZW5zaXR5XCIpLFxuICAgICAgICB1X2xpZ2h0Y29sb3I6IFtjLnIsIGMuZywgYy5iXSxcbiAgICAgICAgdV92ZXJ0aWNhbF9ncmFkaWVudDogK28sXG4gICAgICAgIHVfb3BhY2l0eTogclxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBFaSA9IGZ1bmN0aW9uIEVpKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIHJldHVybiB0LmV4dGVuZChUaShlLCBpLCBvLCByKSwgd2kobiwgaSwgcyksIHtcbiAgICAgICAgdV9oZWlnaHRfZmFjdG9yOiAtTWF0aC5wb3coMiwgYS5vdmVyc2NhbGVkWikgLyBzLnRpbGVTaXplIC8gOFxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgSWkgPSBmdW5jdGlvbiBJaSh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdFxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBQaSA9IGZ1bmN0aW9uIFBpKGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiB0LmV4dGVuZChJaShlKSwgd2kobywgaSwgcikpO1xuICAgIH0sXG4gICAgICAgIFNpID0gZnVuY3Rpb24gU2kodCwgZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgIHVfd29ybGQ6IGVcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQ2kgPSBmdW5jdGlvbiBDaShlLCBpLCBvLCByLCBhKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoUGkoZSwgaSwgbywgciksIHtcbiAgICAgICAgdV93b3JsZDogYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgemkgPSBmdW5jdGlvbiB6aShlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSBlLnRyYW5zZm9ybTtcblxuICAgICAgaWYgKFwibWFwXCIgPT09IHIucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiKSkge1xuICAgICAgICB2YXIgbCA9IHBlKG8sIDEsIHMuem9vbSk7XG4gICAgICAgIGEgPSAhMCwgbiA9IFtsLCBsXTtcbiAgICAgIH0gZWxzZSBhID0gITEsIG4gPSBzLnBpeGVsc1RvR0xVbml0cztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsXG4gICAgICAgIHVfc2NhbGVfd2l0aF9tYXA6ICsoXCJtYXBcIiA9PT0gci5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikpLFxuICAgICAgICB1X21hdHJpeDogZS50cmFuc2xhdGVQb3NNYXRyaXgoaS5wb3NNYXRyaXgsIG8sIHIucGFpbnQuZ2V0KFwiY2lyY2xlLXRyYW5zbGF0ZVwiKSwgci5wYWludC5nZXQoXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiKSksXG4gICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6ICthLFxuICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHVfZXh0cnVkZV9zY2FsZTogblxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBEaSA9IGZ1bmN0aW9uIERpKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gcGUoaSwgMSwgZS56b29tKSxcbiAgICAgICAgICByID0gTWF0aC5wb3coMiwgZS56b29tIC0gaS50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgIGEgPSBpLnRpbGVJRC5vdmVyc2NhbGVGYWN0b3IoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IGUuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSxcbiAgICAgICAgdV9waXhlbHNfdG9fdGlsZV91bml0czogbyxcbiAgICAgICAgdV9leHRydWRlX3NjYWxlOiBbZS5waXhlbHNUb0dMVW5pdHNbMF0gLyAobyAqIHIpLCBlLnBpeGVsc1RvR0xVbml0c1sxXSAvIChvICogcildLFxuICAgICAgICB1X292ZXJzY2FsZV9mYWN0b3I6IGFcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQWkgPSBmdW5jdGlvbiBBaSh0LCBlLCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdCxcbiAgICAgICAgdV9pbnZfbWF0cml4OiBlLFxuICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IGkuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSxcbiAgICAgICAgdV92aWV3cG9ydF9zaXplOiBbaS53aWR0aCwgaS5oZWlnaHRdXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIE1pID0gZnVuY3Rpb24gTWkodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IDEpLCB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X2NvbG9yOiBlLFxuICAgICAgICB1X292ZXJsYXk6IDAsXG4gICAgICAgIHVfb3ZlcmxheV9zY2FsZTogaVxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBMaSA9IGZ1bmN0aW9uIExpKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIFJpID0gZnVuY3Rpb24gUmkodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgIHVfZXh0cnVkZV9zY2FsZTogcGUoZSwgMSwgaSksXG4gICAgICAgIHVfaW50ZW5zaXR5OiBvXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGtpID0gZnVuY3Rpb24ga2koZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBlLnRyYW5zZm9ybTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiBOaShlLCBpLCBvKSxcbiAgICAgICAgdV9yYXRpbzogMSAvIHBlKGksIDEsIHIuem9vbSksXG4gICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgdV91bml0c190b19waXhlbHM6IFsxIC8gci5waXhlbHNUb0dMVW5pdHNbMF0sIDEgLyByLnBpeGVsc1RvR0xVbml0c1sxXV1cbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQmkgPSBmdW5jdGlvbiBCaShlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoa2koZSwgaSwgbyksIHtcbiAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgdV9pbWFnZV9oZWlnaHQ6IHJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIE9pID0gZnVuY3Rpb24gT2koZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSBlLnRyYW5zZm9ybSxcbiAgICAgICAgICBuID0gVWkoaSwgYSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogTmkoZSwgaSwgbyksXG4gICAgICAgIHVfdGV4c2l6ZTogaS5pbWFnZUF0bGFzVGV4dHVyZS5zaXplLFxuICAgICAgICB1X3JhdGlvOiAxIC8gcGUoaSwgMSwgYS56b29tKSxcbiAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICB1X3NjYWxlOiBbbiwgci5mcm9tU2NhbGUsIHIudG9TY2FsZV0sXG4gICAgICAgIHVfZmFkZTogci50LFxuICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogWzEgLyBhLnBpeGVsc1RvR0xVbml0c1swXSwgMSAvIGEucGl4ZWxzVG9HTFVuaXRzWzFdXVxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBGaSA9IGZ1bmN0aW9uIEZpKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gZS5saW5lQXRsYXMsXG4gICAgICAgICAgcyA9IFVpKGksIGUudHJhbnNmb3JtKSxcbiAgICAgICAgICBsID0gXCJyb3VuZFwiID09PSBvLmxheW91dC5nZXQoXCJsaW5lLWNhcFwiKSxcbiAgICAgICAgICBjID0gbi5nZXREYXNoKHIuZnJvbSwgbCksXG4gICAgICAgICAgdSA9IG4uZ2V0RGFzaChyLnRvLCBsKSxcbiAgICAgICAgICBoID0gYy53aWR0aCAqIGEuZnJvbVNjYWxlLFxuICAgICAgICAgIHAgPSB1LndpZHRoICogYS50b1NjYWxlO1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKGtpKGUsIGksIG8pLCB7XG4gICAgICAgIHVfcGF0dGVybnNjYWxlX2E6IFtzIC8gaCwgLWMuaGVpZ2h0IC8gMl0sXG4gICAgICAgIHVfcGF0dGVybnNjYWxlX2I6IFtzIC8gcCwgLXUuaGVpZ2h0IC8gMl0sXG4gICAgICAgIHVfc2RmZ2FtbWE6IG4ud2lkdGggLyAoMjU2ICogTWF0aC5taW4oaCwgcCkgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbykgLyAyLFxuICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICB1X3RleF95X2E6IGMueSxcbiAgICAgICAgdV90ZXhfeV9iOiB1LnksXG4gICAgICAgIHVfbWl4OiBhLnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBVaSh0LCBlKSB7XG4gICAgICByZXR1cm4gMSAvIHBlKHQsIDEsIGUudGlsZVpvb20pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE5pKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiB0LnRyYW5zbGF0ZVBvc01hdHJpeChlLnRpbGVJRC5wb3NNYXRyaXgsIGUsIGkucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGVcIiksIGkucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgWmkgPSBmdW5jdGlvbiBaaSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdCxcbiAgICAgICAgdV90bF9wYXJlbnQ6IGUsXG4gICAgICAgIHVfc2NhbGVfcGFyZW50OiBpLFxuICAgICAgICB1X2J1ZmZlcl9zY2FsZTogMSxcbiAgICAgICAgdV9mYWRlX3Q6IG8ubWl4LFxuICAgICAgICB1X29wYWNpdHk6IG8ub3BhY2l0eSAqIHIucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIiksXG4gICAgICAgIHVfaW1hZ2UwOiAwLFxuICAgICAgICB1X2ltYWdlMTogMSxcbiAgICAgICAgdV9icmlnaHRuZXNzX2xvdzogci5wYWludC5nZXQoXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIiksXG4gICAgICAgIHVfYnJpZ2h0bmVzc19oaWdoOiByLnBhaW50LmdldChcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiKSxcbiAgICAgICAgdV9zYXR1cmF0aW9uX2ZhY3RvcjogKG4gPSByLnBhaW50LmdldChcInJhc3Rlci1zYXR1cmF0aW9uXCIpLCBuID4gMCA/IDEgLSAxIC8gKDEuMDAxIC0gbikgOiAtbiksXG4gICAgICAgIHVfY29udHJhc3RfZmFjdG9yOiAoYSA9IHIucGFpbnQuZ2V0KFwicmFzdGVyLWNvbnRyYXN0XCIpLCBhID4gMCA/IDEgLyAoMSAtIGEpIDogMSArIGEpLFxuICAgICAgICB1X3NwaW5fd2VpZ2h0czogcWkoci5wYWludC5nZXQoXCJyYXN0ZXItaHVlLXJvdGF0ZVwiKSlcbiAgICAgIH07XG4gICAgICB2YXIgYSwgbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcWkodCkge1xuICAgICAgdCAqPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgdmFyIGUgPSBNYXRoLnNpbih0KSxcbiAgICAgICAgICBpID0gTWF0aC5jb3ModCk7XG4gICAgICByZXR1cm4gWygyICogaSArIDEpIC8gMywgKC1NYXRoLnNxcnQoMykgKiBlIC0gaSArIDEpIC8gMywgKE1hdGguc3FydCgzKSAqIGUgLSBpICsgMSkgLyAzXTtcbiAgICB9XG5cbiAgICB2YXIgamksXG4gICAgICAgIFZpID0gZnVuY3Rpb24gVmkodCwgZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYykge1xuICAgICAgdmFyIHUgPSByLnRyYW5zZm9ybTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiArKFwiY29uc3RhbnRcIiA9PT0gdCB8fCBcInNvdXJjZVwiID09PSB0KSxcbiAgICAgICAgdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQ6ICsoXCJjb25zdGFudFwiID09PSB0IHx8IFwiY2FtZXJhXCIgPT09IHQpLFxuICAgICAgICB1X3NpemVfdDogZSA/IGUudVNpemVUIDogMCxcbiAgICAgICAgdV9zaXplOiBlID8gZS51U2l6ZSA6IDAsXG4gICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogdS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLFxuICAgICAgICB1X3BpdGNoOiB1LnBpdGNoIC8gMzYwICogMiAqIE1hdGguUEksXG4gICAgICAgIHVfcm90YXRlX3N5bWJvbDogK2ksXG4gICAgICAgIHVfYXNwZWN0X3JhdGlvOiB1LndpZHRoIC8gdS5oZWlnaHQsXG4gICAgICAgIHVfZmFkZV9jaGFuZ2U6IHIub3B0aW9ucy5mYWRlRHVyYXRpb24gPyByLnN5bWJvbEZhZGVDaGFuZ2UgOiAxLFxuICAgICAgICB1X21hdHJpeDogYSxcbiAgICAgICAgdV9sYWJlbF9wbGFuZV9tYXRyaXg6IG4sXG4gICAgICAgIHVfY29vcmRfbWF0cml4OiBzLFxuICAgICAgICB1X2lzX3RleHQ6ICtsLFxuICAgICAgICB1X3BpdGNoX3dpdGhfbWFwOiArbyxcbiAgICAgICAgdV90ZXhzaXplOiBjLFxuICAgICAgICB1X3RleHR1cmU6IDBcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgR2kgPSBmdW5jdGlvbiBHaShlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoKSB7XG4gICAgICB2YXIgcCA9IGEudHJhbnNmb3JtO1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKFZpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUpLCB7XG4gICAgICAgIHVfZ2FtbWFfc2NhbGU6IHIgPyBNYXRoLmNvcyhwLl9waXRjaCkgKiBwLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgOiAxLFxuICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHVfaXNfaGFsbzogK2hcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIFdpID0gZnVuY3Rpb24gV2koZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSkge1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKEdpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsICEwLCBjLCAhMCksIHtcbiAgICAgICAgdV90ZXhzaXplX2ljb246IHUsXG4gICAgICAgIHVfdGV4dHVyZV9pY29uOiAxXG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBYaSA9IGZ1bmN0aW9uIFhpKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X29wYWNpdHk6IGUsXG4gICAgICAgIHVfY29sb3I6IGlcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgSGkgPSBmdW5jdGlvbiBIaShlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgdmFyIHIgPSBpLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQuZnJvbS50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGEgPSBpLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQudG8udG9TdHJpbmcoKSksXG4gICAgICAgICAgICBuID0gaS5pbWFnZU1hbmFnZXIuZ2V0UGl4ZWxTaXplKCksXG4gICAgICAgICAgICBzID0gbi53aWR0aCxcbiAgICAgICAgICAgIGwgPSBuLmhlaWdodCxcbiAgICAgICAgICAgIGMgPSBNYXRoLnBvdygyLCBvLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgICAgICB1ID0gby50aWxlU2l6ZSAqIE1hdGgucG93KDIsIGkudHJhbnNmb3JtLnRpbGVab29tKSAvIGMsXG4gICAgICAgICAgICBoID0gdSAqIChvLnRpbGVJRC5jYW5vbmljYWwueCArIG8udGlsZUlELndyYXAgKiBjKSxcbiAgICAgICAgICAgIHAgPSB1ICogby50aWxlSUQuY2Fub25pY2FsLnk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgICB1X3BhdHRlcm5fdGxfYTogci50bCxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogci5icixcbiAgICAgICAgICB1X3BhdHRlcm5fdGxfYjogYS50bCxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYjogYS5icixcbiAgICAgICAgICB1X3RleHNpemU6IFtzLCBsXSxcbiAgICAgICAgICB1X21peDogZS50LFxuICAgICAgICAgIHVfcGF0dGVybl9zaXplX2E6IHIuZGlzcGxheVNpemUsXG4gICAgICAgICAgdV9wYXR0ZXJuX3NpemVfYjogYS5kaXNwbGF5U2l6ZSxcbiAgICAgICAgICB1X3NjYWxlX2E6IGUuZnJvbVNjYWxlLFxuICAgICAgICAgIHVfc2NhbGVfYjogZS50b1NjYWxlLFxuICAgICAgICAgIHVfdGlsZV91bml0c190b19waXhlbHM6IDEgLyBwZShvLCAxLCBpLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogW2ggPj4gMTYsIHAgPj4gMTZdLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IFs2NTUzNSAmIGgsIDY1NTM1ICYgcF1cbiAgICAgICAgfTtcbiAgICAgIH0ociwgbiwgbywgYSksIHtcbiAgICAgICAgdV9tYXRyaXg6IGUsXG4gICAgICAgIHVfb3BhY2l0eTogaVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgS2kgPSB7XG4gICAgICBmaWxsRXh0cnVzaW9uOiBmdW5jdGlvbiBmaWxsRXh0cnVzaW9uKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGlnaHRwb3M6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfbGlnaHRwb3MpLFxuICAgICAgICAgIHVfbGlnaHRpbnRlbnNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbGlnaHRpbnRlbnNpdHkpLFxuICAgICAgICAgIHVfbGlnaHRjb2xvcjogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodGNvbG9yKSxcbiAgICAgICAgICB1X3ZlcnRpY2FsX2dyYWRpZW50OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3ZlcnRpY2FsX2dyYWRpZW50KSxcbiAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmaWxsRXh0cnVzaW9uUGF0dGVybjogZnVuY3Rpb24gZmlsbEV4dHJ1c2lvblBhdHRlcm4oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9saWdodHBvczogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodHBvcyksXG4gICAgICAgICAgdV9saWdodGludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9saWdodGludGVuc2l0eSksXG4gICAgICAgICAgdV9saWdodGNvbG9yOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X2xpZ2h0Y29sb3IpLFxuICAgICAgICAgIHVfdmVydGljYWxfZ3JhZGllbnQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdmVydGljYWxfZ3JhZGllbnQpLFxuICAgICAgICAgIHVfaGVpZ2h0X2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9oZWlnaHRfZmFjdG9yKSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF91cHBlciksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF9sb3dlciksXG4gICAgICAgICAgdV9zY2FsZTogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9zY2FsZSksXG4gICAgICAgICAgdV9mYWRlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGUpLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmaWxsUGF0dGVybjogZnVuY3Rpb24gZmlsbFBhdHRlcm4oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfbG93ZXIpLFxuICAgICAgICAgIHVfc2NhbGU6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGxPdXRsaW5lOiBmdW5jdGlvbiBmaWxsT3V0bGluZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3dvcmxkOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3dvcmxkKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGxPdXRsaW5lUGF0dGVybjogZnVuY3Rpb24gZmlsbE91dGxpbmVQYXR0ZXJuKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfd29ybGQ6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfd29ybGQpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICB1X3BpeGVsX2Nvb3JkX3VwcGVyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX3VwcGVyKSxcbiAgICAgICAgICB1X3BpeGVsX2Nvb3JkX2xvd2VyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX2xvd2VyKSxcbiAgICAgICAgICB1X3NjYWxlOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X3NjYWxlKSxcbiAgICAgICAgICB1X2ZhZGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UpLFxuICAgICAgICAgIHVfc2NhbGVfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfc2NhbGVfd2l0aF9tYXApLFxuICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcGl0Y2hfd2l0aF9tYXApLFxuICAgICAgICAgIHVfZXh0cnVkZV9zY2FsZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9leHRydWRlX3NjYWxlKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb2xsaXNpb25Cb3g6IGZ1bmN0aW9uIGNvbGxpc2lvbkJveChlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV9waXhlbHNfdG9fdGlsZV91bml0czogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9waXhlbHNfdG9fdGlsZV91bml0cyksXG4gICAgICAgICAgdV9leHRydWRlX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X2V4dHJ1ZGVfc2NhbGUpLFxuICAgICAgICAgIHVfb3ZlcnNjYWxlX2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vdmVyc2NhbGVfZmFjdG9yKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNvbGxpc2lvbkNpcmNsZTogZnVuY3Rpb24gY29sbGlzaW9uQ2lyY2xlKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfaW52X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9pbnZfbWF0cml4KSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV92aWV3cG9ydF9zaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3ZpZXdwb3J0X3NpemUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X2NvbG9yOiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X2NvbG9yKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfb3ZlcmxheTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9vdmVybGF5KSxcbiAgICAgICAgICB1X292ZXJsYXlfc2NhbGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3ZlcmxheV9zY2FsZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjbGlwcGluZ01hc2s6IGZ1bmN0aW9uIGNsaXBwaW5nTWFzayhlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhlYXRtYXA6IGZ1bmN0aW9uIGhlYXRtYXAoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfZXh0cnVkZV9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9leHRydWRlX3NjYWxlKSxcbiAgICAgICAgICB1X2ludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9pbnRlbnNpdHkpLFxuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBoZWF0bWFwVGV4dHVyZTogZnVuY3Rpb24gaGVhdG1hcFRleHR1cmUoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV93b3JsZDogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV93b3JsZCksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9jb2xvcl9yYW1wOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2NvbG9yX3JhbXApLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhpbGxzaGFkZTogZnVuY3Rpb24gaGlsbHNoYWRlKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfbGF0cmFuZ2U6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfbGF0cmFuZ2UpLFxuICAgICAgICAgIHVfbGlnaHQ6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfbGlnaHQpLFxuICAgICAgICAgIHVfc2hhZG93OiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X3NoYWRvdyksXG4gICAgICAgICAgdV9oaWdobGlnaHQ6IG5ldyB0LlVuaWZvcm1Db2xvcihlLCBpLnVfaGlnaGxpZ2h0KSxcbiAgICAgICAgICB1X2FjY2VudDogbmV3IHQuVW5pZm9ybUNvbG9yKGUsIGkudV9hY2NlbnQpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaGlsbHNoYWRlUHJlcGFyZTogZnVuY3Rpb24gaGlsbHNoYWRlUHJlcGFyZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X2RpbWVuc2lvbjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9kaW1lbnNpb24pLFxuICAgICAgICAgIHVfem9vbTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV96b29tKSxcbiAgICAgICAgICB1X3VucGFjazogbmV3IHQuVW5pZm9ybTRmKGUsIGkudV91bnBhY2spXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGluZTogZnVuY3Rpb24gbGluZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsaW5lR3JhZGllbnQ6IGZ1bmN0aW9uIGxpbmVHcmFkaWVudChlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscyksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9pbWFnZV9oZWlnaHQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfaW1hZ2VfaGVpZ2h0KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxpbmVQYXR0ZXJuOiBmdW5jdGlvbiBsaW5lUGF0dGVybihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9yYXRpbyksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgIHVfc2NhbGU6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxpbmVTREY6IGZ1bmN0aW9uIGxpbmVTREYoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9yYXRpbyksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgIHVfcGF0dGVybnNjYWxlX2E6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybnNjYWxlX2EpLFxuICAgICAgICAgIHVfcGF0dGVybnNjYWxlX2I6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybnNjYWxlX2IpLFxuICAgICAgICAgIHVfc2RmZ2FtbWE6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2RmZ2FtbWEpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfdGV4X3lfYTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV90ZXhfeV9hKSxcbiAgICAgICAgICB1X3RleF95X2I6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGV4X3lfYiksXG4gICAgICAgICAgdV9taXg6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbWl4KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJhc3RlcjogZnVuY3Rpb24gcmFzdGVyKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfdGxfcGFyZW50OiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RsX3BhcmVudCksXG4gICAgICAgICAgdV9zY2FsZV9wYXJlbnQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2NhbGVfcGFyZW50KSxcbiAgICAgICAgICB1X2J1ZmZlcl9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9idWZmZXJfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfdCksXG4gICAgICAgICAgdV9vcGFjaXR5OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X29wYWNpdHkpLFxuICAgICAgICAgIHVfaW1hZ2UwOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlMCksXG4gICAgICAgICAgdV9pbWFnZTE6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UxKSxcbiAgICAgICAgICB1X2JyaWdodG5lc3NfbG93OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2JyaWdodG5lc3NfbG93KSxcbiAgICAgICAgICB1X2JyaWdodG5lc3NfaGlnaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9icmlnaHRuZXNzX2hpZ2gpLFxuICAgICAgICAgIHVfc2F0dXJhdGlvbl9mYWN0b3I6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2F0dXJhdGlvbl9mYWN0b3IpLFxuICAgICAgICAgIHVfY29udHJhc3RfZmFjdG9yOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2NvbnRyYXN0X2ZhY3RvciksXG4gICAgICAgICAgdV9zcGluX3dlaWdodHM6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc3Bpbl93ZWlnaHRzKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHN5bWJvbEljb246IGZ1bmN0aW9uIHN5bWJvbEljb24oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3NpemVfem9vbV9jb25zdGFudCksXG4gICAgICAgICAgdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSxcbiAgICAgICAgICB1X3NpemVfdDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplX3QpLFxuICAgICAgICAgIHVfc2l6ZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplKSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV9waXRjaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9waXRjaCksXG4gICAgICAgICAgdV9yb3RhdGVfc3ltYm9sOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3JvdGF0ZV9zeW1ib2wpLFxuICAgICAgICAgIHVfYXNwZWN0X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2FzcGVjdF9yYXRpbyksXG4gICAgICAgICAgdV9mYWRlX2NoYW5nZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlX2NoYW5nZSksXG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2xhYmVsX3BsYW5lX21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9sYWJlbF9wbGFuZV9tYXRyaXgpLFxuICAgICAgICAgIHVfY29vcmRfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2Nvb3JkX21hdHJpeCksXG4gICAgICAgICAgdV9pc190ZXh0OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3RleHQpLFxuICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcGl0Y2hfd2l0aF9tYXApLFxuICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICB1X3RleHR1cmU6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfdGV4dHVyZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzeW1ib2xTREY6IGZ1bmN0aW9uIHN5bWJvbFNERihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pc19zaXplX3pvb21fY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV96b29tX2NvbnN0YW50KSxcbiAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgIHVfc2l6ZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemVfdCksXG4gICAgICAgICAgdV9zaXplOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemUpLFxuICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICB1X3BpdGNoOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3BpdGNoKSxcbiAgICAgICAgICB1X3JvdGF0ZV9zeW1ib2w6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcm90YXRlX3N5bWJvbCksXG4gICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICB1X2ZhZGVfY2hhbmdlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfY2hhbmdlKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgdV9jb29yZF9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfY29vcmRfbWF0cml4KSxcbiAgICAgICAgICB1X2lzX3RleHQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfdGV4dCksXG4gICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfdGV4dHVyZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV90ZXh0dXJlKSxcbiAgICAgICAgICB1X2dhbW1hX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2dhbW1hX3NjYWxlKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfaXNfaGFsbzogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19oYWxvKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHN5bWJvbFRleHRBbmRJY29uOiBmdW5jdGlvbiBzeW1ib2xUZXh0QW5kSWNvbihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pc19zaXplX3pvb21fY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV96b29tX2NvbnN0YW50KSxcbiAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgIHVfc2l6ZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemVfdCksXG4gICAgICAgICAgdV9zaXplOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemUpLFxuICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICB1X3BpdGNoOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3BpdGNoKSxcbiAgICAgICAgICB1X3JvdGF0ZV9zeW1ib2w6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcm90YXRlX3N5bWJvbCksXG4gICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICB1X2ZhZGVfY2hhbmdlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfY2hhbmdlKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgdV9jb29yZF9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfY29vcmRfbWF0cml4KSxcbiAgICAgICAgICB1X2lzX3RleHQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfdGV4dCksXG4gICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfdGV4c2l6ZV9pY29uOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemVfaWNvbiksXG4gICAgICAgICAgdV90ZXh0dXJlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3RleHR1cmUpLFxuICAgICAgICAgIHVfdGV4dHVyZV9pY29uOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3RleHR1cmVfaWNvbiksXG4gICAgICAgICAgdV9nYW1tYV9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9nYW1tYV9zY2FsZSksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X2lzX2hhbG86IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfaGFsbylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbiBiYWNrZ3JvdW5kKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KSxcbiAgICAgICAgICB1X2NvbG9yOiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X2NvbG9yKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmRQYXR0ZXJuOiBmdW5jdGlvbiBiYWNrZ3JvdW5kUGF0dGVybihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9wYXR0ZXJuX3RsX2E6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybl90bF9hKSxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9wYXR0ZXJuX2JyX2EpLFxuICAgICAgICAgIHVfcGF0dGVybl90bF9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fdGxfYiksXG4gICAgICAgICAgdV9wYXR0ZXJuX2JyX2I6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybl9icl9iKSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9taXg6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbWl4KSxcbiAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9hOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fc2l6ZV9hKSxcbiAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fc2l6ZV9iKSxcbiAgICAgICAgICB1X3NjYWxlX2E6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2NhbGVfYSksXG4gICAgICAgICAgdV9zY2FsZV9iOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NjYWxlX2IpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfbG93ZXIpLFxuICAgICAgICAgIHVfdGlsZV91bml0c190b19waXhlbHM6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGlsZV91bml0c190b19waXhlbHMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFlpKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIGZvciAodmFyIGwgPSBlLmNvbnRleHQsIGMgPSBsLmdsLCB1ID0gZS51c2VQcm9ncmFtKFwiY29sbGlzaW9uQm94XCIpLCBoID0gW10sIHAgPSAwLCBkID0gMCwgXyA9IDA7IF8gPCByLmxlbmd0aDsgXysrKSB7XG4gICAgICAgIHZhciBmID0gcltfXSxcbiAgICAgICAgICAgIG0gPSBpLmdldFRpbGUoZiksXG4gICAgICAgICAgICBnID0gbS5nZXRCdWNrZXQobyk7XG5cbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgdiA9IGYucG9zTWF0cml4O1xuICAgICAgICAgIDAgPT09IGFbMF0gJiYgMCA9PT0gYVsxXSB8fCAodiA9IGUudHJhbnNsYXRlUG9zTWF0cml4KGYucG9zTWF0cml4LCBtLCBhLCBuKSk7XG4gICAgICAgICAgdmFyIHkgPSBzID8gZy50ZXh0Q29sbGlzaW9uQm94IDogZy5pY29uQ29sbGlzaW9uQm94LFxuICAgICAgICAgICAgICB4ID0gZy5jb2xsaXNpb25DaXJjbGVBcnJheTtcblxuICAgICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBiID0gdC5jcmVhdGUoKSxcbiAgICAgICAgICAgICAgICB3ID0gdjtcbiAgICAgICAgICAgIHQubXVsKGIsIGcucGxhY2VtZW50SW52UHJvak1hdHJpeCwgZS50cmFuc2Zvcm0uZ2xDb29yZE1hdHJpeCksIHQubXVsKGIsIGIsIGcucGxhY2VtZW50Vmlld3BvcnRNYXRyaXgpLCBoLnB1c2goe1xuICAgICAgICAgICAgICBjaXJjbGVBcnJheTogeCxcbiAgICAgICAgICAgICAgY2lyY2xlT2Zmc2V0OiBkLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHcsXG4gICAgICAgICAgICAgIGludlRyYW5zZm9ybTogYlxuICAgICAgICAgICAgfSksIGQgPSBwICs9IHgubGVuZ3RoIC8gNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ICYmIHUuZHJhdyhsLCBjLkxJTkVTLCBJdC5kaXNhYmxlZCwgUHQuZGlzYWJsZWQsIGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBDdC5kaXNhYmxlZCwgRGkodiwgZS50cmFuc2Zvcm0sIG0pLCBvLmlkLCB5LmxheW91dFZlcnRleEJ1ZmZlciwgeS5pbmRleEJ1ZmZlciwgeS5zZWdtZW50cywgbnVsbCwgZS50cmFuc2Zvcm0uem9vbSwgbnVsbCwgbnVsbCwgeS5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzICYmIGgubGVuZ3RoKSB7XG4gICAgICAgIHZhciBUID0gZS51c2VQcm9ncmFtKFwiY29sbGlzaW9uQ2lyY2xlXCIpLFxuICAgICAgICAgICAgRSA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0MmYxZjJpMTYoKTtcbiAgICAgICAgRS5yZXNpemUoNCAqIHApLCBFLl90cmltKCk7XG5cbiAgICAgICAgZm9yICh2YXIgSSA9IDAsIFAgPSAwLCBTID0gaDsgUCA8IFMubGVuZ3RoOyBQICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBDID0gU1tQXSwgeiA9IDA7IHogPCBDLmNpcmNsZUFycmF5Lmxlbmd0aCAvIDQ7IHorKykge1xuICAgICAgICAgICAgdmFyIEQgPSA0ICogeixcbiAgICAgICAgICAgICAgICBBID0gQy5jaXJjbGVBcnJheVtEICsgMF0sXG4gICAgICAgICAgICAgICAgTSA9IEMuY2lyY2xlQXJyYXlbRCArIDFdLFxuICAgICAgICAgICAgICAgIEwgPSBDLmNpcmNsZUFycmF5W0QgKyAyXSxcbiAgICAgICAgICAgICAgICBSID0gQy5jaXJjbGVBcnJheVtEICsgM107XG4gICAgICAgICAgICBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAwKSwgRS5lbXBsYWNlKEkrKywgQSwgTSwgTCwgUiwgMSksIEUuZW1wbGFjZShJKyssIEEsIE0sIEwsIFIsIDIpLCBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAoIWppIHx8IGppLmxlbmd0aCA8IDIgKiBwKSAmJiAoamkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gMiAqIGUsXG4gICAgICAgICAgICAgIG8gPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDN1aTYoKTtcbiAgICAgICAgICBvLnJlc2l6ZShpKSwgby5fdHJpbSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBpOyByKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gNiAqIHI7XG4gICAgICAgICAgICBvLnVpbnQxNlthICsgMF0gPSA0ICogciArIDAsIG8udWludDE2W2EgKyAxXSA9IDQgKiByICsgMSwgby51aW50MTZbYSArIDJdID0gNCAqIHIgKyAyLCBvLnVpbnQxNlthICsgM10gPSA0ICogciArIDIsIG8udWludDE2W2EgKyA0XSA9IDQgKiByICsgMywgby51aW50MTZbYSArIDVdID0gNCAqIHIgKyAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9KHApKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gbC5jcmVhdGVJbmRleEJ1ZmZlcihqaSwgITApLCBCID0gbC5jcmVhdGVWZXJ0ZXhCdWZmZXIoRSwgdC5jb2xsaXNpb25DaXJjbGVMYXlvdXQubWVtYmVycywgITApLCBPID0gMCwgRiA9IGg7IE8gPCBGLmxlbmd0aDsgTyArPSAxKSB7XG4gICAgICAgICAgdmFyIFUgPSBGW09dLFxuICAgICAgICAgICAgICBOID0gQWkoVS50cmFuc2Zvcm0sIFUuaW52VHJhbnNmb3JtLCBlLnRyYW5zZm9ybSk7XG4gICAgICAgICAgVC5kcmF3KGwsIGMuVFJJQU5HTEVTLCBJdC5kaXNhYmxlZCwgUHQuZGlzYWJsZWQsIGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBDdC5kaXNhYmxlZCwgTiwgby5pZCwgQiwgaywgdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMiAqIFUuY2lyY2xlT2Zmc2V0LCBVLmNpcmNsZUFycmF5Lmxlbmd0aCwgVS5jaXJjbGVBcnJheS5sZW5ndGggLyAyKSwgbnVsbCwgZS50cmFuc2Zvcm0uem9vbSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBCLmRlc3Ryb3koKSwgay5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEppID0gdC5pZGVudGl0eShuZXcgRmxvYXQzMkFycmF5KDE2KSk7XG5cbiAgICBmdW5jdGlvbiBRaShlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IHQuZ2V0QW5jaG9yQWxpZ25tZW50KGUpLFxuICAgICAgICAgIGwgPSAtKHMuaG9yaXpvbnRhbEFsaWduIC0gLjUpICogaSxcbiAgICAgICAgICBjID0gLShzLnZlcnRpY2FsQWxpZ24gLSAuNSkgKiBvLFxuICAgICAgICAgIHUgPSB0LmV2YWx1YXRlVmFyaWFibGVPZmZzZXQoZSwgcik7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQoKGwgLyBhICsgdVswXSkgKiBuLCAoYyAvIGEgKyB1WzFdKSAqIG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgpIHtcbiAgICAgIHZhciBwID0gZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LFxuICAgICAgICAgIGQgPSBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEFycmF5LFxuICAgICAgICAgIF8gPSBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEFycmF5LFxuICAgICAgICAgIGYgPSB7fTtcbiAgICAgIGQuY2xlYXIoKTtcblxuICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBwLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciBnID0gcC5nZXQobSksXG4gICAgICAgICAgICB2ID0gZy5oaWRkZW4gfHwgIWcuY3Jvc3NUaWxlSUQgfHwgZS5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmICFnLnBsYWNlZE9yaWVudGF0aW9uID8gbnVsbCA6IHJbZy5jcm9zc1RpbGVJRF07XG5cbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB2YXIgeSA9IG5ldyB0LlBvaW50KGcuYW5jaG9yWCwgZy5hbmNob3JZKSxcbiAgICAgICAgICAgICAgeCA9ICR0KHksIG8gPyBsIDogcyksXG4gICAgICAgICAgICAgIGIgPSB0ZShuLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsIHguc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhKSxcbiAgICAgICAgICAgICAgdyA9IGEuZXZhbHVhdGVTaXplRm9yRmVhdHVyZShlLnRleHRTaXplRGF0YSwgdSwgZykgKiBiIC8gdC5PTkVfRU07XG4gICAgICAgICAgbyAmJiAodyAqPSBlLnRpbGVQaXhlbFJhdGlvIC8gYyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBUID0gUWkodi5hbmNob3IsIHYud2lkdGgsIHYuaGVpZ2h0LCB2LnRleHRPZmZzZXQsIHYudGV4dEJveFNjYWxlLCB3KSwgRSA9IG8gPyAkdCh5LmFkZChUKSwgcykucG9pbnQgOiB4LnBvaW50LmFkZChpID8gVC5yb3RhdGUoLW4uYW5nbGUpIDogVCksIEkgPSBlLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZy5wbGFjZWRPcmllbnRhdGlvbiA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCA/IE1hdGguUEkgLyAyIDogMCwgUCA9IDA7IFAgPCBnLm51bUdseXBoczsgUCsrKSB7XG4gICAgICAgICAgICB0LmFkZER5bmFtaWNBdHRyaWJ1dGVzKGQsIEUsIEkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGggJiYgZy5hc3NvY2lhdGVkSWNvbkluZGV4ID49IDAgJiYgKGZbZy5hc3NvY2lhdGVkSWNvbkluZGV4XSA9IHtcbiAgICAgICAgICAgIHNoaWZ0ZWRBbmNob3I6IEUsXG4gICAgICAgICAgICBhbmdsZTogSVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgY2UoZy5udW1HbHlwaHMsIGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCkge1xuICAgICAgICBfLmNsZWFyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgUyA9IGUuaWNvbi5wbGFjZWRTeW1ib2xBcnJheSwgQyA9IDA7IEMgPCBTLmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgdmFyIHogPSBTLmdldChDKTtcbiAgICAgICAgICBpZiAoei5oaWRkZW4pIGNlKHoubnVtR2x5cGhzLCBfKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBEID0gZltDXTtcbiAgICAgICAgICAgIGlmIChEKSBmb3IgKHZhciBBID0gMDsgQSA8IHoubnVtR2x5cGhzOyBBKyspIHtcbiAgICAgICAgICAgICAgdC5hZGREeW5hbWljQXR0cmlidXRlcyhfLCBELnNoaWZ0ZWRBbmNob3IsIEQuYW5nbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGNlKHoubnVtR2x5cGhzLCBfKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKF8pO1xuICAgICAgfVxuXG4gICAgICBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBpLmljb25zSW5UZXh0ICYmIGUgPyBcInN5bWJvbFRleHRBbmRJY29uXCIgOiB0ID8gXCJzeW1ib2xTREZcIiA6IFwic3ltYm9sSWNvblwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVvKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHApIHtcbiAgICAgIGZvciAodmFyIGQgPSBlLmNvbnRleHQsIF8gPSBkLmdsLCBmID0gZS50cmFuc2Zvcm0sIG0gPSBcIm1hcFwiID09PSBsLCBnID0gXCJtYXBcIiA9PT0gYywgdiA9IG0gJiYgXCJwb2ludFwiICE9PSBvLmxheW91dC5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpLCB5ID0gbSAmJiAhZyAmJiAhdiwgeCA9IHZvaWQgMCAhPT0gby5sYXlvdXQuZ2V0KFwic3ltYm9sLXNvcnQta2V5XCIpLmNvbnN0YW50T3IoMSksIGIgPSAhMSwgdyA9IGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpLCBUID0gby5sYXlvdXQuZ2V0KFwidGV4dC12YXJpYWJsZS1hbmNob3JcIiksIEUgPSBbXSwgSSA9IDAsIFAgPSByOyBJIDwgUC5sZW5ndGg7IEkgKz0gMSkge1xuICAgICAgICB2YXIgUyA9IFBbSV0sXG4gICAgICAgICAgICBDID0gaS5nZXRUaWxlKFMpLFxuICAgICAgICAgICAgeiA9IEMuZ2V0QnVja2V0KG8pO1xuXG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgdmFyIEQgPSBhID8gei50ZXh0IDogei5pY29uO1xuXG4gICAgICAgICAgaWYgKEQgJiYgRC5zZWdtZW50cy5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBBID0gRC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpLFxuICAgICAgICAgICAgICAgIE0gPSBhIHx8IHouc2RmSWNvbnMsXG4gICAgICAgICAgICAgICAgTCA9IGEgPyB6LnRleHRTaXplRGF0YSA6IHouaWNvblNpemVEYXRhLFxuICAgICAgICAgICAgICAgIFIgPSBnIHx8IDAgIT09IGYucGl0Y2gsXG4gICAgICAgICAgICAgICAgayA9IGUudXNlUHJvZ3JhbSh0byhNLCBhLCB6KSwgQSksXG4gICAgICAgICAgICAgICAgQiA9IHQuZXZhbHVhdGVTaXplRm9yWm9vbShMLCBmLnpvb20pLFxuICAgICAgICAgICAgICAgIE8gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgRiA9IFswLCAwXSxcbiAgICAgICAgICAgICAgICBVID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIE4gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgWiA9IG51bGwsXG4gICAgICAgICAgICAgICAgcSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhKSBVID0gQy5nbHlwaEF0bGFzVGV4dHVyZSwgTiA9IF8uTElORUFSLCBPID0gQy5nbHlwaEF0bGFzVGV4dHVyZS5zaXplLCB6Lmljb25zSW5UZXh0ICYmIChGID0gQy5pbWFnZUF0bGFzVGV4dHVyZS5zaXplLCBaID0gQy5pbWFnZUF0bGFzVGV4dHVyZSwgcSA9IFIgfHwgZS5vcHRpb25zLnJvdGF0aW5nIHx8IGUub3B0aW9ucy56b29taW5nIHx8IFwiY29tcG9zaXRlXCIgPT09IEwua2luZCB8fCBcImNhbWVyYVwiID09PSBMLmtpbmQgPyBfLkxJTkVBUiA6IF8uTkVBUkVTVCk7ZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBqID0gMSAhPT0gby5sYXlvdXQuZ2V0KFwiaWNvbi1zaXplXCIpLmNvbnN0YW50T3IoMCkgfHwgei5pY29uc05lZWRMaW5lYXI7XG4gICAgICAgICAgICAgIFUgPSBDLmltYWdlQXRsYXNUZXh0dXJlLCBOID0gTSB8fCBlLm9wdGlvbnMucm90YXRpbmcgfHwgZS5vcHRpb25zLnpvb21pbmcgfHwgaiB8fCBSID8gXy5MSU5FQVIgOiBfLk5FQVJFU1QsIE8gPSBDLmltYWdlQXRsYXNUZXh0dXJlLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgViA9IHBlKEMsIDEsIGUudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAgICAgICAgIEcgPSBKdChTLnBvc01hdHJpeCwgZywgbSwgZS50cmFuc2Zvcm0sIFYpLFxuICAgICAgICAgICAgICAgIFcgPSBRdChTLnBvc01hdHJpeCwgZywgbSwgZS50cmFuc2Zvcm0sIFYpLFxuICAgICAgICAgICAgICAgIFggPSBUICYmIHouaGFzVGV4dERhdGEoKSxcbiAgICAgICAgICAgICAgICBIID0gXCJub25lXCIgIT09IG8ubGF5b3V0LmdldChcImljb24tdGV4dC1maXRcIikgJiYgWCAmJiB6Lmhhc0ljb25EYXRhKCk7XG4gICAgICAgICAgICB2ICYmIGllKHosIFMucG9zTWF0cml4LCBlLCBhLCBHLCBXLCBnLCB1KTtcbiAgICAgICAgICAgIHZhciBLID0gZS50cmFuc2xhdGVQb3NNYXRyaXgoUy5wb3NNYXRyaXgsIEMsIG4sIHMpLFxuICAgICAgICAgICAgICAgIFkgPSB2IHx8IGEgJiYgVCB8fCBIID8gSmkgOiBHLFxuICAgICAgICAgICAgICAgIEogPSBlLnRyYW5zbGF0ZVBvc01hdHJpeChXLCBDLCBuLCBzLCAhMCksXG4gICAgICAgICAgICAgICAgUSA9IE0gJiYgMCAhPT0gby5wYWludC5nZXQoYSA/IFwidGV4dC1oYWxvLXdpZHRoXCIgOiBcImljb24taGFsby13aWR0aFwiKS5jb25zdGFudE9yKDEpLFxuICAgICAgICAgICAgICAgICQgPSB7XG4gICAgICAgICAgICAgIHByb2dyYW06IGssXG4gICAgICAgICAgICAgIGJ1ZmZlcnM6IEQsXG4gICAgICAgICAgICAgIHVuaWZvcm1WYWx1ZXM6IE0gPyB6Lmljb25zSW5UZXh0ID8gV2koTC5raW5kLCBCLCB5LCBnLCBlLCBLLCBZLCBKLCBPLCBGKSA6IEdpKEwua2luZCwgQiwgeSwgZywgZSwgSywgWSwgSiwgYSwgTywgITApIDogVmkoTC5raW5kLCBCLCB5LCBnLCBlLCBLLCBZLCBKLCBhLCBPKSxcbiAgICAgICAgICAgICAgYXRsYXNUZXh0dXJlOiBVLFxuICAgICAgICAgICAgICBhdGxhc1RleHR1cmVJY29uOiBaLFxuICAgICAgICAgICAgICBhdGxhc0ludGVycG9sYXRpb246IE4sXG4gICAgICAgICAgICAgIGF0bGFzSW50ZXJwb2xhdGlvbkljb246IHEsXG4gICAgICAgICAgICAgIGlzU0RGOiBNLFxuICAgICAgICAgICAgICBoYXNIYWxvOiBRXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoeCAmJiB6LmNhbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgYiA9ICEwO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHR0ID0gMCwgZXQgPSBELnNlZ21lbnRzLmdldCgpOyB0dCA8IGV0Lmxlbmd0aDsgdHQgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IGV0W3R0XTtcbiAgICAgICAgICAgICAgICBFLnB1c2goe1xuICAgICAgICAgICAgICAgICAgc2VnbWVudHM6IG5ldyB0LlNlZ21lbnRWZWN0b3IoW2l0XSksXG4gICAgICAgICAgICAgICAgICBzb3J0S2V5OiBpdC5zb3J0S2V5LFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIEUucHVzaCh7XG4gICAgICAgICAgICAgIHNlZ21lbnRzOiBELnNlZ21lbnRzLFxuICAgICAgICAgICAgICBzb3J0S2V5OiAwLFxuICAgICAgICAgICAgICBzdGF0ZTogJFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGIgJiYgRS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgb3QgPSAwLCBydCA9IEU7IG90IDwgcnQubGVuZ3RoOyBvdCArPSAxKSB7XG4gICAgICAgIHZhciBhdCA9IHJ0W290XSxcbiAgICAgICAgICAgIG50ID0gYXQuc3RhdGU7XG5cbiAgICAgICAgaWYgKGQuYWN0aXZlVGV4dHVyZS5zZXQoXy5URVhUVVJFMCksIG50LmF0bGFzVGV4dHVyZS5iaW5kKG50LmF0bGFzSW50ZXJwb2xhdGlvbiwgXy5DTEFNUF9UT19FREdFKSwgbnQuYXRsYXNUZXh0dXJlSWNvbiAmJiAoZC5hY3RpdmVUZXh0dXJlLnNldChfLlRFWFRVUkUxKSwgbnQuYXRsYXNUZXh0dXJlSWNvbiAmJiBudC5hdGxhc1RleHR1cmVJY29uLmJpbmQobnQuYXRsYXNJbnRlcnBvbGF0aW9uSWNvbiwgXy5DTEFNUF9UT19FREdFKSksIG50LmlzU0RGKSB7XG4gICAgICAgICAgdmFyIHN0ID0gbnQudW5pZm9ybVZhbHVlcztcbiAgICAgICAgICBudC5oYXNIYWxvICYmIChzdC51X2lzX2hhbG8gPSAxLCBpbyhudC5idWZmZXJzLCBhdC5zZWdtZW50cywgbywgZSwgbnQucHJvZ3JhbSwgdywgaCwgcCwgc3QpKSwgc3QudV9pc19oYWxvID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlvKG50LmJ1ZmZlcnMsIGF0LnNlZ21lbnRzLCBvLCBlLCBudC5wcm9ncmFtLCB3LCBoLCBwLCBudC51bmlmb3JtVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbyh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsKSB7XG4gICAgICB2YXIgYyA9IG8uY29udGV4dDtcbiAgICAgIHIuZHJhdyhjLCBjLmdsLlRSSUFOR0xFUywgYSwgbiwgcywgQ3QuZGlzYWJsZWQsIGwsIGkuaWQsIHQubGF5b3V0VmVydGV4QnVmZmVyLCB0LmluZGV4QnVmZmVyLCBlLCBpLnBhaW50LCBvLnRyYW5zZm9ybS56b29tLCB0LnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoaS5pZCksIHQuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlciwgdC5vcGFjaXR5VmVydGV4QnVmZmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbyh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBoLFxuICAgICAgICAgIHAgPSB0LmNvbnRleHQuZ2wsXG4gICAgICAgICAgZCA9IGkucGFpbnQuZ2V0KFwiZmlsbC1wYXR0ZXJuXCIpLFxuICAgICAgICAgIF8gPSBkICYmIGQuY29uc3RhbnRPcigxKSxcbiAgICAgICAgICBmID0gaS5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIG4gPyAobCA9IF8gJiYgIWkuZ2V0UGFpbnRQcm9wZXJ0eShcImZpbGwtb3V0bGluZS1jb2xvclwiKSA/IFwiZmlsbE91dGxpbmVQYXR0ZXJuXCIgOiBcImZpbGxPdXRsaW5lXCIsIHMgPSBwLkxJTkVTKSA6IChsID0gXyA/IFwiZmlsbFBhdHRlcm5cIiA6IFwiZmlsbFwiLCBzID0gcC5UUklBTkdMRVMpO1xuXG4gICAgICBmb3IgKHZhciBtID0gMCwgZyA9IG87IG0gPCBnLmxlbmd0aDsgbSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gZ1ttXSxcbiAgICAgICAgICAgIHkgPSBlLmdldFRpbGUodik7XG5cbiAgICAgICAgaWYgKCFfIHx8IHkucGF0dGVybnNMb2FkZWQoKSkge1xuICAgICAgICAgIHZhciB4ID0geS5nZXRCdWNrZXQoaSk7XG5cbiAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgdmFyIGIgPSB4LnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoaS5pZCksXG4gICAgICAgICAgICAgICAgdyA9IHQudXNlUHJvZ3JhbShsLCBiKTtcbiAgICAgICAgICAgIF8gJiYgKHQuY29udGV4dC5hY3RpdmVUZXh0dXJlLnNldChwLlRFWFRVUkUwKSwgeS5pbWFnZUF0bGFzVGV4dHVyZS5iaW5kKHAuTElORUFSLCBwLkNMQU1QX1RPX0VER0UpLCBiLnVwZGF0ZVBhaW50QnVmZmVycyhmKSk7XG4gICAgICAgICAgICB2YXIgVCA9IGQuY29uc3RhbnRPcihudWxsKTtcblxuICAgICAgICAgICAgaWYgKFQgJiYgeS5pbWFnZUF0bGFzKSB7XG4gICAgICAgICAgICAgIHZhciBFID0geS5pbWFnZUF0bGFzLFxuICAgICAgICAgICAgICAgICAgSSA9IEUucGF0dGVyblBvc2l0aW9uc1tULnRvLnRvU3RyaW5nKCldLFxuICAgICAgICAgICAgICAgICAgUCA9IEUucGF0dGVyblBvc2l0aW9uc1tULmZyb20udG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgIEkgJiYgUCAmJiBiLnNldENvbnN0YW50UGF0dGVyblBvc2l0aW9ucyhJLCBQKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFMgPSB0LnRyYW5zbGF0ZVBvc01hdHJpeCh2LnBvc01hdHJpeCwgeSwgaS5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZVwiKSwgaS5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIikpO1xuXG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICB1ID0geC5pbmRleEJ1ZmZlcjIsIGggPSB4LnNlZ21lbnRzMjtcbiAgICAgICAgICAgICAgdmFyIEMgPSBbcC5kcmF3aW5nQnVmZmVyV2lkdGgsIHAuZHJhd2luZ0J1ZmZlckhlaWdodF07XG4gICAgICAgICAgICAgIGMgPSBcImZpbGxPdXRsaW5lUGF0dGVyblwiID09PSBsICYmIF8gPyBDaShTLCB0LCBmLCB5LCBDKSA6IFNpKFMsIEMpO1xuICAgICAgICAgICAgfSBlbHNlIHUgPSB4LmluZGV4QnVmZmVyLCBoID0geC5zZWdtZW50cywgYyA9IF8gPyBQaShTLCB0LCBmLCB5KSA6IElpKFMpO1xuXG4gICAgICAgICAgICB3LmRyYXcodC5jb250ZXh0LCBzLCByLCB0LnN0ZW5jaWxNb2RlRm9yQ2xpcHBpbmcodiksIGEsIEN0LmRpc2FibGVkLCBjLCBpLmlkLCB4LmxheW91dFZlcnRleEJ1ZmZlciwgdSwgaCwgaS5wYWludCwgdC50cmFuc2Zvcm0uem9vbSwgYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm8odCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgZm9yICh2YXIgcyA9IHQuY29udGV4dCwgbCA9IHMuZ2wsIGMgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIiksIHUgPSBjLmNvbnN0YW50T3IoMSksIGggPSBpLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSwgcCA9IGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiKSwgZCA9IDAsIF8gPSBvOyBkIDwgXy5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICB2YXIgZiA9IF9bZF0sXG4gICAgICAgICAgICBtID0gZS5nZXRUaWxlKGYpLFxuICAgICAgICAgICAgZyA9IG0uZ2V0QnVja2V0KGkpO1xuXG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgdmFyIHYgPSBnLnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoaS5pZCksXG4gICAgICAgICAgICAgIHkgPSB0LnVzZVByb2dyYW0odSA/IFwiZmlsbEV4dHJ1c2lvblBhdHRlcm5cIiA6IFwiZmlsbEV4dHJ1c2lvblwiLCB2KTtcbiAgICAgICAgICB1ICYmICh0LmNvbnRleHQuYWN0aXZlVGV4dHVyZS5zZXQobC5URVhUVVJFMCksIG0uaW1hZ2VBdGxhc1RleHR1cmUuYmluZChsLkxJTkVBUiwgbC5DTEFNUF9UT19FREdFKSwgdi51cGRhdGVQYWludEJ1ZmZlcnMoaCkpO1xuICAgICAgICAgIHZhciB4ID0gYy5jb25zdGFudE9yKG51bGwpO1xuXG4gICAgICAgICAgaWYgKHggJiYgbS5pbWFnZUF0bGFzKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG0uaW1hZ2VBdGxhcyxcbiAgICAgICAgICAgICAgICB3ID0gYi5wYXR0ZXJuUG9zaXRpb25zW3gudG8udG9TdHJpbmcoKV0sXG4gICAgICAgICAgICAgICAgVCA9IGIucGF0dGVyblBvc2l0aW9uc1t4LmZyb20udG9TdHJpbmcoKV07XG4gICAgICAgICAgICB3ICYmIFQgJiYgdi5zZXRDb25zdGFudFBhdHRlcm5Qb3NpdGlvbnModywgVCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEUgPSB0LnRyYW5zbGF0ZVBvc01hdHJpeChmLnBvc01hdHJpeCwgbSwgaS5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIiksIGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiKSksXG4gICAgICAgICAgICAgIEkgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCIpLFxuICAgICAgICAgICAgICBQID0gdSA/IEVpKEUsIHQsIEksIHAsIGYsIGgsIG0pIDogVGkoRSwgdCwgSSwgcCk7XG4gICAgICAgICAgeS5kcmF3KHMsIHMuZ2wuVFJJQU5HTEVTLCByLCBhLCBuLCBDdC5iYWNrQ0NXLCBQLCBpLmlkLCBnLmxheW91dFZlcnRleEJ1ZmZlciwgZy5pbmRleEJ1ZmZlciwgZy5zZWdtZW50cywgaS5wYWludCwgdC50cmFuc2Zvcm0uem9vbSwgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbyhlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IGUuY29udGV4dCxcbiAgICAgICAgICBsID0gcy5nbCxcbiAgICAgICAgICBjID0gaS5mYm87XG5cbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHZhciB1ID0gZS51c2VQcm9ncmFtKFwiaGlsbHNoYWRlXCIpO1xuICAgICAgICBzLmFjdGl2ZVRleHR1cmUuc2V0KGwuVEVYVFVSRTApLCBsLmJpbmRUZXh0dXJlKGwuVEVYVFVSRV8yRCwgYy5jb2xvckF0dGFjaG1lbnQuZ2V0KCkpO1xuXG4gICAgICAgIHZhciBoID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICB2YXIgciA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiKSxcbiAgICAgICAgICAgICAgYSA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiKSxcbiAgICAgICAgICAgICAgbiA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWFjY2VudC1jb2xvclwiKSxcbiAgICAgICAgICAgICAgcyA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIikgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgXCJ2aWV3cG9ydFwiID09PSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCIpICYmIChzIC09IGUudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgICB2YXIgbCxcbiAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgaCA9ICFlLm9wdGlvbnMubW92aW5nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogZS50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KGkudGlsZUlELnRvVW53cmFwcGVkKCksIGgpLFxuICAgICAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgICAgIHVfbGF0cmFuZ2U6IChsID0gaS50aWxlSUQsIGMgPSBNYXRoLnBvdygyLCBsLmNhbm9uaWNhbC56KSwgdSA9IGwuY2Fub25pY2FsLnksIFtuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoMCwgdSAvIGMpLnRvTG5nTGF0KCkubGF0LCBuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoMCwgKHUgKyAxKSAvIGMpLnRvTG5nTGF0KCkubGF0XSksXG4gICAgICAgICAgICB1X2xpZ2h0OiBbby5wYWludC5nZXQoXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCIpLCBzXSxcbiAgICAgICAgICAgIHVfc2hhZG93OiByLFxuICAgICAgICAgICAgdV9oaWdobGlnaHQ6IGEsXG4gICAgICAgICAgICB1X2FjY2VudDogblxuICAgICAgICAgIH07XG4gICAgICAgIH0oZSwgaSwgbyk7XG5cbiAgICAgICAgdS5kcmF3KHMsIGwuVFJJQU5HTEVTLCByLCBhLCBuLCBDdC5kaXNhYmxlZCwgaCwgby5pZCwgZS5yYXN0ZXJCb3VuZHNCdWZmZXIsIGUucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIGUucmFzdGVyQm91bmRzU2VnbWVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vKGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gZS5jb250ZXh0LFxuICAgICAgICAgIGwgPSBzLmdsLFxuICAgICAgICAgIGMgPSBpLmRlbTtcblxuICAgICAgaWYgKGMgJiYgYy5kYXRhKSB7XG4gICAgICAgIHZhciB1ID0gYy5kaW0sXG4gICAgICAgICAgICBoID0gYy5zdHJpZGUsXG4gICAgICAgICAgICBwID0gYy5nZXRQaXhlbHMoKTtcblxuICAgICAgICBpZiAocy5hY3RpdmVUZXh0dXJlLnNldChsLlRFWFRVUkUxKSwgcy5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYS5zZXQoITEpLCBpLmRlbVRleHR1cmUgPSBpLmRlbVRleHR1cmUgfHwgZS5nZXRUaWxlVGV4dHVyZShoKSwgaS5kZW1UZXh0dXJlKSB7XG4gICAgICAgICAgdmFyIGQgPSBpLmRlbVRleHR1cmU7XG4gICAgICAgICAgZC51cGRhdGUocCwge1xuICAgICAgICAgICAgcHJlbXVsdGlwbHk6ICExXG4gICAgICAgICAgfSksIGQuYmluZChsLk5FQVJFU1QsIGwuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIH0gZWxzZSBpLmRlbVRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKHMsIHAsIGwuUkdCQSwge1xuICAgICAgICAgIHByZW11bHRpcGx5OiAhMVxuICAgICAgICB9KSwgaS5kZW1UZXh0dXJlLmJpbmQobC5ORUFSRVNULCBsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIHMuYWN0aXZlVGV4dHVyZS5zZXQobC5URVhUVVJFMCk7XG4gICAgICAgIHZhciBfID0gaS5mYm87XG5cbiAgICAgICAgaWYgKCFfKSB7XG4gICAgICAgICAgdmFyIGYgPSBuZXcgdC5UZXh0dXJlKHMsIHtcbiAgICAgICAgICAgIHdpZHRoOiB1LFxuICAgICAgICAgICAgaGVpZ2h0OiB1LFxuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgIH0sIGwuUkdCQSk7XG4gICAgICAgICAgZi5iaW5kKGwuTElORUFSLCBsLkNMQU1QX1RPX0VER0UpLCAoXyA9IGkuZmJvID0gcy5jcmVhdGVGcmFtZWJ1ZmZlcih1LCB1LCAhMCkpLmNvbG9yQXR0YWNobWVudC5zZXQoZi50ZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuYmluZEZyYW1lYnVmZmVyLnNldChfLmZyYW1lYnVmZmVyKSwgcy52aWV3cG9ydC5zZXQoWzAsIDAsIHUsIHVdKSwgZS51c2VQcm9ncmFtKFwiaGlsbHNoYWRlUHJlcGFyZVwiKS5kcmF3KHMsIGwuVFJJQU5HTEVTLCByLCBhLCBuLCBDdC5kaXNhYmxlZCwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IGkuc3RyaWRlLFxuICAgICAgICAgICAgICByID0gdC5jcmVhdGUoKTtcbiAgICAgICAgICByZXR1cm4gdC5vcnRobyhyLCAwLCB0LkVYVEVOVCwgLXQuRVhURU5ULCAwLCAwLCAxKSwgdC50cmFuc2xhdGUociwgciwgWzAsIC10LkVYVEVOVCwgMF0pLCB7XG4gICAgICAgICAgICB1X21hdHJpeDogcixcbiAgICAgICAgICAgIHVfaW1hZ2U6IDEsXG4gICAgICAgICAgICB1X2RpbWVuc2lvbjogW28sIG9dLFxuICAgICAgICAgICAgdV96b29tOiBlLm92ZXJzY2FsZWRaLFxuICAgICAgICAgICAgdV91bnBhY2s6IGkuZ2V0VW5wYWNrVmVjdG9yKClcbiAgICAgICAgICB9O1xuICAgICAgICB9KGkudGlsZUlELCBjKSwgby5pZCwgZS5yYXN0ZXJCb3VuZHNCdWZmZXIsIGUucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIGUucmFzdGVyQm91bmRzU2VnbWVudHMpLCBpLm5lZWRzSGlsbHNoYWRlUHJlcGFyZSA9ICExO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gci5wYWludC5nZXQoXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiKTtcblxuICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgIHZhciBzID0gdC5icm93c2VyLm5vdygpLFxuICAgICAgICAgICAgbCA9IChzIC0gZS50aW1lQWRkZWQpIC8gbixcbiAgICAgICAgICAgIGMgPSBpID8gKHMgLSBpLnRpbWVBZGRlZCkgLyBuIDogLTEsXG4gICAgICAgICAgICB1ID0gby5nZXRTb3VyY2UoKSxcbiAgICAgICAgICAgIGggPSBhLmNvdmVyaW5nWm9vbUxldmVsKHtcbiAgICAgICAgICB0aWxlU2l6ZTogdS50aWxlU2l6ZSxcbiAgICAgICAgICByb3VuZFpvb206IHUucm91bmRab29tXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgcCA9ICFpIHx8IE1hdGguYWJzKGkudGlsZUlELm92ZXJzY2FsZWRaIC0gaCkgPiBNYXRoLmFicyhlLnRpbGVJRC5vdmVyc2NhbGVkWiAtIGgpLFxuICAgICAgICAgICAgZCA9IHAgJiYgZS5yZWZyZXNoZWRVcG9uRXhwaXJhdGlvbiA/IDEgOiB0LmNsYW1wKHAgPyBsIDogMSAtIGMsIDAsIDEpO1xuICAgICAgICByZXR1cm4gZS5yZWZyZXNoZWRVcG9uRXhwaXJhdGlvbiAmJiBsID49IDEgJiYgKGUucmVmcmVzaGVkVXBvbkV4cGlyYXRpb24gPSAhMSksIGkgPyB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBtaXg6IDEgLSBkXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgb3BhY2l0eTogZCxcbiAgICAgICAgICBtaXg6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgbWl4OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsbyA9IG5ldyB0LkNvbG9yKDEsIDAsIDAsIDEpLFxuICAgICAgICBjbyA9IG5ldyB0LkNvbG9yKDAsIDEsIDAsIDEpLFxuICAgICAgICB1byA9IG5ldyB0LkNvbG9yKDAsIDAsIDEsIDEpLFxuICAgICAgICBobyA9IG5ldyB0LkNvbG9yKDEsIDAsIDEsIDEpLFxuICAgICAgICBwbyA9IG5ldyB0LkNvbG9yKDAsIDEsIDEsIDEpO1xuXG4gICAgZnVuY3Rpb24gX28odCwgZSwgaSwgbykge1xuICAgICAgbW8odCwgMCwgZSArIGkgLyAyLCB0LnRyYW5zZm9ybS53aWR0aCwgaSwgbyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm8odCwgZSwgaSwgbykge1xuICAgICAgbW8odCwgZSAtIGkgLyAyLCAwLCBpLCB0LnRyYW5zZm9ybS5oZWlnaHQsIG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vKGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gZS5jb250ZXh0LFxuICAgICAgICAgIGwgPSBzLmdsO1xuICAgICAgbC5lbmFibGUobC5TQ0lTU09SX1RFU1QpLCBsLnNjaXNzb3IoaSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLCBvICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIHIgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbywgYSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSwgcy5jbGVhcih7XG4gICAgICAgIGNvbG9yOiBuXG4gICAgICB9KSwgbC5kaXNhYmxlKGwuU0NJU1NPUl9URVNUKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnbyhlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IGUuY29udGV4dCxcbiAgICAgICAgICBhID0gci5nbCxcbiAgICAgICAgICBuID0gby5wb3NNYXRyaXgsXG4gICAgICAgICAgcyA9IGUudXNlUHJvZ3JhbShcImRlYnVnXCIpLFxuICAgICAgICAgIGwgPSBJdC5kaXNhYmxlZCxcbiAgICAgICAgICBjID0gUHQuZGlzYWJsZWQsXG4gICAgICAgICAgdSA9IGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpO1xuICAgICAgci5hY3RpdmVUZXh0dXJlLnNldChhLlRFWFRVUkUwKSwgZS5lbXB0eVRleHR1cmUuYmluZChhLkxJTkVBUiwgYS5DTEFNUF9UT19FREdFKSwgcy5kcmF3KHIsIGEuTElORV9TVFJJUCwgbCwgYywgdSwgQ3QuZGlzYWJsZWQsIE1pKG4sIHQuQ29sb3IucmVkKSwgXCIkZGVidWdcIiwgZS5kZWJ1Z0J1ZmZlciwgZS50aWxlQm9yZGVySW5kZXhCdWZmZXIsIGUuZGVidWdTZWdtZW50cyk7XG5cbiAgICAgIHZhciBoID0gaS5nZXRUaWxlQnlJRChvLmtleSkubGF0ZXN0UmF3VGlsZURhdGEsXG4gICAgICAgICAgcCA9IE1hdGguZmxvb3IoKGggJiYgaC5ieXRlTGVuZ3RoIHx8IDApIC8gMTAyNCksXG4gICAgICAgICAgZCA9IGkuZ2V0VGlsZShvKS50aWxlU2l6ZSxcbiAgICAgICAgICBfID0gNTEyIC8gTWF0aC5taW4oZCwgNTEyKSAqIChvLm92ZXJzY2FsZWRaIC8gZS50cmFuc2Zvcm0uem9vbSkgKiAuNSxcbiAgICAgICAgICBmID0gby5jYW5vbmljYWwudG9TdHJpbmcoKTtcblxuICAgICAgby5vdmVyc2NhbGVkWiAhPT0gby5jYW5vbmljYWwueiAmJiAoZiArPSBcIiA9PiBcIiArIG8ub3ZlcnNjYWxlZFopLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LmluaXREZWJ1Z092ZXJsYXlDYW52YXMoKTtcbiAgICAgICAgdmFyIGkgPSB0LmRlYnVnT3ZlcmxheUNhbnZhcyxcbiAgICAgICAgICAgIG8gPSB0LmNvbnRleHQuZ2wsXG4gICAgICAgICAgICByID0gdC5kZWJ1Z092ZXJsYXlDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICByLmNsZWFyUmVjdCgwLCAwLCBpLndpZHRoLCBpLmhlaWdodCksIHIuc2hhZG93Q29sb3IgPSBcIndoaXRlXCIsIHIuc2hhZG93Qmx1ciA9IDIsIHIubGluZVdpZHRoID0gMS41LCByLnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiLCByLnRleHRCYXNlbGluZSA9IFwidG9wXCIsIHIuZm9udCA9IFwiYm9sZCAzNnB4IE9wZW4gU2Fucywgc2Fucy1zZXJpZlwiLCByLmZpbGxUZXh0KGUsIDUsIDUpLCByLnN0cm9rZVRleHQoZSwgNSwgNSksIHQuZGVidWdPdmVybGF5VGV4dHVyZS51cGRhdGUoaSksIHQuZGVidWdPdmVybGF5VGV4dHVyZS5iaW5kKG8uTElORUFSLCBvLkNMQU1QX1RPX0VER0UpO1xuICAgICAgfShlLCBmICsgXCIgXCIgKyBwICsgXCJrYlwiKSwgcy5kcmF3KHIsIGEuVFJJQU5HTEVTLCBsLCBjLCBTdC5hbHBoYUJsZW5kZWQsIEN0LmRpc2FibGVkLCBNaShuLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBfKSwgXCIkZGVidWdcIiwgZS5kZWJ1Z0J1ZmZlciwgZS5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgZS5kZWJ1Z1NlZ21lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgdm8gPSB7XG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbChlLCBpLCBvLCByLCBhKSB7XG4gICAgICAgIGlmIChcInRyYW5zbHVjZW50XCIgPT09IGUucmVuZGVyUGFzcykge1xuICAgICAgICAgIHZhciBuID0gUHQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgIHMgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKTtcbiAgICAgICAgICBvLmxheW91dC5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKSAmJiBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IGkudHJhbnNmb3JtLCBjID0gXCJtYXBcIiA9PT0gYSwgdSA9IFwibWFwXCIgPT09IG4sIGggPSAwLCBwID0gZTsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBwW2hdLFxuICAgICAgICAgICAgICAgICAgXyA9IHIuZ2V0VGlsZShkKSxcbiAgICAgICAgICAgICAgICAgIGYgPSBfLmdldEJ1Y2tldChvKTtcblxuICAgICAgICAgICAgICBpZiAoZiAmJiBmLnRleHQgJiYgZi50ZXh0LnNlZ21lbnRzLmdldCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtID0gdC5ldmFsdWF0ZVNpemVGb3Jab29tKGYudGV4dFNpemVEYXRhLCBsLnpvb20pLFxuICAgICAgICAgICAgICAgICAgICBnID0gcGUoXywgMSwgaS50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgICAgICAgICAgIHYgPSBKdChkLnBvc01hdHJpeCwgdSwgYywgaS50cmFuc2Zvcm0sIGcpLFxuICAgICAgICAgICAgICAgICAgICB5ID0gXCJub25lXCIgIT09IG8ubGF5b3V0LmdldChcImljb24tdGV4dC1maXRcIikgJiYgZi5oYXNJY29uRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID0gTWF0aC5wb3coMiwgbC56b29tIC0gXy50aWxlSUQub3ZlcnNjYWxlZFopO1xuICAgICAgICAgICAgICAgICAgJGkoZiwgYywgdSwgcywgdC5zeW1ib2xTaXplLCBsLCB2LCBkLnBvc01hdHJpeCwgeCwgbSwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfShyLCBlLCBvLCBpLCBvLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSwgby5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksIGEpLCAwICE9PSBvLnBhaW50LmdldChcImljb24tb3BhY2l0eVwiKS5jb25zdGFudE9yKDEpICYmIGVvKGUsIGksIG8sIHIsICExLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlLWFuY2hvclwiKSwgby5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcImljb24tcGl0Y2gtYWxpZ25tZW50XCIpLCBvLmxheW91dC5nZXQoXCJpY29uLWtlZXAtdXByaWdodFwiKSwgbiwgcyksIDAgIT09IG8ucGFpbnQuZ2V0KFwidGV4dC1vcGFjaXR5XCIpLmNvbnN0YW50T3IoMSkgJiYgZW8oZSwgaSwgbywgciwgITAsIG8ucGFpbnQuZ2V0KFwidGV4dC10cmFuc2xhdGVcIiksIG8ucGFpbnQuZ2V0KFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCIpLCBvLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSwgby5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcInRleHQta2VlcC11cHJpZ2h0XCIpLCBuLCBzKSwgaS5tYXAuc2hvd0NvbGxpc2lvbkJveGVzICYmIChZaShlLCBpLCBvLCByLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiKSwgITApLCBZaShlLCBpLCBvLCByLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlLWFuY2hvclwiKSwgITEpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNpcmNsZTogZnVuY3Rpb24gY2lyY2xlKGUsIGksIG8sIHIpIHtcbiAgICAgICAgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gZS5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgdmFyIGEgPSBvLnBhaW50LmdldChcImNpcmNsZS1vcGFjaXR5XCIpLFxuICAgICAgICAgICAgICBuID0gby5wYWludC5nZXQoXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCIpLFxuICAgICAgICAgICAgICBzID0gby5wYWludC5nZXQoXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIiksXG4gICAgICAgICAgICAgIGwgPSB2b2lkIDAgIT09IG8ubGF5b3V0LmdldChcImNpcmNsZS1zb3J0LWtleVwiKS5jb25zdGFudE9yKDEpO1xuXG4gICAgICAgICAgaWYgKDAgIT09IGEuY29uc3RhbnRPcigxKSB8fCAwICE9PSBuLmNvbnN0YW50T3IoMSkgJiYgMCAhPT0gcy5jb25zdGFudE9yKDEpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gZS5jb250ZXh0LCB1ID0gYy5nbCwgaCA9IGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpLCBwID0gUHQuZGlzYWJsZWQsIGQgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSwgXyA9IFtdLCBmID0gMDsgZiA8IHIubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSByW2ZdLFxuICAgICAgICAgICAgICAgICAgZyA9IGkuZ2V0VGlsZShtKSxcbiAgICAgICAgICAgICAgICAgIHYgPSBnLmdldEJ1Y2tldChvKTtcblxuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdi5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpLFxuICAgICAgICAgICAgICAgICAgICB4ID0ge1xuICAgICAgICAgICAgICAgICAgcHJvZ3JhbUNvbmZpZ3VyYXRpb246IHksXG4gICAgICAgICAgICAgICAgICBwcm9ncmFtOiBlLnVzZVByb2dyYW0oXCJjaXJjbGVcIiwgeSksXG4gICAgICAgICAgICAgICAgICBsYXlvdXRWZXJ0ZXhCdWZmZXI6IHYubGF5b3V0VmVydGV4QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgaW5kZXhCdWZmZXI6IHYuaW5kZXhCdWZmZXIsXG4gICAgICAgICAgICAgICAgICB1bmlmb3JtVmFsdWVzOiB6aShlLCBtLCBnLCBvKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGwpIGZvciAodmFyIGIgPSAwLCB3ID0gdi5zZWdtZW50cy5nZXQoKTsgYiA8IHcubGVuZ3RoOyBiICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBUID0gd1tiXTtcblxuICAgICAgICAgICAgICAgICAgXy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM6IG5ldyB0LlNlZ21lbnRWZWN0b3IoW1RdKSxcbiAgICAgICAgICAgICAgICAgICAgc29ydEtleTogVC5zb3J0S2V5LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogeFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIF8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzZWdtZW50czogdi5zZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgIHNvcnRLZXk6IDAsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogeFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgJiYgXy5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgRSA9IDAsIEkgPSBfOyBFIDwgSS5sZW5ndGg7IEUgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgUCA9IElbRV0sXG4gICAgICAgICAgICAgICAgICBTID0gUC5zdGF0ZTtcbiAgICAgICAgICAgICAgUy5wcm9ncmFtLmRyYXcoYywgdS5UUklBTkdMRVMsIGgsIHAsIGQsIEN0LmRpc2FibGVkLCBTLnVuaWZvcm1WYWx1ZXMsIG8uaWQsIFMubGF5b3V0VmVydGV4QnVmZmVyLCBTLmluZGV4QnVmZmVyLCBQLnNlZ21lbnRzLCBvLnBhaW50LCBlLnRyYW5zZm9ybS56b29tLCBTLnByb2dyYW1Db25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoZWF0bWFwOiBmdW5jdGlvbiBoZWF0bWFwKGUsIGksIG8sIHIpIHtcbiAgICAgICAgaWYgKDAgIT09IG8ucGFpbnQuZ2V0KFwiaGVhdG1hcC1vcGFjaXR5XCIpKSBpZiAoXCJvZmZzY3JlZW5cIiA9PT0gZS5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgdmFyIGEgPSBlLmNvbnRleHQsXG4gICAgICAgICAgICAgIG4gPSBhLmdsLFxuICAgICAgICAgICAgICBzID0gUHQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgIGwgPSBuZXcgU3QoW24uT05FLCBuLk9ORV0sIHQuQ29sb3IudHJhbnNwYXJlbnQsIFshMCwgITAsICEwLCAhMF0pO1xuICAgICAgICAgICFmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgICAgdmFyIG8gPSB0LmdsO1xuICAgICAgICAgICAgdC5hY3RpdmVUZXh0dXJlLnNldChvLlRFWFRVUkUxKSwgdC52aWV3cG9ydC5zZXQoWzAsIDAsIGUud2lkdGggLyA0LCBlLmhlaWdodCAvIDRdKTtcbiAgICAgICAgICAgIHZhciByID0gaS5oZWF0bWFwRmJvO1xuICAgICAgICAgICAgaWYgKHIpIG8uYmluZFRleHR1cmUoby5URVhUVVJFXzJELCByLmNvbG9yQXR0YWNobWVudC5nZXQoKSksIHQuYmluZEZyYW1lYnVmZmVyLnNldChyLmZyYW1lYnVmZmVyKTtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBvLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsIGEpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfV1JBUF9TLCBvLkNMQU1QX1RPX0VER0UpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfV1JBUF9ULCBvLkNMQU1QX1RPX0VER0UpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfTUlOX0ZJTFRFUiwgby5MSU5FQVIpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfTUFHX0ZJTFRFUiwgby5MSU5FQVIpLCByID0gaS5oZWF0bWFwRmJvID0gdC5jcmVhdGVGcmFtZWJ1ZmZlcihlLndpZHRoIC8gNCwgZS5oZWlnaHQgLyA0LCAhMSksIGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0LmdsO1xuICAgICAgICAgICAgICAgIHIudGV4SW1hZ2UyRChyLlRFWFRVUkVfMkQsIDAsIHIuUkdCQSwgZS53aWR0aCAvIDQsIGUuaGVpZ2h0IC8gNCwgMCwgci5SR0JBLCB0LmV4dFJlbmRlclRvVGV4dHVyZUhhbGZGbG9hdCA/IHQuZXh0VGV4dHVyZUhhbGZGbG9hdC5IQUxGX0ZMT0FUX09FUyA6IHIuVU5TSUdORURfQllURSwgbnVsbCksIG8uY29sb3JBdHRhY2htZW50LnNldChpKTtcbiAgICAgICAgICAgICAgfSh0LCBlLCBhLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KGEsIGUsIG8pLCBhLmNsZWFyKHtcbiAgICAgICAgICAgIGNvbG9yOiB0LkNvbG9yLnRyYW5zcGFyZW50XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHIubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gcltjXTtcblxuICAgICAgICAgICAgaWYgKCFpLmhhc1JlbmRlcmFibGVQYXJlbnQodSkpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBpLmdldFRpbGUodSksXG4gICAgICAgICAgICAgICAgICBwID0gaC5nZXRCdWNrZXQobyk7XG5cbiAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHAucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmdldChvLmlkKTtcbiAgICAgICAgICAgICAgICBlLnVzZVByb2dyYW0oXCJoZWF0bWFwXCIsIGQpLmRyYXcoYSwgbi5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCBzLCBsLCBDdC5kaXNhYmxlZCwgUmkodS5wb3NNYXRyaXgsIGgsIGUudHJhbnNmb3JtLnpvb20sIG8ucGFpbnQuZ2V0KFwiaGVhdG1hcC1pbnRlbnNpdHlcIikpLCBvLmlkLCBwLmxheW91dFZlcnRleEJ1ZmZlciwgcC5pbmRleEJ1ZmZlciwgcC5zZWdtZW50cywgby5wYWludCwgZS50cmFuc2Zvcm0uem9vbSwgZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhLnZpZXdwb3J0LnNldChbMCwgMCwgZS53aWR0aCwgZS5oZWlnaHRdKTtcbiAgICAgICAgfSBlbHNlIFwidHJhbnNsdWNlbnRcIiA9PT0gZS5yZW5kZXJQYXNzICYmIChlLmNvbnRleHQuc2V0Q29sb3JNb2RlKGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKSwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IGUuY29udGV4dCxcbiAgICAgICAgICAgICAgciA9IG8uZ2wsXG4gICAgICAgICAgICAgIGEgPSBpLmhlYXRtYXBGYm87XG5cbiAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgby5hY3RpdmVUZXh0dXJlLnNldChyLlRFWFRVUkUwKSwgci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsIGEuY29sb3JBdHRhY2htZW50LmdldCgpKSwgby5hY3RpdmVUZXh0dXJlLnNldChyLlRFWFRVUkUxKTtcbiAgICAgICAgICAgIHZhciBuID0gaS5jb2xvclJhbXBUZXh0dXJlO1xuICAgICAgICAgICAgbiB8fCAobiA9IGkuY29sb3JSYW1wVGV4dHVyZSA9IG5ldyB0LlRleHR1cmUobywgaS5jb2xvclJhbXAsIHIuUkdCQSkpLCBuLmJpbmQoci5MSU5FQVIsIHIuQ0xBTVBfVE9fRURHRSksIGUudXNlUHJvZ3JhbShcImhlYXRtYXBUZXh0dXJlXCIpLmRyYXcobywgci5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCBQdC5kaXNhYmxlZCwgZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIEN0LmRpc2FibGVkLCBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICAgICAgICB2YXIgYSA9IHQuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIHQub3J0aG8oYSwgMCwgZS53aWR0aCwgZS5oZWlnaHQsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICB2YXIgbiA9IGUuY29udGV4dC5nbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1X21hdHJpeDogYSxcbiAgICAgICAgICAgICAgICB1X3dvcmxkOiBbbi5kcmF3aW5nQnVmZmVyV2lkdGgsIG4uZHJhd2luZ0J1ZmZlckhlaWdodF0sXG4gICAgICAgICAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgICAgICAgICB1X2NvbG9yX3JhbXA6IDEsXG4gICAgICAgICAgICAgICAgdV9vcGFjaXR5OiBpLnBhaW50LmdldChcImhlYXRtYXAtb3BhY2l0eVwiKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShlLCBpKSwgaS5pZCwgZS52aWV3cG9ydEJ1ZmZlciwgZS5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgZS52aWV3cG9ydFNlZ21lbnRzLCBpLnBhaW50LCBlLnRyYW5zZm9ybS56b29tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oZSwgbykpO1xuICAgICAgfSxcbiAgICAgIGxpbmU6IGZ1bmN0aW9uIGxpbmUoZSwgaSwgbywgcikge1xuICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICB2YXIgYSA9IG8ucGFpbnQuZ2V0KFwibGluZS1vcGFjaXR5XCIpLFxuICAgICAgICAgICAgICBuID0gby5wYWludC5nZXQoXCJsaW5lLXdpZHRoXCIpO1xuICAgICAgICAgIGlmICgwICE9PSBhLmNvbnN0YW50T3IoMSkgJiYgMCAhPT0gbi5jb25zdGFudE9yKDEpKSBmb3IgKHZhciBzID0gZS5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBJdC5SZWFkT25seSksIGwgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSwgYyA9IG8ucGFpbnQuZ2V0KFwibGluZS1kYXNoYXJyYXlcIiksIHUgPSBvLnBhaW50LmdldChcImxpbmUtcGF0dGVyblwiKSwgaCA9IHUuY29uc3RhbnRPcigxKSwgcCA9IG8ucGFpbnQuZ2V0KFwibGluZS1ncmFkaWVudFwiKSwgZCA9IG8uZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycygpLCBfID0gaCA/IFwibGluZVBhdHRlcm5cIiA6IGMgPyBcImxpbmVTREZcIiA6IHAgPyBcImxpbmVHcmFkaWVudFwiIDogXCJsaW5lXCIsIGYgPSBlLmNvbnRleHQsIG0gPSBmLmdsLCBnID0gITAsIHYgPSAwLCB5ID0gcjsgdiA8IHkubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB4ID0geVt2XSxcbiAgICAgICAgICAgICAgICBiID0gaS5nZXRUaWxlKHgpO1xuXG4gICAgICAgICAgICBpZiAoIWggfHwgYi5wYXR0ZXJuc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gYi5nZXRCdWNrZXQobyk7XG5cbiAgICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICB2YXIgVCA9IHcucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmdldChvLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgRSA9IGUuY29udGV4dC5wcm9ncmFtLmdldCgpLFxuICAgICAgICAgICAgICAgICAgICBJID0gZS51c2VQcm9ncmFtKF8sIFQpLFxuICAgICAgICAgICAgICAgICAgICBQID0gZyB8fCBJLnByb2dyYW0gIT09IEUsXG4gICAgICAgICAgICAgICAgICAgIFMgPSB1LmNvbnN0YW50T3IobnVsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoUyAmJiBiLmltYWdlQXRsYXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBDID0gYi5pbWFnZUF0bGFzLFxuICAgICAgICAgICAgICAgICAgICAgIHogPSBDLnBhdHRlcm5Qb3NpdGlvbnNbUy50by50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgICAgICAgICBEID0gQy5wYXR0ZXJuUG9zaXRpb25zW1MuZnJvbS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgIHogJiYgRCAmJiBULnNldENvbnN0YW50UGF0dGVyblBvc2l0aW9ucyh6LCBEKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgQSA9IGggPyBPaShlLCBiLCBvLCBkKSA6IGMgPyBGaShlLCBiLCBvLCBjLCBkKSA6IHAgPyBCaShlLCBiLCBvLCB3LmxpbmVDbGlwc0FycmF5Lmxlbmd0aCkgOiBraShlLCBiLCBvKTtcbiAgICAgICAgICAgICAgICBpZiAoaCkgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgYi5pbWFnZUF0bGFzVGV4dHVyZS5iaW5kKG0uTElORUFSLCBtLkNMQU1QX1RPX0VER0UpLCBULnVwZGF0ZVBhaW50QnVmZmVycyhkKTtlbHNlIGlmIChjICYmIChQIHx8IGUubGluZUF0bGFzLmRpcnR5KSkgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgZS5saW5lQXRsYXMuYmluZChmKTtlbHNlIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgTSA9IHcuZ3JhZGllbnRzW28uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgIEwgPSBNLnRleHR1cmU7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvLmdyYWRpZW50VmVyc2lvbiAhPT0gTS52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBSID0gMjU2O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnN0ZXBJbnRlcnBvbGFudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gaS5nZXRTb3VyY2UoKS5tYXh6b29tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBCID0geC5jYW5vbmljYWwueiA9PT0gayA/IE1hdGguY2VpbCgxIDw8IGUudHJhbnNmb3JtLm1heFpvb20gLSB4LmNhbm9uaWNhbC56KSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgUiA9IHQuY2xhbXAodC5uZXh0UG93ZXJPZlR3byh3Lm1heExpbmVMZW5ndGggLyB0LkVYVEVOVCAqIDEwMjQgKiBCKSwgMjU2LCBmLm1heFRleHR1cmVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE0uZ3JhZGllbnQgPSB0LnJlbmRlckNvbG9yUmFtcCh7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogby5ncmFkaWVudEV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0aW9uS2V5OiBcImxpbmVQcm9ncmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb246IFIsXG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IE0uZ3JhZGllbnQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNsaXBzOiB3LmxpbmVDbGlwc0FycmF5XG4gICAgICAgICAgICAgICAgICAgIH0pLCBNLnRleHR1cmUgPyBNLnRleHR1cmUudXBkYXRlKE0uZ3JhZGllbnQpIDogTS50ZXh0dXJlID0gbmV3IHQuVGV4dHVyZShmLCBNLmdyYWRpZW50LCBtLlJHQkEpLCBNLnZlcnNpb24gPSBvLmdyYWRpZW50VmVyc2lvbiwgTCA9IE0udGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgTC5iaW5kKG8uc3RlcEludGVycG9sYW50ID8gbS5ORUFSRVNUIDogbS5MSU5FQVIsIG0uQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEkuZHJhdyhmLCBtLlRSSUFOR0xFUywgcywgZS5zdGVuY2lsTW9kZUZvckNsaXBwaW5nKHgpLCBsLCBDdC5kaXNhYmxlZCwgQSwgby5pZCwgdy5sYXlvdXRWZXJ0ZXhCdWZmZXIsIHcuaW5kZXhCdWZmZXIsIHcuc2VnbWVudHMsIG8ucGFpbnQsIGUudHJhbnNmb3JtLnpvb20sIFQsIHcubGF5b3V0VmVydGV4QnVmZmVyMiksIGcgPSAhMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwoZSwgaSwgbywgcikge1xuICAgICAgICB2YXIgYSA9IG8ucGFpbnQuZ2V0KFwiZmlsbC1jb2xvclwiKSxcbiAgICAgICAgICAgIG4gPSBvLnBhaW50LmdldChcImZpbGwtb3BhY2l0eVwiKTtcblxuICAgICAgICBpZiAoMCAhPT0gbi5jb25zdGFudE9yKDEpKSB7XG4gICAgICAgICAgdmFyIHMgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSxcbiAgICAgICAgICAgICAgbCA9IG8ucGFpbnQuZ2V0KFwiZmlsbC1wYXR0ZXJuXCIpLFxuICAgICAgICAgICAgICBjID0gZS5vcGFxdWVQYXNzRW5hYmxlZEZvckxheWVyKCkgJiYgIWwuY29uc3RhbnRPcigxKSAmJiAxID09PSBhLmNvbnN0YW50T3IodC5Db2xvci50cmFuc3BhcmVudCkuYSAmJiAxID09PSBuLmNvbnN0YW50T3IoMCkgPyBcIm9wYXF1ZVwiIDogXCJ0cmFuc2x1Y2VudFwiO1xuXG4gICAgICAgICAgaWYgKGUucmVuZGVyUGFzcyA9PT0gYykge1xuICAgICAgICAgICAgdmFyIHUgPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKDEsIFwib3BhcXVlXCIgPT09IGUucmVuZGVyUGFzcyA/IEl0LlJlYWRXcml0ZSA6IEl0LlJlYWRPbmx5KTtcbiAgICAgICAgICAgIG9vKGUsIGksIG8sIHIsIHUsIHMsICExKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MgJiYgby5wYWludC5nZXQoXCJmaWxsLWFudGlhbGlhc1wiKSkge1xuICAgICAgICAgICAgdmFyIGggPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKG8uZ2V0UGFpbnRQcm9wZXJ0eShcImZpbGwtb3V0bGluZS1jb2xvclwiKSA/IDIgOiAwLCBJdC5SZWFkT25seSk7XG4gICAgICAgICAgICBvbyhlLCBpLCBvLCByLCBoLCBzLCAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJmaWxsLWV4dHJ1c2lvblwiOiBmdW5jdGlvbiBmaWxsRXh0cnVzaW9uKHQsIGUsIGksIG8pIHtcbiAgICAgICAgdmFyIHIgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIik7XG5cbiAgICAgICAgaWYgKDAgIT09IHIgJiYgXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MpIHtcbiAgICAgICAgICB2YXIgYSA9IG5ldyBJdCh0LmNvbnRleHQuZ2wuTEVRVUFMLCBJdC5SZWFkV3JpdGUsIHQuZGVwdGhSYW5nZUZvcjNEKTtcbiAgICAgICAgICBpZiAoMSAhPT0gciB8fCBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIikuY29uc3RhbnRPcigxKSkgcm8odCwgZSwgaSwgbywgYSwgUHQuZGlzYWJsZWQsIFN0LmRpc2FibGVkKSwgcm8odCwgZSwgaSwgbywgYSwgdC5zdGVuY2lsTW9kZUZvcjNEKCksIHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBuID0gdC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCk7XG4gICAgICAgICAgICBybyh0LCBlLCBpLCBvLCBhLCBQdC5kaXNhYmxlZCwgbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlsbHNoYWRlOiBmdW5jdGlvbiBoaWxsc2hhZGUodCwgZSwgaSwgbykge1xuICAgICAgICBpZiAoXCJvZmZzY3JlZW5cIiA9PT0gdC5yZW5kZXJQYXNzIHx8IFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IHQuY29udGV4dCwgYSA9IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpLCBuID0gdC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIHMgPSBcInRyYW5zbHVjZW50XCIgPT09IHQucmVuZGVyUGFzcyA/IHQuc3RlbmNpbENvbmZpZ0Zvck92ZXJsYXAobykgOiBbe30sIG9dLCBsID0gc1swXSwgYyA9IDAsIHUgPSBzWzFdOyBjIDwgdS5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGggPSB1W2NdLFxuICAgICAgICAgICAgICAgIHAgPSBlLmdldFRpbGUoaCk7XG4gICAgICAgICAgICBwLm5lZWRzSGlsbHNoYWRlUHJlcGFyZSAmJiBcIm9mZnNjcmVlblwiID09PSB0LnJlbmRlclBhc3MgPyBubyh0LCBwLCBpLCBhLCBQdC5kaXNhYmxlZCwgbikgOiBcInRyYW5zbHVjZW50XCIgPT09IHQucmVuZGVyUGFzcyAmJiBhbyh0LCBwLCBpLCBhLCBsW2gub3ZlcnNjYWxlZFpdLCBuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnZpZXdwb3J0LnNldChbMCwgMCwgdC53aWR0aCwgdC5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJhc3RlcjogZnVuY3Rpb24gcmFzdGVyKHQsIGUsIGksIG8pIHtcbiAgICAgICAgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzICYmIDAgIT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIikgJiYgby5sZW5ndGgpIGZvciAodmFyIHIgPSB0LmNvbnRleHQsIGEgPSByLmdsLCBuID0gZS5nZXRTb3VyY2UoKSwgcyA9IHQudXNlUHJvZ3JhbShcInJhc3RlclwiKSwgbCA9IHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBjID0gbiBpbnN0YW5jZW9mIE0gPyBbe30sIG9dIDogdC5zdGVuY2lsQ29uZmlnRm9yT3ZlcmxhcChvKSwgdSA9IGNbMF0sIGggPSBjWzFdLCBwID0gaFtoLmxlbmd0aCAtIDFdLm92ZXJzY2FsZWRaLCBkID0gIXQub3B0aW9ucy5tb3ZpbmcsIF8gPSAwLCBmID0gaDsgXyA8IGYubGVuZ3RoOyBfICs9IDEpIHtcbiAgICAgICAgICB2YXIgbSA9IGZbX10sXG4gICAgICAgICAgICAgIGcgPSB0LmRlcHRoTW9kZUZvclN1YmxheWVyKG0ub3ZlcnNjYWxlZFogLSBwLCAxID09PSBpLnBhaW50LmdldChcInJhc3Rlci1vcGFjaXR5XCIpID8gSXQuUmVhZFdyaXRlIDogSXQuUmVhZE9ubHksIGEuTEVTUyksXG4gICAgICAgICAgICAgIHYgPSBlLmdldFRpbGUobSksXG4gICAgICAgICAgICAgIHkgPSB0LnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgobS50b1Vud3JhcHBlZCgpLCBkKTtcbiAgICAgICAgICB2LnJlZ2lzdGVyRmFkZUR1cmF0aW9uKGkucGFpbnQuZ2V0KFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIikpO1xuICAgICAgICAgIHZhciB4ID0gZS5maW5kTG9hZGVkUGFyZW50KG0sIDApLFxuICAgICAgICAgICAgICBiID0gc28odiwgeCwgZSwgaSwgdC50cmFuc2Zvcm0pLFxuICAgICAgICAgICAgICB3ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBUID0gdm9pZCAwLFxuICAgICAgICAgICAgICBFID0gXCJuZWFyZXN0XCIgPT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLXJlc2FtcGxpbmdcIikgPyBhLk5FQVJFU1QgOiBhLkxJTkVBUjtcbiAgICAgICAgICByLmFjdGl2ZVRleHR1cmUuc2V0KGEuVEVYVFVSRTApLCB2LnRleHR1cmUuYmluZChFLCBhLkNMQU1QX1RPX0VER0UsIGEuTElORUFSX01JUE1BUF9ORUFSRVNUKSwgci5hY3RpdmVUZXh0dXJlLnNldChhLlRFWFRVUkUxKSwgeCA/ICh4LnRleHR1cmUuYmluZChFLCBhLkNMQU1QX1RPX0VER0UsIGEuTElORUFSX01JUE1BUF9ORUFSRVNUKSwgdyA9IE1hdGgucG93KDIsIHgudGlsZUlELm92ZXJzY2FsZWRaIC0gdi50aWxlSUQub3ZlcnNjYWxlZFopLCBUID0gW3YudGlsZUlELmNhbm9uaWNhbC54ICogdyAlIDEsIHYudGlsZUlELmNhbm9uaWNhbC55ICogdyAlIDFdKSA6IHYudGV4dHVyZS5iaW5kKEUsIGEuQ0xBTVBfVE9fRURHRSwgYS5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgIHZhciBJID0gWmkoeSwgVCB8fCBbMCwgMF0sIHcgfHwgMSwgYiwgaSk7XG4gICAgICAgICAgbiBpbnN0YW5jZW9mIE0gPyBzLmRyYXcociwgYS5UUklBTkdMRVMsIGcsIFB0LmRpc2FibGVkLCBsLCBDdC5kaXNhYmxlZCwgSSwgaS5pZCwgbi5ib3VuZHNCdWZmZXIsIHQucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIG4uYm91bmRzU2VnbWVudHMpIDogcy5kcmF3KHIsIGEuVFJJQU5HTEVTLCBnLCB1W20ub3ZlcnNjYWxlZFpdLCBsLCBDdC5kaXNhYmxlZCwgSSwgaS5pZCwgdC5yYXN0ZXJCb3VuZHNCdWZmZXIsIHQucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIHQucmFzdGVyQm91bmRzU2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDogZnVuY3Rpb24gYmFja2dyb3VuZCh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBvID0gaS5wYWludC5nZXQoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpLFxuICAgICAgICAgICAgciA9IGkucGFpbnQuZ2V0KFwiYmFja2dyb3VuZC1vcGFjaXR5XCIpO1xuXG4gICAgICAgIGlmICgwICE9PSByKSB7XG4gICAgICAgICAgdmFyIGEgPSB0LmNvbnRleHQsXG4gICAgICAgICAgICAgIG4gPSBhLmdsLFxuICAgICAgICAgICAgICBzID0gdC50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGwgPSBzLnRpbGVTaXplLFxuICAgICAgICAgICAgICBjID0gaS5wYWludC5nZXQoXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIik7XG5cbiAgICAgICAgICBpZiAoIXQuaXNQYXR0ZXJuTWlzc2luZyhjKSkge1xuICAgICAgICAgICAgdmFyIHUgPSAhYyAmJiAxID09PSBvLmEgJiYgMSA9PT0gciAmJiB0Lm9wYXF1ZVBhc3NFbmFibGVkRm9yTGF5ZXIoKSA/IFwib3BhcXVlXCIgOiBcInRyYW5zbHVjZW50XCI7XG5cbiAgICAgICAgICAgIGlmICh0LnJlbmRlclBhc3MgPT09IHUpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBQdC5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgIHAgPSB0LmRlcHRoTW9kZUZvclN1YmxheWVyKDAsIFwib3BhcXVlXCIgPT09IHUgPyBJdC5SZWFkV3JpdGUgOiBJdC5SZWFkT25seSksXG4gICAgICAgICAgICAgICAgICBkID0gdC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksXG4gICAgICAgICAgICAgICAgICBfID0gdC51c2VQcm9ncmFtKGMgPyBcImJhY2tncm91bmRQYXR0ZXJuXCIgOiBcImJhY2tncm91bmRcIiksXG4gICAgICAgICAgICAgICAgICBmID0gcy5jb3ZlcmluZ1RpbGVzKHtcbiAgICAgICAgICAgICAgICB0aWxlU2l6ZTogbFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjICYmIChhLmFjdGl2ZVRleHR1cmUuc2V0KG4uVEVYVFVSRTApLCB0LmltYWdlTWFuYWdlci5iaW5kKHQuY29udGV4dCkpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIG0gPSBpLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSwgZyA9IDAsIHYgPSBmOyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdltnXSxcbiAgICAgICAgICAgICAgICAgICAgeCA9IHQudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeCh5LnRvVW53cmFwcGVkKCkpLFxuICAgICAgICAgICAgICAgICAgICBiID0gYyA/IEhpKHgsIHIsIHQsIGMsIHtcbiAgICAgICAgICAgICAgICAgIHRpbGVJRDogeSxcbiAgICAgICAgICAgICAgICAgIHRpbGVTaXplOiBsXG4gICAgICAgICAgICAgICAgfSwgbSkgOiBYaSh4LCByLCBvKTtcblxuICAgICAgICAgICAgICAgIF8uZHJhdyhhLCBuLlRSSUFOR0xFUywgcCwgaCwgZCwgQ3QuZGlzYWJsZWQsIGIsIGkuaWQsIHQudGlsZUV4dGVudEJ1ZmZlciwgdC5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgdC50aWxlRXh0ZW50U2VnbWVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKHQsIGUsIGkpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBpLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgZ28odCwgZSwgaVtvXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbSh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdC5jb250ZXh0LFxuICAgICAgICAgICAgciA9IGkuaW1wbGVtZW50YXRpb247XG5cbiAgICAgICAgaWYgKFwib2Zmc2NyZWVuXCIgPT09IHQucmVuZGVyUGFzcykge1xuICAgICAgICAgIHZhciBhID0gci5wcmVyZW5kZXI7XG4gICAgICAgICAgYSAmJiAodC5zZXRDdXN0b21MYXllckRlZmF1bHRzKCksIG8uc2V0Q29sb3JNb2RlKHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKSwgYS5jYWxsKHIsIG8uZ2wsIHQudHJhbnNmb3JtLmN1c3RvbUxheWVyTWF0cml4KCkpLCBvLnNldERpcnR5KCksIHQuc2V0QmFzZVN0YXRlKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgdC5zZXRDdXN0b21MYXllckRlZmF1bHRzKCksIG8uc2V0Q29sb3JNb2RlKHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKSwgby5zZXRTdGVuY2lsTW9kZShQdC5kaXNhYmxlZCk7XG4gICAgICAgICAgdmFyIG4gPSBcIjNkXCIgPT09IHIucmVuZGVyaW5nTW9kZSA/IG5ldyBJdCh0LmNvbnRleHQuZ2wuTEVRVUFMLCBJdC5SZWFkV3JpdGUsIHQuZGVwdGhSYW5nZUZvcjNEKSA6IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpO1xuICAgICAgICAgIG8uc2V0RGVwdGhNb2RlKG4pLCByLnJlbmRlcihvLmdsLCB0LnRyYW5zZm9ybS5jdXN0b21MYXllck1hdHJpeCgpKSwgby5zZXREaXJ0eSgpLCB0LnNldEJhc2VTdGF0ZSgpLCBvLmJpbmRGcmFtZWJ1ZmZlci5zZXQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICB5byA9IGZ1bmN0aW9uIHlvKHQsIGUpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IG5ldyB6dCh0KSwgdGhpcy50cmFuc2Zvcm0gPSBlLCB0aGlzLl90aWxlVGV4dHVyZXMgPSB7fSwgdGhpcy5zZXR1cCgpLCB0aGlzLm51bVN1YmxheWVycyA9IER0Lm1heFVuZGVyem9vbWluZyArIER0Lm1heE92ZXJ6b29taW5nICsgMSwgdGhpcy5kZXB0aEVwc2lsb24gPSAxIC8gTWF0aC5wb3coMiwgMTYpLCB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4ID0gbmV3IEZlKCksIHRoaXMuZ3B1VGltZXJzID0ge307XG4gICAgfTtcblxuICAgIHlvLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgaWYgKHRoaXMud2lkdGggPSBlICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIHRoaXMuaGVpZ2h0ID0gaSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLCB0aGlzLmNvbnRleHQudmlld3BvcnQuc2V0KFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0pLCB0aGlzLnN0eWxlKSBmb3IgKHZhciBvID0gMCwgciA9IHRoaXMuc3R5bGUuX29yZGVyOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICB0aGlzLnN0eWxlLl9sYXllcnNbcltvXV0ucmVzaXplKCk7XG4gICAgICB9XG4gICAgfSwgeW8ucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaSA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0Mmk0KCk7XG4gICAgICBpLmVtcGxhY2VCYWNrKDAsIDApLCBpLmVtcGxhY2VCYWNrKHQuRVhURU5ULCAwKSwgaS5lbXBsYWNlQmFjaygwLCB0LkVYVEVOVCksIGkuZW1wbGFjZUJhY2sodC5FWFRFTlQsIHQuRVhURU5UKSwgdGhpcy50aWxlRXh0ZW50QnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIoaSwgVmUubWVtYmVycyksIHRoaXMudGlsZUV4dGVudFNlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMik7XG4gICAgICB2YXIgbyA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0Mmk0KCk7XG4gICAgICBvLmVtcGxhY2VCYWNrKDAsIDApLCBvLmVtcGxhY2VCYWNrKHQuRVhURU5ULCAwKSwgby5lbXBsYWNlQmFjaygwLCB0LkVYVEVOVCksIG8uZW1wbGFjZUJhY2sodC5FWFRFTlQsIHQuRVhURU5UKSwgdGhpcy5kZWJ1Z0J1ZmZlciA9IGUuY3JlYXRlVmVydGV4QnVmZmVyKG8sIFZlLm1lbWJlcnMpLCB0aGlzLmRlYnVnU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCA1KTtcbiAgICAgIHZhciByID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQ0aTgoKTtcbiAgICAgIHIuZW1wbGFjZUJhY2soMCwgMCwgMCwgMCksIHIuZW1wbGFjZUJhY2sodC5FWFRFTlQsIDAsIHQuRVhURU5ULCAwKSwgci5lbXBsYWNlQmFjaygwLCB0LkVYVEVOVCwgMCwgdC5FWFRFTlQpLCByLmVtcGxhY2VCYWNrKHQuRVhURU5ULCB0LkVYVEVOVCwgdC5FWFRFTlQsIHQuRVhURU5UKSwgdGhpcy5yYXN0ZXJCb3VuZHNCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcihyLCBBLm1lbWJlcnMpLCB0aGlzLnJhc3RlckJvdW5kc1NlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMik7XG4gICAgICB2YXIgYSA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0Mmk0KCk7XG4gICAgICBhLmVtcGxhY2VCYWNrKDAsIDApLCBhLmVtcGxhY2VCYWNrKDEsIDApLCBhLmVtcGxhY2VCYWNrKDAsIDEpLCBhLmVtcGxhY2VCYWNrKDEsIDEpLCB0aGlzLnZpZXdwb3J0QnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIoYSwgVmUubWVtYmVycyksIHRoaXMudmlld3BvcnRTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDIpO1xuICAgICAgdmFyIG4gPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDF1aTIoKTtcbiAgICAgIG4uZW1wbGFjZUJhY2soMCksIG4uZW1wbGFjZUJhY2soMSksIG4uZW1wbGFjZUJhY2soMyksIG4uZW1wbGFjZUJhY2soMiksIG4uZW1wbGFjZUJhY2soMCksIHRoaXMudGlsZUJvcmRlckluZGV4QnVmZmVyID0gZS5jcmVhdGVJbmRleEJ1ZmZlcihuKTtcbiAgICAgIHZhciBzID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQzdWk2KCk7XG4gICAgICBzLmVtcGxhY2VCYWNrKDAsIDEsIDIpLCBzLmVtcGxhY2VCYWNrKDIsIDEsIDMpLCB0aGlzLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyID0gZS5jcmVhdGVJbmRleEJ1ZmZlcihzKSwgdGhpcy5lbXB0eVRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGUsIHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDBdKVxuICAgICAgfSwgZS5nbC5SR0JBKTtcbiAgICAgIHZhciBsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5zdGVuY2lsQ2xlYXJNb2RlID0gbmV3IFB0KHtcbiAgICAgICAgZnVuYzogbC5BTFdBWVMsXG4gICAgICAgIG1hc2s6IDBcbiAgICAgIH0sIDAsIDI1NSwgbC5aRVJPLCBsLlpFUk8sIGwuWkVSTyk7XG4gICAgfSwgeW8ucHJvdG90eXBlLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGkgPSBlLmdsO1xuICAgICAgdGhpcy5uZXh0U3RlbmNpbElEID0gMSwgdGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBvID0gdC5jcmVhdGUoKTtcbiAgICAgIHQub3J0aG8obywgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIDAsIDEpLCB0LnNjYWxlKG8sIG8sIFtpLmRyYXdpbmdCdWZmZXJXaWR0aCwgaS5kcmF3aW5nQnVmZmVySGVpZ2h0LCAwXSksIHRoaXMudXNlUHJvZ3JhbShcImNsaXBwaW5nTWFza1wiKS5kcmF3KGUsIGkuVFJJQU5HTEVTLCBJdC5kaXNhYmxlZCwgdGhpcy5zdGVuY2lsQ2xlYXJNb2RlLCBTdC5kaXNhYmxlZCwgQ3QuZGlzYWJsZWQsIExpKG8pLCBcIiRjbGlwcGluZ1wiLCB0aGlzLnZpZXdwb3J0QnVmZmVyLCB0aGlzLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCB0aGlzLnZpZXdwb3J0U2VnbWVudHMpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5fcmVuZGVyVGlsZUNsaXBwaW5nTWFza3MgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFN0ZW5jaWxTb3VyY2UgIT09IHQuc291cmNlICYmIHQuaXNUaWxlQ2xpcHBlZCgpICYmIGUgJiYgZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSA9IHQuc291cmNlO1xuICAgICAgICB2YXIgaSA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIG8gPSBpLmdsO1xuICAgICAgICB0aGlzLm5leHRTdGVuY2lsSUQgKyBlLmxlbmd0aCA+IDI1NiAmJiB0aGlzLmNsZWFyU3RlbmNpbCgpLCBpLnNldENvbG9yTW9kZShTdC5kaXNhYmxlZCksIGkuc2V0RGVwdGhNb2RlKEl0LmRpc2FibGVkKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnVzZVByb2dyYW0oXCJjbGlwcGluZ01hc2tcIik7XG4gICAgICAgIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMCwgbiA9IGU7IGEgPCBuLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgdmFyIHMgPSBuW2FdLFxuICAgICAgICAgICAgICBsID0gdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1tzLmtleV0gPSB0aGlzLm5leHRTdGVuY2lsSUQrKztcbiAgICAgICAgICByLmRyYXcoaSwgby5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCBuZXcgUHQoe1xuICAgICAgICAgICAgZnVuYzogby5BTFdBWVMsXG4gICAgICAgICAgICBtYXNrOiAwXG4gICAgICAgICAgfSwgbCwgMjU1LCBvLktFRVAsIG8uS0VFUCwgby5SRVBMQUNFKSwgU3QuZGlzYWJsZWQsIEN0LmRpc2FibGVkLCBMaShzLnBvc01hdHJpeCksIFwiJGNsaXBwaW5nXCIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlciwgdGhpcy5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgdGhpcy50aWxlRXh0ZW50U2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgeW8ucHJvdG90eXBlLnN0ZW5jaWxNb2RlRm9yM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVuY2lsU291cmNlID0gdm9pZCAwLCB0aGlzLm5leHRTdGVuY2lsSUQgKyAxID4gMjU2ICYmIHRoaXMuY2xlYXJTdGVuY2lsKCk7XG4gICAgICB2YXIgdCA9IHRoaXMubmV4dFN0ZW5jaWxJRCsrLFxuICAgICAgICAgIGUgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICByZXR1cm4gbmV3IFB0KHtcbiAgICAgICAgZnVuYzogZS5OT1RFUVVBTCxcbiAgICAgICAgbWFzazogMjU1XG4gICAgICB9LCB0LCAyNTUsIGUuS0VFUCwgZS5LRUVQLCBlLlJFUExBQ0UpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5zdGVuY2lsTW9kZUZvckNsaXBwaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgcmV0dXJuIG5ldyBQdCh7XG4gICAgICAgIGZ1bmM6IGUuRVFVQUwsXG4gICAgICAgIG1hc2s6IDI1NVxuICAgICAgfSwgdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1t0LmtleV0sIDAsIGUuS0VFUCwgZS5LRUVQLCBlLlJFUExBQ0UpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5zdGVuY2lsQ29uZmlnRm9yT3ZlcmxhcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgICBpID0gdGhpcy5jb250ZXh0LmdsLFxuICAgICAgICAgIG8gPSB0LnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGUub3ZlcnNjYWxlZFogLSB0Lm92ZXJzY2FsZWRaO1xuICAgICAgfSksXG4gICAgICAgICAgciA9IG9bby5sZW5ndGggLSAxXS5vdmVyc2NhbGVkWixcbiAgICAgICAgICBhID0gb1swXS5vdmVyc2NhbGVkWiAtIHIgKyAxO1xuXG4gICAgICBpZiAoYSA+IDEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSA9IHZvaWQgMCwgdGhpcy5uZXh0U3RlbmNpbElEICsgYSA+IDI1NiAmJiB0aGlzLmNsZWFyU3RlbmNpbCgpO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSB7fSwgcyA9IDA7IHMgPCBhOyBzKyspIHtcbiAgICAgICAgICBuW3MgKyByXSA9IG5ldyBQdCh7XG4gICAgICAgICAgICBmdW5jOiBpLkdFUVVBTCxcbiAgICAgICAgICAgIG1hc2s6IDI1NVxuICAgICAgICAgIH0sIHMgKyB0aGlzLm5leHRTdGVuY2lsSUQsIDI1NSwgaS5LRUVQLCBpLktFRVAsIGkuUkVQTEFDRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0U3RlbmNpbElEICs9IGEsIFtuLCBvXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFsoZSA9IHt9LCBlW3JdID0gUHQuZGlzYWJsZWQsIGUpLCBvXTtcbiAgICB9LCB5by5wcm90b3R5cGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgcmV0dXJuIHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciA/IG5ldyBTdChbZS5DT05TVEFOVF9DT0xPUiwgZS5PTkVdLCBuZXcgdC5Db2xvcigxIC8gOCwgMSAvIDgsIDEgLyA4LCAwKSwgWyEwLCAhMCwgITAsICEwXSkgOiBcIm9wYXF1ZVwiID09PSB0aGlzLnJlbmRlclBhc3MgPyBTdC51bmJsZW5kZWQgOiBTdC5hbHBoYUJsZW5kZWQ7XG4gICAgfSwgeW8ucHJvdG90eXBlLmRlcHRoTW9kZUZvclN1YmxheWVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICghdGhpcy5vcGFxdWVQYXNzRW5hYmxlZEZvckxheWVyKCkpIHJldHVybiBJdC5kaXNhYmxlZDtcbiAgICAgIHZhciBvID0gMSAtICgoMSArIHRoaXMuY3VycmVudExheWVyKSAqIHRoaXMubnVtU3VibGF5ZXJzICsgdCkgKiB0aGlzLmRlcHRoRXBzaWxvbjtcbiAgICAgIHJldHVybiBuZXcgSXQoaSB8fCB0aGlzLmNvbnRleHQuZ2wuTEVRVUFMLCBlLCBbbywgb10pO1xuICAgIH0sIHlvLnByb3RvdHlwZS5vcGFxdWVQYXNzRW5hYmxlZEZvckxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExheWVyIDwgdGhpcy5vcGFxdWVQYXNzQ3V0b2ZmO1xuICAgIH0sIHlvLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgdGhpcy5zdHlsZSA9IGUsIHRoaXMub3B0aW9ucyA9IGksIHRoaXMubGluZUF0bGFzID0gZS5saW5lQXRsYXMsIHRoaXMuaW1hZ2VNYW5hZ2VyID0gZS5pbWFnZU1hbmFnZXIsIHRoaXMuZ2x5cGhNYW5hZ2VyID0gZS5nbHlwaE1hbmFnZXIsIHRoaXMuc3ltYm9sRmFkZUNoYW5nZSA9IGUucGxhY2VtZW50LnN5bWJvbEZhZGVDaGFuZ2UodC5icm93c2VyLm5vdygpKSwgdGhpcy5pbWFnZU1hbmFnZXIuYmVnaW5GcmFtZSgpO1xuICAgICAgdmFyIHIgPSB0aGlzLnN0eWxlLl9vcmRlcixcbiAgICAgICAgICBhID0gdGhpcy5zdHlsZS5zb3VyY2VDYWNoZXM7XG5cbiAgICAgIGZvciAodmFyIG4gaW4gYSkge1xuICAgICAgICB2YXIgcyA9IGFbbl07XG4gICAgICAgIHMudXNlZCAmJiBzLnByZXBhcmUodGhpcy5jb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGwsXG4gICAgICAgICAgYyxcbiAgICAgICAgICB1ID0ge30sXG4gICAgICAgICAgaCA9IHt9LFxuICAgICAgICAgIHAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgZCBpbiBhKSB7XG4gICAgICAgIHZhciBfID0gYVtkXTtcbiAgICAgICAgdVtkXSA9IF8uZ2V0VmlzaWJsZUNvb3JkaW5hdGVzKCksIGhbZF0gPSB1W2RdLnNsaWNlKCkucmV2ZXJzZSgpLCBwW2RdID0gXy5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMoITApLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcGFxdWVQYXNzQ3V0b2ZmID0gMSAvIDA7XG5cbiAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgci5sZW5ndGg7IGYrKykge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5fbGF5ZXJzW3JbZl1dLmlzM0QoKSkge1xuICAgICAgICAgIHRoaXMub3BhcXVlUGFzc0N1dG9mZiA9IGY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJQYXNzID0gXCJvZmZzY3JlZW5cIjtcblxuICAgICAgZm9yICh2YXIgbSA9IDAsIGcgPSByOyBtIDwgZy5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuc3R5bGUuX2xheWVyc1tnW21dXTtcblxuICAgICAgICBpZiAodi5oYXNPZmZzY3JlZW5QYXNzKCkgJiYgIXYuaXNIaWRkZW4odGhpcy50cmFuc2Zvcm0uem9vbSkpIHtcbiAgICAgICAgICB2YXIgeSA9IGhbdi5zb3VyY2VdO1xuICAgICAgICAgIChcImN1c3RvbVwiID09PSB2LnR5cGUgfHwgeS5sZW5ndGgpICYmIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgYVt2LnNvdXJjZV0sIHYsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodGhpcy5jb250ZXh0LmJpbmRGcmFtZWJ1ZmZlci5zZXQobnVsbCksIHRoaXMuY29udGV4dC5jbGVhcih7XG4gICAgICAgIGNvbG9yOiBpLnNob3dPdmVyZHJhd0luc3BlY3RvciA/IHQuQ29sb3IuYmxhY2sgOiB0LkNvbG9yLnRyYW5zcGFyZW50LFxuICAgICAgICBkZXB0aDogMVxuICAgICAgfSksIHRoaXMuY2xlYXJTdGVuY2lsKCksIHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciA9IGkuc2hvd092ZXJkcmF3SW5zcGVjdG9yLCB0aGlzLmRlcHRoUmFuZ2VGb3IzRCA9IFswLCAxIC0gKGUuX29yZGVyLmxlbmd0aCArIDIpICogdGhpcy5udW1TdWJsYXllcnMgKiB0aGlzLmRlcHRoRXBzaWxvbl0sIHRoaXMucmVuZGVyUGFzcyA9IFwib3BhcXVlXCIsIHRoaXMuY3VycmVudExheWVyID0gci5sZW5ndGggLSAxOyB0aGlzLmN1cnJlbnRMYXllciA+PSAwOyB0aGlzLmN1cnJlbnRMYXllci0tKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5zdHlsZS5fbGF5ZXJzW3JbdGhpcy5jdXJyZW50TGF5ZXJdXSxcbiAgICAgICAgICAgIGIgPSBhW3guc291cmNlXSxcbiAgICAgICAgICAgIHcgPSB1W3guc291cmNlXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGlsZUNsaXBwaW5nTWFza3MoeCwgdyksIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgYiwgeCwgdyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodGhpcy5yZW5kZXJQYXNzID0gXCJ0cmFuc2x1Y2VudFwiLCB0aGlzLmN1cnJlbnRMYXllciA9IDA7IHRoaXMuY3VycmVudExheWVyIDwgci5sZW5ndGg7IHRoaXMuY3VycmVudExheWVyKyspIHtcbiAgICAgICAgdmFyIFQgPSB0aGlzLnN0eWxlLl9sYXllcnNbclt0aGlzLmN1cnJlbnRMYXllcl1dLFxuICAgICAgICAgICAgRSA9IGFbVC5zb3VyY2VdLFxuICAgICAgICAgICAgSSA9IChcInN5bWJvbFwiID09PSBULnR5cGUgPyBwIDogaClbVC5zb3VyY2VdO1xuICAgICAgICB0aGlzLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyhULCB1W1Quc291cmNlXSksIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgRSwgVCwgSSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucy5zaG93VGlsZUJvdW5kYXJpZXMgJiYgKHQudmFsdWVzKHRoaXMuc3R5bGUuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnNvdXJjZSAmJiAhdC5pc0hpZGRlbihvLnRyYW5zZm9ybS56b29tKSAmJiAodC5zb3VyY2UgIT09IChjICYmIGMuaWQpICYmIChjID0gby5zdHlsZS5zb3VyY2VDYWNoZXNbdC5zb3VyY2VdKSwgKCFsIHx8IGwuZ2V0U291cmNlKCkubWF4em9vbSA8IGMuZ2V0U291cmNlKCkubWF4em9vbSkgJiYgKGwgPSBjKSk7XG4gICAgICB9KSwgbCAmJiB2by5kZWJ1Zyh0aGlzLCBsLCBsLmdldFZpc2libGVDb29yZGluYXRlcygpKSksIHRoaXMub3B0aW9ucy5zaG93UGFkZGluZyAmJiBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQudHJhbnNmb3JtLnBhZGRpbmc7XG4gICAgICAgIF9vKHQsIHQudHJhbnNmb3JtLmhlaWdodCAtIChlLnRvcCB8fCAwKSwgMywgbG8pLCBfbyh0LCBlLmJvdHRvbSB8fCAwLCAzLCBjbyksIGZvKHQsIGUubGVmdCB8fCAwLCAzLCB1byksIGZvKHQsIHQudHJhbnNmb3JtLndpZHRoIC0gKGUucmlnaHQgfHwgMCksIDMsIGhvKTtcbiAgICAgICAgdmFyIGkgPSB0LnRyYW5zZm9ybS5jZW50ZXJQb2ludDtcbiAgICAgICAgIWZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgICAgbW8odCwgZSAtIDEsIGkgLSAxMCwgMiwgMjAsIG8pLCBtbyh0LCBlIC0gMTAsIGkgLSAxLCAyMCwgMiwgbyk7XG4gICAgICAgIH0odCwgaS54LCB0LnRyYW5zZm9ybS5oZWlnaHQgLSBpLnksIHBvKTtcbiAgICAgIH0odGhpcyksIHRoaXMuY29udGV4dC5zZXREZWZhdWx0KCk7XG4gICAgfSwgeW8ucHJvdG90eXBlLnJlbmRlckxheWVyID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgIGkuaXNIaWRkZW4odGhpcy50cmFuc2Zvcm0uem9vbSkgfHwgKFwiYmFja2dyb3VuZFwiID09PSBpLnR5cGUgfHwgXCJjdXN0b21cIiA9PT0gaS50eXBlIHx8IG8ubGVuZ3RoKSAmJiAodGhpcy5pZCA9IGkuaWQsIHRoaXMuZ3B1VGltaW5nU3RhcnQoaSksIHZvW2kudHlwZV0odCwgZSwgaSwgbywgdGhpcy5zdHlsZS5wbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzKSwgdGhpcy5ncHVUaW1pbmdFbmQoKSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLmdwdVRpbWluZ1N0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3B1VGltaW5nKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmV4dFRpbWVyUXVlcnksXG4gICAgICAgICAgICBpID0gdGhpcy5ncHVUaW1lcnNbdC5pZF07XG4gICAgICAgIGkgfHwgKGkgPSB0aGlzLmdwdVRpbWVyc1t0LmlkXSA9IHtcbiAgICAgICAgICBjYWxsczogMCxcbiAgICAgICAgICBjcHVUaW1lOiAwLFxuICAgICAgICAgIHF1ZXJ5OiBlLmNyZWF0ZVF1ZXJ5RVhUKClcbiAgICAgICAgfSksIGkuY2FsbHMrKywgZS5iZWdpblF1ZXJ5RVhUKGUuVElNRV9FTEFQU0VEX0VYVCwgaS5xdWVyeSk7XG4gICAgICB9XG4gICAgfSwgeW8ucHJvdG90eXBlLmdwdVRpbWluZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3B1VGltaW5nKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5jb250ZXh0LmV4dFRpbWVyUXVlcnk7XG4gICAgICAgIHQuZW5kUXVlcnlFWFQodC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgIH1cbiAgICB9LCB5by5wcm90b3R5cGUuY29sbGVjdEdwdVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5ncHVUaW1lcnM7XG4gICAgICByZXR1cm4gdGhpcy5ncHVUaW1lcnMgPSB7fSwgdDtcbiAgICB9LCB5by5wcm90b3R5cGUucXVlcnlHcHVUaW1lcnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiB0KSB7XG4gICAgICAgIHZhciBvID0gdFtpXSxcbiAgICAgICAgICAgIHIgPSB0aGlzLmNvbnRleHQuZXh0VGltZXJRdWVyeSxcbiAgICAgICAgICAgIGEgPSByLmdldFF1ZXJ5T2JqZWN0RVhUKG8ucXVlcnksIHIuUVVFUllfUkVTVUxUX0VYVCkgLyAxZTY7XG4gICAgICAgIHIuZGVsZXRlUXVlcnlFWFQoby5xdWVyeSksIGVbaV0gPSBhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9LCB5by5wcm90b3R5cGUudHJhbnNsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmICghb1swXSAmJiAhb1sxXSkgcmV0dXJuIGU7XG4gICAgICB2YXIgbiA9IGEgPyBcIm1hcFwiID09PSByID8gdGhpcy50cmFuc2Zvcm0uYW5nbGUgOiAwIDogXCJ2aWV3cG9ydFwiID09PSByID8gLXRoaXMudHJhbnNmb3JtLmFuZ2xlIDogMDtcblxuICAgICAgaWYgKG4pIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbihuKSxcbiAgICAgICAgICAgIGwgPSBNYXRoLmNvcyhuKTtcbiAgICAgICAgbyA9IFtvWzBdICogbCAtIG9bMV0gKiBzLCBvWzBdICogcyArIG9bMV0gKiBsXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSBbYSA/IG9bMF0gOiBwZShpLCBvWzBdLCB0aGlzLnRyYW5zZm9ybS56b29tKSwgYSA/IG9bMV0gOiBwZShpLCBvWzFdLCB0aGlzLnRyYW5zZm9ybS56b29tKSwgMF0sXG4gICAgICAgICAgdSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKHUsIGUsIGMpLCB1O1xuICAgIH0sIHlvLnByb3RvdHlwZS5zYXZlVGlsZVRleHR1cmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl90aWxlVGV4dHVyZXNbdC5zaXplWzBdXTtcbiAgICAgIGUgPyBlLnB1c2godCkgOiB0aGlzLl90aWxlVGV4dHVyZXNbdC5zaXplWzBdXSA9IFt0XTtcbiAgICB9LCB5by5wcm90b3R5cGUuZ2V0VGlsZVRleHR1cmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl90aWxlVGV4dHVyZXNbdF07XG4gICAgICByZXR1cm4gZSAmJiBlLmxlbmd0aCA+IDAgPyBlLnBvcCgpIDogbnVsbDtcbiAgICB9LCB5by5wcm90b3R5cGUuaXNQYXR0ZXJuTWlzc2luZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAoIXQpIHJldHVybiAhMTtcbiAgICAgIGlmICghdC5mcm9tIHx8ICF0LnRvKSByZXR1cm4gITA7XG4gICAgICB2YXIgZSA9IHRoaXMuaW1hZ2VNYW5hZ2VyLmdldFBhdHRlcm4odC5mcm9tLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGkgPSB0aGlzLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQudG8udG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gIWUgfHwgIWk7XG4gICAgfSwgeW8ucHJvdG90eXBlLnVzZVByb2dyYW0gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUgfHwge307XG4gICAgICB2YXIgaSA9IFwiXCIgKyB0ICsgKGUgPyBlLmNhY2hlS2V5IDogXCJcIikgKyAodGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID8gXCIvb3ZlcmRyYXdcIiA6IFwiXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVbaV0gfHwgKHRoaXMuY2FjaGVbaV0gPSBuZXcgYmkodGhpcy5jb250ZXh0LCB0LCB2aVt0XSwgZSwgS2lbdF0sIHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvcikpLCB0aGlzLmNhY2hlW2ldO1xuICAgIH0sIHlvLnByb3RvdHlwZS5zZXRDdXN0b21MYXllckRlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb250ZXh0LnVuYmluZFZBTygpLCB0aGlzLmNvbnRleHQuY3VsbEZhY2Uuc2V0RGVmYXVsdCgpLCB0aGlzLmNvbnRleHQuYWN0aXZlVGV4dHVyZS5zZXREZWZhdWx0KCksIHRoaXMuY29udGV4dC5waXhlbFN0b3JlVW5wYWNrLnNldERlZmF1bHQoKSwgdGhpcy5jb250ZXh0LnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLnNldERlZmF1bHQoKSwgdGhpcy5jb250ZXh0LnBpeGVsU3RvcmVVbnBhY2tGbGlwWS5zZXREZWZhdWx0KCk7XG4gICAgfSwgeW8ucHJvdG90eXBlLnNldEJhc2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5jb250ZXh0LmN1bGxGYWNlLnNldCghMSksIHRoaXMuY29udGV4dC52aWV3cG9ydC5zZXQoWzAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSksIHRoaXMuY29udGV4dC5ibGVuZEVxdWF0aW9uLnNldCh0LkZVTkNfQUREKTtcbiAgICB9LCB5by5wcm90b3R5cGUuaW5pdERlYnVnT3ZlcmxheUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG51bGwgPT0gdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMgJiYgKHRoaXMuZGVidWdPdmVybGF5Q2FudmFzID0gdC53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMud2lkdGggPSA1MTIsIHRoaXMuZGVidWdPdmVybGF5Q2FudmFzLmhlaWdodCA9IDUxMiwgdGhpcy5kZWJ1Z092ZXJsYXlUZXh0dXJlID0gbmV3IHQuVGV4dHVyZSh0aGlzLmNvbnRleHQsIHRoaXMuZGVidWdPdmVybGF5Q2FudmFzLCB0aGlzLmNvbnRleHQuZ2wuUkdCQSkpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5lbXB0eVRleHR1cmUuZGVzdHJveSgpLCB0aGlzLmRlYnVnT3ZlcmxheVRleHR1cmUgJiYgdGhpcy5kZWJ1Z092ZXJsYXlUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgdmFyIHhvID0gZnVuY3Rpb24geG8odCwgZSkge1xuICAgICAgdGhpcy5wb2ludHMgPSB0LCB0aGlzLnBsYW5lcyA9IGU7XG4gICAgfTtcblxuICAgIHhvLmZyb21JbnZQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gTWF0aC5wb3coMiwgbyksXG4gICAgICAgICAgYSA9IFtbLTEsIDEsIC0xLCAxXSwgWzEsIDEsIC0xLCAxXSwgWzEsIC0xLCAtMSwgMV0sIFstMSwgLTEsIC0xLCAxXSwgWy0xLCAxLCAxLCAxXSwgWzEsIDEsIDEsIDFdLCBbMSwgLTEsIDEsIDFdLCBbLTEsIC0xLCAxLCAxXV0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0LnRyYW5zZm9ybU1hdDQoW10sIGksIGUpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0LnNjYWxlJDEoW10sIGUsIDEgLyBlWzNdIC8gaSAqIHIpO1xuICAgICAgfSksXG4gICAgICAgICAgbiA9IFtbMCwgMSwgMl0sIFs2LCA1LCA0XSwgWzAsIDMsIDddLCBbMiwgMSwgNV0sIFszLCAyLCA2XSwgWzAsIDQsIDVdXS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0LnN1YihbXSwgYVtlWzBdXSwgYVtlWzFdXSksXG4gICAgICAgICAgICBvID0gdC5zdWIoW10sIGFbZVsyXV0sIGFbZVsxXV0pLFxuICAgICAgICAgICAgciA9IHQubm9ybWFsaXplKFtdLCB0LmNyb3NzKFtdLCBpLCBvKSksXG4gICAgICAgICAgICBuID0gLXQuZG90KHIsIGFbZVsxXV0pO1xuICAgICAgICByZXR1cm4gci5jb25jYXQobik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgeG8oYSwgbik7XG4gICAgfTtcblxuICAgIHZhciBibyA9IGZ1bmN0aW9uIGJvKGUsIGkpIHtcbiAgICAgIHRoaXMubWluID0gZSwgdGhpcy5tYXggPSBpLCB0aGlzLmNlbnRlciA9IHQuc2NhbGUkMihbXSwgdC5hZGQoW10sIHRoaXMubWluLCB0aGlzLm1heCksIC41KTtcbiAgICB9O1xuXG4gICAgYm8ucHJvdG90eXBlLnF1YWRyYW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBbZSAlIDIgPT0gMCwgZSA8IDJdLCBvID0gdC5jbG9uZSQyKHRoaXMubWluKSwgciA9IHQuY2xvbmUkMih0aGlzLm1heCksIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgICAgICBvW2FdID0gaVthXSA/IHRoaXMubWluW2FdIDogdGhpcy5jZW50ZXJbYV0sIHJbYV0gPSBpW2FdID8gdGhpcy5jZW50ZXJbYV0gOiB0aGlzLm1heFthXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJbMl0gPSB0aGlzLm1heFsyXSwgbmV3IGJvKG8sIHIpO1xuICAgIH0sIGJvLnByb3RvdHlwZS5kaXN0YW5jZVggPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHRoaXMubWF4WzBdLCB0WzBdKSwgdGhpcy5taW5bMF0pIC0gdFswXTtcbiAgICB9LCBiby5wcm90b3R5cGUuZGlzdGFuY2VZID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih0aGlzLm1heFsxXSwgdFsxXSksIHRoaXMubWluWzFdKSAtIHRbMV07XG4gICAgfSwgYm8ucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IFtbdGhpcy5taW5bMF0sIHRoaXMubWluWzFdLCAwLCAxXSwgW3RoaXMubWF4WzBdLCB0aGlzLm1pblsxXSwgMCwgMV0sIFt0aGlzLm1heFswXSwgdGhpcy5tYXhbMV0sIDAsIDFdLCBbdGhpcy5taW5bMF0sIHRoaXMubWF4WzFdLCAwLCAxXV0sIG8gPSAhMCwgciA9IDA7IHIgPCBlLnBsYW5lcy5sZW5ndGg7IHIrKykge1xuICAgICAgICBmb3IgKHZhciBhID0gZS5wbGFuZXNbcl0sIG4gPSAwLCBzID0gMDsgcyA8IGkubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICBuICs9IHQuZG90JDEoYSwgaVtzXSkgPj0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgwID09PSBuKSByZXR1cm4gMDtcbiAgICAgICAgbiAhPT0gaS5sZW5ndGggJiYgKG8gPSAhMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvKSByZXR1cm4gMjtcblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCAzOyBsKyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IE51bWJlci5NQVhfVkFMVUUsIHUgPSAtTnVtYmVyLk1BWF9WQUxVRSwgaCA9IDA7IGggPCBlLnBvaW50cy5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBwID0gZS5wb2ludHNbaF1bbF0gLSB0aGlzLm1pbltsXTtcbiAgICAgICAgICBjID0gTWF0aC5taW4oYywgcCksIHUgPSBNYXRoLm1heCh1LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1IDwgMCB8fCBjID4gdGhpcy5tYXhbbF0gLSB0aGlzLm1pbltsXSkgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICB2YXIgd28gPSBmdW5jdGlvbiB3byh0LCBlLCBpLCBvKSB7XG4gICAgICBpZiAodm9pZCAwID09PSB0ICYmICh0ID0gMCksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCB2b2lkIDAgPT09IGkgJiYgKGkgPSAwKSwgdm9pZCAwID09PSBvICYmIChvID0gMCksIGlzTmFOKHQpIHx8IHQgPCAwIHx8IGlzTmFOKGUpIHx8IGUgPCAwIHx8IGlzTmFOKGkpIHx8IGkgPCAwIHx8IGlzTmFOKG8pIHx8IG8gPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBlZGdlLWluc2V0cywgdG9wLCBib3R0b20sIGxlZnQgYW5kIHJpZ2h0IG11c3QgYWxsIGJlIG51bWJlcnNcIik7XG4gICAgICB0aGlzLnRvcCA9IHQsIHRoaXMuYm90dG9tID0gZSwgdGhpcy5sZWZ0ID0gaSwgdGhpcy5yaWdodCA9IG87XG4gICAgfTtcblxuICAgIHdvLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gbnVsbCAhPSBpLnRvcCAmJiBudWxsICE9IGUudG9wICYmICh0aGlzLnRvcCA9IHQubnVtYmVyKGUudG9wLCBpLnRvcCwgbykpLCBudWxsICE9IGkuYm90dG9tICYmIG51bGwgIT0gZS5ib3R0b20gJiYgKHRoaXMuYm90dG9tID0gdC5udW1iZXIoZS5ib3R0b20sIGkuYm90dG9tLCBvKSksIG51bGwgIT0gaS5sZWZ0ICYmIG51bGwgIT0gZS5sZWZ0ICYmICh0aGlzLmxlZnQgPSB0Lm51bWJlcihlLmxlZnQsIGkubGVmdCwgbykpLCBudWxsICE9IGkucmlnaHQgJiYgbnVsbCAhPSBlLnJpZ2h0ICYmICh0aGlzLnJpZ2h0ID0gdC5udW1iZXIoZS5yaWdodCwgaS5yaWdodCwgbykpLCB0aGlzO1xuICAgIH0sIHdvLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSB0LmNsYW1wKCh0aGlzLmxlZnQgKyBlIC0gdGhpcy5yaWdodCkgLyAyLCAwLCBlKSxcbiAgICAgICAgICByID0gdC5jbGFtcCgodGhpcy50b3AgKyBpIC0gdGhpcy5ib3R0b20pIC8gMiwgMCwgaSk7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQobywgcik7XG4gICAgfSwgd28ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b3AgPT09IHQudG9wICYmIHRoaXMuYm90dG9tID09PSB0LmJvdHRvbSAmJiB0aGlzLmxlZnQgPT09IHQubGVmdCAmJiB0aGlzLnJpZ2h0ID09PSB0LnJpZ2h0O1xuICAgIH0sIHdvLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgd28odGhpcy50b3AsIHRoaXMuYm90dG9tLCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpO1xuICAgIH0sIHdvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICBib3R0b206IHRoaXMuYm90dG9tLFxuICAgICAgICBsZWZ0OiB0aGlzLmxlZnQsXG4gICAgICAgIHJpZ2h0OiB0aGlzLnJpZ2h0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgVG8gPSBmdW5jdGlvbiBUbyhlLCBpLCBvLCByLCBhKSB7XG4gICAgICB0aGlzLnRpbGVTaXplID0gNTEyLCB0aGlzLm1heFZhbGlkTGF0aXR1ZGUgPSA4NS4wNTExMjksIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzID0gdm9pZCAwID09PSBhIHx8IGEsIHRoaXMuX21pblpvb20gPSBlIHx8IDAsIHRoaXMuX21heFpvb20gPSBpIHx8IDIyLCB0aGlzLl9taW5QaXRjaCA9IG51bGwgPT0gbyA/IDAgOiBvLCB0aGlzLl9tYXhQaXRjaCA9IG51bGwgPT0gciA/IDYwIDogciwgdGhpcy5zZXRNYXhCb3VuZHMoKSwgdGhpcy53aWR0aCA9IDAsIHRoaXMuaGVpZ2h0ID0gMCwgdGhpcy5fY2VudGVyID0gbmV3IHQuTG5nTGF0KDAsIDApLCB0aGlzLnpvb20gPSAwLCB0aGlzLmFuZ2xlID0gMCwgdGhpcy5fZm92ID0gLjY0MzUwMTEwODc5MzI4NDQsIHRoaXMuX3BpdGNoID0gMCwgdGhpcy5fdW5tb2RpZmllZCA9ICEwLCB0aGlzLl9lZGdlSW5zZXRzID0gbmV3IHdvKCksIHRoaXMuX3Bvc01hdHJpeENhY2hlID0ge30sIHRoaXMuX2FsaWduZWRQb3NNYXRyaXhDYWNoZSA9IHt9O1xuICAgIH0sXG4gICAgICAgIEVvID0ge1xuICAgICAgbWluWm9vbToge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgbWF4Wm9vbToge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgbWluUGl0Y2g6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIG1heFBpdGNoOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICByZW5kZXJXb3JsZENvcGllczoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgd29ybGRTaXplOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBjZW50ZXJPZmZzZXQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIGJlYXJpbmc6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHBpdGNoOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBmb3Y6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHpvb206IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgcGFkZGluZzoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgY2VudGVyUG9pbnQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHVubW9kaWZpZWQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG8ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgVG8odGhpcy5fbWluWm9vbSwgdGhpcy5fbWF4Wm9vbSwgdGhpcy5fbWluUGl0Y2gsIHRoaXMubWF4UGl0Y2gsIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzKTtcbiAgICAgIHJldHVybiB0LnRpbGVTaXplID0gdGhpcy50aWxlU2l6ZSwgdC5sYXRSYW5nZSA9IHRoaXMubGF0UmFuZ2UsIHQud2lkdGggPSB0aGlzLndpZHRoLCB0LmhlaWdodCA9IHRoaXMuaGVpZ2h0LCB0Ll9jZW50ZXIgPSB0aGlzLl9jZW50ZXIsIHQuem9vbSA9IHRoaXMuem9vbSwgdC5hbmdsZSA9IHRoaXMuYW5nbGUsIHQuX2ZvdiA9IHRoaXMuX2ZvdiwgdC5fcGl0Y2ggPSB0aGlzLl9waXRjaCwgdC5fdW5tb2RpZmllZCA9IHRoaXMuX3VubW9kaWZpZWQsIHQuX2VkZ2VJbnNldHMgPSB0aGlzLl9lZGdlSW5zZXRzLmNsb25lKCksIHQuX2NhbGNNYXRyaWNlcygpLCB0O1xuICAgIH0sIEVvLm1pblpvb20uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pblpvb207XG4gICAgfSwgRW8ubWluWm9vbS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWluWm9vbSAhPT0gdCAmJiAodGhpcy5fbWluWm9vbSA9IHQsIHRoaXMuem9vbSA9IE1hdGgubWF4KHRoaXMuem9vbSwgdCkpO1xuICAgIH0sIEVvLm1heFpvb20uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heFpvb207XG4gICAgfSwgRW8ubWF4Wm9vbS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWF4Wm9vbSAhPT0gdCAmJiAodGhpcy5fbWF4Wm9vbSA9IHQsIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgdCkpO1xuICAgIH0sIEVvLm1pblBpdGNoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5QaXRjaDtcbiAgICB9LCBFby5taW5QaXRjaC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWluUGl0Y2ggIT09IHQgJiYgKHRoaXMuX21pblBpdGNoID0gdCwgdGhpcy5waXRjaCA9IE1hdGgubWF4KHRoaXMucGl0Y2gsIHQpKTtcbiAgICB9LCBFby5tYXhQaXRjaC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4UGl0Y2g7XG4gICAgfSwgRW8ubWF4UGl0Y2guc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21heFBpdGNoICE9PSB0ICYmICh0aGlzLl9tYXhQaXRjaCA9IHQsIHRoaXMucGl0Y2ggPSBNYXRoLm1pbih0aGlzLnBpdGNoLCB0KSk7XG4gICAgfSwgRW8ucmVuZGVyV29ybGRDb3BpZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzO1xuICAgIH0sIEVvLnJlbmRlcldvcmxkQ29waWVzLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2b2lkIDAgPT09IHQgPyB0ID0gITAgOiBudWxsID09PSB0ICYmICh0ID0gITEpLCB0aGlzLl9yZW5kZXJXb3JsZENvcGllcyA9IHQ7XG4gICAgfSwgRW8ud29ybGRTaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LCBFby5jZW50ZXJPZmZzZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2VudGVyUG9pbnQuX3N1Yih0aGlzLnNpemUuX2RpdigyKSk7XG4gICAgfSwgRW8uc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sIEVvLmJlYXJpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LCBFby5iZWFyaW5nLnNldCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IC10LndyYXAoZSwgLTE4MCwgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICB0aGlzLmFuZ2xlICE9PSBpICYmICh0aGlzLl91bm1vZGlmaWVkID0gITEsIHRoaXMuYW5nbGUgPSBpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSwgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IHQuY3JlYXRlJDIoKSwgdC5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5hbmdsZSkpO1xuICAgIH0sIEVvLnBpdGNoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waXRjaCAvIE1hdGguUEkgKiAxODA7XG4gICAgfSwgRW8ucGl0Y2guc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gdC5jbGFtcChlLCB0aGlzLm1pblBpdGNoLCB0aGlzLm1heFBpdGNoKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgICB0aGlzLl9waXRjaCAhPT0gaSAmJiAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9waXRjaCA9IGksIHRoaXMuX2NhbGNNYXRyaWNlcygpKTtcbiAgICB9LCBFby5mb3YuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvdiAvIE1hdGguUEkgKiAxODA7XG4gICAgfSwgRW8uZm92LnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ID0gTWF0aC5tYXgoLjAxLCBNYXRoLm1pbig2MCwgdCkpLCB0aGlzLl9mb3YgIT09IHQgJiYgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZm92ID0gdCAvIDE4MCAqIE1hdGguUEksIHRoaXMuX2NhbGNNYXRyaWNlcygpKTtcbiAgICB9LCBFby56b29tLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl96b29tO1xuICAgIH0sIEVvLnpvb20uc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gTWF0aC5taW4oTWF0aC5tYXgodCwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcbiAgICAgIHRoaXMuX3pvb20gIT09IGUgJiYgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fem9vbSA9IGUsIHRoaXMuc2NhbGUgPSB0aGlzLnpvb21TY2FsZShlKSwgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3IoZSksIHRoaXMuem9vbUZyYWN0aW9uID0gZSAtIHRoaXMudGlsZVpvb20sIHRoaXMuX2NvbnN0cmFpbigpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSk7XG4gICAgfSwgRW8uY2VudGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XG4gICAgfSwgRW8uY2VudGVyLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LmxhdCA9PT0gdGhpcy5fY2VudGVyLmxhdCAmJiB0LmxuZyA9PT0gdGhpcy5fY2VudGVyLmxuZyB8fCAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9jZW50ZXIgPSB0LCB0aGlzLl9jb25zdHJhaW4oKSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLnBhZGRpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VJbnNldHMudG9KU09OKCk7XG4gICAgfSwgRW8ucGFkZGluZy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZWRnZUluc2V0cy5lcXVhbHModCkgfHwgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZWRnZUluc2V0cy5pbnRlcnBvbGF0ZSh0aGlzLl9lZGdlSW5zZXRzLCB0LCAxKSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLmNlbnRlclBvaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGdlSW5zZXRzLmdldENlbnRlcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmlzUGFkZGluZ0VxdWFsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGdlSW5zZXRzLmVxdWFscyh0KTtcbiAgICB9LCBUby5wcm90b3R5cGUuaW50ZXJwb2xhdGVQYWRkaW5nID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZWRnZUluc2V0cy5pbnRlcnBvbGF0ZSh0LCBlLCBpKSwgdGhpcy5fY29uc3RyYWluKCksIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5jb3ZlcmluZ1pvb21MZXZlbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICh0LnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKSh0aGlzLnpvb20gKyB0aGlzLnNjYWxlWm9vbSh0aGlzLnRpbGVTaXplIC8gdC50aWxlU2l6ZSkpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGUpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRWaXNpYmxlVW53cmFwcGVkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSBbbmV3IHQuVW53cmFwcGVkVGlsZUlEKDAsIGUpXTtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJXb3JsZENvcGllcykgZm9yICh2YXIgbyA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KDAsIDApKSwgciA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIDApKSwgYSA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSksIG4gPSB0aGlzLnBvaW50Q29vcmRpbmF0ZShuZXcgdC5Qb2ludCgwLCB0aGlzLmhlaWdodCkpLCBzID0gTWF0aC5mbG9vcihNYXRoLm1pbihvLngsIHIueCwgYS54LCBuLngpKSwgbCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoby54LCByLngsIGEueCwgbi54KSksIGMgPSBzIC0gMTsgYyA8PSBsICsgMTsgYysrKSB7XG4gICAgICAgIDAgIT09IGMgJiYgaS5wdXNoKG5ldyB0LlVud3JhcHBlZFRpbGVJRChjLCBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9LCBUby5wcm90b3R5cGUuY292ZXJpbmdUaWxlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuY292ZXJpbmdab29tTGV2ZWwoZSksXG4gICAgICAgICAgbyA9IGk7XG4gICAgICBpZiAodm9pZCAwICE9PSBlLm1pbnpvb20gJiYgaSA8IGUubWluem9vbSkgcmV0dXJuIFtdO1xuICAgICAgdm9pZCAwICE9PSBlLm1heHpvb20gJiYgaSA+IGUubWF4em9vbSAmJiAoaSA9IGUubWF4em9vbSk7XG4gICAgICB2YXIgciA9IHQuTWVyY2F0b3JDb29yZGluYXRlLmZyb21MbmdMYXQodGhpcy5jZW50ZXIpLFxuICAgICAgICAgIGEgPSBNYXRoLnBvdygyLCBpKSxcbiAgICAgICAgICBuID0gW2EgKiByLngsIGEgKiByLnksIDBdLFxuICAgICAgICAgIHMgPSB4by5mcm9tSW52UHJvamVjdGlvbk1hdHJpeCh0aGlzLmludlByb2pNYXRyaXgsIHRoaXMud29ybGRTaXplLCBpKSxcbiAgICAgICAgICBsID0gZS5taW56b29tIHx8IDA7XG4gICAgICB0aGlzLnBpdGNoIDw9IDYwICYmIHRoaXMuX2VkZ2VJbnNldHMudG9wIDwgLjEgJiYgKGwgPSBpKTtcblxuICAgICAgdmFyIGMgPSBmdW5jdGlvbiBjKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhYWJiOiBuZXcgYm8oW3QgKiBhLCAwLCAwXSwgWyh0ICsgMSkgKiBhLCBhLCAwXSksXG4gICAgICAgICAgem9vbTogMCxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd3JhcDogdCxcbiAgICAgICAgICBmdWxseVZpc2libGU6ICExXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgICAgIHUgPSBbXSxcbiAgICAgICAgICBoID0gW10sXG4gICAgICAgICAgcCA9IGksXG4gICAgICAgICAgZCA9IGUucmVwYXJzZU92ZXJzY2FsZWQgPyBvIDogaTtcblxuICAgICAgaWYgKHRoaXMuX3JlbmRlcldvcmxkQ29waWVzKSBmb3IgKHZhciBfID0gMTsgXyA8PSAzOyBfKyspIHtcbiAgICAgICAgdS5wdXNoKGMoLV8pKSwgdS5wdXNoKGMoXykpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHUucHVzaChjKDApKTsgdS5sZW5ndGggPiAwOykge1xuICAgICAgICB2YXIgZiA9IHUucG9wKCksXG4gICAgICAgICAgICBtID0gZi54LFxuICAgICAgICAgICAgZyA9IGYueSxcbiAgICAgICAgICAgIHYgPSBmLmZ1bGx5VmlzaWJsZTtcblxuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICB2YXIgeSA9IGYuYWFiYi5pbnRlcnNlY3RzKHMpO1xuICAgICAgICAgIGlmICgwID09PSB5KSBjb250aW51ZTtcbiAgICAgICAgICB2ID0gMiA9PT0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gZi5hYWJiLmRpc3RhbmNlWChuKSxcbiAgICAgICAgICAgIGIgPSBmLmFhYmIuZGlzdGFuY2VZKG4pLFxuICAgICAgICAgICAgdyA9IE1hdGgubWF4KE1hdGguYWJzKHgpLCBNYXRoLmFicyhiKSk7XG4gICAgICAgIGlmIChmLnpvb20gPT09IHAgfHwgdyA+IDMgKyAoMSA8PCBwIC0gZi56b29tKSAtIDIgJiYgZi56b29tID49IGwpIGgucHVzaCh7XG4gICAgICAgICAgdGlsZUlEOiBuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGYuem9vbSA9PT0gcCA/IGQgOiBmLnpvb20sIGYud3JhcCwgZi56b29tLCBtLCBnKSxcbiAgICAgICAgICBkaXN0YW5jZVNxOiB0LnNxckxlbihbblswXSAtIC41IC0gbSwgblsxXSAtIC41IC0gZ10pXG4gICAgICAgIH0pO2Vsc2UgZm9yICh2YXIgVCA9IDA7IFQgPCA0OyBUKyspIHtcbiAgICAgICAgICB2YXIgRSA9IChtIDw8IDEpICsgVCAlIDIsXG4gICAgICAgICAgICAgIEkgPSAoZyA8PCAxKSArIChUID4+IDEpO1xuICAgICAgICAgIHUucHVzaCh7XG4gICAgICAgICAgICBhYWJiOiBmLmFhYmIucXVhZHJhbnQoVCksXG4gICAgICAgICAgICB6b29tOiBmLnpvb20gKyAxLFxuICAgICAgICAgICAgeDogRSxcbiAgICAgICAgICAgIHk6IEksXG4gICAgICAgICAgICB3cmFwOiBmLndyYXAsXG4gICAgICAgICAgICBmdWxseVZpc2libGU6IHZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaC5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LmRpc3RhbmNlU3EgLSBlLmRpc3RhbmNlU3E7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudGlsZUlEO1xuICAgICAgfSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLndpZHRoID0gdCwgdGhpcy5oZWlnaHQgPSBlLCB0aGlzLnBpeGVsc1RvR0xVbml0cyA9IFsyIC8gdCwgLTIgLyBlXSwgdGhpcy5fY29uc3RyYWluKCksIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuICAgIH0sIEVvLnVubW9kaWZpZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VubW9kaWZpZWQ7XG4gICAgfSwgVG8ucHJvdG90eXBlLnpvb21TY2FsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgdCk7XG4gICAgfSwgVG8ucHJvdG90eXBlLnNjYWxlWm9vbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2codCkgLyBNYXRoLkxOMjtcbiAgICB9LCBUby5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IHQuY2xhbXAoZS5sYXQsIC10aGlzLm1heFZhbGlkTGF0aXR1ZGUsIHRoaXMubWF4VmFsaWRMYXRpdHVkZSk7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQodC5tZXJjYXRvclhmcm9tTG5nKGUubG5nKSAqIHRoaXMud29ybGRTaXplLCB0Lm1lcmNhdG9yWWZyb21MYXQoaSkgKiB0aGlzLndvcmxkU2l6ZSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLnVucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKGUueCAvIHRoaXMud29ybGRTaXplLCBlLnkgLyB0aGlzLndvcmxkU2l6ZSkudG9MbmdMYXQoKTtcbiAgICB9LCBFby5wb2ludC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0KHRoaXMuY2VudGVyKTtcbiAgICB9LCBUby5wcm90b3R5cGUuc2V0TG9jYXRpb25BdFBvaW50ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5wb2ludENvb3JkaW5hdGUoaSksXG4gICAgICAgICAgciA9IHRoaXMucG9pbnRDb29yZGluYXRlKHRoaXMuY2VudGVyUG9pbnQpLFxuICAgICAgICAgIGEgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShlKSxcbiAgICAgICAgICBuID0gbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKGEueCAtIChvLnggLSByLngpLCBhLnkgLSAoby55IC0gci55KSk7XG4gICAgICB0aGlzLmNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKG4pLCB0aGlzLl9yZW5kZXJXb3JsZENvcGllcyAmJiAodGhpcy5jZW50ZXIgPSB0aGlzLmNlbnRlci53cmFwKCkpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5sb2NhdGlvblBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZSh0KSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLnBvaW50TG9jYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHQpKTtcbiAgICB9LCBUby5wcm90b3R5cGUubG9jYXRpb25Db29yZGluYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB0Lk1lcmNhdG9yQ29vcmRpbmF0ZS5mcm9tTG5nTGF0KGUpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5jb29yZGluYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudG9MbmdMYXQoKTtcbiAgICB9LCBUby5wcm90b3R5cGUucG9pbnRDb29yZGluYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gW2UueCwgZS55LCAwLCAxXSxcbiAgICAgICAgICBvID0gW2UueCwgZS55LCAxLCAxXTtcbiAgICAgIHQudHJhbnNmb3JtTWF0NChpLCBpLCB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSksIHQudHJhbnNmb3JtTWF0NChvLCBvLCB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSk7XG4gICAgICB2YXIgciA9IGlbM10sXG4gICAgICAgICAgYSA9IG9bM10sXG4gICAgICAgICAgbiA9IGlbMV0gLyByLFxuICAgICAgICAgIHMgPSBvWzFdIC8gYSxcbiAgICAgICAgICBsID0gaVsyXSAvIHIsXG4gICAgICAgICAgYyA9IG9bMl0gLyBhLFxuICAgICAgICAgIHUgPSBsID09PSBjID8gMCA6ICgwIC0gbCkgLyAoYyAtIGwpO1xuICAgICAgcmV0dXJuIG5ldyB0Lk1lcmNhdG9yQ29vcmRpbmF0ZSh0Lm51bWJlcihpWzBdIC8gciwgb1swXSAvIGEsIHUpIC8gdGhpcy53b3JsZFNpemUsIHQubnVtYmVyKG4sIHMsIHUpIC8gdGhpcy53b3JsZFNpemUpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5jb29yZGluYXRlUG9pbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSBbZS54ICogdGhpcy53b3JsZFNpemUsIGUueSAqIHRoaXMud29ybGRTaXplLCAwLCAxXTtcbiAgICAgIHJldHVybiB0LnRyYW5zZm9ybU1hdDQoaSwgaSwgdGhpcy5waXhlbE1hdHJpeCksIG5ldyB0LlBvaW50KGlbMF0gLyBpWzNdLCBpWzFdIC8gaVszXSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgdC5MbmdMYXRCb3VuZHMoKS5leHRlbmQodGhpcy5wb2ludExvY2F0aW9uKG5ldyB0LlBvaW50KDAsIDApKSkuZXh0ZW5kKHRoaXMucG9pbnRMb2NhdGlvbihuZXcgdC5Qb2ludCh0aGlzLndpZHRoLCAwKSkpLmV4dGVuZCh0aGlzLnBvaW50TG9jYXRpb24obmV3IHQuUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpKSkuZXh0ZW5kKHRoaXMucG9pbnRMb2NhdGlvbihuZXcgdC5Qb2ludCgwLCB0aGlzLmhlaWdodCkpKTtcbiAgICB9LCBUby5wcm90b3R5cGUuZ2V0TWF4Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0UmFuZ2UgJiYgMiA9PT0gdGhpcy5sYXRSYW5nZS5sZW5ndGggJiYgdGhpcy5sbmdSYW5nZSAmJiAyID09PSB0aGlzLmxuZ1JhbmdlLmxlbmd0aCA/IG5ldyB0LkxuZ0xhdEJvdW5kcyhbdGhpcy5sbmdSYW5nZVswXSwgdGhpcy5sYXRSYW5nZVswXV0sIFt0aGlzLmxuZ1JhbmdlWzFdLCB0aGlzLmxhdFJhbmdlWzFdXSkgOiBudWxsO1xuICAgIH0sIFRvLnByb3RvdHlwZS5zZXRNYXhCb3VuZHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCA/ICh0aGlzLmxuZ1JhbmdlID0gW3QuZ2V0V2VzdCgpLCB0LmdldEVhc3QoKV0sIHRoaXMubGF0UmFuZ2UgPSBbdC5nZXRTb3V0aCgpLCB0LmdldE5vcnRoKCldLCB0aGlzLl9jb25zdHJhaW4oKSkgOiAodGhpcy5sbmdSYW5nZSA9IG51bGwsIHRoaXMubGF0UmFuZ2UgPSBbLXRoaXMubWF4VmFsaWRMYXRpdHVkZSwgdGhpcy5tYXhWYWxpZExhdGl0dWRlXSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNhbGN1bGF0ZVBvc01hdHJpeCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSAhMSk7XG4gICAgICB2YXIgbyA9IGUua2V5LFxuICAgICAgICAgIHIgPSBpID8gdGhpcy5fYWxpZ25lZFBvc01hdHJpeENhY2hlIDogdGhpcy5fcG9zTWF0cml4Q2FjaGU7XG4gICAgICBpZiAocltvXSkgcmV0dXJuIHJbb107XG4gICAgICB2YXIgYSA9IGUuY2Fub25pY2FsLFxuICAgICAgICAgIG4gPSB0aGlzLndvcmxkU2l6ZSAvIHRoaXMuem9vbVNjYWxlKGEueiksXG4gICAgICAgICAgcyA9IGEueCArIE1hdGgucG93KDIsIGEueikgKiBlLndyYXAsXG4gICAgICAgICAgbCA9IHQuaWRlbnRpdHkobmV3IEZsb2F0NjRBcnJheSgxNikpO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKGwsIGwsIFtzICogbiwgYS55ICogbiwgMF0pLCB0LnNjYWxlKGwsIGwsIFtuIC8gdC5FWFRFTlQsIG4gLyB0LkVYVEVOVCwgMV0pLCB0Lm11bHRpcGx5KGwsIGkgPyB0aGlzLmFsaWduZWRQcm9qTWF0cml4IDogdGhpcy5wcm9qTWF0cml4LCBsKSwgcltvXSA9IG5ldyBGbG9hdDMyQXJyYXkobCksIHJbb107XG4gICAgfSwgVG8ucHJvdG90eXBlLmN1c3RvbUxheWVyTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVyY2F0b3JNYXRyaXguc2xpY2UoKTtcbiAgICB9LCBUby5wcm90b3R5cGUuX2NvbnN0cmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNlbnRlciAmJiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0ICYmICF0aGlzLl9jb25zdHJhaW5pbmcpIHtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gITA7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgYSA9IC05MCxcbiAgICAgICAgICAgIG4gPSA5MCxcbiAgICAgICAgICAgIHMgPSAtMTgwLFxuICAgICAgICAgICAgbCA9IDE4MCxcbiAgICAgICAgICAgIGMgPSB0aGlzLnNpemUsXG4gICAgICAgICAgICB1ID0gdGhpcy5fdW5tb2RpZmllZDtcblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgIHZhciBoID0gdGhpcy5sYXRSYW5nZTtcbiAgICAgICAgICBhID0gdC5tZXJjYXRvcllmcm9tTGF0KGhbMV0pICogdGhpcy53b3JsZFNpemUsIGUgPSAobiA9IHQubWVyY2F0b3JZZnJvbUxhdChoWzBdKSAqIHRoaXMud29ybGRTaXplKSAtIGEgPCBjLnkgPyBjLnkgLyAobiAtIGEpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzLmxuZ1JhbmdlO1xuICAgICAgICAgIHMgPSB0Lm1lcmNhdG9yWGZyb21MbmcocFswXSkgKiB0aGlzLndvcmxkU2l6ZSwgaSA9IChsID0gdC5tZXJjYXRvclhmcm9tTG5nKHBbMV0pICogdGhpcy53b3JsZFNpemUpIC0gcyA8IGMueCA/IGMueCAvIChsIC0gcykgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGQgPSB0aGlzLnBvaW50LFxuICAgICAgICAgICAgXyA9IE1hdGgubWF4KGkgfHwgMCwgZSB8fCAwKTtcblxuICAgICAgICBpZiAoXykgcmV0dXJuIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IHQuUG9pbnQoaSA/IChsICsgcykgLyAyIDogZC54LCBlID8gKG4gKyBhKSAvIDIgOiBkLnkpKSwgdGhpcy56b29tICs9IHRoaXMuc2NhbGVab29tKF8pLCB0aGlzLl91bm1vZGlmaWVkID0gdSwgdm9pZCAodGhpcy5fY29uc3RyYWluaW5nID0gITEpO1xuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgdmFyIGYgPSBkLnksXG4gICAgICAgICAgICAgIG0gPSBjLnkgLyAyO1xuICAgICAgICAgIGYgLSBtIDwgYSAmJiAociA9IGEgKyBtKSwgZiArIG0gPiBuICYmIChyID0gbiAtIG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgZyA9IGQueCxcbiAgICAgICAgICAgICAgdiA9IGMueCAvIDI7XG4gICAgICAgICAgZyAtIHYgPCBzICYmIChvID0gcyArIHYpLCBnICsgdiA+IGwgJiYgKG8gPSBsIC0gdik7XG4gICAgICAgIH1cblxuICAgICAgICB2b2lkIDAgPT09IG8gJiYgdm9pZCAwID09PSByIHx8ICh0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyB0LlBvaW50KHZvaWQgMCAhPT0gbyA/IG8gOiBkLngsIHZvaWQgMCAhPT0gciA/IHIgOiBkLnkpKSksIHRoaXMuX3VubW9kaWZpZWQgPSB1LCB0aGlzLl9jb25zdHJhaW5pbmcgPSAhMTtcbiAgICAgIH1cbiAgICB9LCBUby5wcm90b3R5cGUuX2NhbGNNYXRyaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmhlaWdodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2VudGVyT2Zmc2V0O1xuICAgICAgICB0aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgPSAuNSAvIE1hdGgudGFuKHRoaXMuX2ZvdiAvIDIpICogdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBpID0gTWF0aC5QSSAvIDIgKyB0aGlzLl9waXRjaCxcbiAgICAgICAgICAgIG8gPSB0aGlzLl9mb3YgKiAoLjUgKyBlLnkgLyB0aGlzLmhlaWdodCksXG4gICAgICAgICAgICByID0gTWF0aC5zaW4obykgKiB0aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgLyBNYXRoLnNpbih0LmNsYW1wKE1hdGguUEkgLSBpIC0gbywgLjAxLCBNYXRoLlBJIC0gLjAxKSksXG4gICAgICAgICAgICBhID0gdGhpcy5wb2ludCxcbiAgICAgICAgICAgIG4gPSBhLngsXG4gICAgICAgICAgICBzID0gYS55LFxuICAgICAgICAgICAgbCA9IDEuMDEgKiAoTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSB0aGlzLl9waXRjaCkgKiByICsgdGhpcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlKSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmhlaWdodCAvIDUwLFxuICAgICAgICAgICAgdSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0LnBlcnNwZWN0aXZlKHUsIHRoaXMuX2ZvdiwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCBjLCBsKSwgdVs4XSA9IDIgKiAtZS54IC8gdGhpcy53aWR0aCwgdVs5XSA9IDIgKiBlLnkgLyB0aGlzLmhlaWdodCwgdC5zY2FsZSh1LCB1LCBbMSwgLTEsIDFdKSwgdC50cmFuc2xhdGUodSwgdSwgWzAsIDAsIC10aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2VdKSwgdC5yb3RhdGVYKHUsIHUsIHRoaXMuX3BpdGNoKSwgdC5yb3RhdGVaKHUsIHUsIHRoaXMuYW5nbGUpLCB0LnRyYW5zbGF0ZSh1LCB1LCBbLW4sIC1zLCAwXSksIHRoaXMubWVyY2F0b3JNYXRyaXggPSB0LnNjYWxlKFtdLCB1LCBbdGhpcy53b3JsZFNpemUsIHRoaXMud29ybGRTaXplLCB0aGlzLndvcmxkU2l6ZV0pLCB0LnNjYWxlKHUsIHUsIFsxLCAxLCB0Lm1lcmNhdG9yWmZyb21BbHRpdHVkZSgxLCB0aGlzLmNlbnRlci5sYXQpICogdGhpcy53b3JsZFNpemUsIDFdKSwgdGhpcy5wcm9qTWF0cml4ID0gdSwgdGhpcy5pbnZQcm9qTWF0cml4ID0gdC5pbnZlcnQoW10sIHRoaXMucHJvak1hdHJpeCk7XG5cbiAgICAgICAgdmFyIGggPSB0aGlzLndpZHRoICUgMiAvIDIsXG4gICAgICAgICAgICBwID0gdGhpcy5oZWlnaHQgJSAyIC8gMixcbiAgICAgICAgICAgIGQgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICAgIF8gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSxcbiAgICAgICAgICAgIGYgPSBuIC0gTWF0aC5yb3VuZChuKSArIGQgKiBoICsgXyAqIHAsXG4gICAgICAgICAgICBtID0gcyAtIE1hdGgucm91bmQocykgKyBkICogcCArIF8gKiBoLFxuICAgICAgICAgICAgZyA9IG5ldyBGbG9hdDY0QXJyYXkodSk7XG5cbiAgICAgICAgaWYgKHQudHJhbnNsYXRlKGcsIGcsIFtmID4gLjUgPyBmIC0gMSA6IGYsIG0gPiAuNSA/IG0gLSAxIDogbSwgMF0pLCB0aGlzLmFsaWduZWRQcm9qTWF0cml4ID0gZywgdSA9IHQuY3JlYXRlKCksIHQuc2NhbGUodSwgdSwgW3RoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyLCAxXSksIHQudHJhbnNsYXRlKHUsIHUsIFsxLCAtMSwgMF0pLCB0aGlzLmxhYmVsUGxhbmVNYXRyaXggPSB1LCB1ID0gdC5jcmVhdGUoKSwgdC5zY2FsZSh1LCB1LCBbMSwgLTEsIDFdKSwgdC50cmFuc2xhdGUodSwgdSwgWy0xLCAtMSwgMF0pLCB0LnNjYWxlKHUsIHUsIFsyIC8gdGhpcy53aWR0aCwgMiAvIHRoaXMuaGVpZ2h0LCAxXSksIHRoaXMuZ2xDb29yZE1hdHJpeCA9IHUsIHRoaXMucGl4ZWxNYXRyaXggPSB0Lm11bHRpcGx5KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCB0aGlzLmxhYmVsUGxhbmVNYXRyaXgsIHRoaXMucHJvak1hdHJpeCksICEodSA9IHQuaW52ZXJ0KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCB0aGlzLnBpeGVsTWF0cml4KSkpIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBpbnZlcnQgbWF0cml4XCIpO1xuICAgICAgICB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSA9IHUsIHRoaXMuX3Bvc01hdHJpeENhY2hlID0ge30sIHRoaXMuX2FsaWduZWRQb3NNYXRyaXhDYWNoZSA9IHt9O1xuICAgICAgfVxuICAgIH0sIFRvLnByb3RvdHlwZS5tYXhQaXRjaFNjYWxlRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSkgcmV0dXJuIDE7XG4gICAgICB2YXIgZSA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KDAsIDApKSxcbiAgICAgICAgICBpID0gW2UueCAqIHRoaXMud29ybGRTaXplLCBlLnkgKiB0aGlzLndvcmxkU2l6ZSwgMCwgMV07XG4gICAgICByZXR1cm4gdC50cmFuc2Zvcm1NYXQ0KGksIGksIHRoaXMucGl4ZWxNYXRyaXgpWzNdIC8gdGhpcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRDYW1lcmFQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gTWF0aC50YW4odGhpcy5fcGl0Y2gpICogKHRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSB8fCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmNlbnRlclBvaW50LmFkZChuZXcgdC5Qb2ludCgwLCBlKSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmdldENhbWVyYVF1ZXJ5R2VvbWV0cnkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmdldENhbWVyYVBvaW50KCk7XG4gICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiBbZVswXSwgaV07XG5cbiAgICAgIGZvciAodmFyIG8gPSBpLngsIHIgPSBpLnksIGEgPSBpLngsIG4gPSBpLnksIHMgPSAwLCBsID0gZTsgcyA8IGwubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBsW3NdO1xuICAgICAgICBvID0gTWF0aC5taW4obywgYy54KSwgciA9IE1hdGgubWluKHIsIGMueSksIGEgPSBNYXRoLm1heChhLCBjLngpLCBuID0gTWF0aC5tYXgobiwgYy55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtuZXcgdC5Qb2ludChvLCByKSwgbmV3IHQuUG9pbnQoYSwgciksIG5ldyB0LlBvaW50KGEsIG4pLCBuZXcgdC5Qb2ludChvLCBuKSwgbmV3IHQuUG9pbnQobywgcildO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRvLnByb3RvdHlwZSwgRW8pO1xuXG4gICAgdmFyIElvID0gZnVuY3Rpb24gSW8oZSkge1xuICAgICAgdmFyIGksIG8sIHIsIF9hMztcblxuICAgICAgdGhpcy5faGFzaE5hbWUgPSBlICYmIGVuY29kZVVSSUNvbXBvbmVudChlKSwgdC5iaW5kQWxsKFtcIl9nZXRDdXJyZW50SGFzaFwiLCBcIl9vbkhhc2hDaGFuZ2VcIiwgXCJfdXBkYXRlSGFzaFwiXSwgdGhpcyksIHRoaXMuX3VwZGF0ZUhhc2ggPSAoaSA9IHRoaXMuX3VwZGF0ZUhhc2hVbnRocm90dGxlZC5iaW5kKHRoaXMpLCBvID0gITEsIHIgPSBudWxsLCBfYTMgPSBmdW5jdGlvbiBhKCkge1xuICAgICAgICByID0gbnVsbCwgbyAmJiAoaSgpLCByID0gc2V0VGltZW91dChfYTMsIDMwMCksIG8gPSAhMSk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvID0gITAsIHIgfHwgX2EzKCksIHI7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgSW8ucHJvdG90eXBlLmFkZFRvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPSBlLCB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCB0aGlzLl9vbkhhc2hDaGFuZ2UsICExKSwgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGVIYXNoKSwgdGhpcztcbiAgICB9LCBJby5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHRoaXMuX29uSGFzaENoYW5nZSwgITEpLCB0aGlzLl9tYXAub2ZmKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGVIYXNoKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZUhhc2goKSksIGRlbGV0ZSB0aGlzLl9tYXAsIHRoaXM7XG4gICAgfSwgSW8ucHJvdG90eXBlLmdldEhhc2hTdHJpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgbyA9IE1hdGgucm91bmQoMTAwICogdGhpcy5fbWFwLmdldFpvb20oKSkgLyAxMDAsXG4gICAgICAgICAgciA9IE1hdGguY2VpbCgobyAqIE1hdGguTE4yICsgTWF0aC5sb2coNTEyIC8gMzYwIC8gLjUpKSAvIE1hdGguTE4xMCksXG4gICAgICAgICAgYSA9IE1hdGgucG93KDEwLCByKSxcbiAgICAgICAgICBuID0gTWF0aC5yb3VuZChpLmxuZyAqIGEpIC8gYSxcbiAgICAgICAgICBzID0gTWF0aC5yb3VuZChpLmxhdCAqIGEpIC8gYSxcbiAgICAgICAgICBsID0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICBjID0gdGhpcy5fbWFwLmdldFBpdGNoKCksXG4gICAgICAgICAgdSA9IFwiXCI7XG5cbiAgICAgIGlmICh1ICs9IGUgPyBcIi9cIiArIG4gKyBcIi9cIiArIHMgKyBcIi9cIiArIG8gOiBvICsgXCIvXCIgKyBzICsgXCIvXCIgKyBuLCAobCB8fCBjKSAmJiAodSArPSBcIi9cIiArIE1hdGgucm91bmQoMTAgKiBsKSAvIDEwKSwgYyAmJiAodSArPSBcIi9cIiArIE1hdGgucm91bmQoYykpLCB0aGlzLl9oYXNoTmFtZSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuX2hhc2hOYW1lLFxuICAgICAgICAgICAgcCA9ICExLFxuICAgICAgICAgICAgZCA9IHQud2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkuc3BsaXQoXCImXCIpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdC5zcGxpdChcIj1cIilbMF07XG4gICAgICAgICAgcmV0dXJuIGUgPT09IGggPyAocCA9ICEwLCBlICsgXCI9XCIgKyB1KSA6IHQ7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHAgfHwgZC5wdXNoKGggKyBcIj1cIiArIHUpLCBcIiNcIiArIGQuam9pbihcIiZcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIiNcIiArIHU7XG4gICAgfSwgSW8ucHJvdG90eXBlLl9nZXRDdXJyZW50SGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICAgIGkgPSB0aGlzLFxuICAgICAgICAgIG8gPSB0LndpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc2hOYW1lID8gKG8uc3BsaXQoXCImXCIpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zcGxpdChcIj1cIik7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRbMF0gPT09IGkuX2hhc2hOYW1lICYmIChlID0gdCk7XG4gICAgICB9KSwgKGUgJiYgZVsxXSB8fCBcIlwiKS5zcGxpdChcIi9cIikpIDogby5zcGxpdChcIi9cIik7XG4gICAgfSwgSW8ucHJvdG90eXBlLl9vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2dldEN1cnJlbnRIYXNoKCk7XG5cbiAgICAgIGlmICh0Lmxlbmd0aCA+PSAzICYmICF0LnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHQpO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9tYXAuZHJhZ1JvdGF0ZS5pc0VuYWJsZWQoKSAmJiB0aGlzLl9tYXAudG91Y2hab29tUm90YXRlLmlzRW5hYmxlZCgpID8gKyh0WzNdIHx8IDApIDogdGhpcy5fbWFwLmdldEJlYXJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5qdW1wVG8oe1xuICAgICAgICAgIGNlbnRlcjogWyt0WzJdLCArdFsxXV0sXG4gICAgICAgICAgem9vbTogK3RbMF0sXG4gICAgICAgICAgYmVhcmluZzogZSxcbiAgICAgICAgICBwaXRjaDogKyh0WzRdIHx8IDApXG4gICAgICAgIH0pLCAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIElvLnByb3RvdHlwZS5fdXBkYXRlSGFzaFVudGhyb3R0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0LndpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLygjLispPyQvLCB0aGlzLmdldEhhc2hTdHJpbmcoKSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHQud2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHQud2luZG93Lmhpc3Rvcnkuc3RhdGUsIG51bGwsIGUpO1xuICAgICAgfSBjYXRjaCAodCkge31cbiAgICB9O1xuXG4gICAgdmFyIFBvID0ge1xuICAgICAgbGluZWFyaXR5OiAuMyxcbiAgICAgIGVhc2luZzogdC5iZXppZXIoMCwgMCwgLjMsIDEpXG4gICAgfSxcbiAgICAgICAgU28gPSB0LmV4dGVuZCh7XG4gICAgICBkZWNlbGVyYXRpb246IDI1MDAsXG4gICAgICBtYXhTcGVlZDogMTQwMFxuICAgIH0sIFBvKSxcbiAgICAgICAgQ28gPSB0LmV4dGVuZCh7XG4gICAgICBkZWNlbGVyYXRpb246IDIwLFxuICAgICAgbWF4U3BlZWQ6IDE0MDBcbiAgICB9LCBQbyksXG4gICAgICAgIHpvID0gdC5leHRlbmQoe1xuICAgICAgZGVjZWxlcmF0aW9uOiAxZTMsXG4gICAgICBtYXhTcGVlZDogMzYwXG4gICAgfSwgUG8pLFxuICAgICAgICBEbyA9IHQuZXh0ZW5kKHtcbiAgICAgIGRlY2VsZXJhdGlvbjogMWUzLFxuICAgICAgbWF4U3BlZWQ6IDkwXG4gICAgfSwgUG8pLFxuICAgICAgICBBbyA9IGZ1bmN0aW9uIEFvKHQpIHtcbiAgICAgIHRoaXMuX21hcCA9IHQsIHRoaXMuY2xlYXIoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTW8odCwgZSkge1xuICAgICAgKCF0LmR1cmF0aW9uIHx8IHQuZHVyYXRpb24gPCBlLmR1cmF0aW9uKSAmJiAodC5kdXJhdGlvbiA9IGUuZHVyYXRpb24sIHQuZWFzaW5nID0gZS5lYXNpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gby5tYXhTcGVlZCxcbiAgICAgICAgICBhID0gby5saW5lYXJpdHksXG4gICAgICAgICAgbiA9IG8uZGVjZWxlcmF0aW9uLFxuICAgICAgICAgIHMgPSB0LmNsYW1wKGUgKiBhIC8gKGkgLyAxZTMpLCAtciwgciksXG4gICAgICAgICAgbCA9IE1hdGguYWJzKHMpIC8gKG4gKiBhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVhc2luZzogby5lYXNpbmcsXG4gICAgICAgIGR1cmF0aW9uOiAxZTMgKiBsLFxuICAgICAgICBhbW91bnQ6IHMgKiAobCAvIDIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIEFvLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2luZXJ0aWFCdWZmZXIgPSBbXTtcbiAgICB9LCBBby5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpLCB0aGlzLl9pbmVydGlhQnVmZmVyLnB1c2goe1xuICAgICAgICB0aW1lOiB0LmJyb3dzZXIubm93KCksXG4gICAgICAgIHNldHRpbmdzOiBlXG4gICAgICB9KTtcbiAgICB9LCBBby5wcm90b3R5cGUuX2RyYWluSW5lcnRpYUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLl9pbmVydGlhQnVmZmVyLCBpID0gdC5icm93c2VyLm5vdygpOyBlLmxlbmd0aCA+IDAgJiYgaSAtIGVbMF0udGltZSA+IDE2MDspIHtcbiAgICAgICAgZS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH0sIEFvLnByb3RvdHlwZS5fb25Nb3ZlRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKSwgISh0aGlzLl9pbmVydGlhQnVmZmVyLmxlbmd0aCA8IDIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB7XG4gICAgICAgICAgem9vbTogMCxcbiAgICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICAgIHBpdGNoOiAwLFxuICAgICAgICAgIHBhbjogbmV3IHQuUG9pbnQoMCwgMCksXG4gICAgICAgICAgcGluY2hBcm91bmQ6IHZvaWQgMCxcbiAgICAgICAgICBhcm91bmQ6IHZvaWQgMFxuICAgICAgICB9LCBvID0gMCwgciA9IHRoaXMuX2luZXJ0aWFCdWZmZXI7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dLnNldHRpbmdzO1xuICAgICAgICAgIGkuem9vbSArPSBhLnpvb21EZWx0YSB8fCAwLCBpLmJlYXJpbmcgKz0gYS5iZWFyaW5nRGVsdGEgfHwgMCwgaS5waXRjaCArPSBhLnBpdGNoRGVsdGEgfHwgMCwgYS5wYW5EZWx0YSAmJiBpLnBhbi5fYWRkKGEucGFuRGVsdGEpLCBhLmFyb3VuZCAmJiAoaS5hcm91bmQgPSBhLmFyb3VuZCksIGEucGluY2hBcm91bmQgJiYgKGkucGluY2hBcm91bmQgPSBhLnBpbmNoQXJvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gdGhpcy5faW5lcnRpYUJ1ZmZlclt0aGlzLl9pbmVydGlhQnVmZmVyLmxlbmd0aCAtIDFdLnRpbWUgLSB0aGlzLl9pbmVydGlhQnVmZmVyWzBdLnRpbWUsXG4gICAgICAgICAgICBzID0ge307XG5cbiAgICAgICAgaWYgKGkucGFuLm1hZygpKSB7XG4gICAgICAgICAgdmFyIGwgPSBMbyhpLnBhbi5tYWcoKSwgbiwgdC5leHRlbmQoe30sIFNvLCBlIHx8IHt9KSk7XG4gICAgICAgICAgcy5vZmZzZXQgPSBpLnBhbi5tdWx0KGwuYW1vdW50IC8gaS5wYW4ubWFnKCkpLCBzLmNlbnRlciA9IHRoaXMuX21hcC50cmFuc2Zvcm0uY2VudGVyLCBNbyhzLCBsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpLnpvb20pIHtcbiAgICAgICAgICB2YXIgYyA9IExvKGkuem9vbSwgbiwgQ28pO1xuICAgICAgICAgIHMuem9vbSA9IHRoaXMuX21hcC50cmFuc2Zvcm0uem9vbSArIGMuYW1vdW50LCBNbyhzLCBjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpLmJlYXJpbmcpIHtcbiAgICAgICAgICB2YXIgdSA9IExvKGkuYmVhcmluZywgbiwgem8pO1xuICAgICAgICAgIHMuYmVhcmluZyA9IHRoaXMuX21hcC50cmFuc2Zvcm0uYmVhcmluZyArIHQuY2xhbXAodS5hbW91bnQsIC0xNzksIDE3OSksIE1vKHMsIHUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkucGl0Y2gpIHtcbiAgICAgICAgICB2YXIgaCA9IExvKGkucGl0Y2gsIG4sIERvKTtcbiAgICAgICAgICBzLnBpdGNoID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5waXRjaCArIGguYW1vdW50LCBNbyhzLCBoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzLnpvb20gfHwgcy5iZWFyaW5nKSB7XG4gICAgICAgICAgdmFyIHAgPSB2b2lkIDAgPT09IGkucGluY2hBcm91bmQgPyBpLmFyb3VuZCA6IGkucGluY2hBcm91bmQ7XG4gICAgICAgICAgcy5hcm91bmQgPSBwID8gdGhpcy5fbWFwLnVucHJvamVjdChwKSA6IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyKCksIHQuZXh0ZW5kKHMsIHtcbiAgICAgICAgICBub01vdmVTdGFydDogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBSbyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBvKG8sIHIsIGEsIG4pIHtcbiAgICAgICAgdm9pZCAwID09PSBuICYmIChuID0ge30pO1xuICAgICAgICB2YXIgcyA9IGkubW91c2VQb3Moci5nZXRDYW52YXNDb250YWluZXIoKSwgYSksXG4gICAgICAgICAgICBsID0gci51bnByb2plY3Qocyk7XG4gICAgICAgIGUuY2FsbCh0aGlzLCBvLCB0LmV4dGVuZCh7XG4gICAgICAgICAgcG9pbnQ6IHMsXG4gICAgICAgICAgbG5nTGF0OiBsLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGFcbiAgICAgICAgfSwgbikpLCB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITEsIHRoaXMudGFyZ2V0ID0gcjtcbiAgICAgIH1cblxuICAgICAgZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvO1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gby5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgIH0sIHIuZGVmYXVsdFByZXZlbnRlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoby5wcm90b3R5cGUsIHIpLCBvO1xuICAgIH0odC5FdmVudCksXG4gICAgICAgIGtvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIG8obywgciwgYSkge1xuICAgICAgICB2YXIgbiA9IFwidG91Y2hlbmRcIiA9PT0gbyA/IGEuY2hhbmdlZFRvdWNoZXMgOiBhLnRvdWNoZXMsXG4gICAgICAgICAgICBzID0gaS50b3VjaFBvcyhyLmdldENhbnZhc0NvbnRhaW5lcigpLCBuKSxcbiAgICAgICAgICAgIGwgPSBzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiByLnVucHJvamVjdCh0KTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBjID0gcy5yZWR1Y2UoZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICByZXR1cm4gdC5hZGQoZS5kaXYoby5sZW5ndGgpKTtcbiAgICAgICAgfSwgbmV3IHQuUG9pbnQoMCwgMCkpLFxuICAgICAgICAgICAgdSA9IHIudW5wcm9qZWN0KGMpO1xuICAgICAgICBlLmNhbGwodGhpcywgbywge1xuICAgICAgICAgIHBvaW50czogcyxcbiAgICAgICAgICBwb2ludDogYyxcbiAgICAgICAgICBsbmdMYXRzOiBsLFxuICAgICAgICAgIGxuZ0xhdDogdSxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBhXG4gICAgICAgIH0pLCB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITE7XG4gICAgICB9XG5cbiAgICAgIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbztcbiAgICAgIHZhciByID0ge1xuICAgICAgICBkZWZhdWx0UHJldmVudGVkOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG8ucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICB9LCByLmRlZmF1bHRQcmV2ZW50ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG8ucHJvdG90eXBlLCByKSwgbztcbiAgICB9KHQuRXZlbnQpLFxuICAgICAgICBCbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIGksIG8pIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvXG4gICAgICAgIH0pLCB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITE7XG4gICAgICB9XG5cbiAgICAgIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZTtcbiAgICAgIHZhciBpID0ge1xuICAgICAgICBkZWZhdWx0UHJldmVudGVkOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGUucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICB9LCBpLmRlZmF1bHRQcmV2ZW50ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCBpKSwgZTtcbiAgICB9KHQuRXZlbnQpLFxuICAgICAgICBPbyA9IGZ1bmN0aW9uIE9vKHQsIGUpIHtcbiAgICAgIHRoaXMuX21hcCA9IHQsIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gZS5jbGlja1RvbGVyYW5jZTtcbiAgICB9O1xuXG4gICAgT28ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX21vdXNlZG93blBvcztcbiAgICB9LCBPby5wcm90b3R5cGUud2hlZWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcmVQcmV2ZW50YWJsZShuZXcgQm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZWRvd25Qb3MgPSBlLCB0aGlzLl9maXJlUHJldmVudGFibGUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLm1vdXNldXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuX21vdXNlZG93blBvcyAmJiB0aGlzLl9tb3VzZWRvd25Qb3MuZGlzdChlKSA+PSB0aGlzLl9jbGlja1RvbGVyYW5jZSB8fCB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUuZGJsY2xpY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcmVQcmV2ZW50YWJsZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUubW91c2VvdmVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5tb3VzZW91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyZVByZXZlbnRhYmxlKG5ldyBrbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IGtvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBrbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcga28odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUuX2ZpcmVQcmV2ZW50YWJsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5fbWFwLmZpcmUodCksIHQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuIHt9O1xuICAgIH0sIE9vLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgT28ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIE9vLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7fSwgT28ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBGbyA9IGZ1bmN0aW9uIEZvKHQpIHtcbiAgICAgIHRoaXMuX21hcCA9IHQ7XG4gICAgfTtcblxuICAgIEZvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RlbGF5Q29udGV4dE1lbnUgPSAhMSwgZGVsZXRlIHRoaXMuX2NvbnRleHRNZW51RXZlbnQ7XG4gICAgfSwgRm8ucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBGby5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZGVsYXlDb250ZXh0TWVudSA9ICEwO1xuICAgIH0sIEZvLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZGVsYXlDb250ZXh0TWVudSA9ICExLCB0aGlzLl9jb250ZXh0TWVudUV2ZW50ICYmICh0aGlzLl9tYXAuZmlyZShuZXcgUm8oXCJjb250ZXh0bWVudVwiLCB0aGlzLl9tYXAsIHRoaXMuX2NvbnRleHRNZW51RXZlbnQpKSwgZGVsZXRlIHRoaXMuX2NvbnRleHRNZW51RXZlbnQpO1xuICAgIH0sIEZvLnByb3RvdHlwZS5jb250ZXh0bWVudSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9kZWxheUNvbnRleHRNZW51ID8gdGhpcy5fY29udGV4dE1lbnVFdmVudCA9IHQgOiB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKSwgdGhpcy5fbWFwLmxpc3RlbnMoXCJjb250ZXh0bWVudVwiKSAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgRm8ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LCBGby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgRm8ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHt9LCBGby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdmFyIFVvID0gZnVuY3Rpb24gVW8odCwgZSkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fZWwgPSB0LmdldENhbnZhc0NvbnRhaW5lcigpLCB0aGlzLl9jb250YWluZXIgPSB0LmdldENvbnRhaW5lcigpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2UgfHwgMTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTm8odCwgZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHt9LCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgaVt0W29dLmlkZW50aWZpZXJdID0gZVtvXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgVW8ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgVW8ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fYWN0aXZlO1xuICAgIH0sIFVvLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCgpIHx8ICh0aGlzLl9lbmFibGVkID0gITApO1xuICAgIH0sIFVvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQoKSAmJiAodGhpcy5fZW5hYmxlZCA9ICExKTtcbiAgICB9LCBVby5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgJiYgdC5zaGlmdEtleSAmJiAwID09PSB0LmJ1dHRvbiAmJiAoaS5kaXNhYmxlRHJhZygpLCB0aGlzLl9zdGFydFBvcyA9IHRoaXMuX2xhc3RQb3MgPSBlLCB0aGlzLl9hY3RpdmUgPSAhMCk7XG4gICAgfSwgVW8ucHJvdG90eXBlLm1vdXNlbW92ZVdpbmRvdyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgIHZhciBvID0gZTtcblxuICAgICAgICBpZiAoISh0aGlzLl9sYXN0UG9zLmVxdWFscyhvKSB8fCAhdGhpcy5fYm94ICYmIG8uZGlzdCh0aGlzLl9zdGFydFBvcykgPCB0aGlzLl9jbGlja1RvbGVyYW5jZSkpIHtcbiAgICAgICAgICB2YXIgciA9IHRoaXMuX3N0YXJ0UG9zO1xuICAgICAgICAgIHRoaXMuX2xhc3RQb3MgPSBvLCB0aGlzLl9ib3ggfHwgKHRoaXMuX2JveCA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtYm94em9vbVwiLCB0aGlzLl9jb250YWluZXIpLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWNyb3NzaGFpclwiKSwgdGhpcy5fZmlyZUV2ZW50KFwiYm94em9vbXN0YXJ0XCIsIHQpKTtcbiAgICAgICAgICB2YXIgYSA9IE1hdGgubWluKHIueCwgby54KSxcbiAgICAgICAgICAgICAgbiA9IE1hdGgubWF4KHIueCwgby54KSxcbiAgICAgICAgICAgICAgcyA9IE1hdGgubWluKHIueSwgby55KSxcbiAgICAgICAgICAgICAgbCA9IE1hdGgubWF4KHIueSwgby55KTtcbiAgICAgICAgICBpLnNldFRyYW5zZm9ybSh0aGlzLl9ib3gsIFwidHJhbnNsYXRlKFwiICsgYSArIFwicHgsXCIgKyBzICsgXCJweClcIiksIHRoaXMuX2JveC5zdHlsZS53aWR0aCA9IG4gLSBhICsgXCJweFwiLCB0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gbCAtIHMgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBVby5wcm90b3R5cGUubW91c2V1cFdpbmRvdyA9IGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgMCA9PT0gZS5idXR0b24pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIG4gPSBvO1xuICAgICAgICBpZiAodGhpcy5yZXNldCgpLCBpLnN1cHByZXNzQ2xpY2soKSwgYS54ICE9PSBuLnggfHwgYS55ICE9PSBuLnkpIHJldHVybiB0aGlzLl9tYXAuZmlyZShuZXcgdC5FdmVudChcImJveHpvb21lbmRcIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgY2FtZXJhQW5pbWF0aW9uOiBmdW5jdGlvbiBjYW1lcmFBbmltYXRpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZml0U2NyZWVuQ29vcmRpbmF0ZXMoYSwgbiwgci5fbWFwLmdldEJlYXJpbmcoKSwge1xuICAgICAgICAgICAgICBsaW5lYXI6ICEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwiYm94em9vbWNhbmNlbFwiLCBlKTtcbiAgICAgIH1cbiAgICB9LCBVby5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgJiYgMjcgPT09IHQua2V5Q29kZSAmJiAodGhpcy5yZXNldCgpLCB0aGlzLl9maXJlRXZlbnQoXCJib3h6b29tY2FuY2VsXCIsIHQpKTtcbiAgICB9LCBVby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1jcm9zc2hhaXJcIiksIHRoaXMuX2JveCAmJiAoaS5yZW1vdmUodGhpcy5fYm94KSwgdGhpcy5fYm94ID0gbnVsbCksIGkuZW5hYmxlRHJhZygpLCBkZWxldGUgdGhpcy5fc3RhcnRQb3MsIGRlbGV0ZSB0aGlzLl9sYXN0UG9zO1xuICAgIH0sIFVvLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZShuZXcgdC5FdmVudChlLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGlcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgdmFyIFpvID0gZnVuY3Rpb24gWm8odCkge1xuICAgICAgdGhpcy5yZXNldCgpLCB0aGlzLm51bVRvdWNoZXMgPSB0Lm51bVRvdWNoZXM7XG4gICAgfTtcblxuICAgIFpvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNlbnRyb2lkLCBkZWxldGUgdGhpcy5zdGFydFRpbWUsIGRlbGV0ZSB0aGlzLnRvdWNoZXMsIHRoaXMuYWJvcnRlZCA9ICExO1xuICAgIH0sIFpvLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICh0aGlzLmNlbnRyb2lkIHx8IG8ubGVuZ3RoID4gdGhpcy5udW1Ub3VjaGVzKSAmJiAodGhpcy5hYm9ydGVkID0gITApLCB0aGlzLmFib3J0ZWQgfHwgKHZvaWQgMCA9PT0gdGhpcy5zdGFydFRpbWUgJiYgKHRoaXMuc3RhcnRUaW1lID0gZS50aW1lU3RhbXApLCBvLmxlbmd0aCA9PT0gdGhpcy5udW1Ub3VjaGVzICYmICh0aGlzLmNlbnRyb2lkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5ldyB0LlBvaW50KDAsIDApLCBvID0gMCwgciA9IGU7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgaS5fYWRkKHJbb10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkuZGl2KGUubGVuZ3RoKTtcbiAgICAgIH0oaSksIHRoaXMudG91Y2hlcyA9IE5vKG8sIGkpKSk7XG4gICAgfSwgWm8ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAoIXRoaXMuYWJvcnRlZCAmJiB0aGlzLmNlbnRyb2lkKSB7XG4gICAgICAgIHZhciBvID0gTm8oaSwgZSk7XG5cbiAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnRvdWNoZXMpIHtcbiAgICAgICAgICB2YXIgYSA9IG9bcl07XG4gICAgICAgICAgKCFhIHx8IGEuZGlzdCh0aGlzLnRvdWNoZXNbcl0pID4gMzApICYmICh0aGlzLmFib3J0ZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBaby5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgaWYgKCghdGhpcy5jZW50cm9pZCB8fCB0LnRpbWVTdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gNTAwKSAmJiAodGhpcy5hYm9ydGVkID0gITApLCAwID09PSBpLmxlbmd0aCkge1xuICAgICAgICB2YXIgbyA9ICF0aGlzLmFib3J0ZWQgJiYgdGhpcy5jZW50cm9pZDtcbiAgICAgICAgaWYgKHRoaXMucmVzZXQoKSwgbykgcmV0dXJuIG87XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBxbyA9IGZ1bmN0aW9uIHFvKHQpIHtcbiAgICAgIHRoaXMuc2luZ2xlVGFwID0gbmV3IFpvKHQpLCB0aGlzLm51bVRhcHMgPSB0Lm51bVRhcHMsIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgcW8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IDEgLyAwLCBkZWxldGUgdGhpcy5sYXN0VGFwLCB0aGlzLmNvdW50ID0gMCwgdGhpcy5zaW5nbGVUYXAucmVzZXQoKTtcbiAgICB9LCBxby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLnNpbmdsZVRhcC50b3VjaHN0YXJ0KHQsIGUsIGkpO1xuICAgIH0sIHFvLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5zaW5nbGVUYXAudG91Y2htb3ZlKHQsIGUsIGkpO1xuICAgIH0sIHFvLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuc2luZ2xlVGFwLnRvdWNoZW5kKHQsIGUsIGkpO1xuXG4gICAgICBpZiAobykge1xuICAgICAgICB2YXIgciA9IHQudGltZVN0YW1wIC0gdGhpcy5sYXN0VGltZSA8IDUwMCxcbiAgICAgICAgICAgIGEgPSAhdGhpcy5sYXN0VGFwIHx8IHRoaXMubGFzdFRhcC5kaXN0KG8pIDwgMzA7XG4gICAgICAgIGlmIChyICYmIGEgfHwgdGhpcy5yZXNldCgpLCB0aGlzLmNvdW50KyssIHRoaXMubGFzdFRpbWUgPSB0LnRpbWVTdGFtcCwgdGhpcy5sYXN0VGFwID0gbywgdGhpcy5jb3VudCA9PT0gdGhpcy5udW1UYXBzKSByZXR1cm4gdGhpcy5yZXNldCgpLCBvO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgam8gPSBmdW5jdGlvbiBqbygpIHtcbiAgICAgIHRoaXMuX3pvb21JbiA9IG5ldyBxbyh7XG4gICAgICAgIG51bVRvdWNoZXM6IDEsXG4gICAgICAgIG51bVRhcHM6IDJcbiAgICAgIH0pLCB0aGlzLl96b29tT3V0ID0gbmV3IHFvKHtcbiAgICAgICAgbnVtVG91Y2hlczogMixcbiAgICAgICAgbnVtVGFwczogMVxuICAgICAgfSksIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgam8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITEsIHRoaXMuX3pvb21Jbi5yZXNldCgpLCB0aGlzLl96b29tT3V0LnJlc2V0KCk7XG4gICAgfSwgam8ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fem9vbUluLnRvdWNoc3RhcnQodCwgZSwgaSksIHRoaXMuX3pvb21PdXQudG91Y2hzdGFydCh0LCBlLCBpKTtcbiAgICB9LCBqby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3pvb21Jbi50b3VjaG1vdmUodCwgZSwgaSksIHRoaXMuX3pvb21PdXQudG91Y2htb3ZlKHQsIGUsIGkpO1xuICAgIH0sIGpvLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMsXG4gICAgICAgICAgciA9IHRoaXMuX3pvb21Jbi50b3VjaGVuZCh0LCBlLCBpKSxcbiAgICAgICAgICBhID0gdGhpcy5fem9vbU91dC50b3VjaGVuZCh0LCBlLCBpKTtcblxuICAgICAgcmV0dXJuIHIgPyAodGhpcy5fYWN0aXZlID0gITAsIHQucHJldmVudERlZmF1bHQoKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvLnJlc2V0KCk7XG4gICAgICB9LCAwKSwge1xuICAgICAgICBjYW1lcmFBbmltYXRpb246IGZ1bmN0aW9uIGNhbWVyYUFuaW1hdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZWFzZVRvKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICB6b29tOiBlLmdldFpvb20oKSArIDEsXG4gICAgICAgICAgICBhcm91bmQ6IGUudW5wcm9qZWN0KHIpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSA6IGEgPyAodGhpcy5fYWN0aXZlID0gITAsIHQucHJldmVudERlZmF1bHQoKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvLnJlc2V0KCk7XG4gICAgICB9LCAwKSwge1xuICAgICAgICBjYW1lcmFBbmltYXRpb246IGZ1bmN0aW9uIGNhbWVyYUFuaW1hdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZWFzZVRvKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICB6b29tOiBlLmdldFpvb20oKSAtIDEsXG4gICAgICAgICAgICBhcm91bmQ6IGUudW5wcm9qZWN0KGEpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICB9LCBqby5wcm90b3R5cGUudG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSwgam8ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBqby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIGpvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBqby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG5cbiAgICB2YXIgVm8gPSB7XG4gICAgICAwOiAxLFxuICAgICAgMjogMlxuICAgIH0sXG4gICAgICAgIEdvID0gZnVuY3Rpb24gR28odCkge1xuICAgICAgdGhpcy5yZXNldCgpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IHQuY2xpY2tUb2xlcmFuY2UgfHwgMTtcbiAgICB9O1xuXG4gICAgR28ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITEsIHRoaXMuX21vdmVkID0gITEsIGRlbGV0ZSB0aGlzLl9sYXN0UG9pbnQsIGRlbGV0ZSB0aGlzLl9ldmVudEJ1dHRvbjtcbiAgICB9LCBHby5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIEdvLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSwgR28ucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIXRoaXMuX2xhc3RQb2ludCkge1xuICAgICAgICB2YXIgbyA9IGkubW91c2VCdXR0b24odCk7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCdXR0b24odCwgbykgJiYgKHRoaXMuX2xhc3RQb2ludCA9IGUsIHRoaXMuX2V2ZW50QnV0dG9uID0gbyk7XG4gICAgICB9XG4gICAgfSwgR28ucHJvdG90eXBlLm1vdXNlbW92ZVdpbmRvdyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2xhc3RQb2ludDtcbiAgICAgIGlmIChpKSBpZiAodC5wcmV2ZW50RGVmYXVsdCgpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9IFZvW2VdO1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0LmJ1dHRvbnMgfHwgKHQuYnV0dG9ucyAmIGkpICE9PSBpO1xuICAgICAgfSh0LCB0aGlzLl9ldmVudEJ1dHRvbikpIHRoaXMucmVzZXQoKTtlbHNlIGlmICh0aGlzLl9tb3ZlZCB8fCAhKGUuZGlzdChpKSA8IHRoaXMuX2NsaWNrVG9sZXJhbmNlKSkgcmV0dXJuIHRoaXMuX21vdmVkID0gITAsIHRoaXMuX2xhc3RQb2ludCA9IGUsIHRoaXMuX21vdmUoaSwgZSk7XG4gICAgfSwgR28ucHJvdG90eXBlLm1vdXNldXBXaW5kb3cgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbGFzdFBvaW50ICYmIGkubW91c2VCdXR0b24odCkgPT09IHRoaXMuX2V2ZW50QnV0dG9uICYmICh0aGlzLl9tb3ZlZCAmJiBpLnN1cHByZXNzQ2xpY2soKSwgdGhpcy5yZXNldCgpKTtcbiAgICB9LCBHby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIEdvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgR28ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIEdvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcblxuICAgIHZhciBXbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHQucHJvdG90eXBlLm1vdXNlZG93bi5jYWxsKHRoaXMsIGUsIGkpLCB0aGlzLl9sYXN0UG9pbnQgJiYgKHRoaXMuX2FjdGl2ZSA9ICEwKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9jb3JyZWN0QnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IGUgJiYgIXQuY3RybEtleTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcm91bmQ6IGUsXG4gICAgICAgICAgcGFuRGVsdGE6IGUuc3ViKHQpXG4gICAgICAgIH07XG4gICAgICB9LCBlO1xuICAgIH0oR28pLFxuICAgICAgICBYbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9jb3JyZWN0QnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IGUgJiYgdC5jdHJsS2V5IHx8IDIgPT09IGU7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gLjggKiAoZS54IC0gdC54KTtcbiAgICAgICAgaWYgKGkpIHJldHVybiB0aGlzLl9hY3RpdmUgPSAhMCwge1xuICAgICAgICAgIGJlYXJpbmdEZWx0YTogaVxuICAgICAgICB9O1xuICAgICAgfSwgZS5wcm90b3R5cGUuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCBlO1xuICAgIH0oR28pLFxuICAgICAgICBIbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9jb3JyZWN0QnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IGUgJiYgdC5jdHJsS2V5IHx8IDIgPT09IGU7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gLS41ICogKGUueSAtIHQueSk7XG4gICAgICAgIGlmIChpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICBwaXRjaERlbHRhOiBpXG4gICAgICAgIH07XG4gICAgICB9LCBlLnByb3RvdHlwZS5jb250ZXh0bWVudSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIGU7XG4gICAgfShHbyksXG4gICAgICAgIEtvID0gZnVuY3Rpb24gS28odCkge1xuICAgICAgdGhpcy5fbWluVG91Y2hlcyA9IDEsIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gdC5jbGlja1RvbGVyYW5jZSB8fCAxLCB0aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIEtvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCB0aGlzLl90b3VjaGVzID0ge30sIHRoaXMuX3N1bSA9IG5ldyB0LlBvaW50KDAsIDApO1xuICAgIH0sIEtvLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm0odCwgZSwgaSk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlICYmICEoaS5sZW5ndGggPCB0aGlzLl9taW5Ub3VjaGVzKSkgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtKHQsIGUsIGkpO1xuICAgIH0sIEtvLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm0odCwgZSwgaSksIHRoaXMuX2FjdGl2ZSAmJiBpLmxlbmd0aCA8IHRoaXMuX21pblRvdWNoZXMgJiYgdGhpcy5yZXNldCgpO1xuICAgIH0sIEtvLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LCBLby5wcm90b3R5cGUuX2NhbGN1bGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICBvLmxlbmd0aCA+IDAgJiYgKHRoaXMuX2FjdGl2ZSA9ICEwKTtcbiAgICAgIHZhciByID0gTm8obywgaSksXG4gICAgICAgICAgYSA9IG5ldyB0LlBvaW50KDAsIDApLFxuICAgICAgICAgIG4gPSBuZXcgdC5Qb2ludCgwLCAwKSxcbiAgICAgICAgICBzID0gMDtcblxuICAgICAgZm9yICh2YXIgbCBpbiByKSB7XG4gICAgICAgIHZhciBjID0gcltsXSxcbiAgICAgICAgICAgIHUgPSB0aGlzLl90b3VjaGVzW2xdO1xuICAgICAgICB1ICYmIChhLl9hZGQoYyksIG4uX2FkZChjLnN1Yih1KSksIHMrKywgcltsXSA9IGMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdG91Y2hlcyA9IHIsICEocyA8IHRoaXMuX21pblRvdWNoZXMpICYmIG4ubWFnKCkpIHtcbiAgICAgICAgdmFyIGggPSBuLmRpdihzKTtcbiAgICAgICAgaWYgKHRoaXMuX3N1bS5fYWRkKGgpLCAhKHRoaXMuX3N1bS5tYWcoKSA8IHRoaXMuX2NsaWNrVG9sZXJhbmNlKSkgcmV0dXJuIHtcbiAgICAgICAgICBhcm91bmQ6IGEuZGl2KHMpLFxuICAgICAgICAgIHBhbkRlbHRhOiBoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgS28ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBLby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIEtvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBLby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG5cbiAgICB2YXIgWW8gPSBmdW5jdGlvbiBZbygpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSm8odCwgZSwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGlmICh0W29dLmlkZW50aWZpZXIgPT09IGkpIHJldHVybiBlW29dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFFvKHQsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyh0IC8gZSkgLyBNYXRoLkxOMjtcbiAgICB9XG5cbiAgICBZby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgZGVsZXRlIHRoaXMuX2ZpcnN0VHdvVG91Y2hlcztcbiAgICB9LCBZby5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHQpIHt9LCBZby5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0sIFlvLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX2ZpcnN0VHdvVG91Y2hlcyB8fCBpLmxlbmd0aCA8IDIgfHwgKHRoaXMuX2ZpcnN0VHdvVG91Y2hlcyA9IFtpWzBdLmlkZW50aWZpZXIsIGlbMV0uaWRlbnRpZmllcl0sIHRoaXMuX3N0YXJ0KFtlWzBdLCBlWzFdXSkpO1xuICAgIH0sIFlvLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgaWYgKHRoaXMuX2ZpcnN0VHdvVG91Y2hlcykge1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBvID0gdGhpcy5fZmlyc3RUd29Ub3VjaGVzLFxuICAgICAgICAgICAgciA9IG9bMV0sXG4gICAgICAgICAgICBhID0gSm8oaSwgZSwgb1swXSksXG4gICAgICAgICAgICBuID0gSm8oaSwgZSwgcik7XG5cbiAgICAgICAgaWYgKGEgJiYgbikge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5fYXJvdW5kQ2VudGVyID8gbnVsbCA6IGEuYWRkKG4pLmRpdigyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbW92ZShbYSwgbl0sIHMsIHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIG8pIHtcbiAgICAgIGlmICh0aGlzLl9maXJzdFR3b1RvdWNoZXMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLl9maXJzdFR3b1RvdWNoZXMsXG4gICAgICAgICAgICBhID0gclsxXSxcbiAgICAgICAgICAgIG4gPSBKbyhvLCBlLCByWzBdKSxcbiAgICAgICAgICAgIHMgPSBKbyhvLCBlLCBhKTtcbiAgICAgICAgbiAmJiBzIHx8ICh0aGlzLl9hY3RpdmUgJiYgaS5zdXBwcmVzc0NsaWNrKCksIHRoaXMucmVzZXQoKSk7XG4gICAgICB9XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sIFlvLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwLCB0aGlzLl9hcm91bmRDZW50ZXIgPSAhIXQgJiYgXCJjZW50ZXJcIiA9PT0gdC5hcm91bmQ7XG4gICAgfSwgWW8ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICB9LCBZby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgWW8ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9O1xuXG4gICAgdmFyICRvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyksIGRlbGV0ZSB0aGlzLl9kaXN0YW5jZSwgZGVsZXRlIHRoaXMuX3N0YXJ0RGlzdGFuY2U7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zdGFydERpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2UgPSB0WzBdLmRpc3QodFsxXSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fZGlzdGFuY2U7XG4gICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZSA9IHRbMF0uZGlzdCh0WzFdKSwgdGhpcy5fYWN0aXZlIHx8ICEoTWF0aC5hYnMoUW8odGhpcy5fZGlzdGFuY2UsIHRoaXMuX3N0YXJ0RGlzdGFuY2UpKSA8IC4xKSkgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgem9vbURlbHRhOiBRbyh0aGlzLl9kaXN0YW5jZSwgaSksXG4gICAgICAgICAgcGluY2hBcm91bmQ6IGVcbiAgICAgICAgfTtcbiAgICAgIH0sIGU7XG4gICAgfShZbyk7XG5cbiAgICBmdW5jdGlvbiB0cih0LCBlKSB7XG4gICAgICByZXR1cm4gMTgwICogdC5hbmdsZVdpdGgoZSkgLyBNYXRoLlBJO1xuICAgIH1cblxuICAgIHZhciBlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0LnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpLCBkZWxldGUgdGhpcy5fbWluRGlhbWV0ZXIsIGRlbGV0ZSB0aGlzLl9zdGFydFZlY3RvciwgZGVsZXRlIHRoaXMuX3ZlY3RvcjtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VmVjdG9yID0gdGhpcy5fdmVjdG9yID0gdFswXS5zdWIodFsxXSksIHRoaXMuX21pbkRpYW1ldGVyID0gdFswXS5kaXN0KHRbMV0pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX3ZlY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuX3ZlY3RvciA9IHRbMF0uc3ViKHRbMV0pLCB0aGlzLl9hY3RpdmUgfHwgIXRoaXMuX2lzQmVsb3dUaHJlc2hvbGQodGhpcy5fdmVjdG9yKSkgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgYmVhcmluZ0RlbHRhOiB0cih0aGlzLl92ZWN0b3IsIGkpLFxuICAgICAgICAgIHBpbmNoQXJvdW5kOiBlXG4gICAgICAgIH07XG4gICAgICB9LCBlLnByb3RvdHlwZS5faXNCZWxvd1RocmVzaG9sZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX21pbkRpYW1ldGVyID0gTWF0aC5taW4odGhpcy5fbWluRGlhbWV0ZXIsIHQubWFnKCkpO1xuICAgICAgICB2YXIgZSA9IDI1IC8gKE1hdGguUEkgKiB0aGlzLl9taW5EaWFtZXRlcikgKiAzNjAsXG4gICAgICAgICAgICBpID0gdHIodCwgdGhpcy5fc3RhcnRWZWN0b3IpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoaSkgPCBlO1xuICAgICAgfSwgZTtcbiAgICB9KFlvKTtcblxuICAgIGZ1bmN0aW9uIGlyKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0LnkpID4gTWF0aC5hYnModC54KTtcbiAgICB9XG5cbiAgICB2YXIgb3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKSwgdGhpcy5fdmFsaWQgPSB2b2lkIDAsIGRlbGV0ZSB0aGlzLl9maXJzdE1vdmUsIGRlbGV0ZSB0aGlzLl9sYXN0UG9pbnRzO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFBvaW50cyA9IHQsIGlyKHRbMF0uc3ViKHRbMV0pKSAmJiAodGhpcy5fdmFsaWQgPSAhMSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdFswXS5zdWIodGhpcy5fbGFzdFBvaW50c1swXSksXG4gICAgICAgICAgICByID0gdFsxXS5zdWIodGhpcy5fbGFzdFBvaW50c1sxXSk7XG4gICAgICAgIGlmICh0aGlzLl92YWxpZCA9IHRoaXMuZ2VzdHVyZUJlZ2luc1ZlcnRpY2FsbHkobywgciwgaS50aW1lU3RhbXApLCB0aGlzLl92YWxpZCkgcmV0dXJuIHRoaXMuX2xhc3RQb2ludHMgPSB0LCB0aGlzLl9hY3RpdmUgPSAhMCwge1xuICAgICAgICAgIHBpdGNoRGVsdGE6IChvLnkgKyByLnkpIC8gMiAqIC0uNVxuICAgICAgICB9O1xuICAgICAgfSwgZS5wcm90b3R5cGUuZ2VzdHVyZUJlZ2luc1ZlcnRpY2FsbHkgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwICE9PSB0aGlzLl92YWxpZCkgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgICAgICB2YXIgbyA9IHQubWFnKCkgPj0gMixcbiAgICAgICAgICAgIHIgPSBlLm1hZygpID49IDI7XG5cbiAgICAgICAgaWYgKG8gfHwgcikge1xuICAgICAgICAgIGlmICghbyB8fCAhcikgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5fZmlyc3RNb3ZlICYmICh0aGlzLl9maXJzdE1vdmUgPSBpKSwgaSAtIHRoaXMuX2ZpcnN0TW92ZSA8IDEwMCAmJiB2b2lkIDA7XG4gICAgICAgICAgdmFyIGEgPSB0LnkgPiAwID09IGUueSA+IDA7XG4gICAgICAgICAgcmV0dXJuIGlyKHQpICYmIGlyKGUpICYmIGE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShZbyksXG4gICAgICAgIHJyID0ge1xuICAgICAgcGFuU3RlcDogMTAwLFxuICAgICAgYmVhcmluZ1N0ZXA6IDE1LFxuICAgICAgcGl0Y2hTdGVwOiAxMFxuICAgIH0sXG4gICAgICAgIGFyID0gZnVuY3Rpb24gYXIoKSB7XG4gICAgICB2YXIgdCA9IHJyO1xuICAgICAgdGhpcy5fcGFuU3RlcCA9IHQucGFuU3RlcCwgdGhpcy5fYmVhcmluZ1N0ZXAgPSB0LmJlYXJpbmdTdGVwLCB0aGlzLl9waXRjaFN0ZXAgPSB0LnBpdGNoU3RlcCwgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBucih0KSB7XG4gICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgfVxuXG4gICAgYXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITE7XG4gICAgfSwgYXIucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuXG4gICAgICBpZiAoISh0LmFsdEtleSB8fCB0LmN0cmxLZXkgfHwgdC5tZXRhS2V5KSkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBvID0gMCxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgYSA9IDAsXG4gICAgICAgICAgICBuID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgY2FzZSAxNzE6XG4gICAgICAgICAgY2FzZSAxODc6XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODk6XG4gICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgY2FzZSAxNzM6XG4gICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gbyA9IC0xIDogKHQucHJldmVudERlZmF1bHQoKSwgYSA9IC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIHQuc2hpZnRLZXkgPyBvID0gMSA6ICh0LnByZXZlbnREZWZhdWx0KCksIGEgPSAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIHQuc2hpZnRLZXkgPyByID0gMSA6ICh0LnByZXZlbnREZWZhdWx0KCksIG4gPSAtMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gciA9IC0xIDogKHQucHJldmVudERlZmF1bHQoKSwgbiA9IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgJiYgKG8gPSAwLCByID0gMCksIHtcbiAgICAgICAgICBjYW1lcmFBbmltYXRpb246IGZ1bmN0aW9uIGNhbWVyYUFuaW1hdGlvbihzKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHMuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgcy5lYXNlVG8oe1xuICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICBlYXNlSWQ6IFwia2V5Ym9hcmRIYW5kbGVyXCIsXG4gICAgICAgICAgICAgIGVhc2luZzogbnIsXG4gICAgICAgICAgICAgIHpvb206IGkgPyBNYXRoLnJvdW5kKGwpICsgaSAqICh0LnNoaWZ0S2V5ID8gMiA6IDEpIDogbCxcbiAgICAgICAgICAgICAgYmVhcmluZzogcy5nZXRCZWFyaW5nKCkgKyBvICogZS5fYmVhcmluZ1N0ZXAsXG4gICAgICAgICAgICAgIHBpdGNoOiBzLmdldFBpdGNoKCkgKyByICogZS5fcGl0Y2hTdGVwLFxuICAgICAgICAgICAgICBvZmZzZXQ6IFstYSAqIGUuX3BhblN0ZXAsIC1uICogZS5fcGFuU3RlcF0sXG4gICAgICAgICAgICAgIGNlbnRlcjogcy5nZXRDZW50ZXIoKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgYXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBhci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIGFyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBhci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH0sIGFyLnByb3RvdHlwZS5kaXNhYmxlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITA7XG4gICAgfSwgYXIucHJvdG90eXBlLmVuYWJsZVJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExO1xuICAgIH07XG5cbiAgICB2YXIgc3IgPSBmdW5jdGlvbiBzcihlLCBpKSB7XG4gICAgICB0aGlzLl9tYXAgPSBlLCB0aGlzLl9lbCA9IGUuZ2V0Q2FudmFzQ29udGFpbmVyKCksIHRoaXMuX2hhbmRsZXIgPSBpLCB0aGlzLl9kZWx0YSA9IDAsIHRoaXMuX2RlZmF1bHRab29tUmF0ZSA9IC4wMSwgdGhpcy5fd2hlZWxab29tUmF0ZSA9IDEgLyA0NTAsIHQuYmluZEFsbChbXCJfb25UaW1lb3V0XCJdLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgc3IucHJvdG90eXBlLnNldFpvb21SYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRab29tUmF0ZSA9IHQ7XG4gICAgfSwgc3IucHJvdG90eXBlLnNldFdoZWVsWm9vbVJhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fd2hlZWxab29tUmF0ZSA9IHQ7XG4gICAgfSwgc3IucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgc3IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fYWN0aXZlIHx8IHZvaWQgMCAhPT0gdGhpcy5fZmluaXNoVGltZW91dDtcbiAgICB9LCBzci5wcm90b3R5cGUuaXNab29taW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fem9vbWluZztcbiAgICB9LCBzci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgfHwgKHRoaXMuX2VuYWJsZWQgPSAhMCwgdGhpcy5fYXJvdW5kQ2VudGVyID0gdCAmJiBcImNlbnRlclwiID09PSB0LmFyb3VuZCk7XG4gICAgfSwgc3IucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCgpICYmICh0aGlzLl9lbmFibGVkID0gITEpO1xuICAgIH0sIHNyLnByb3RvdHlwZS53aGVlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5pc0VuYWJsZWQoKSkge1xuICAgICAgICB2YXIgaSA9IGUuZGVsdGFNb2RlID09PSB0LndpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FID8gNDAgKiBlLmRlbHRhWSA6IGUuZGVsdGFZLFxuICAgICAgICAgICAgbyA9IHQuYnJvd3Nlci5ub3coKSxcbiAgICAgICAgICAgIHIgPSBvIC0gKHRoaXMuX2xhc3RXaGVlbEV2ZW50VGltZSB8fCAwKTtcbiAgICAgICAgdGhpcy5fbGFzdFdoZWVsRXZlbnRUaW1lID0gbywgMCAhPT0gaSAmJiBpICUgNC4wMDAyNDQxNDA2MjUgPT0gMCA/IHRoaXMuX3R5cGUgPSBcIndoZWVsXCIgOiAwICE9PSBpICYmIE1hdGguYWJzKGkpIDwgNCA/IHRoaXMuX3R5cGUgPSBcInRyYWNrcGFkXCIgOiByID4gNDAwID8gKHRoaXMuX3R5cGUgPSBudWxsLCB0aGlzLl9sYXN0VmFsdWUgPSBpLCB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDQwLCBlKSkgOiB0aGlzLl90eXBlIHx8ICh0aGlzLl90eXBlID0gTWF0aC5hYnMociAqIGkpIDwgMjAwID8gXCJ0cmFja3BhZFwiIDogXCJ3aGVlbFwiLCB0aGlzLl90aW1lb3V0ICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBudWxsLCBpICs9IHRoaXMuX2xhc3RWYWx1ZSkpLCBlLnNoaWZ0S2V5ICYmIGkgJiYgKGkgLz0gNCksIHRoaXMuX3R5cGUgJiYgKHRoaXMuX2xhc3RXaGVlbEV2ZW50ID0gZSwgdGhpcy5fZGVsdGEgLT0gaSwgdGhpcy5fYWN0aXZlIHx8IHRoaXMuX3N0YXJ0KGUpKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sIHNyLnByb3RvdHlwZS5fb25UaW1lb3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBcIndoZWVsXCIsIHRoaXMuX2RlbHRhIC09IHRoaXMuX2xhc3RWYWx1ZSwgdGhpcy5fYWN0aXZlIHx8IHRoaXMuX3N0YXJ0KHQpO1xuICAgIH0sIHNyLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuX2RlbHRhKSB7XG4gICAgICAgIHRoaXMuX2ZyYW1lSWQgJiYgKHRoaXMuX2ZyYW1lSWQgPSBudWxsKSwgdGhpcy5fYWN0aXZlID0gITAsIHRoaXMuaXNab29taW5nKCkgfHwgKHRoaXMuX3pvb21pbmcgPSAhMCksIHRoaXMuX2ZpbmlzaFRpbWVvdXQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9maW5pc2hUaW1lb3V0KSwgZGVsZXRlIHRoaXMuX2ZpbmlzaFRpbWVvdXQpO1xuICAgICAgICB2YXIgbyA9IGkubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9hcm91bmQgPSB0LkxuZ0xhdC5jb252ZXJ0KHRoaXMuX2Fyb3VuZENlbnRlciA/IHRoaXMuX21hcC5nZXRDZW50ZXIoKSA6IHRoaXMuX21hcC51bnByb2plY3QobykpLCB0aGlzLl9hcm91bmRQb2ludCA9IHRoaXMuX21hcC50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludCh0aGlzLl9hcm91bmQpLCB0aGlzLl9mcmFtZUlkIHx8ICh0aGlzLl9mcmFtZUlkID0gITAsIHRoaXMuX2hhbmRsZXIuX3RyaWdnZXJSZW5kZXJGcmFtZSgpKTtcbiAgICAgIH1cbiAgICB9LCBzci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9mcmFtZUlkICYmICh0aGlzLl9mcmFtZUlkID0gbnVsbCwgdGhpcy5pc0FjdGl2ZSgpKSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX21hcC50cmFuc2Zvcm07XG5cbiAgICAgICAgaWYgKDAgIT09IHRoaXMuX2RlbHRhKSB7XG4gICAgICAgICAgdmFyIG8gPSBcIndoZWVsXCIgPT09IHRoaXMuX3R5cGUgJiYgTWF0aC5hYnModGhpcy5fZGVsdGEpID4gNC4wMDAyNDQxNDA2MjUgPyB0aGlzLl93aGVlbFpvb21SYXRlIDogdGhpcy5fZGVmYXVsdFpvb21SYXRlLFxuICAgICAgICAgICAgICByID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKHRoaXMuX2RlbHRhICogbykpKTtcbiAgICAgICAgICB0aGlzLl9kZWx0YSA8IDAgJiYgMCAhPT0gciAmJiAociA9IDEgLyByKTtcbiAgICAgICAgICB2YXIgYSA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIHRoaXMuX3RhcmdldFpvb20gPyBpLnpvb21TY2FsZSh0aGlzLl90YXJnZXRab29tKSA6IGkuc2NhbGU7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0Wm9vbSA9IE1hdGgubWluKGkubWF4Wm9vbSwgTWF0aC5tYXgoaS5taW5ab29tLCBpLnNjYWxlWm9vbShhICogcikpKSwgXCJ3aGVlbFwiID09PSB0aGlzLl90eXBlICYmICh0aGlzLl9zdGFydFpvb20gPSBpLnpvb20sIHRoaXMuX2Vhc2luZyA9IHRoaXMuX3Ntb290aE91dEVhc2luZygyMDApKSwgdGhpcy5fZGVsdGEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgICBzID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgdGhpcy5fdGFyZ2V0Wm9vbSA/IHRoaXMuX3RhcmdldFpvb20gOiBpLnpvb20sXG4gICAgICAgICAgICBsID0gdGhpcy5fc3RhcnRab29tLFxuICAgICAgICAgICAgYyA9IHRoaXMuX2Vhc2luZyxcbiAgICAgICAgICAgIHUgPSAhMTtcblxuICAgICAgICBpZiAoXCJ3aGVlbFwiID09PSB0aGlzLl90eXBlICYmIGwgJiYgYykge1xuICAgICAgICAgIHZhciBoID0gTWF0aC5taW4oKHQuYnJvd3Nlci5ub3coKSAtIHRoaXMuX2xhc3RXaGVlbEV2ZW50VGltZSkgLyAyMDAsIDEpLFxuICAgICAgICAgICAgICBwID0gYyhoKTtcbiAgICAgICAgICBuID0gdC5udW1iZXIobCwgcywgcCksIGggPCAxID8gdGhpcy5fZnJhbWVJZCB8fCAodGhpcy5fZnJhbWVJZCA9ICEwKSA6IHUgPSAhMDtcbiAgICAgICAgfSBlbHNlIG4gPSBzLCB1ID0gITA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB1ICYmICh0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fZmluaXNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUuX3pvb21pbmcgPSAhMSwgZS5faGFuZGxlci5fdHJpZ2dlclJlbmRlckZyYW1lKCksIGRlbGV0ZSBlLl90YXJnZXRab29tLCBkZWxldGUgZS5fZmluaXNoVGltZW91dDtcbiAgICAgICAgfSwgMjAwKSksIHtcbiAgICAgICAgICBub0luZXJ0aWE6ICEwLFxuICAgICAgICAgIG5lZWRzUmVuZGVyRnJhbWU6ICF1LFxuICAgICAgICAgIHpvb21EZWx0YTogbiAtIGkuem9vbSxcbiAgICAgICAgICBhcm91bmQ6IHRoaXMuX2Fyb3VuZFBvaW50LFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RXaGVlbEV2ZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgc3IucHJvdG90eXBlLl9zbW9vdGhPdXRFYXNpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0LmVhc2U7XG5cbiAgICAgIGlmICh0aGlzLl9wcmV2RWFzZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuX3ByZXZFYXNlLFxuICAgICAgICAgICAgciA9ICh0LmJyb3dzZXIubm93KCkgLSBvLnN0YXJ0KSAvIG8uZHVyYXRpb24sXG4gICAgICAgICAgICBhID0gby5lYXNpbmcociArIC4wMSkgLSBvLmVhc2luZyhyKSxcbiAgICAgICAgICAgIG4gPSAuMjcgLyBNYXRoLnNxcnQoYSAqIGEgKyAxZS00KSAqIC4wMSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQoLjA3MjkgLSBuICogbik7XG4gICAgICAgIGkgPSB0LmJlemllcihuLCBzLCAuMjUsIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcHJldkVhc2UgPSB7XG4gICAgICAgIHN0YXJ0OiB0LmJyb3dzZXIubm93KCksXG4gICAgICAgIGR1cmF0aW9uOiBlLFxuICAgICAgICBlYXNpbmc6IGlcbiAgICAgIH0sIGk7XG4gICAgfSwgc3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITE7XG4gICAgfTtcblxuICAgIHZhciBsciA9IGZ1bmN0aW9uIGxyKHQsIGUpIHtcbiAgICAgIHRoaXMuX2NsaWNrWm9vbSA9IHQsIHRoaXMuX3RhcFpvb20gPSBlO1xuICAgIH07XG5cbiAgICBsci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fY2xpY2tab29tLmVuYWJsZSgpLCB0aGlzLl90YXBab29tLmVuYWJsZSgpO1xuICAgIH0sIGxyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fY2xpY2tab29tLmRpc2FibGUoKSwgdGhpcy5fdGFwWm9vbS5kaXNhYmxlKCk7XG4gICAgfSwgbHIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGlja1pvb20uaXNFbmFibGVkKCkgJiYgdGhpcy5fdGFwWm9vbS5pc0VuYWJsZWQoKTtcbiAgICB9LCBsci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xpY2tab29tLmlzQWN0aXZlKCkgfHwgdGhpcy5fdGFwWm9vbS5pc0FjdGl2ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgY3IgPSBmdW5jdGlvbiBjcigpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgY3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITE7XG4gICAgfSwgY3IucHJvdG90eXBlLmRibGNsaWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCksIHtcbiAgICAgICAgY2FtZXJhQW5pbWF0aW9uOiBmdW5jdGlvbiBjYW1lcmFBbmltYXRpb24oaSkge1xuICAgICAgICAgIGkuZWFzZVRvKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICB6b29tOiBpLmdldFpvb20oKSArICh0LnNoaWZ0S2V5ID8gLTEgOiAxKSxcbiAgICAgICAgICAgIGFyb3VuZDogaS51bnByb2plY3QoZSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgY3IucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBjci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIGNyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBjci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG5cbiAgICB2YXIgdXIgPSBmdW5jdGlvbiB1cigpIHtcbiAgICAgIHRoaXMuX3RhcCA9IG5ldyBxbyh7XG4gICAgICAgIG51bVRvdWNoZXM6IDEsXG4gICAgICAgIG51bVRhcHM6IDFcbiAgICAgIH0pLCB0aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCBkZWxldGUgdGhpcy5fc3dpcGVQb2ludCwgZGVsZXRlIHRoaXMuX3N3aXBlVG91Y2gsIGRlbGV0ZSB0aGlzLl90YXBUaW1lLCB0aGlzLl90YXAucmVzZXQoKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl9zd2lwZVBvaW50IHx8ICh0aGlzLl90YXBUaW1lICYmIHQudGltZVN0YW1wIC0gdGhpcy5fdGFwVGltZSA+IDUwMCAmJiB0aGlzLnJlc2V0KCksIHRoaXMuX3RhcFRpbWUgPyBpLmxlbmd0aCA+IDAgJiYgKHRoaXMuX3N3aXBlUG9pbnQgPSBlWzBdLCB0aGlzLl9zd2lwZVRvdWNoID0gaVswXS5pZGVudGlmaWVyKSA6IHRoaXMuX3RhcC50b3VjaHN0YXJ0KHQsIGUsIGkpKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICh0aGlzLl90YXBUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9zd2lwZVBvaW50KSB7XG4gICAgICAgICAgaWYgKGlbMF0uaWRlbnRpZmllciAhPT0gdGhpcy5fc3dpcGVUb3VjaCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBvID0gZVswXSxcbiAgICAgICAgICAgICAgciA9IG8ueSAtIHRoaXMuX3N3aXBlUG9pbnQueTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3dpcGVQb2ludCA9IG8sIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICAgIHpvb21EZWx0YTogciAvIDEyOFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB0aGlzLl90YXAudG91Y2htb3ZlKHQsIGUsIGkpO1xuICAgIH0sIHVyLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl90YXBUaW1lID8gdGhpcy5fc3dpcGVQb2ludCAmJiAwID09PSBpLmxlbmd0aCAmJiB0aGlzLnJlc2V0KCkgOiB0aGlzLl90YXAudG91Y2hlbmQodCwgZSwgaSkgJiYgKHRoaXMuX3RhcFRpbWUgPSB0LnRpbWVTdGFtcCk7XG4gICAgfSwgdXIucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sIHVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITA7XG4gICAgfSwgdXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICB9LCB1ci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgdXIucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9O1xuXG4gICAgdmFyIGhyID0gZnVuY3Rpb24gaHIodCwgZSwgaSkge1xuICAgICAgdGhpcy5fZWwgPSB0LCB0aGlzLl9tb3VzZVBhbiA9IGUsIHRoaXMuX3RvdWNoUGFuID0gaTtcbiAgICB9O1xuXG4gICAgaHIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9pbmVydGlhT3B0aW9ucyA9IHQgfHwge30sIHRoaXMuX21vdXNlUGFuLmVuYWJsZSgpLCB0aGlzLl90b3VjaFBhbi5lbmFibGUoKSwgdGhpcy5fZWwuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLXRvdWNoLWRyYWctcGFuXCIpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VQYW4uZGlzYWJsZSgpLCB0aGlzLl90b3VjaFBhbi5kaXNhYmxlKCksIHRoaXMuX2VsLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC10b3VjaC1kcmFnLXBhblwiKTtcbiAgICB9LCBoci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUGFuLmlzRW5hYmxlZCgpICYmIHRoaXMuX3RvdWNoUGFuLmlzRW5hYmxlZCgpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVBhbi5pc0FjdGl2ZSgpIHx8IHRoaXMuX3RvdWNoUGFuLmlzQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIHZhciBwciA9IGZ1bmN0aW9uIHByKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3BpdGNoV2l0aFJvdGF0ZSA9IHQucGl0Y2hXaXRoUm90YXRlLCB0aGlzLl9tb3VzZVJvdGF0ZSA9IGUsIHRoaXMuX21vdXNlUGl0Y2ggPSBpO1xuICAgIH07XG5cbiAgICBwci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZW5hYmxlKCksIHRoaXMuX3BpdGNoV2l0aFJvdGF0ZSAmJiB0aGlzLl9tb3VzZVBpdGNoLmVuYWJsZSgpO1xuICAgIH0sIHByLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZGlzYWJsZSgpLCB0aGlzLl9tb3VzZVBpdGNoLmRpc2FibGUoKTtcbiAgICB9LCBwci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUm90YXRlLmlzRW5hYmxlZCgpICYmICghdGhpcy5fcGl0Y2hXaXRoUm90YXRlIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNFbmFibGVkKCkpO1xuICAgIH0sIHByLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVJvdGF0ZS5pc0FjdGl2ZSgpIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyID0gZnVuY3Rpb24gZHIodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5fZWwgPSB0LCB0aGlzLl90b3VjaFpvb20gPSBlLCB0aGlzLl90b3VjaFJvdGF0ZSA9IGksIHRoaXMuX3RhcERyYWdab29tID0gbywgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExLCB0aGlzLl9lbmFibGVkID0gITA7XG4gICAgfTtcblxuICAgIGRyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fdG91Y2hab29tLmVuYWJsZSh0KSwgdGhpcy5fcm90YXRpb25EaXNhYmxlZCB8fCB0aGlzLl90b3VjaFJvdGF0ZS5lbmFibGUodCksIHRoaXMuX3RhcERyYWdab29tLmVuYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtdG91Y2gtem9vbS1yb3RhdGVcIik7XG4gICAgfSwgZHIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl90b3VjaFpvb20uZGlzYWJsZSgpLCB0aGlzLl90b3VjaFJvdGF0ZS5kaXNhYmxlKCksIHRoaXMuX3RhcERyYWdab29tLmRpc2FibGUoKSwgdGhpcy5fZWwuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLXRvdWNoLXpvb20tcm90YXRlXCIpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG91Y2hab29tLmlzRW5hYmxlZCgpICYmICh0aGlzLl9yb3RhdGlvbkRpc2FibGVkIHx8IHRoaXMuX3RvdWNoUm90YXRlLmlzRW5hYmxlZCgpKSAmJiB0aGlzLl90YXBEcmFnWm9vbS5pc0VuYWJsZWQoKTtcbiAgICB9LCBkci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG91Y2hab29tLmlzQWN0aXZlKCkgfHwgdGhpcy5fdG91Y2hSb3RhdGUuaXNBY3RpdmUoKSB8fCB0aGlzLl90YXBEcmFnWm9vbS5pc0FjdGl2ZSgpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5kaXNhYmxlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITAsIHRoaXMuX3RvdWNoUm90YXRlLmRpc2FibGUoKTtcbiAgICB9LCBkci5wcm90b3R5cGUuZW5hYmxlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITEsIHRoaXMuX3RvdWNoWm9vbS5pc0VuYWJsZWQoKSAmJiB0aGlzLl90b3VjaFJvdGF0ZS5lbmFibGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9yID0gZnVuY3Rpb24gX3IodCkge1xuICAgICAgcmV0dXJuIHQuem9vbSB8fCB0LmRyYWcgfHwgdC5waXRjaCB8fCB0LnJvdGF0ZTtcbiAgICB9LFxuICAgICAgICBmciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgfSh0LkV2ZW50KTtcblxuICAgIGZ1bmN0aW9uIG1yKHQpIHtcbiAgICAgIHJldHVybiB0LnBhbkRlbHRhICYmIHQucGFuRGVsdGEubWFnKCkgfHwgdC56b29tRGVsdGEgfHwgdC5iZWFyaW5nRGVsdGEgfHwgdC5waXRjaERlbHRhO1xuICAgIH1cblxuICAgIHZhciBnciA9IGZ1bmN0aW9uIGdyKGUsIG8pIHtcbiAgICAgIHRoaXMuX21hcCA9IGUsIHRoaXMuX2VsID0gdGhpcy5fbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLCB0aGlzLl9oYW5kbGVycyA9IFtdLCB0aGlzLl9oYW5kbGVyc0J5SWQgPSB7fSwgdGhpcy5fY2hhbmdlcyA9IFtdLCB0aGlzLl9pbmVydGlhID0gbmV3IEFvKGUpLCB0aGlzLl9iZWFyaW5nU25hcCA9IG8uYmVhcmluZ1NuYXAsIHRoaXMuX3ByZXZpb3VzQWN0aXZlSGFuZGxlcnMgPSB7fSwgdGhpcy5fZXZlbnRzSW5Qcm9ncmVzcyA9IHt9LCB0aGlzLl9hZGREZWZhdWx0SGFuZGxlcnMobyksIHQuYmluZEFsbChbXCJoYW5kbGVFdmVudFwiLCBcImhhbmRsZVdpbmRvd0V2ZW50XCJdLCB0aGlzKTtcbiAgICAgIHZhciByID0gdGhpcy5fZWw7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbW3IsIFwidG91Y2hzdGFydFwiLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9XSwgW3IsIFwidG91Y2htb3ZlXCIsIHtcbiAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgIH1dLCBbciwgXCJ0b3VjaGVuZFwiLCB2b2lkIDBdLCBbciwgXCJ0b3VjaGNhbmNlbFwiLCB2b2lkIDBdLCBbciwgXCJtb3VzZWRvd25cIiwgdm9pZCAwXSwgW3IsIFwibW91c2Vtb3ZlXCIsIHZvaWQgMF0sIFtyLCBcIm1vdXNldXBcIiwgdm9pZCAwXSwgW3Qud2luZG93LmRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB7XG4gICAgICAgIGNhcHR1cmU6ICEwXG4gICAgICB9XSwgW3Qud2luZG93LmRvY3VtZW50LCBcIm1vdXNldXBcIiwgdm9pZCAwXSwgW3IsIFwibW91c2VvdmVyXCIsIHZvaWQgMF0sIFtyLCBcIm1vdXNlb3V0XCIsIHZvaWQgMF0sIFtyLCBcImRibGNsaWNrXCIsIHZvaWQgMF0sIFtyLCBcImNsaWNrXCIsIHZvaWQgMF0sIFtyLCBcImtleWRvd25cIiwge1xuICAgICAgICBjYXB0dXJlOiAhMVxuICAgICAgfV0sIFtyLCBcImtleXVwXCIsIHZvaWQgMF0sIFtyLCBcIndoZWVsXCIsIHtcbiAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgIH1dLCBbciwgXCJjb250ZXh0bWVudVwiLCB2b2lkIDBdLCBbdC53aW5kb3csIFwiYmx1clwiLCB2b2lkIDBdXTtcblxuICAgICAgZm9yICh2YXIgYSA9IDAsIG4gPSB0aGlzLl9saXN0ZW5lcnM7IGEgPCBuLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gblthXSxcbiAgICAgICAgICAgIGwgPSBzWzBdO1xuICAgICAgICBpLmFkZEV2ZW50TGlzdGVuZXIobCwgc1sxXSwgbCA9PT0gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLmhhbmRsZVdpbmRvd0V2ZW50IDogdGhpcy5oYW5kbGVFdmVudCwgc1syXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGdyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIG8gPSB0aGlzLl9saXN0ZW5lcnM7IGUgPCBvLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciByID0gb1tlXSxcbiAgICAgICAgICAgIGEgPSByWzBdO1xuICAgICAgICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgclsxXSwgYSA9PT0gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLmhhbmRsZVdpbmRvd0V2ZW50IDogdGhpcy5oYW5kbGVFdmVudCwgclsyXSk7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9hZGREZWZhdWx0SGFuZGxlcnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgaSA9IGUuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICAgIHRoaXMuX2FkZChcIm1hcEV2ZW50XCIsIG5ldyBPbyhlLCB0KSk7XG5cbiAgICAgIHZhciBvID0gZS5ib3hab29tID0gbmV3IFVvKGUsIHQpO1xuXG4gICAgICB0aGlzLl9hZGQoXCJib3hab29tXCIsIG8pO1xuXG4gICAgICB2YXIgciA9IG5ldyBqbygpLFxuICAgICAgICAgIGEgPSBuZXcgY3IoKTtcbiAgICAgIGUuZG91YmxlQ2xpY2tab29tID0gbmV3IGxyKGEsIHIpLCB0aGlzLl9hZGQoXCJ0YXBab29tXCIsIHIpLCB0aGlzLl9hZGQoXCJjbGlja1pvb21cIiwgYSk7XG4gICAgICB2YXIgbiA9IG5ldyB1cigpO1xuXG4gICAgICB0aGlzLl9hZGQoXCJ0YXBEcmFnWm9vbVwiLCBuKTtcblxuICAgICAgdmFyIHMgPSBlLnRvdWNoUGl0Y2ggPSBuZXcgb3IoKTtcblxuICAgICAgdGhpcy5fYWRkKFwidG91Y2hQaXRjaFwiLCBzKTtcblxuICAgICAgdmFyIGwgPSBuZXcgWG8odCksXG4gICAgICAgICAgYyA9IG5ldyBIbyh0KTtcbiAgICAgIGUuZHJhZ1JvdGF0ZSA9IG5ldyBwcih0LCBsLCBjKSwgdGhpcy5fYWRkKFwibW91c2VSb3RhdGVcIiwgbCwgW1wibW91c2VQaXRjaFwiXSksIHRoaXMuX2FkZChcIm1vdXNlUGl0Y2hcIiwgYywgW1wibW91c2VSb3RhdGVcIl0pO1xuICAgICAgdmFyIHUgPSBuZXcgV28odCksXG4gICAgICAgICAgaCA9IG5ldyBLbyh0KTtcbiAgICAgIGUuZHJhZ1BhbiA9IG5ldyBocihpLCB1LCBoKSwgdGhpcy5fYWRkKFwibW91c2VQYW5cIiwgdSksIHRoaXMuX2FkZChcInRvdWNoUGFuXCIsIGgsIFtcInRvdWNoWm9vbVwiLCBcInRvdWNoUm90YXRlXCJdKTtcbiAgICAgIHZhciBwID0gbmV3IGVyKCksXG4gICAgICAgICAgZCA9IG5ldyAkbygpO1xuICAgICAgZS50b3VjaFpvb21Sb3RhdGUgPSBuZXcgZHIoaSwgZCwgcCwgbiksIHRoaXMuX2FkZChcInRvdWNoUm90YXRlXCIsIHAsIFtcInRvdWNoUGFuXCIsIFwidG91Y2hab29tXCJdKSwgdGhpcy5fYWRkKFwidG91Y2hab29tXCIsIGQsIFtcInRvdWNoUGFuXCIsIFwidG91Y2hSb3RhdGVcIl0pO1xuXG4gICAgICB2YXIgXyA9IGUuc2Nyb2xsWm9vbSA9IG5ldyBzcihlLCB0aGlzKTtcblxuICAgICAgdGhpcy5fYWRkKFwic2Nyb2xsWm9vbVwiLCBfLCBbXCJtb3VzZVBhblwiXSk7XG5cbiAgICAgIHZhciBmID0gZS5rZXlib2FyZCA9IG5ldyBhcigpO1xuICAgICAgdGhpcy5fYWRkKFwia2V5Ym9hcmRcIiwgZiksIHRoaXMuX2FkZChcImJsb2NrYWJsZU1hcEV2ZW50XCIsIG5ldyBGbyhlKSk7XG5cbiAgICAgIGZvciAodmFyIG0gPSAwLCBnID0gW1wiYm94Wm9vbVwiLCBcImRvdWJsZUNsaWNrWm9vbVwiLCBcInRhcERyYWdab29tXCIsIFwidG91Y2hQaXRjaFwiLCBcImRyYWdSb3RhdGVcIiwgXCJkcmFnUGFuXCIsIFwidG91Y2hab29tUm90YXRlXCIsIFwic2Nyb2xsWm9vbVwiLCBcImtleWJvYXJkXCJdOyBtIDwgZy5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgdiA9IGdbbV07XG4gICAgICAgIHQuaW50ZXJhY3RpdmUgJiYgdFt2XSAmJiBlW3ZdLmVuYWJsZSh0W3ZdKTtcbiAgICAgIH1cbiAgICB9LCBnci5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgaGFuZGxlck5hbWU6IHQsXG4gICAgICAgIGhhbmRsZXI6IGUsXG4gICAgICAgIGFsbG93ZWQ6IGlcbiAgICAgIH0pLCB0aGlzLl9oYW5kbGVyc0J5SWRbdF0gPSBlO1xuICAgIH0sIGdyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICghdGhpcy5fdXBkYXRpbmdDYW1lcmEpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIGkgPSB0aGlzLl9oYW5kbGVyczsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICBpW2VdLmhhbmRsZXIucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2luZXJ0aWEuY2xlYXIoKSwgdGhpcy5fZmlyZUV2ZW50cyh7fSwge30sIHQpLCB0aGlzLl9jaGFuZ2VzID0gW107XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSB0aGlzLl9oYW5kbGVyczsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIHtcbiAgICAgICAgaWYgKGVbdF0uaGFuZGxlci5pc0FjdGl2ZSgpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBnci5wcm90b3R5cGUuaXNab29taW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZXZlbnRzSW5Qcm9ncmVzcy56b29tIHx8IHRoaXMuX21hcC5zY3JvbGxab29tLmlzWm9vbWluZygpO1xuICAgIH0sIGdyLnByb3RvdHlwZS5pc1JvdGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZXZlbnRzSW5Qcm9ncmVzcy5yb3RhdGU7XG4gICAgfSwgZ3IucHJvdG90eXBlLmlzTW92aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oX3IodGhpcy5fZXZlbnRzSW5Qcm9ncmVzcykpIHx8IHRoaXMuaXNab29taW5nKCk7XG4gICAgfSwgZ3IucHJvdG90eXBlLl9ibG9ja2VkQnlBY3RpdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgZm9yICh2YXIgbyBpbiB0KSB7XG4gICAgICAgIGlmIChvICE9PSBpICYmICghZSB8fCBlLmluZGV4T2YobykgPCAwKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZ3IucHJvdG90eXBlLmhhbmRsZVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXZlbnQodCwgdC50eXBlICsgXCJXaW5kb3dcIik7XG4gICAgfSwgZ3IucHJvdG90eXBlLl9nZXRNYXBUb3VjaGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IDAsIG8gPSB0OyBpIDwgby5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgciA9IG9baV07XG4gICAgICAgIHRoaXMuX2VsLmNvbnRhaW5zKHIudGFyZ2V0KSAmJiBlLnB1c2gocik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH0sIGdyLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoXCJibHVyXCIgIT09IHQudHlwZSkge1xuICAgICAgICB0aGlzLl91cGRhdGluZ0NhbWVyYSA9ICEwO1xuXG4gICAgICAgIGZvciAodmFyIG8gPSBcInJlbmRlckZyYW1lXCIgPT09IHQudHlwZSA/IHZvaWQgMCA6IHQsIHIgPSB7XG4gICAgICAgICAgbmVlZHNSZW5kZXJGcmFtZTogITFcbiAgICAgICAgfSwgYSA9IHt9LCBuID0ge30sIHMgPSB0LnRvdWNoZXMgPyB0aGlzLl9nZXRNYXBUb3VjaGVzKHQudG91Y2hlcykgOiB2b2lkIDAsIGwgPSBzID8gaS50b3VjaFBvcyh0aGlzLl9lbCwgcykgOiBpLm1vdXNlUG9zKHRoaXMuX2VsLCB0KSwgYyA9IDAsIHUgPSB0aGlzLl9oYW5kbGVyczsgYyA8IHUubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICB2YXIgaCA9IHVbY10sXG4gICAgICAgICAgICAgIHAgPSBoLmhhbmRsZXJOYW1lLFxuICAgICAgICAgICAgICBkID0gaC5oYW5kbGVyLFxuICAgICAgICAgICAgICBfID0gaC5hbGxvd2VkO1xuXG4gICAgICAgICAgaWYgKGQuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBmID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tlZEJ5QWN0aXZlKG4sIF8sIHApID8gZC5yZXNldCgpIDogZFtlIHx8IHQudHlwZV0gJiYgKGYgPSBkW2UgfHwgdC50eXBlXSh0LCBsLCBzKSwgdGhpcy5tZXJnZUhhbmRsZXJSZXN1bHQociwgYSwgZiwgcCwgbyksIGYgJiYgZi5uZWVkc1JlbmRlckZyYW1lICYmIHRoaXMuX3RyaWdnZXJSZW5kZXJGcmFtZSgpKSwgKGYgfHwgZC5pc0FjdGl2ZSgpKSAmJiAobltwXSA9IGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgZyBpbiB0aGlzLl9wcmV2aW91c0FjdGl2ZUhhbmRsZXJzKSB7XG4gICAgICAgICAgbltnXSB8fCAobVtnXSA9IG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJldmlvdXNBY3RpdmVIYW5kbGVycyA9IG4sIChPYmplY3Qua2V5cyhtKS5sZW5ndGggfHwgbXIocikpICYmICh0aGlzLl9jaGFuZ2VzLnB1c2goW3IsIGEsIG1dKSwgdGhpcy5fdHJpZ2dlclJlbmRlckZyYW1lKCkpLCAoT2JqZWN0LmtleXMobikubGVuZ3RoIHx8IG1yKHIpKSAmJiB0aGlzLl9tYXAuX3N0b3AoITApLCB0aGlzLl91cGRhdGluZ0NhbWVyYSA9ICExO1xuICAgICAgICB2YXIgdiA9IHIuY2FtZXJhQW5pbWF0aW9uO1xuICAgICAgICB2ICYmICh0aGlzLl9pbmVydGlhLmNsZWFyKCksIHRoaXMuX2ZpcmVFdmVudHMoe30sIHt9LCAhMCksIHRoaXMuX2NoYW5nZXMgPSBbXSwgdih0aGlzLl9tYXApKTtcbiAgICAgIH0gZWxzZSB0aGlzLnN0b3AoITApO1xuICAgIH0sIGdyLnByb3RvdHlwZS5tZXJnZUhhbmRsZXJSZXN1bHQgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdC5leHRlbmQoZSwgbyk7XG4gICAgICAgIHZhciBuID0ge1xuICAgICAgICAgIGhhbmRsZXJOYW1lOiByLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG8ub3JpZ2luYWxFdmVudCB8fCBhXG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgMCAhPT0gby56b29tRGVsdGEgJiYgKGkuem9vbSA9IG4pLCB2b2lkIDAgIT09IG8ucGFuRGVsdGEgJiYgKGkuZHJhZyA9IG4pLCB2b2lkIDAgIT09IG8ucGl0Y2hEZWx0YSAmJiAoaS5waXRjaCA9IG4pLCB2b2lkIDAgIT09IG8uYmVhcmluZ0RlbHRhICYmIChpLnJvdGF0ZSA9IG4pO1xuICAgICAgfVxuICAgIH0sIGdyLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgZSA9IHt9LCBpID0ge30sIG8gPSB7fSwgciA9IDAsIGEgPSB0aGlzLl9jaGFuZ2VzOyByIDwgYS5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IGFbcl0sXG4gICAgICAgICAgICBzID0gblswXSxcbiAgICAgICAgICAgIGwgPSBuWzFdLFxuICAgICAgICAgICAgYyA9IG5bMl07XG4gICAgICAgIHMucGFuRGVsdGEgJiYgKGUucGFuRGVsdGEgPSAoZS5wYW5EZWx0YSB8fCBuZXcgdC5Qb2ludCgwLCAwKSkuX2FkZChzLnBhbkRlbHRhKSksIHMuem9vbURlbHRhICYmIChlLnpvb21EZWx0YSA9IChlLnpvb21EZWx0YSB8fCAwKSArIHMuem9vbURlbHRhKSwgcy5iZWFyaW5nRGVsdGEgJiYgKGUuYmVhcmluZ0RlbHRhID0gKGUuYmVhcmluZ0RlbHRhIHx8IDApICsgcy5iZWFyaW5nRGVsdGEpLCBzLnBpdGNoRGVsdGEgJiYgKGUucGl0Y2hEZWx0YSA9IChlLnBpdGNoRGVsdGEgfHwgMCkgKyBzLnBpdGNoRGVsdGEpLCB2b2lkIDAgIT09IHMuYXJvdW5kICYmIChlLmFyb3VuZCA9IHMuYXJvdW5kKSwgdm9pZCAwICE9PSBzLnBpbmNoQXJvdW5kICYmIChlLnBpbmNoQXJvdW5kID0gcy5waW5jaEFyb3VuZCksIHMubm9JbmVydGlhICYmIChlLm5vSW5lcnRpYSA9IHMubm9JbmVydGlhKSwgdC5leHRlbmQoaSwgbCksIHQuZXh0ZW5kKG8sIGMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVNYXBUcmFuc2Zvcm0oZSwgaSwgbyksIHRoaXMuX2NoYW5nZXMgPSBbXTtcbiAgICB9LCBnci5wcm90b3R5cGUuX3VwZGF0ZU1hcFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuX21hcCxcbiAgICAgICAgICByID0gby50cmFuc2Zvcm07XG4gICAgICBpZiAoIW1yKHQpKSByZXR1cm4gdGhpcy5fZmlyZUV2ZW50cyhlLCBpLCAhMCk7XG4gICAgICB2YXIgYSA9IHQucGFuRGVsdGEsXG4gICAgICAgICAgbiA9IHQuem9vbURlbHRhLFxuICAgICAgICAgIHMgPSB0LmJlYXJpbmdEZWx0YSxcbiAgICAgICAgICBsID0gdC5waXRjaERlbHRhLFxuICAgICAgICAgIGMgPSB0LmFyb3VuZCxcbiAgICAgICAgICB1ID0gdC5waW5jaEFyb3VuZDtcbiAgICAgIHZvaWQgMCAhPT0gdSAmJiAoYyA9IHUpLCBvLl9zdG9wKCEwKSwgYyA9IGMgfHwgby50cmFuc2Zvcm0uY2VudGVyUG9pbnQ7XG4gICAgICB2YXIgaCA9IHIucG9pbnRMb2NhdGlvbihhID8gYy5zdWIoYSkgOiBjKTtcbiAgICAgIHMgJiYgKHIuYmVhcmluZyArPSBzKSwgbCAmJiAoci5waXRjaCArPSBsKSwgbiAmJiAoci56b29tICs9IG4pLCByLnNldExvY2F0aW9uQXRQb2ludChoLCBjKSwgdGhpcy5fbWFwLl91cGRhdGUoKSwgdC5ub0luZXJ0aWEgfHwgdGhpcy5faW5lcnRpYS5yZWNvcmQodCksIHRoaXMuX2ZpcmVFdmVudHMoZSwgaSwgITApO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fZmlyZUV2ZW50cyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgICAgYSA9IF9yKHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIG4gPSBfcihlKSxcbiAgICAgICAgICBzID0ge307XG5cbiAgICAgIGZvciAodmFyIGwgaW4gZSkge1xuICAgICAgICB0aGlzLl9ldmVudHNJblByb2dyZXNzW2xdIHx8IChzW2wgKyBcInN0YXJ0XCJdID0gZVtsXS5vcmlnaW5hbEV2ZW50KSwgdGhpcy5fZXZlbnRzSW5Qcm9ncmVzc1tsXSA9IGVbbF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGMgaW4gIWEgJiYgbiAmJiB0aGlzLl9maXJlRXZlbnQoXCJtb3Zlc3RhcnRcIiwgbi5vcmlnaW5hbEV2ZW50KSwgcykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoYywgc1tjXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHUgaW4gbiAmJiB0aGlzLl9maXJlRXZlbnQoXCJtb3ZlXCIsIG4ub3JpZ2luYWxFdmVudCksIGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KHUsIGVbdV0ub3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoLFxuICAgICAgICAgIHAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLl9ldmVudHNJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fZXZlbnRzSW5Qcm9ncmVzc1tkXSxcbiAgICAgICAgICAgIGYgPSBfLmhhbmRsZXJOYW1lLFxuICAgICAgICAgICAgbSA9IF8ub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy5faGFuZGxlcnNCeUlkW2ZdLmlzQWN0aXZlKCkgfHwgKGRlbGV0ZSB0aGlzLl9ldmVudHNJblByb2dyZXNzW2RdLCBwW2QgKyBcImVuZFwiXSA9IGggPSBpW2ZdIHx8IG0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBnIGluIHApIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KGcsIHBbZ10pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdiA9IF9yKHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAobyAmJiAoYSB8fCBuKSAmJiAhdikge1xuICAgICAgICB0aGlzLl91cGRhdGluZ0NhbWVyYSA9ICEwO1xuXG4gICAgICAgIHZhciB5ID0gdGhpcy5faW5lcnRpYS5fb25Nb3ZlRW5kKHRoaXMuX21hcC5kcmFnUGFuLl9pbmVydGlhT3B0aW9ucyksXG4gICAgICAgICAgICB4ID0gZnVuY3Rpb24geCh0KSB7XG4gICAgICAgICAgcmV0dXJuIDAgIT09IHQgJiYgLXIuX2JlYXJpbmdTbmFwIDwgdCAmJiB0IDwgci5fYmVhcmluZ1NuYXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgeSA/ICh4KHkuYmVhcmluZyB8fCB0aGlzLl9tYXAuZ2V0QmVhcmluZygpKSAmJiAoeS5iZWFyaW5nID0gMCksIHRoaXMuX21hcC5lYXNlVG8oeSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGhcbiAgICAgICAgfSkpIDogKHRoaXMuX21hcC5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogaFxuICAgICAgICB9KSksIHgodGhpcy5fbWFwLmdldEJlYXJpbmcoKSkgJiYgdGhpcy5fbWFwLnJlc2V0Tm9ydGgoKSksIHRoaXMuX3VwZGF0aW5nQ2FtZXJhID0gITE7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9maXJlRXZlbnQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IHQuRXZlbnQoZSwgaSA/IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogaVxuICAgICAgfSA6IHt9KSk7XG4gICAgfSwgZ3IucHJvdG90eXBlLl9yZXF1ZXN0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLnRyaWdnZXJSZXBhaW50KCksIHRoaXMuX21hcC5fcmVuZGVyVGFza1F1ZXVlLmFkZChmdW5jdGlvbiAoZSkge1xuICAgICAgICBkZWxldGUgdC5fZnJhbWVJZCwgdC5oYW5kbGVFdmVudChuZXcgZnIoXCJyZW5kZXJGcmFtZVwiLCB7XG4gICAgICAgICAgdGltZVN0YW1wOiBlXG4gICAgICAgIH0pKSwgdC5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9LCBnci5wcm90b3R5cGUuX3RyaWdnZXJSZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZvaWQgMCA9PT0gdGhpcy5fZnJhbWVJZCAmJiAodGhpcy5fZnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RGcmFtZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIHZyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSwgbykge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuX21vdmluZyA9ICExLCB0aGlzLl96b29taW5nID0gITEsIHRoaXMudHJhbnNmb3JtID0gaSwgdGhpcy5fYmVhcmluZ1NuYXAgPSBvLmJlYXJpbmdTbmFwLCB0LmJpbmRBbGwoW1wiX3JlbmRlckZyYW1lQ2FsbGJhY2tcIl0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdC5MbmdMYXQodGhpcy50cmFuc2Zvcm0uY2VudGVyLmxuZywgdGhpcy50cmFuc2Zvcm0uY2VudGVyLmxhdCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qdW1wVG8oe1xuICAgICAgICAgIGNlbnRlcjogdFxuICAgICAgICB9LCBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBhbkJ5ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIGUgPSB0LlBvaW50LmNvbnZlcnQoZSkubXVsdCgtMSksIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB0LmV4dGVuZCh7XG4gICAgICAgICAgb2Zmc2V0OiBlXG4gICAgICAgIH0sIGkpLCBvKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBhblRvID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHQuZXh0ZW5kKHtcbiAgICAgICAgICBjZW50ZXI6IGVcbiAgICAgICAgfSwgaSksIG8pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnpvb207XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICB6b29tOiB0XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHQuZXh0ZW5kKHtcbiAgICAgICAgICB6b29tOiBlXG4gICAgICAgIH0sIGkpLCBvKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnpvb21JbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20oKSArIDEsIHQsIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuem9vbU91dCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20oKSAtIDEsIHQsIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0QmVhcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmJlYXJpbmc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRCZWFyaW5nID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICBiZWFyaW5nOiB0XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBhZGRpbmc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRQYWRkaW5nID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICBwYWRkaW5nOiB0XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUucm90YXRlVG8gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odC5leHRlbmQoe1xuICAgICAgICAgIGJlYXJpbmc6IGVcbiAgICAgICAgfSwgaSksIG8pO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVzZXROb3J0aCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVRvKDAsIHQuZXh0ZW5kKHtcbiAgICAgICAgICBkdXJhdGlvbjogMWUzXG4gICAgICAgIH0sIGUpLCBpKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlc2V0Tm9ydGhQaXRjaCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgICBwaXRjaDogMCxcbiAgICAgICAgICBkdXJhdGlvbjogMWUzXG4gICAgICAgIH0sIGUpLCBpKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnNuYXBUb05vcnRoID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0QmVhcmluZygpKSA8IHRoaXMuX2JlYXJpbmdTbmFwID8gdGhpcy5yZXNldE5vcnRoKHQsIGUpIDogdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFBpdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl0Y2g7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRQaXRjaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bXBUbyh7XG4gICAgICAgICAgcGl0Y2g6IHRcbiAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5jYW1lcmFGb3JCb3VuZHMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBlID0gdC5MbmdMYXRCb3VuZHMuY29udmVydChlKTtcbiAgICAgICAgdmFyIG8gPSBpICYmIGkuYmVhcmluZyB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhRm9yQm94QW5kQmVhcmluZyhlLmdldE5vcnRoV2VzdCgpLCBlLmdldFNvdXRoRWFzdCgpLCBvLCBpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9jYW1lcmFGb3JCb3hBbmRCZWFyaW5nID0gZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIChyID0gdC5leHRlbmQoe1xuICAgICAgICAgIHBhZGRpbmc6IGEsXG4gICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgbWF4Wm9vbTogdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbVxuICAgICAgICB9LCByKSkucGFkZGluZykge1xuICAgICAgICAgIHZhciBuID0gci5wYWRkaW5nO1xuICAgICAgICAgIHIucGFkZGluZyA9IHtcbiAgICAgICAgICAgIHRvcDogbixcbiAgICAgICAgICAgIGJvdHRvbTogbixcbiAgICAgICAgICAgIHJpZ2h0OiBuLFxuICAgICAgICAgICAgbGVmdDogblxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByLnBhZGRpbmcgPSB0LmV4dGVuZChhLCByLnBhZGRpbmcpO1xuXG4gICAgICAgIHZhciBzID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBsID0gcy5wYWRkaW5nLFxuICAgICAgICAgICAgYyA9IHMucHJvamVjdCh0LkxuZ0xhdC5jb252ZXJ0KGUpKSxcbiAgICAgICAgICAgIHUgPSBzLnByb2plY3QodC5MbmdMYXQuY29udmVydChpKSksXG4gICAgICAgICAgICBoID0gYy5yb3RhdGUoLW8gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgICAgIHAgPSB1LnJvdGF0ZSgtbyAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgZCA9IG5ldyB0LlBvaW50KE1hdGgubWF4KGgueCwgcC54KSwgTWF0aC5tYXgoaC55LCBwLnkpKSxcbiAgICAgICAgICAgIF8gPSBuZXcgdC5Qb2ludChNYXRoLm1pbihoLngsIHAueCksIE1hdGgubWluKGgueSwgcC55KSksXG4gICAgICAgICAgICBmID0gZC5zdWIoXyksXG4gICAgICAgICAgICBtID0gKHMud2lkdGggLSAobC5sZWZ0ICsgbC5yaWdodCArIHIucGFkZGluZy5sZWZ0ICsgci5wYWRkaW5nLnJpZ2h0KSkgLyBmLngsXG4gICAgICAgICAgICBnID0gKHMuaGVpZ2h0IC0gKGwudG9wICsgbC5ib3R0b20gKyByLnBhZGRpbmcudG9wICsgci5wYWRkaW5nLmJvdHRvbSkpIC8gZi55O1xuXG4gICAgICAgIGlmICghKGcgPCAwIHx8IG0gPCAwKSkge1xuICAgICAgICAgIHZhciB2ID0gTWF0aC5taW4ocy5zY2FsZVpvb20ocy5zY2FsZSAqIE1hdGgubWluKG0sIGcpKSwgci5tYXhab29tKSxcbiAgICAgICAgICAgICAgeSA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIHIub2Zmc2V0LnggPyBuZXcgdC5Qb2ludChyLm9mZnNldC54LCByLm9mZnNldC55KSA6IHQuUG9pbnQuY29udmVydChyLm9mZnNldCksXG4gICAgICAgICAgICAgIHggPSBuZXcgdC5Qb2ludCgoci5wYWRkaW5nLmxlZnQgLSByLnBhZGRpbmcucmlnaHQpIC8gMiwgKHIucGFkZGluZy50b3AgLSByLnBhZGRpbmcuYm90dG9tKSAvIDIpLnJvdGF0ZShvICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICAgIGIgPSB5LmFkZCh4KS5tdWx0KHMuc2NhbGUgLyBzLnpvb21TY2FsZSh2KSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogcy51bnByb2plY3QoYy5hZGQodSkuZGl2KDIpLnN1YihiKSksXG4gICAgICAgICAgICB6b29tOiB2LFxuICAgICAgICAgICAgYmVhcmluZzogb1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0Lndhcm5PbmNlKFwiTWFwIGNhbm5vdCBmaXQgd2l0aGluIGNhbnZhcyB3aXRoIHRoZSBnaXZlbiBib3VuZHMsIHBhZGRpbmcsIGFuZC9vciBvZmZzZXQuXCIpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZml0Qm91bmRzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpdEludGVybmFsKHRoaXMuY2FtZXJhRm9yQm91bmRzKHQsIGUpLCBlLCBpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmZpdFNjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpdEludGVybmFsKHRoaXMuX2NhbWVyYUZvckJveEFuZEJlYXJpbmcodGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0LlBvaW50LmNvbnZlcnQoZSkpLCB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHQuUG9pbnQuY29udmVydChpKSksIG8sIHIpLCByLCBhKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9maXRJbnRlcm5hbCA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiBlID8gKGRlbGV0ZSAoaSA9IHQuZXh0ZW5kKGUsIGkpKS5wYWRkaW5nLCBpLmxpbmVhciA/IHRoaXMuZWFzZVRvKGksIG8pIDogdGhpcy5mbHlUbyhpLCBvKSkgOiB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuanVtcFRvID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHZhciBvID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICByID0gITEsXG4gICAgICAgICAgICBhID0gITEsXG4gICAgICAgICAgICBuID0gITE7XG4gICAgICAgIHJldHVybiBcInpvb21cIiBpbiBlICYmIG8uem9vbSAhPT0gK2Uuem9vbSAmJiAociA9ICEwLCBvLnpvb20gPSArZS56b29tKSwgdm9pZCAwICE9PSBlLmNlbnRlciAmJiAoby5jZW50ZXIgPSB0LkxuZ0xhdC5jb252ZXJ0KGUuY2VudGVyKSksIFwiYmVhcmluZ1wiIGluIGUgJiYgby5iZWFyaW5nICE9PSArZS5iZWFyaW5nICYmIChhID0gITAsIG8uYmVhcmluZyA9ICtlLmJlYXJpbmcpLCBcInBpdGNoXCIgaW4gZSAmJiBvLnBpdGNoICE9PSArZS5waXRjaCAmJiAobiA9ICEwLCBvLnBpdGNoID0gK2UucGl0Y2gpLCBudWxsID09IGUucGFkZGluZyB8fCBvLmlzUGFkZGluZ0VxdWFsKGUucGFkZGluZykgfHwgKG8ucGFkZGluZyA9IGUucGFkZGluZyksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVzdGFydFwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcIm1vdmVcIiwgaSkpLCByICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInpvb21zdGFydFwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInpvb21cIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tZW5kXCIsIGkpKSwgYSAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVzdGFydFwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZVwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZWVuZFwiLCBpKSksIG4gJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicGl0Y2hzdGFydFwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInBpdGNoXCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwicGl0Y2hlbmRcIiwgaSkpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJtb3ZlZW5kXCIsIGkpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmVhc2VUbyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RvcCghMSwgZS5lYXNlSWQpLCAoITEgPT09IChlID0gdC5leHRlbmQoe1xuICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgZWFzaW5nOiB0LmVhc2VcbiAgICAgICAgfSwgZSkpLmFuaW1hdGUgfHwgIWUuZXNzZW50aWFsICYmIHQuYnJvd3Nlci5wcmVmZXJzUmVkdWNlZE1vdGlvbikgJiYgKGUuZHVyYXRpb24gPSAwKTtcblxuICAgICAgICB2YXIgciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgYSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgbiA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgcyA9IHRoaXMuZ2V0UGl0Y2goKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgICAgIGMgPSBcInpvb21cIiBpbiBlID8gK2Uuem9vbSA6IGEsXG4gICAgICAgICAgICB1ID0gXCJiZWFyaW5nXCIgaW4gZSA/IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcoZS5iZWFyaW5nLCBuKSA6IG4sXG4gICAgICAgICAgICBoID0gXCJwaXRjaFwiIGluIGUgPyArZS5waXRjaCA6IHMsXG4gICAgICAgICAgICBwID0gXCJwYWRkaW5nXCIgaW4gZSA/IGUucGFkZGluZyA6IHIucGFkZGluZyxcbiAgICAgICAgICAgIGQgPSB0LlBvaW50LmNvbnZlcnQoZS5vZmZzZXQpLFxuICAgICAgICAgICAgXyA9IHIuY2VudGVyUG9pbnQuYWRkKGQpLFxuICAgICAgICAgICAgZiA9IHIucG9pbnRMb2NhdGlvbihfKSxcbiAgICAgICAgICAgIG0gPSB0LkxuZ0xhdC5jb252ZXJ0KGUuY2VudGVyIHx8IGYpO1xuXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZUNlbnRlcihtKTtcblxuICAgICAgICB2YXIgZyxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICB5ID0gci5wcm9qZWN0KGYpLFxuICAgICAgICAgICAgeCA9IHIucHJvamVjdChtKS5zdWIoeSksXG4gICAgICAgICAgICBiID0gci56b29tU2NhbGUoYyAtIGEpO1xuICAgICAgICBlLmFyb3VuZCAmJiAoZyA9IHQuTG5nTGF0LmNvbnZlcnQoZS5hcm91bmQpLCB2ID0gci5sb2NhdGlvblBvaW50KGcpKTtcbiAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgbW92aW5nOiB0aGlzLl9tb3ZpbmcsXG4gICAgICAgICAgem9vbWluZzogdGhpcy5fem9vbWluZyxcbiAgICAgICAgICByb3RhdGluZzogdGhpcy5fcm90YXRpbmcsXG4gICAgICAgICAgcGl0Y2hpbmc6IHRoaXMuX3BpdGNoaW5nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl96b29taW5nID0gdGhpcy5fem9vbWluZyB8fCBjICE9PSBhLCB0aGlzLl9yb3RhdGluZyA9IHRoaXMuX3JvdGF0aW5nIHx8IG4gIT09IHUsIHRoaXMuX3BpdGNoaW5nID0gdGhpcy5fcGl0Y2hpbmcgfHwgaCAhPT0gcywgdGhpcy5fcGFkZGluZyA9ICFyLmlzUGFkZGluZ0VxdWFsKHApLCB0aGlzLl9lYXNlSWQgPSBlLmVhc2VJZCwgdGhpcy5fcHJlcGFyZUVhc2UoaSwgZS5ub01vdmVTdGFydCwgdyksIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoby5fem9vbWluZyAmJiAoci56b29tID0gdC5udW1iZXIoYSwgYywgZSkpLCBvLl9yb3RhdGluZyAmJiAoci5iZWFyaW5nID0gdC5udW1iZXIobiwgdSwgZSkpLCBvLl9waXRjaGluZyAmJiAoci5waXRjaCA9IHQubnVtYmVyKHMsIGgsIGUpKSwgby5fcGFkZGluZyAmJiAoci5pbnRlcnBvbGF0ZVBhZGRpbmcobCwgcCwgZSksIF8gPSByLmNlbnRlclBvaW50LmFkZChkKSksIGcpIHIuc2V0TG9jYXRpb25BdFBvaW50KGcsIHYpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSByLnpvb21TY2FsZShyLnpvb20gLSBhKSxcbiAgICAgICAgICAgICAgICBtID0gYyA+IGEgPyBNYXRoLm1pbigyLCBiKSA6IE1hdGgubWF4KC41LCBiKSxcbiAgICAgICAgICAgICAgICB3ID0gTWF0aC5wb3cobSwgMSAtIGUpLFxuICAgICAgICAgICAgICAgIFQgPSByLnVucHJvamVjdCh5LmFkZCh4Lm11bHQoZSAqIHcpKS5tdWx0KGYpKTtcbiAgICAgICAgICAgIHIuc2V0TG9jYXRpb25BdFBvaW50KHIucmVuZGVyV29ybGRDb3BpZXMgPyBULndyYXAoKSA6IFQsIF8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG8uX2ZpcmVNb3ZlRXZlbnRzKGkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIG8uX2FmdGVyRWFzZShpLCB0KTtcbiAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcHJlcGFyZUVhc2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuX21vdmluZyA9ICEwLCBpIHx8IG8ubW92aW5nIHx8IHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVzdGFydFwiLCBlKSksIHRoaXMuX3pvb21pbmcgJiYgIW8uem9vbWluZyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tc3RhcnRcIiwgZSkpLCB0aGlzLl9yb3RhdGluZyAmJiAhby5yb3RhdGluZyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVzdGFydFwiLCBlKSksIHRoaXMuX3BpdGNoaW5nICYmICFvLnBpdGNoaW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoc3RhcnRcIiwgZSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2ZpcmVNb3ZlRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZVwiLCBlKSksIHRoaXMuX3pvb21pbmcgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiem9vbVwiLCBlKSksIHRoaXMuX3JvdGF0aW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZVwiLCBlKSksIHRoaXMuX3BpdGNoaW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoXCIsIGUpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9hZnRlckVhc2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAoIXRoaXMuX2Vhc2VJZCB8fCAhaSB8fCB0aGlzLl9lYXNlSWQgIT09IGkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZWFzZUlkO1xuICAgICAgICAgIHZhciBvID0gdGhpcy5fem9vbWluZyxcbiAgICAgICAgICAgICAgciA9IHRoaXMuX3JvdGF0aW5nLFxuICAgICAgICAgICAgICBhID0gdGhpcy5fcGl0Y2hpbmc7XG4gICAgICAgICAgdGhpcy5fbW92aW5nID0gITEsIHRoaXMuX3pvb21pbmcgPSAhMSwgdGhpcy5fcm90YXRpbmcgPSAhMSwgdGhpcy5fcGl0Y2hpbmcgPSAhMSwgdGhpcy5fcGFkZGluZyA9ICExLCBvICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInpvb21lbmRcIiwgZSkpLCByICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZWVuZFwiLCBlKSksIGEgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicGl0Y2hlbmRcIiwgZSkpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJtb3ZlZW5kXCIsIGUpKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuZmx5VG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFlLmVzc2VudGlhbCAmJiB0LmJyb3dzZXIucHJlZmVyc1JlZHVjZWRNb3Rpb24pIHtcbiAgICAgICAgICB2YXIgciA9IHQucGljayhlLCBbXCJjZW50ZXJcIiwgXCJ6b29tXCIsIFwiYmVhcmluZ1wiLCBcInBpdGNoXCIsIFwiYXJvdW5kXCJdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5qdW1wVG8ociwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3AoKSwgZSA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICBzcGVlZDogMS4yLFxuICAgICAgICAgIGN1cnZlOiAxLjQyLFxuICAgICAgICAgIGVhc2luZzogdC5lYXNlXG4gICAgICAgIH0sIGUpO1xuXG4gICAgICAgIHZhciBhID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBuID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzID0gdGhpcy5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBsID0gdGhpcy5nZXRQaXRjaCgpLFxuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgdSA9IFwiem9vbVwiIGluIGUgPyB0LmNsYW1wKCtlLnpvb20sIGEubWluWm9vbSwgYS5tYXhab29tKSA6IG4sXG4gICAgICAgICAgICBoID0gXCJiZWFyaW5nXCIgaW4gZSA/IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcoZS5iZWFyaW5nLCBzKSA6IHMsXG4gICAgICAgICAgICBwID0gXCJwaXRjaFwiIGluIGUgPyArZS5waXRjaCA6IGwsXG4gICAgICAgICAgICBkID0gXCJwYWRkaW5nXCIgaW4gZSA/IGUucGFkZGluZyA6IGEucGFkZGluZyxcbiAgICAgICAgICAgIF8gPSBhLnpvb21TY2FsZSh1IC0gbiksXG4gICAgICAgICAgICBmID0gdC5Qb2ludC5jb252ZXJ0KGUub2Zmc2V0KSxcbiAgICAgICAgICAgIG0gPSBhLmNlbnRlclBvaW50LmFkZChmKSxcbiAgICAgICAgICAgIGcgPSBhLnBvaW50TG9jYXRpb24obSksXG4gICAgICAgICAgICB2ID0gdC5MbmdMYXQuY29udmVydChlLmNlbnRlciB8fCBnKTtcblxuICAgICAgICB0aGlzLl9ub3JtYWxpemVDZW50ZXIodik7XG5cbiAgICAgICAgdmFyIHkgPSBhLnByb2plY3QoZyksXG4gICAgICAgICAgICB4ID0gYS5wcm9qZWN0KHYpLnN1Yih5KSxcbiAgICAgICAgICAgIGIgPSBlLmN1cnZlLFxuICAgICAgICAgICAgdyA9IE1hdGgubWF4KGEud2lkdGgsIGEuaGVpZ2h0KSxcbiAgICAgICAgICAgIFQgPSB3IC8gXyxcbiAgICAgICAgICAgIEUgPSB4Lm1hZygpO1xuXG4gICAgICAgIGlmIChcIm1pblpvb21cIiBpbiBlKSB7XG4gICAgICAgICAgdmFyIEkgPSB0LmNsYW1wKE1hdGgubWluKGUubWluWm9vbSwgbiwgdSksIGEubWluWm9vbSwgYS5tYXhab29tKSxcbiAgICAgICAgICAgICAgUCA9IHcgLyBhLnpvb21TY2FsZShJIC0gbik7XG4gICAgICAgICAgYiA9IE1hdGguc3FydChQIC8gRSAqIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFMgPSBiICogYjtcblxuICAgICAgICBmdW5jdGlvbiBDKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IChUICogVCAtIHcgKiB3ICsgKHQgPyAtMSA6IDEpICogUyAqIFMgKiBFICogRSkgLyAoMiAqICh0ID8gVCA6IHcpICogUyAqIEUpO1xuICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhNYXRoLnNxcnQoZSAqIGUgKyAxKSAtIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24geih0KSB7XG4gICAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh0KSAtIE1hdGguZXhwKC10KSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gRCh0KSB7XG4gICAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh0KSArIE1hdGguZXhwKC10KSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEEgPSBDKDApLFxuICAgICAgICAgICAgTSA9IGZ1bmN0aW9uIE0odCkge1xuICAgICAgICAgIHJldHVybiBEKEEpIC8gRChBICsgYiAqIHQpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgTCA9IGZ1bmN0aW9uIEwodCkge1xuICAgICAgICAgIHJldHVybiB3ICogKChEKEEpICogKHooZSA9IEEgKyBiICogdCkgLyBEKGUpKSAtIHooQSkpIC8gUykgLyBFO1xuICAgICAgICAgIHZhciBlO1xuICAgICAgICB9LFxuICAgICAgICAgICAgUiA9IChDKDEpIC0gQSkgLyBiO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhFKSA8IDFlLTYgfHwgIWlzRmluaXRlKFIpKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHcgLSBUKSA8IDFlLTYpIHJldHVybiB0aGlzLmVhc2VUbyhlLCBpKTtcbiAgICAgICAgICB2YXIgayA9IFQgPCB3ID8gLTEgOiAxO1xuICAgICAgICAgIFIgPSBNYXRoLmFicyhNYXRoLmxvZyhUIC8gdykpIC8gYiwgTCA9IGZ1bmN0aW9uIEwoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LCBNID0gZnVuY3Rpb24gTSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5leHAoayAqIGIgKiB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGUuZHVyYXRpb24gPSBcImR1cmF0aW9uXCIgaW4gZSA/ICtlLmR1cmF0aW9uIDogMWUzICogUiAvIChcInNjcmVlblNwZWVkXCIgaW4gZSA/ICtlLnNjcmVlblNwZWVkIC8gYiA6ICtlLnNwZWVkKSwgZS5tYXhEdXJhdGlvbiAmJiBlLmR1cmF0aW9uID4gZS5tYXhEdXJhdGlvbiAmJiAoZS5kdXJhdGlvbiA9IDApLCB0aGlzLl96b29taW5nID0gITAsIHRoaXMuX3JvdGF0aW5nID0gcyAhPT0gaCwgdGhpcy5fcGl0Y2hpbmcgPSBwICE9PSBsLCB0aGlzLl9wYWRkaW5nID0gIWEuaXNQYWRkaW5nRXF1YWwoZCksIHRoaXMuX3ByZXBhcmVFYXNlKGksICExKSwgdGhpcy5fZWFzZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciByID0gZSAqIFIsXG4gICAgICAgICAgICAgIF8gPSAxIC8gTShyKTtcblxuICAgICAgICAgIGEuem9vbSA9IDEgPT09IGUgPyB1IDogbiArIGEuc2NhbGVab29tKF8pLCBvLl9yb3RhdGluZyAmJiAoYS5iZWFyaW5nID0gdC5udW1iZXIocywgaCwgZSkpLCBvLl9waXRjaGluZyAmJiAoYS5waXRjaCA9IHQubnVtYmVyKGwsIHAsIGUpKSwgby5fcGFkZGluZyAmJiAoYS5pbnRlcnBvbGF0ZVBhZGRpbmcoYywgZCwgZSksIG0gPSBhLmNlbnRlclBvaW50LmFkZChmKSk7XG4gICAgICAgICAgdmFyIGcgPSAxID09PSBlID8gdiA6IGEudW5wcm9qZWN0KHkuYWRkKHgubXVsdChMKHIpKSkubXVsdChfKSk7XG4gICAgICAgICAgYS5zZXRMb2NhdGlvbkF0UG9pbnQoYS5yZW5kZXJXb3JsZENvcGllcyA/IGcud3JhcCgpIDogZywgbSksIG8uX2ZpcmVNb3ZlRXZlbnRzKGkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG8uX2FmdGVyRWFzZShpKTtcbiAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc0Vhc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZWFzZUZyYW1lSWQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAodGhpcy5fZWFzZUZyYW1lSWQgJiYgKHRoaXMuX2NhbmNlbFJlbmRlckZyYW1lKHRoaXMuX2Vhc2VGcmFtZUlkKSwgZGVsZXRlIHRoaXMuX2Vhc2VGcmFtZUlkLCBkZWxldGUgdGhpcy5fb25FYXNlRnJhbWUpLCB0aGlzLl9vbkVhc2VFbmQpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuX29uRWFzZUVuZDtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fb25FYXNlRW5kLCBpLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgbyAmJiBvLnN0b3AoITEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZWFzZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICExID09PSBvLmFuaW1hdGUgfHwgMCA9PT0gby5kdXJhdGlvbiA/IChlKDEpLCBpKCkpIDogKHRoaXMuX2Vhc2VTdGFydCA9IHQuYnJvd3Nlci5ub3coKSwgdGhpcy5fZWFzZU9wdGlvbnMgPSBvLCB0aGlzLl9vbkVhc2VGcmFtZSA9IGUsIHRoaXMuX29uRWFzZUVuZCA9IGksIHRoaXMuX2Vhc2VGcmFtZUlkID0gdGhpcy5fcmVxdWVzdFJlbmRlckZyYW1lKHRoaXMuX3JlbmRlckZyYW1lQ2FsbGJhY2spKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9yZW5kZXJGcmFtZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IE1hdGgubWluKCh0LmJyb3dzZXIubm93KCkgLSB0aGlzLl9lYXNlU3RhcnQpIC8gdGhpcy5fZWFzZU9wdGlvbnMuZHVyYXRpb24sIDEpO1xuICAgICAgICB0aGlzLl9vbkVhc2VGcmFtZSh0aGlzLl9lYXNlT3B0aW9ucy5lYXNpbmcoZSkpLCBlIDwgMSA/IHRoaXMuX2Vhc2VGcmFtZUlkID0gdGhpcy5fcmVxdWVzdFJlbmRlckZyYW1lKHRoaXMuX3JlbmRlckZyYW1lQ2FsbGJhY2spIDogdGhpcy5zdG9wKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbm9ybWFsaXplQmVhcmluZyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGUgPSB0LndyYXAoZSwgLTE4MCwgMTgwKTtcbiAgICAgICAgdmFyIG8gPSBNYXRoLmFicyhlIC0gaSk7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhlIC0gMzYwIC0gaSkgPCBvICYmIChlIC09IDM2MCksIE1hdGguYWJzKGUgKyAzNjAgLSBpKSA8IG8gJiYgKGUgKz0gMzYwKSwgZTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9ub3JtYWxpemVDZW50ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgICAgIGlmIChlLnJlbmRlcldvcmxkQ29waWVzICYmICFlLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgdmFyIGkgPSB0LmxuZyAtIGUuY2VudGVyLmxuZztcbiAgICAgICAgICB0LmxuZyArPSBpID4gMTgwID8gLTM2MCA6IGkgPCAtMTgwID8gMzYwIDogMDtcbiAgICAgICAgfVxuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIHlyID0gZnVuY3Rpb24geXIoZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0ge30pLCB0aGlzLm9wdGlvbnMgPSBlLCB0LmJpbmRBbGwoW1wiX3RvZ2dsZUF0dHJpYnV0aW9uXCIsIFwiX3VwZGF0ZUVkaXRMaW5rXCIsIFwiX3VwZGF0ZURhdGFcIiwgXCJfdXBkYXRlQ29tcGFjdFwiXSwgdGhpcyk7XG4gICAgfTtcblxuICAgIHlyLnByb3RvdHlwZS5nZXREZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJib3R0b20tcmlnaHRcIjtcbiAgICB9LCB5ci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmNvbXBhY3Q7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID0gdCwgdGhpcy5fY29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtYXR0cmliXCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uID0gaS5jcmVhdGUoXCJidXR0b25cIiwgXCJtYXBib3hnbC1jdHJsLWF0dHJpYi1idXR0b25cIiwgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fY29tcGFjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdG9nZ2xlQXR0cmlidXRpb24pLCB0aGlzLl9zZXRFbGVtZW50VGl0bGUodGhpcy5fY29tcGFjdEJ1dHRvbiwgXCJUb2dnbGVBdHRyaWJ1dGlvblwiKSwgdGhpcy5faW5uZXJDb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLWN0cmwtYXR0cmliLWlubmVyXCIsIHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2lubmVyQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0XCIpLCBlICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY29tcGFjdFwiKSwgdGhpcy5fdXBkYXRlQXR0cmlidXRpb25zKCksIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCksIHRoaXMuX21hcC5vbihcInN0eWxlZGF0YVwiLCB0aGlzLl91cGRhdGVEYXRhKSwgdGhpcy5fbWFwLm9uKFwic291cmNlZGF0YVwiLCB0aGlzLl91cGRhdGVEYXRhKSwgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGVFZGl0TGluayksIHZvaWQgMCA9PT0gZSAmJiAodGhpcy5fbWFwLm9uKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpLCB0aGlzLl91cGRhdGVDb21wYWN0KCkpLCB0aGlzLl9jb250YWluZXI7XG4gICAgfSwgeXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwLm9mZihcInN0eWxlZGF0YVwiLCB0aGlzLl91cGRhdGVEYXRhKSwgdGhpcy5fbWFwLm9mZihcInNvdXJjZWRhdGFcIiwgdGhpcy5fdXBkYXRlRGF0YSksIHRoaXMuX21hcC5vZmYoXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKSwgdGhpcy5fbWFwLm9mZihcInJlc2l6ZVwiLCB0aGlzLl91cGRhdGVDb21wYWN0KSwgdGhpcy5fbWFwID0gdm9pZCAwLCB0aGlzLl9hdHRyaWJIVE1MID0gdm9pZCAwO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fc2V0RWxlbWVudFRpdGxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkF0dHJpYnV0aW9uQ29udHJvbC5cIiArIGUpO1xuXG4gICAgICB0LnRpdGxlID0gaSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGkpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fdG9nZ2xlQXR0cmlidXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwibWFwYm94Z2wtY29tcGFjdC1zaG93XCIpID8gKHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY29tcGFjdC1zaG93XCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpKSA6ICh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWNvbXBhY3Qtc2hvd1wiKSwgdGhpcy5fY29tcGFjdEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuX3VwZGF0ZUVkaXRMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9lZGl0TGluaztcbiAgICAgIGUgfHwgKGUgPSB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLm1hcGJveC1pbXByb3ZlLW1hcFwiKSk7XG4gICAgICB2YXIgaSA9IFt7XG4gICAgICAgIGtleTogXCJvd25lclwiLFxuICAgICAgICB2YWx1ZTogdGhpcy5zdHlsZU93bmVyXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJpZFwiLFxuICAgICAgICB2YWx1ZTogdGhpcy5zdHlsZUlkXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJhY2Nlc3NfdG9rZW5cIixcbiAgICAgICAgdmFsdWU6IHRoaXMuX21hcC5fcmVxdWVzdE1hbmFnZXIuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IHQuY29uZmlnLkFDQ0VTU19UT0tFTlxuICAgICAgfV07XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciBvID0gaS5yZWR1Y2UoZnVuY3Rpb24gKHQsIGUsIG8pIHtcbiAgICAgICAgICByZXR1cm4gZS52YWx1ZSAmJiAodCArPSBlLmtleSArIFwiPVwiICsgZS52YWx1ZSArIChvIDwgaS5sZW5ndGggLSAxID8gXCImXCIgOiBcIlwiKSksIHQ7XG4gICAgICAgIH0sIFwiP1wiKTtcbiAgICAgICAgZS5ocmVmID0gdC5jb25maWcuRkVFREJBQ0tfVVJMICsgXCIvXCIgKyBvICsgKHRoaXMuX21hcC5faGFzaCA/IHRoaXMuX21hcC5faGFzaC5nZXRIYXNoU3RyaW5nKCEwKSA6IFwiXCIpLCBlLnJlbCA9IFwibm9vcGVuZXIgbm9mb2xsb3dcIiwgdGhpcy5fc2V0RWxlbWVudFRpdGxlKGUsIFwiTWFwRmVlZGJhY2tcIik7XG4gICAgICB9XG4gICAgfSwgeXIucHJvdG90eXBlLl91cGRhdGVEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICF0IHx8IFwibWV0YWRhdGFcIiAhPT0gdC5zb3VyY2VEYXRhVHlwZSAmJiBcInZpc2liaWxpdHlcIiAhPT0gdC5zb3VyY2VEYXRhVHlwZSAmJiBcInN0eWxlXCIgIT09IHQuZGF0YVR5cGUgfHwgKHRoaXMuX3VwZGF0ZUF0dHJpYnV0aW9ucygpLCB0aGlzLl91cGRhdGVFZGl0TGluaygpKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuX3VwZGF0ZUF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgdmFyIHQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbUF0dHJpYnV0aW9uICYmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvbikgPyB0ID0gdC5jb25jYXQodGhpcy5vcHRpb25zLmN1c3RvbUF0dHJpYnV0aW9uLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiB0ID8gXCJcIiA6IHQ7XG4gICAgICAgIH0pKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMub3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvbiAmJiB0LnB1c2godGhpcy5vcHRpb25zLmN1c3RvbUF0dHJpYnV0aW9uKSksIHRoaXMuX21hcC5zdHlsZS5zdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLl9tYXAuc3R5bGUuc3R5bGVzaGVldDtcbiAgICAgICAgICB0aGlzLnN0eWxlT3duZXIgPSBlLm93bmVyLCB0aGlzLnN0eWxlSWQgPSBlLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuc3R5bGUuc291cmNlQ2FjaGVzO1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gaSkge1xuICAgICAgICAgIHZhciByID0gaVtvXTtcblxuICAgICAgICAgIGlmIChyLnVzZWQpIHtcbiAgICAgICAgICAgIHZhciBhID0gci5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIGEuYXR0cmlidXRpb24gJiYgdC5pbmRleE9mKGEuYXR0cmlidXRpb24pIDwgMCAmJiB0LnB1c2goYS5hdHRyaWJ1dGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdC5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQubGVuZ3RoIC0gZS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbiA9ICh0ID0gdC5maWx0ZXIoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0gaSArIDE7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAodFtvXS5pbmRleE9mKGUpID49IDApIHJldHVybiAhMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0pKS5qb2luKFwiIHwgXCIpO1xuICAgICAgICBuICE9PSB0aGlzLl9hdHRyaWJIVE1MICYmICh0aGlzLl9hdHRyaWJIVE1MID0gbiwgdC5sZW5ndGggPyAodGhpcy5faW5uZXJDb250YWluZXIuaW5uZXJIVE1MID0gbiwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1hdHRyaWItZW1wdHlcIikpIDogdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1hdHRyaWItZW1wdHlcIiksIHRoaXMuX2VkaXRMaW5rID0gbnVsbCk7XG4gICAgICB9XG4gICAgfSwgeXIucHJvdG90eXBlLl91cGRhdGVDb21wYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLm9mZnNldFdpZHRoIDw9IDY0MCA/IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY29tcGFjdFwiKSA6IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY29tcGFjdFwiLCBcIm1hcGJveGdsLWNvbXBhY3Qtc2hvd1wiKTtcbiAgICB9O1xuXG4gICAgdmFyIHhyID0gZnVuY3Rpb24geHIoKSB7XG4gICAgICB0LmJpbmRBbGwoW1wiX3VwZGF0ZUxvZ29cIl0sIHRoaXMpLCB0LmJpbmRBbGwoW1wiX3VwZGF0ZUNvbXBhY3RcIl0sIHRoaXMpO1xuICAgIH07XG5cbiAgICB4ci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fY29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBib3hnbC1jdHJsXCIpO1xuICAgICAgdmFyIGUgPSBpLmNyZWF0ZShcImFcIiwgXCJtYXBib3hnbC1jdHJsLWxvZ29cIik7XG4gICAgICByZXR1cm4gZS50YXJnZXQgPSBcIl9ibGFua1wiLCBlLnJlbCA9IFwibm9vcGVuZXIgbm9mb2xsb3dcIiwgZS5ocmVmID0gXCJodHRwczovL3d3dy5tYXBib3guY29tL1wiLCBlLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkxvZ29Db250cm9sLlRpdGxlXCIpKSwgZS5zZXRBdHRyaWJ1dGUoXCJyZWxcIiwgXCJub29wZW5lciBub2ZvbGxvd1wiKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGUpLCB0aGlzLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCB0aGlzLl9tYXAub24oXCJzb3VyY2VkYXRhXCIsIHRoaXMuX3VwZGF0ZUxvZ28pLCB0aGlzLl91cGRhdGVMb2dvKCksIHRoaXMuX21hcC5vbihcInJlc2l6ZVwiLCB0aGlzLl91cGRhdGVDb21wYWN0KSwgdGhpcy5fdXBkYXRlQ29tcGFjdCgpLCB0aGlzLl9jb250YWluZXI7XG4gICAgfSwgeHIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwLm9mZihcInNvdXJjZWRhdGFcIiwgdGhpcy5fdXBkYXRlTG9nbyksIHRoaXMuX21hcC5vZmYoXCJyZXNpemVcIiwgdGhpcy5fdXBkYXRlQ29tcGFjdCk7XG4gICAgfSwgeHIucHJvdG90eXBlLmdldERlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImJvdHRvbS1sZWZ0XCI7XG4gICAgfSwgeHIucHJvdG90eXBlLl91cGRhdGVMb2dvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQgJiYgXCJtZXRhZGF0YVwiICE9PSB0LnNvdXJjZURhdGFUeXBlIHx8ICh0aGlzLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2xvZ29SZXF1aXJlZCgpID8gXCJibG9ja1wiIDogXCJub25lXCIpO1xuICAgIH0sIHhyLnByb3RvdHlwZS5fbG9nb1JlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX21hcC5zdHlsZSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuX21hcC5zdHlsZS5zb3VyY2VDYWNoZXM7XG5cbiAgICAgICAgZm9yICh2YXIgZSBpbiB0KSB7XG4gICAgICAgICAgaWYgKHRbZV0uZ2V0U291cmNlKCkubWFwYm94X2xvZ28pIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCB4ci5wcm90b3R5cGUuX3VwZGF0ZUNvbXBhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbjtcblxuICAgICAgaWYgKHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlID0gdFswXTtcbiAgICAgICAgdGhpcy5fbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLm9mZnNldFdpZHRoIDwgMjUwID8gZS5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY29tcGFjdFwiKSA6IGUuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWNvbXBhY3RcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBiciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgdGhpcy5fcXVldWUgPSBbXSwgdGhpcy5faWQgPSAwLCB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9O1xuXG4gICAgYnIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICsrdGhpcy5faWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgIGNhbGxiYWNrOiB0LFxuICAgICAgICBpZDogZSxcbiAgICAgICAgY2FuY2VsbGVkOiAhMVxuICAgICAgfSksIGU7XG4gICAgfSwgYnIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5fY3VycmVudGx5UnVubmluZywgaSA9IDAsIG8gPSBlID8gdGhpcy5fcXVldWUuY29uY2F0KGUpIDogdGhpcy5fcXVldWU7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByID0gb1tpXTtcbiAgICAgICAgaWYgKHIuaWQgPT09IHQpIHJldHVybiB2b2lkIChyLmNhbmNlbGxlZCA9ICEwKTtcbiAgICAgIH1cbiAgICB9LCBici5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApO1xuICAgICAgdmFyIGUgPSB0aGlzLl9jdXJyZW50bHlSdW5uaW5nID0gdGhpcy5fcXVldWU7XG4gICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbyA9IGU7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByID0gb1tpXTtcbiAgICAgICAgaWYgKCFyLmNhbmNlbGxlZCAmJiAoci5jYWxsYmFjayh0KSwgdGhpcy5fY2xlYXJlZCkpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9LCBici5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50bHlSdW5uaW5nICYmICh0aGlzLl9jbGVhcmVkID0gITApLCB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH07XG5cbiAgICB2YXIgd3IgPSB7XG4gICAgICBcIkF0dHJpYnV0aW9uQ29udHJvbC5Ub2dnbGVBdHRyaWJ1dGlvblwiOiBcIlRvZ2dsZSBhdHRyaWJ1dGlvblwiLFxuICAgICAgXCJBdHRyaWJ1dGlvbkNvbnRyb2wuTWFwRmVlZGJhY2tcIjogXCJNYXAgZmVlZGJhY2tcIixcbiAgICAgIFwiRnVsbHNjcmVlbkNvbnRyb2wuRW50ZXJcIjogXCJFbnRlciBmdWxsc2NyZWVuXCIsXG4gICAgICBcIkZ1bGxzY3JlZW5Db250cm9sLkV4aXRcIjogXCJFeGl0IGZ1bGxzY3JlZW5cIixcbiAgICAgIFwiR2VvbG9jYXRlQ29udHJvbC5GaW5kTXlMb2NhdGlvblwiOiBcIkZpbmQgbXkgbG9jYXRpb25cIixcbiAgICAgIFwiR2VvbG9jYXRlQ29udHJvbC5Mb2NhdGlvbk5vdEF2YWlsYWJsZVwiOiBcIkxvY2F0aW9uIG5vdCBhdmFpbGFibGVcIixcbiAgICAgIFwiTG9nb0NvbnRyb2wuVGl0bGVcIjogXCJNYXBib3ggbG9nb1wiLFxuICAgICAgXCJOYXZpZ2F0aW9uQ29udHJvbC5SZXNldEJlYXJpbmdcIjogXCJSZXNldCBiZWFyaW5nIHRvIG5vcnRoXCIsXG4gICAgICBcIk5hdmlnYXRpb25Db250cm9sLlpvb21JblwiOiBcIlpvb20gaW5cIixcbiAgICAgIFwiTmF2aWdhdGlvbkNvbnRyb2wuWm9vbU91dFwiOiBcIlpvb20gb3V0XCIsXG4gICAgICBcIlNjYWxlQ29udHJvbC5GZWV0XCI6IFwiZnRcIixcbiAgICAgIFwiU2NhbGVDb250cm9sLk1ldGVyc1wiOiBcIm1cIixcbiAgICAgIFwiU2NhbGVDb250cm9sLktpbG9tZXRlcnNcIjogXCJrbVwiLFxuICAgICAgXCJTY2FsZUNvbnRyb2wuTWlsZXNcIjogXCJtaVwiLFxuICAgICAgXCJTY2FsZUNvbnRyb2wuTmF1dGljYWxNaWxlc1wiOiBcIm5tXCJcbiAgICB9LFxuICAgICAgICBUciA9IHQud2luZG93LkhUTUxJbWFnZUVsZW1lbnQsXG4gICAgICAgIEVyID0gdC53aW5kb3cuSFRNTEVsZW1lbnQsXG4gICAgICAgIElyID0gdC53aW5kb3cuSW1hZ2VCaXRtYXAsXG4gICAgICAgIFByID0ge1xuICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICB6b29tOiAwLFxuICAgICAgYmVhcmluZzogMCxcbiAgICAgIHBpdGNoOiAwLFxuICAgICAgbWluWm9vbTogLTIsXG4gICAgICBtYXhab29tOiAyMixcbiAgICAgIG1pblBpdGNoOiAwLFxuICAgICAgbWF4UGl0Y2g6IDYwLFxuICAgICAgaW50ZXJhY3RpdmU6ICEwLFxuICAgICAgc2Nyb2xsWm9vbTogITAsXG4gICAgICBib3hab29tOiAhMCxcbiAgICAgIGRyYWdSb3RhdGU6ICEwLFxuICAgICAgZHJhZ1BhbjogITAsXG4gICAgICBrZXlib2FyZDogITAsXG4gICAgICBkb3VibGVDbGlja1pvb206ICEwLFxuICAgICAgdG91Y2hab29tUm90YXRlOiAhMCxcbiAgICAgIHRvdWNoUGl0Y2g6ICEwLFxuICAgICAgYmVhcmluZ1NuYXA6IDcsXG4gICAgICBjbGlja1RvbGVyYW5jZTogMyxcbiAgICAgIHBpdGNoV2l0aFJvdGF0ZTogITAsXG4gICAgICBoYXNoOiAhMSxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogITAsXG4gICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiAhMSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogITEsXG4gICAgICB0cmFja1Jlc2l6ZTogITAsXG4gICAgICByZW5kZXJXb3JsZENvcGllczogITAsXG4gICAgICByZWZyZXNoRXhwaXJlZFRpbGVzOiAhMCxcbiAgICAgIG1heFRpbGVDYWNoZVNpemU6IG51bGwsXG4gICAgICBsb2NhbElkZW9ncmFwaEZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxuICAgICAgdHJhbnNmb3JtUmVxdWVzdDogbnVsbCxcbiAgICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgICAgZmFkZUR1cmF0aW9uOiAzMDAsXG4gICAgICBjcm9zc1NvdXJjZUNvbGxpc2lvbnM6ICEwXG4gICAgfSxcbiAgICAgICAgU3IgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgaWYgKG51bGwgIT0gKGUgPSB0LmV4dGVuZCh7fSwgUHIsIGUpKS5taW5ab29tICYmIG51bGwgIT0gZS5tYXhab29tICYmIGUubWluWm9vbSA+IGUubWF4Wm9vbSkgdGhyb3cgbmV3IEVycm9yKFwibWF4Wm9vbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBtaW5ab29tXCIpO1xuICAgICAgICBpZiAobnVsbCAhPSBlLm1pblBpdGNoICYmIG51bGwgIT0gZS5tYXhQaXRjaCAmJiBlLm1pblBpdGNoID4gZS5tYXhQaXRjaCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluUGl0Y2hcIik7XG4gICAgICAgIGlmIChudWxsICE9IGUubWluUGl0Y2ggJiYgZS5taW5QaXRjaCA8IDApIHRocm93IG5ldyBFcnJvcihcIm1pblBpdGNoIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBcIik7XG4gICAgICAgIGlmIChudWxsICE9IGUubWF4UGl0Y2ggJiYgZS5tYXhQaXRjaCA+IDYwKSB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2MFwiKTtcbiAgICAgICAgdmFyIHIgPSBuZXcgVG8oZS5taW5ab29tLCBlLm1heFpvb20sIGUubWluUGl0Y2gsIGUubWF4UGl0Y2gsIGUucmVuZGVyV29ybGRDb3BpZXMpO1xuXG4gICAgICAgIGlmIChvLmNhbGwodGhpcywgciwgZSksIHRoaXMuX2ludGVyYWN0aXZlID0gZS5pbnRlcmFjdGl2ZSwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IGUubWF4VGlsZUNhY2hlU2l6ZSwgdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGUuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCwgdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsIHRoaXMuX2FudGlhbGlhcyA9IGUuYW50aWFsaWFzLCB0aGlzLl90cmFja1Jlc2l6ZSA9IGUudHJhY2tSZXNpemUsIHRoaXMuX2JlYXJpbmdTbmFwID0gZS5iZWFyaW5nU25hcCwgdGhpcy5fcmVmcmVzaEV4cGlyZWRUaWxlcyA9IGUucmVmcmVzaEV4cGlyZWRUaWxlcywgdGhpcy5fZmFkZUR1cmF0aW9uID0gZS5mYWRlRHVyYXRpb24sIHRoaXMuX2Nyb3NzU291cmNlQ29sbGlzaW9ucyA9IGUuY3Jvc3NTb3VyY2VDb2xsaXNpb25zLCB0aGlzLl9jcm9zc0ZhZGluZ0ZhY3RvciA9IDEsIHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyA9IGUuY29sbGVjdFJlc291cmNlVGltaW5nLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUgPSBuZXcgYnIoKSwgdGhpcy5fY29udHJvbHMgPSBbXSwgdGhpcy5fbWFwSWQgPSB0LnVuaXF1ZUlkKCksIHRoaXMuX2xvY2FsZSA9IHQuZXh0ZW5kKHt9LCB3ciwgZS5sb2NhbGUpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2UsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gbmV3IHQuUmVxdWVzdE1hbmFnZXIoZS50cmFuc2Zvcm1SZXF1ZXN0LCBlLmFjY2Vzc1Rva2VuKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jb250YWluZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyID0gdC53aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS5jb250YWluZXIpLCAhdGhpcy5fY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgJ1wiICsgZS5jb250YWluZXIgKyBcIicgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShlLmNvbnRhaW5lciBpbnN0YW5jZW9mIEVyKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlOiAnY29udGFpbmVyJyBtdXN0IGJlIGEgU3RyaW5nIG9yIEhUTUxFbGVtZW50LlwiKTtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBlLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLm1heEJvdW5kcyAmJiB0aGlzLnNldE1heEJvdW5kcyhlLm1heEJvdW5kcyksIHQuYmluZEFsbChbXCJfb25XaW5kb3dPbmxpbmVcIiwgXCJfb25XaW5kb3dSZXNpemVcIiwgXCJfb25NYXBTY3JvbGxcIiwgXCJfY29udGV4dExvc3RcIiwgXCJfY29udGV4dFJlc3RvcmVkXCJdLCB0aGlzKSwgdGhpcy5fc2V0dXBDb250YWluZXIoKSwgdGhpcy5fc2V0dXBQYWludGVyKCksIHZvaWQgMCA9PT0gdGhpcy5wYWludGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTC5cIik7XG4gICAgICAgIHRoaXMub24oXCJtb3ZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCExKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJtb3ZlZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCExKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJ6b29tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSksIHZvaWQgMCAhPT0gdC53aW5kb3cgJiYgKHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgdGhpcy5fb25XaW5kb3dPbmxpbmUsICExKSwgdC53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgITEpLCB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUsICExKSksIHRoaXMuaGFuZGxlcnMgPSBuZXcgZ3IodGhpcywgZSksIHRoaXMuX2hhc2ggPSBlLmhhc2ggJiYgbmV3IElvKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuaGFzaCAmJiBlLmhhc2ggfHwgdm9pZCAwKS5hZGRUbyh0aGlzKSwgdGhpcy5faGFzaCAmJiB0aGlzLl9oYXNoLl9vbkhhc2hDaGFuZ2UoKSB8fCAodGhpcy5qdW1wVG8oe1xuICAgICAgICAgIGNlbnRlcjogZS5jZW50ZXIsXG4gICAgICAgICAgem9vbTogZS56b29tLFxuICAgICAgICAgIGJlYXJpbmc6IGUuYmVhcmluZyxcbiAgICAgICAgICBwaXRjaDogZS5waXRjaFxuICAgICAgICB9KSwgZS5ib3VuZHMgJiYgKHRoaXMucmVzaXplKCksIHRoaXMuZml0Qm91bmRzKGUuYm91bmRzLCB0LmV4dGVuZCh7fSwgZS5maXRCb3VuZHNPcHRpb25zLCB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSkpKSksIHRoaXMucmVzaXplKCksIHRoaXMuX2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseSA9IGUubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5LCBlLnN0eWxlICYmIHRoaXMuc2V0U3R5bGUoZS5zdHlsZSwge1xuICAgICAgICAgIGxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTogZS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHlcbiAgICAgICAgfSksIGUuYXR0cmlidXRpb25Db250cm9sICYmIHRoaXMuYWRkQ29udHJvbChuZXcgeXIoe1xuICAgICAgICAgIGN1c3RvbUF0dHJpYnV0aW9uOiBlLmN1c3RvbUF0dHJpYnV0aW9uXG4gICAgICAgIH0pKSwgdGhpcy5hZGRDb250cm9sKG5ldyB4cigpLCBlLmxvZ29Qb3NpdGlvbiksIHRoaXMub24oXCJzdHlsZS5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpLnRyYW5zZm9ybS51bm1vZGlmaWVkICYmIGkuanVtcFRvKGkuc3R5bGUuc3R5bGVzaGVldCk7XG4gICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGkuX3VwZGF0ZShcInN0eWxlXCIgPT09IGUuZGF0YVR5cGUpLCBpLmZpcmUobmV3IHQuRXZlbnQoZS5kYXRhVHlwZSArIFwiZGF0YVwiLCBlKSk7XG4gICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YWxvYWRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpLmZpcmUobmV3IHQuRXZlbnQoZS5kYXRhVHlwZSArIFwiZGF0YWxvYWRpbmdcIiwgZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbyAmJiAoci5fX3Byb3RvX18gPSBvKSwgKHIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvICYmIG8ucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSByO1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIHNob3dUaWxlQm91bmRhcmllczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd1BhZGRpbmc6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd092ZXJkcmF3SW5zcGVjdG9yOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICByZXBhaW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLnByb3RvdHlwZS5fZ2V0TWFwSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBJZDtcbiAgICAgIH0sIHIucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpICYmIChpID0gZS5nZXREZWZhdWx0UG9zaXRpb24gPyBlLmdldERlZmF1bHRQb3NpdGlvbigpIDogXCJ0b3AtcmlnaHRcIiksICFlIHx8ICFlLm9uQWRkKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0byBtYXAuYWRkQ29udHJvbCgpLiBBcmd1bWVudCBtdXN0IGJlIGEgY29udHJvbCB3aXRoIG9uQWRkIGFuZCBvblJlbW92ZSBtZXRob2RzLlwiKSkpO1xuICAgICAgICB2YXIgbyA9IGUub25BZGQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fY29udHJvbHMucHVzaChlKTtcblxuICAgICAgICB2YXIgciA9IHRoaXMuX2NvbnRyb2xQb3NpdGlvbnNbaV07XG4gICAgICAgIHJldHVybiAtMSAhPT0gaS5pbmRleE9mKFwiYm90dG9tXCIpID8gci5pbnNlcnRCZWZvcmUobywgci5maXJzdENoaWxkKSA6IHIuYXBwZW5kQ2hpbGQobyksIHRoaXM7XG4gICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlIHx8ICFlLm9uUmVtb3ZlKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0byBtYXAucmVtb3ZlQ29udHJvbCgpLiBBcmd1bWVudCBtdXN0IGJlIGEgY29udHJvbCB3aXRoIG9uQWRkIGFuZCBvblJlbW92ZSBtZXRob2RzLlwiKSkpO1xuXG4gICAgICAgIHZhciBpID0gdGhpcy5fY29udHJvbHMuaW5kZXhPZihlKTtcblxuICAgICAgICByZXR1cm4gaSA+IC0xICYmIHRoaXMuX2NvbnRyb2xzLnNwbGljZShpLCAxKSwgZS5vblJlbW92ZSh0aGlzKSwgdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLmhhc0NvbnRyb2wgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udHJvbHMuaW5kZXhPZih0KSA+IC0xO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9jb250YWluZXJEaW1lbnNpb25zKCksXG4gICAgICAgICAgICBvID0gaVswXSxcbiAgICAgICAgICAgIHIgPSBpWzFdO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUNhbnZhcyhvLCByKSwgdGhpcy50cmFuc2Zvcm0ucmVzaXplKG8sIHIpLCB0aGlzLnBhaW50ZXIucmVzaXplKG8sIHIpO1xuICAgICAgICB2YXIgYSA9ICF0aGlzLl9tb3Zpbmc7XG4gICAgICAgIHJldHVybiBhICYmICh0aGlzLnN0b3AoKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZXN0YXJ0XCIsIGUpKS5maXJlKG5ldyB0LkV2ZW50KFwibW92ZVwiLCBlKSkpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyZXNpemVcIiwgZSkpLCBhICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVlbmRcIiwgZSkpLCB0aGlzO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2V0Qm91bmRzKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRNYXhCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nZXRNYXhCb3VuZHMoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldE1heEJvdW5kcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5zZXRNYXhCb3VuZHModC5MbmdMYXRCb3VuZHMuY29udmVydChlKSksIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0TWluWm9vbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IC0yIDogdCkgPj0gLTIgJiYgdCA8PSB0aGlzLnRyYW5zZm9ybS5tYXhab29tKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmdldFpvb20oKSA8IHQgJiYgdGhpcy5zZXRab29tKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5ab29tIG11c3QgYmUgYmV0d2VlbiAtMiBhbmQgdGhlIGN1cnJlbnQgbWF4Wm9vbSwgaW5jbHVzaXZlXCIpO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TWluWm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1pblpvb207XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRNYXhab29tID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCh0ID0gbnVsbCA9PSB0ID8gMjIgOiB0KSA+PSB0aGlzLnRyYW5zZm9ybS5taW5ab29tKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbSA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmdldFpvb20oKSA+IHQgJiYgdGhpcy5zZXRab29tKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhab29tIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IG1pblpvb21cIik7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldE1pblBpdGNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCh0ID0gbnVsbCA9PSB0ID8gMCA6IHQpIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibWluUGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMFwiKTtcbiAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IHRoaXMudHJhbnNmb3JtLm1heFBpdGNoKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluUGl0Y2ggPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcy5nZXRQaXRjaCgpIDwgdCAmJiB0aGlzLnNldFBpdGNoKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5QaXRjaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgdGhlIGN1cnJlbnQgbWF4UGl0Y2gsIGluY2x1c2l2ZVwiKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldE1pblBpdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluUGl0Y2g7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRNYXhQaXRjaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IDYwIDogdCkgPiA2MCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNjBcIik7XG4gICAgICAgIGlmICh0ID49IHRoaXMudHJhbnNmb3JtLm1pblBpdGNoKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4UGl0Y2ggPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcy5nZXRQaXRjaCgpID4gdCAmJiB0aGlzLnNldFBpdGNoKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBtaW5QaXRjaFwiKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldE1heFBpdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4UGl0Y2g7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRSZW5kZXJXb3JsZENvcGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlbmRlcldvcmxkQ29waWVzO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0UmVuZGVyV29ybGRDb3BpZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVuZGVyV29ybGRDb3BpZXMgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludCh0LkxuZ0xhdC5jb252ZXJ0KGUpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnVucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHQuUG9pbnQuY29udmVydChlKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc01vdmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmluZyB8fCB0aGlzLmhhbmRsZXJzLmlzTW92aW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1pvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96b29taW5nIHx8IHRoaXMuaGFuZGxlcnMuaXNab29taW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1JvdGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpbmcgfHwgdGhpcy5oYW5kbGVycy5pc1JvdGF0aW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB2YXIgbyxcbiAgICAgICAgICAgIHIgPSB0aGlzO1xuXG4gICAgICAgIGlmIChcIm1vdXNlZW50ZXJcIiA9PT0gdCB8fCBcIm1vdXNlb3ZlclwiID09PSB0KSB7XG4gICAgICAgICAgdmFyIGEgPSAhMTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5ZXI6IGUsXG4gICAgICAgICAgICBsaXN0ZW5lcjogaSxcbiAgICAgICAgICAgIGRlbGVnYXRlczoge1xuICAgICAgICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIG1vdXNlbW92ZShvKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSByLmdldExheWVyKGUpID8gci5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoby5wb2ludCwge1xuICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBbZV1cbiAgICAgICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgICAgICAgIG4ubGVuZ3RoID8gYSB8fCAoYSA9ICEwLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIG8ub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZXM6IG5cbiAgICAgICAgICAgICAgICB9KSkpIDogYSA9ICExO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gbW91c2VvdXQoKSB7XG4gICAgICAgICAgICAgICAgYSA9ICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcIm1vdXNlbGVhdmVcIiA9PT0gdCB8fCBcIm1vdXNlb3V0XCIgPT09IHQpIHtcbiAgICAgICAgICB2YXIgbiA9ICExO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXllcjogZSxcbiAgICAgICAgICAgIGxpc3RlbmVyOiBpLFxuICAgICAgICAgICAgZGVsZWdhdGVzOiB7XG4gICAgICAgICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKG8pIHtcbiAgICAgICAgICAgICAgICAoci5nZXRMYXllcihlKSA/IHIucXVlcnlSZW5kZXJlZEZlYXR1cmVzKG8ucG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyczogW2VdXG4gICAgICAgICAgICAgICAgfSkgOiBbXSkubGVuZ3RoID8gbiA9ICEwIDogbiAmJiAobiA9ICExLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIG8ub3JpZ2luYWxFdmVudCkpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIG1vdXNlb3V0KGUpIHtcbiAgICAgICAgICAgICAgICBuICYmIChuID0gITEsIGkuY2FsbChyLCBuZXcgUm8odCwgciwgZS5vcmlnaW5hbEV2ZW50KSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXI6IGUsXG4gICAgICAgICAgbGlzdGVuZXI6IGksXG4gICAgICAgICAgZGVsZWdhdGVzOiAobyA9IHt9LCBvW3RdID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBvID0gci5nZXRMYXllcihlKSA/IHIucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHQucG9pbnQsIHtcbiAgICAgICAgICAgICAgbGF5ZXJzOiBbZV1cbiAgICAgICAgICAgIH0pIDogW107XG4gICAgICAgICAgICBvLmxlbmd0aCAmJiAodC5mZWF0dXJlcyA9IG8sIGkuY2FsbChyLCB0KSwgZGVsZXRlIHQuZmVhdHVyZXMpO1xuICAgICAgICAgIH0sIG8pXG4gICAgICAgIH07XG4gICAgICB9LCByLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGkpIHJldHVybiBvLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIHQsIGUpO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIodCwgZSwgaSk7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnMgPSB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnMgfHwge30sIHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XSA9IHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XSB8fCBbXSwgdGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzW3RdLnB1c2gociksIHIuZGVsZWdhdGVzKSB7XG4gICAgICAgICAgdGhpcy5vbihhLCByLmRlbGVnYXRlc1thXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpKSByZXR1cm4gby5wcm90b3R5cGUub25jZS5jYWxsKHRoaXMsIHQsIGUpO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIodCwgZSwgaSk7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiByLmRlbGVnYXRlcykge1xuICAgICAgICAgIHRoaXMub25jZShhLCByLmRlbGVnYXRlc1thXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSA/IG8ucHJvdG90eXBlLm9mZi5jYWxsKHRoaXMsIHQsIGUpIDogKHRoaXMuX2RlbGVnYXRlZExpc3RlbmVycyAmJiB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnNbdF0gJiYgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gb1t0XSwgbiA9IDA7IG4gPCBhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGFbbl07XG5cbiAgICAgICAgICAgIGlmIChzLmxheWVyID09PSBlICYmIHMubGlzdGVuZXIgPT09IGkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbCBpbiBzLmRlbGVnYXRlcykge1xuICAgICAgICAgICAgICAgIHIub2ZmKGwsIHMuZGVsZWdhdGVzW2xdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBhLnNwbGljZShuLCAxKSwgcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0odGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzKSwgdGhpcyk7XG4gICAgICB9LCByLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGkgfHwgdm9pZCAwID09PSBlIHx8IGUgaW5zdGFuY2VvZiB0LlBvaW50IHx8IEFycmF5LmlzQXJyYXkoZSkgfHwgKGkgPSBlLCBlID0gdm9pZCAwKSwgaSA9IGkgfHwge30sIChlID0gZSB8fCBbWzAsIDBdLCBbdGhpcy50cmFuc2Zvcm0ud2lkdGgsIHRoaXMudHJhbnNmb3JtLmhlaWdodF1dKSBpbnN0YW5jZW9mIHQuUG9pbnQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgZVswXSkgbyA9IFt0LlBvaW50LmNvbnZlcnQoZSldO2Vsc2Uge1xuICAgICAgICAgIHZhciByID0gdC5Qb2ludC5jb252ZXJ0KGVbMF0pLFxuICAgICAgICAgICAgICBhID0gdC5Qb2ludC5jb252ZXJ0KGVbMV0pO1xuICAgICAgICAgIG8gPSBbciwgbmV3IHQuUG9pbnQoYS54LCByLnkpLCBhLCBuZXcgdC5Qb2ludChyLngsIGEueSksIHJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhvLCBpLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5xdWVyeVNvdXJjZUZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUucXVlcnlTb3VyY2VGZWF0dXJlcyh0LCBlKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuICExICE9PSAoaSA9IHQuZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgbG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5OiB0aGlzLl9sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHlcbiAgICAgICAgfSwgaSkpLmRpZmYgJiYgaS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPT09IHRoaXMuX2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseSAmJiB0aGlzLnN0eWxlICYmIGUgPyAodGhpcy5fZGlmZlN0eWxlKGUsIGkpLCB0aGlzKSA6ICh0aGlzLl9sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPSBpLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSwgdGhpcy5fdXBkYXRlU3R5bGUoZSwgaSkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2dldFVJU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9sb2NhbGVbdF07XG4gICAgICAgIGlmIChudWxsID09IGUpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgVUkgc3RyaW5nICdcIiArIHQgKyBcIidcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUgJiYgKHRoaXMuc3R5bGUuc2V0RXZlbnRlZFBhcmVudChudWxsKSwgdGhpcy5zdHlsZS5fcmVtb3ZlKCkpLCB0ID8gKHRoaXMuc3R5bGUgPSBuZXcgamUodGhpcywgZSB8fCB7fSksIHRoaXMuc3R5bGUuc2V0RXZlbnRlZFBhcmVudCh0aGlzLCB7XG4gICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVcbiAgICAgICAgfSksIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyB0aGlzLnN0eWxlLmxvYWRVUkwodCkgOiB0aGlzLnN0eWxlLmxvYWRKU09OKHQpLCB0aGlzKSA6IChkZWxldGUgdGhpcy5zdHlsZSwgdGhpcyk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fbGF6eUluaXRFbXB0eVN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0eWxlIHx8ICh0aGlzLnN0eWxlID0gbmV3IGplKHRoaXMsIHt9KSwgdGhpcy5zdHlsZS5zZXRFdmVudGVkUGFyZW50KHRoaXMsIHtcbiAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZVxuICAgICAgICB9KSwgdGhpcy5zdHlsZS5sb2FkRW1wdHkoKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fZGlmZlN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5ub3JtYWxpemVTdHlsZVVSTChlKSxcbiAgICAgICAgICAgICAgYSA9IHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QociwgdC5SZXNvdXJjZVR5cGUuU3R5bGUpO1xuXG4gICAgICAgICAgdC5nZXRKU09OKGEsIGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICBlID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpIDogciAmJiBvLl91cGRhdGVEaWZmKHIsIGkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiB0aGlzLl91cGRhdGVEaWZmKGUsIGkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3VwZGF0ZURpZmYgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0U3RhdGUoZSkgJiYgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgIHQud2Fybk9uY2UoXCJVbmFibGUgdG8gcGVyZm9ybSBzdHlsZSBkaWZmOiBcIiArIChvLm1lc3NhZ2UgfHwgby5lcnJvciB8fCBvKSArIFwiLiAgUmVidWlsZGluZyB0aGUgc3R5bGUgZnJvbSBzY3JhdGNoLlwiKSwgdGhpcy5fdXBkYXRlU3R5bGUoZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkgcmV0dXJuIHRoaXMuc3R5bGUuc2VyaWFsaXplKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1N0eWxlTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA/IHRoaXMuc3R5bGUubG9hZGVkKCkgOiB0Lndhcm5PbmNlKFwiVGhlcmUgaXMgbm8gc3R5bGUgYWRkZWQgdG8gdGhlIG1hcC5cIik7XG4gICAgICB9LCByLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF6eUluaXRFbXB0eVN0eWxlKCksIHRoaXMuc3R5bGUuYWRkU291cmNlKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuaXNTb3VyY2VMb2FkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5zb3VyY2VDYWNoZXNbZV07XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGkpIHJldHVybiBpLmxvYWRlZCgpO1xuICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCBJRCAnXCIgKyBlICsgXCInXCIpKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5hcmVUaWxlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUuc291cmNlQ2FjaGVzO1xuXG4gICAgICAgIGZvciAodmFyIGUgaW4gdCkge1xuICAgICAgICAgIHZhciBpID0gdFtlXS5fdGlsZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBvIGluIGkpIHtcbiAgICAgICAgICAgIHZhciByID0gaVtvXTtcbiAgICAgICAgICAgIGlmIChcImxvYWRlZFwiICE9PSByLnN0YXRlICYmIFwiZXJyb3JlZFwiICE9PSByLnN0YXRlKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgci5wcm90b3R5cGUuYWRkU291cmNlVHlwZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5hZGRTb3VyY2VUeXBlKHQsIGUsIGkpO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlU291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUucmVtb3ZlU291cmNlKHQpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0U291cmNlKHQpO1xuICAgICAgfSwgci5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSk7XG4gICAgICAgIHZhciByID0gby5waXhlbFJhdGlvO1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSAxKTtcbiAgICAgICAgdmFyIGEgPSBvLnNkZjtcbiAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITEpO1xuICAgICAgICB2YXIgbiA9IG8uc3RyZXRjaFgsXG4gICAgICAgICAgICBzID0gby5zdHJldGNoWSxcbiAgICAgICAgICAgIGwgPSBvLmNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhenlJbml0RW1wdHlTdHlsZSgpLCBpIGluc3RhbmNlb2YgVHIgfHwgSXIgJiYgaSBpbnN0YW5jZW9mIElyKSB7XG4gICAgICAgICAgdmFyIGMgPSB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGkpO1xuICAgICAgICAgIHRoaXMuc3R5bGUuYWRkSW1hZ2UoZSwge1xuICAgICAgICAgICAgZGF0YTogbmV3IHQuUkdCQUltYWdlKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogYy5oZWlnaHRcbiAgICAgICAgICAgIH0sIGMuZGF0YSksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiByLFxuICAgICAgICAgICAgc3RyZXRjaFg6IG4sXG4gICAgICAgICAgICBzdHJldGNoWTogcyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGwsXG4gICAgICAgICAgICBzZGY6IGEsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaS53aWR0aCB8fCB2b2lkIDAgPT09IGkuaGVpZ2h0KSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gbWFwLmFkZEltYWdlKCkuIFRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBgSFRNTEltYWdlRWxlbWVudGAsIGBJbWFnZURhdGFgLCBgSW1hZ2VCaXRtYXBgLCBvciBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYW5kIGBkYXRhYCBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgZm9ybWF0IGFzIGBJbWFnZURhdGFgXCIpKSk7XG4gICAgICAgICAgdmFyIHUgPSBpO1xuICAgICAgICAgIHRoaXMuc3R5bGUuYWRkSW1hZ2UoZSwge1xuICAgICAgICAgICAgZGF0YTogbmV3IHQuUkdCQUltYWdlKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGkud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaS5oZWlnaHRcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGkuZGF0YSkpLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzogcixcbiAgICAgICAgICAgIHN0cmV0Y2hYOiBuLFxuICAgICAgICAgICAgc3RyZXRjaFk6IHMsXG4gICAgICAgICAgICBjb250ZW50OiBsLFxuICAgICAgICAgICAgc2RmOiBhLFxuICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICAgIHVzZXJJbWFnZTogdVxuICAgICAgICAgIH0pLCB1Lm9uQWRkICYmIHUub25BZGQodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLnVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLnN0eWxlLmdldEltYWdlKGUpO1xuICAgICAgICBpZiAoIW8pIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbWFwIGhhcyBubyBpbWFnZSB3aXRoIHRoYXQgaWQuIElmIHlvdSBhcmUgYWRkaW5nIGEgbmV3IGltYWdlIHVzZSBgbWFwLmFkZEltYWdlKC4uLilgIGluc3RlYWQuXCIpKSk7XG4gICAgICAgIHZhciByID0gaSBpbnN0YW5jZW9mIFRyIHx8IElyICYmIGkgaW5zdGFuY2VvZiBJciA/IHQuYnJvd3Nlci5nZXRJbWFnZURhdGEoaSkgOiBpLFxuICAgICAgICAgICAgYSA9IHIud2lkdGgsXG4gICAgICAgICAgICBuID0gci5oZWlnaHQsXG4gICAgICAgICAgICBzID0gci5kYXRhO1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhIHx8IHZvaWQgMCA9PT0gbiA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIG1hcC51cGRhdGVJbWFnZSgpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYW4gYEhUTUxJbWFnZUVsZW1lbnRgLCBgSW1hZ2VEYXRhYCwgYEltYWdlQml0bWFwYCwgb3Igb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGFuZCBgZGF0YWAgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIGZvcm1hdCBhcyBgSW1hZ2VEYXRhYFwiKSkpIDogYSAhPT0gby5kYXRhLndpZHRoIHx8IG4gIT09IG8uZGF0YS5oZWlnaHQgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdXBkYXRlZCBpbWFnZSBtdXN0IGJlIHRoYXQgc2FtZSBhcyB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgaW1hZ2VcIikpKSA6IChvLmRhdGEucmVwbGFjZShzLCAhKGkgaW5zdGFuY2VvZiBUciB8fCBJciAmJiBpIGluc3RhbmNlb2YgSXIpKSwgdm9pZCB0aGlzLnN0eWxlLnVwZGF0ZUltYWdlKGUsIG8pKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmhhc0ltYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPyAhIXRoaXMuc3R5bGUuZ2V0SW1hZ2UoZSkgOiAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBpbWFnZSBpZFwiKSkpLCAhMSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlSW1hZ2UodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB0LmdldEltYWdlKHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QoZSwgdC5SZXNvdXJjZVR5cGUuSW1hZ2UpLCBpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmxpc3RJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmxpc3RJbWFnZXMoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlJbml0RW1wdHlTdHlsZSgpLCB0aGlzLnN0eWxlLmFkZExheWVyKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUubW92ZUxheWVyKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5yZW1vdmVMYXllcih0KSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5ZXIodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldExheWVyWm9vbVJhbmdlKHQsIGUsIGkpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5zdHlsZS5zZXRGaWx0ZXIodCwgZSwgaSksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRGaWx0ZXIodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRQYWludFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5zdHlsZS5zZXRQYWludFByb3BlcnR5KHQsIGUsIGksIG8pLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0UGFpbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFBhaW50UHJvcGVydHkodCwgZSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuc3R5bGUuc2V0TGF5b3V0UHJvcGVydHkodCwgZSwgaSwgbyksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheW91dFByb3BlcnR5KHQsIGUpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0TGlnaHQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0ge30pLCB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5zZXRMaWdodCh0LCBlKSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldExpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRMaWdodCgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0RmVhdHVyZVN0YXRlKHQsIGUpLCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnJlbW92ZUZlYXR1cmVTdGF0ZSh0LCBlKSwgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRGZWF0dXJlU3RhdGUodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDYW52YXNDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNDb250YWluZXI7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY29udGFpbmVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSAwLFxuICAgICAgICAgICAgZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIgJiYgKHQgPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgNDAwLCBlID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAzMDApLCBbdCwgZV07XG4gICAgICB9LCByLnByb3RvdHlwZS5fZGV0ZWN0TWlzc2luZ0NTUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXCJyZ2IoMjUwLCAxMjgsIDExNClcIiAhPT0gdC53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9taXNzaW5nQ1NTQ2FuYXJ5KS5nZXRQcm9wZXJ0eVZhbHVlKFwiYmFja2dyb3VuZC1jb2xvclwiKSAmJiB0Lndhcm5PbmNlKFwiVGhpcyBwYWdlIGFwcGVhcnMgdG8gYmUgbWlzc2luZyBDU1MgZGVjbGFyYXRpb25zIGZvciBNYXBib3ggR0wgSlMsIHdoaWNoIG1heSBjYXVzZSB0aGUgbWFwIHRvIGRpc3BsYXkgaW5jb3JyZWN0bHkuIFBsZWFzZSBlbnN1cmUgeW91ciBwYWdlIGluY2x1ZGVzIG1hcGJveC1nbC5jc3MsIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvLlwiKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9zZXR1cENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIHQuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLW1hcFwiKSwgKHRoaXMuX21pc3NpbmdDU1NDYW5hcnkgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLWNhbmFyeVwiLCB0KSkuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHRoaXMuX2RldGVjdE1pc3NpbmdDU1MoKTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLWNhbnZhcy1jb250YWluZXJcIiwgdCk7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aXZlICYmIGUuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWludGVyYWN0aXZlXCIpLCB0aGlzLl9jYW52YXMgPSBpLmNyZWF0ZShcImNhbnZhc1wiLCBcIm1hcGJveGdsLWNhbnZhc1wiLCBlKSwgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuX2NvbnRleHRMb3N0LCAhMSksIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5fY29udGV4dFJlc3RvcmVkLCAhMSksIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIiksIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiTWFwXCIpLCB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInJlZ2lvblwiKTtcblxuICAgICAgICB2YXIgbyA9IHRoaXMuX2NvbnRhaW5lckRpbWVuc2lvbnMoKTtcblxuICAgICAgICB0aGlzLl9yZXNpemVDYW52YXMob1swXSwgb1sxXSk7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBib3hnbC1jb250cm9sLWNvbnRhaW5lclwiLCB0KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLl9jb250cm9sUG9zaXRpb25zID0ge307XG4gICAgICAgIFtcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgXCJib3R0b20tcmlnaHRcIl0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGFbdF0gPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLWN0cmwtXCIgKyB0LCByKTtcbiAgICAgICAgfSksIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuX29uTWFwU2Nyb2xsLCAhMSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fcmVzaXplQ2FudmFzID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBvICogZSwgdGhpcy5fY2FudmFzLmhlaWdodCA9IG8gKiBpLCB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSBlICsgXCJweFwiLCB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaSArIFwicHhcIjtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9zZXR1cFBhaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdC5leHRlbmQoe30sIGUud2ViR0xDb250ZXh0QXR0cmlidXRlcywge1xuICAgICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRoaXMuX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQsXG4gICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0aGlzLl9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgICAgYW50aWFsaWFzOiB0aGlzLl9hbnRpYWxpYXMgfHwgITFcbiAgICAgICAgfSksXG4gICAgICAgICAgICBvID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBpKSB8fCB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBpKTtcblxuICAgICAgICBvID8gKHRoaXMucGFpbnRlciA9IG5ldyB5byhvLCB0aGlzLnRyYW5zZm9ybSksIHQud2VicFN1cHBvcnRlZC50ZXN0U3VwcG9ydChvKSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTFwiKSkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2NvbnRleHRMb3N0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mcmFtZSAmJiAodGhpcy5fZnJhbWUuY2FuY2VsKCksIHRoaXMuX2ZyYW1lID0gbnVsbCksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIndlYmdsY29udGV4dGxvc3RcIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2NvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpLCB0aGlzLnJlc2l6ZSgpLCB0aGlzLl91cGRhdGUoKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX29uTWFwU2Nyb2xsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQudGFyZ2V0ID09PSB0aGlzLl9jb250YWluZXIpIHJldHVybiB0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wID0gMCwgdGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwLCAhMTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9zdHlsZURpcnR5ICYmICF0aGlzLl9zb3VyY2VzRGlydHkgJiYgISF0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUubG9hZGVkKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUgPyAodGhpcy5fc3R5bGVEaXJ0eSA9IHRoaXMuX3N0eWxlRGlydHkgfHwgdCwgdGhpcy5fc291cmNlc0RpcnR5ID0gITAsIHRoaXMudHJpZ2dlclJlcGFpbnQoKSwgdGhpcykgOiB0aGlzO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3JlcXVlc3RSZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUoKSwgdGhpcy5fcmVuZGVyVGFza1F1ZXVlLmFkZCh0KTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9jYW5jZWxSZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhc2tRdWV1ZS5yZW1vdmUodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvID0gdGhpcyxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgYSA9IHRoaXMucGFpbnRlci5jb250ZXh0LmV4dFRpbWVyUXVlcnk7XG5cbiAgICAgICAgaWYgKHRoaXMubGlzdGVucyhcImdwdS10aW1pbmctZnJhbWVcIikgJiYgKGkgPSBhLmNyZWF0ZVF1ZXJ5RVhUKCksIGEuYmVnaW5RdWVyeUVYVChhLlRJTUVfRUxBUFNFRF9FWFQsIGkpLCByID0gdC5icm93c2VyLm5vdygpKSwgdGhpcy5wYWludGVyLmNvbnRleHQuc2V0RGlydHkoKSwgdGhpcy5wYWludGVyLnNldEJhc2VTdGF0ZSgpLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUucnVuKGUpLCAhdGhpcy5fcmVtb3ZlZCkge1xuICAgICAgICAgIHZhciBuID0gITE7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zdHlsZURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gITE7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMudHJhbnNmb3JtLnpvb20sXG4gICAgICAgICAgICAgICAgbCA9IHQuYnJvd3Nlci5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuem9vbUhpc3RvcnkudXBkYXRlKHMsIGwpO1xuICAgICAgICAgICAgdmFyIGMgPSBuZXcgdC5FdmFsdWF0aW9uUGFyYW1ldGVycyhzLCB7XG4gICAgICAgICAgICAgIG5vdzogbCxcbiAgICAgICAgICAgICAgZmFkZUR1cmF0aW9uOiB0aGlzLl9mYWRlRHVyYXRpb24sXG4gICAgICAgICAgICAgIHpvb21IaXN0b3J5OiB0aGlzLnN0eWxlLnpvb21IaXN0b3J5LFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLnN0eWxlLmdldFRyYW5zaXRpb24oKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdSA9IGMuY3Jvc3NGYWRpbmdGYWN0b3IoKTtcbiAgICAgICAgICAgIDEgPT09IHUgJiYgdSA9PT0gdGhpcy5fY3Jvc3NGYWRpbmdGYWN0b3IgfHwgKG4gPSAhMCwgdGhpcy5fY3Jvc3NGYWRpbmdGYWN0b3IgPSB1KSwgdGhpcy5zdHlsZS51cGRhdGUoYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgdGhpcy5fc291cmNlc0RpcnR5ICYmICh0aGlzLl9zb3VyY2VzRGlydHkgPSAhMSwgdGhpcy5zdHlsZS5fdXBkYXRlU291cmNlcyh0aGlzLnRyYW5zZm9ybSkpLCB0aGlzLl9wbGFjZW1lbnREaXJ0eSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5fdXBkYXRlUGxhY2VtZW50KHRoaXMucGFpbnRlci50cmFuc2Zvcm0sIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzLCB0aGlzLl9mYWRlRHVyYXRpb24sIHRoaXMuX2Nyb3NzU291cmNlQ29sbGlzaW9ucyksIHRoaXMucGFpbnRlci5yZW5kZXIodGhpcy5zdHlsZSwge1xuICAgICAgICAgICAgc2hvd1RpbGVCb3VuZGFyaWVzOiB0aGlzLnNob3dUaWxlQm91bmRhcmllcyxcbiAgICAgICAgICAgIHNob3dPdmVyZHJhd0luc3BlY3RvcjogdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yLFxuICAgICAgICAgICAgcm90YXRpbmc6IHRoaXMuaXNSb3RhdGluZygpLFxuICAgICAgICAgICAgem9vbWluZzogdGhpcy5pc1pvb21pbmcoKSxcbiAgICAgICAgICAgIG1vdmluZzogdGhpcy5pc01vdmluZygpLFxuICAgICAgICAgICAgZmFkZUR1cmF0aW9uOiB0aGlzLl9mYWRlRHVyYXRpb24sXG4gICAgICAgICAgICBzaG93UGFkZGluZzogdGhpcy5zaG93UGFkZGluZyxcbiAgICAgICAgICAgIGdwdVRpbWluZzogISF0aGlzLmxpc3RlbnMoXCJncHUtdGltaW5nLWxheWVyXCIpXG4gICAgICAgICAgfSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJlbmRlclwiKSksIHRoaXMubG9hZGVkKCkgJiYgIXRoaXMuX2xvYWRlZCAmJiAodGhpcy5fbG9hZGVkID0gITAsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImxvYWRcIikpKSwgdGhpcy5zdHlsZSAmJiAodGhpcy5zdHlsZS5oYXNUcmFuc2l0aW9ucygpIHx8IG4pICYmICh0aGlzLl9zdHlsZURpcnR5ID0gITApLCB0aGlzLnN0eWxlICYmICF0aGlzLl9wbGFjZW1lbnREaXJ0eSAmJiB0aGlzLnN0eWxlLl9yZWxlYXNlU3ltYm9sRmFkZVRpbGVzKCksIHRoaXMubGlzdGVucyhcImdwdS10aW1pbmctZnJhbWVcIikpIHtcbiAgICAgICAgICAgIHZhciBoID0gdC5icm93c2VyLm5vdygpIC0gcjtcbiAgICAgICAgICAgIGEuZW5kUXVlcnlFWFQoYS5USU1FX0VMQVBTRURfRVhULCBpKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gYS5nZXRRdWVyeU9iamVjdEVYVChpLCBhLlFVRVJZX1JFU1VMVF9FWFQpIC8gMWU2O1xuICAgICAgICAgICAgICBhLmRlbGV0ZVF1ZXJ5RVhUKGkpLCBvLmZpcmUobmV3IHQuRXZlbnQoXCJncHUtdGltaW5nLWZyYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBjcHVUaW1lOiBoLFxuICAgICAgICAgICAgICAgIGdwdVRpbWU6IGVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmxpc3RlbnMoXCJncHUtdGltaW5nLWxheWVyXCIpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFpbnRlci5jb2xsZWN0R3B1VGltZXJzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBvLnBhaW50ZXIucXVlcnlHcHVUaW1lcnMocCk7XG4gICAgICAgICAgICAgIG8uZmlyZShuZXcgdC5FdmVudChcImdwdS10aW1pbmctbGF5ZXJcIiwge1xuICAgICAgICAgICAgICAgIGxheWVyVGltZXM6IGVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkID0gdGhpcy5fc291cmNlc0RpcnR5IHx8IHRoaXMuX3N0eWxlRGlydHkgfHwgdGhpcy5fcGxhY2VtZW50RGlydHk7XG4gICAgICAgICAgcmV0dXJuIGQgfHwgdGhpcy5fcmVwYWludCA/IHRoaXMudHJpZ2dlclJlcGFpbnQoKSA6ICF0aGlzLmlzTW92aW5nKCkgJiYgdGhpcy5sb2FkZWQoKSAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJpZGxlXCIpKSwgIXRoaXMuX2xvYWRlZCB8fCB0aGlzLl9mdWxseUxvYWRlZCB8fCBkIHx8ICh0aGlzLl9mdWxseUxvYWRlZCA9ICEwKSwgdGhpcztcbiAgICAgICAgfVxuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oYXNoICYmIHRoaXMuX2hhc2gucmVtb3ZlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIGkgPSB0aGlzLl9jb250cm9sczsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICBpW2VdLm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBbXSwgdGhpcy5fZnJhbWUgJiYgKHRoaXMuX2ZyYW1lLmNhbmNlbCgpLCB0aGlzLl9mcmFtZSA9IG51bGwpLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUuY2xlYXIoKSwgdGhpcy5wYWludGVyLmRlc3Ryb3koKSwgdGhpcy5oYW5kbGVycy5kZXN0cm95KCksIGRlbGV0ZSB0aGlzLmhhbmRsZXJzLCB0aGlzLnNldFN0eWxlKG51bGwpLCB2b2lkIDAgIT09IHQud2luZG93ICYmICh0LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplLCAhMSksIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgITEpLCB0LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHRoaXMuX29uV2luZG93T25saW5lLCAhMSkpO1xuICAgICAgICB2YXIgbyA9IHRoaXMucGFpbnRlci5jb250ZXh0LmdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICAgICAgbyAmJiBvLmxvc2VDb250ZXh0KCksIENyKHRoaXMuX2NhbnZhc0NvbnRhaW5lciksIENyKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLCBDcih0aGlzLl9taXNzaW5nQ1NTQ2FuYXJ5KSwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1tYXBcIiksIHRoaXMuX3JlbW92ZWQgPSAhMCwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicmVtb3ZlXCIpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnRyaWdnZXJSZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3R5bGUgJiYgIXRoaXMuX2ZyYW1lICYmICh0aGlzLl9mcmFtZSA9IHQuYnJvd3Nlci5mcmFtZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGUuX2ZyYW1lID0gbnVsbCwgZS5fcmVuZGVyKHQpO1xuICAgICAgICB9KSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fb25XaW5kb3dPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX29uV2luZG93UmVzaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tSZXNpemUgJiYgdGhpcy5yZXNpemUoe1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgfSkuX3VwZGF0ZSgpO1xuICAgICAgfSwgYS5zaG93VGlsZUJvdW5kYXJpZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXM7XG4gICAgICB9LCBhLnNob3dUaWxlQm91bmRhcmllcy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXMgIT09IHQgJiYgKHRoaXMuX3Nob3dUaWxlQm91bmRhcmllcyA9IHQsIHRoaXMuX3VwZGF0ZSgpKTtcbiAgICAgIH0sIGEuc2hvd1BhZGRpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93UGFkZGluZztcbiAgICAgIH0sIGEuc2hvd1BhZGRpbmcuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc2hvd1BhZGRpbmcgIT09IHQgJiYgKHRoaXMuX3Nob3dQYWRkaW5nID0gdCwgdGhpcy5fdXBkYXRlKCkpO1xuICAgICAgfSwgYS5zaG93Q29sbGlzaW9uQm94ZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXM7XG4gICAgICB9LCBhLnNob3dDb2xsaXNpb25Cb3hlcy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXMgIT09IHQgJiYgKHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcyA9IHQsIHQgPyB0aGlzLnN0eWxlLl9nZW5lcmF0ZUNvbGxpc2lvbkJveGVzKCkgOiB0aGlzLl91cGRhdGUoKSk7XG4gICAgICB9LCBhLnNob3dPdmVyZHJhd0luc3BlY3Rvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvcjtcbiAgICAgIH0sIGEuc2hvd092ZXJkcmF3SW5zcGVjdG9yLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciAhPT0gdCAmJiAodGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID0gdCwgdGhpcy5fdXBkYXRlKCkpO1xuICAgICAgfSwgYS5yZXBhaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVwYWludDtcbiAgICAgIH0sIGEucmVwYWludC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9yZXBhaW50ICE9PSB0ICYmICh0aGlzLl9yZXBhaW50ID0gdCwgdGhpcy50cmlnZ2VyUmVwYWludCgpKTtcbiAgICAgIH0sIGEudmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl92ZXJ0aWNlcztcbiAgICAgIH0sIGEudmVydGljZXMuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9zZXRDYWNoZUxpbWl0cyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHQuc2V0Q2FjaGVMaW1pdHMoZSwgaSk7XG4gICAgICB9LCBhLnZlcnNpb24uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC52ZXJzaW9uO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoci5wcm90b3R5cGUsIGEpLCByO1xuICAgIH0odnIpO1xuXG4gICAgZnVuY3Rpb24gQ3IodCkge1xuICAgICAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KTtcbiAgICB9XG5cbiAgICB2YXIgenIgPSB7XG4gICAgICBzaG93Q29tcGFzczogITAsXG4gICAgICBzaG93Wm9vbTogITAsXG4gICAgICB2aXN1YWxpemVQaXRjaDogITFcbiAgICB9LFxuICAgICAgICBEciA9IGZ1bmN0aW9uIERyKGUpIHtcbiAgICAgIHZhciBvID0gdGhpcztcbiAgICAgIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCB6ciwgZSksIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIpLCB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KSwgdGhpcy5vcHRpb25zLnNob3dab29tICYmICh0LmJpbmRBbGwoW1wiX3NldEJ1dHRvblRpdGxlXCIsIFwiX3VwZGF0ZVpvb21CdXR0b25zXCJdLCB0aGlzKSwgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwibWFwYm94Z2wtY3RybC16b29tLWluXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBvLl9tYXAuem9vbUluKHt9LCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogdFxuICAgICAgICB9KTtcbiAgICAgIH0pLCBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBib3hnbC1jdHJsLWljb25cIiwgdGhpcy5fem9vbUluQnV0dG9uKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJtYXBib3hnbC1jdHJsLXpvb20tb3V0XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBvLl9tYXAuem9vbU91dCh7fSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgfSk7XG4gICAgICB9KSwgaS5jcmVhdGUoXCJzcGFuXCIsIFwibWFwYm94Z2wtY3RybC1pY29uXCIsIHRoaXMuX3pvb21PdXRCdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSksIHRoaXMub3B0aW9ucy5zaG93Q29tcGFzcyAmJiAodC5iaW5kQWxsKFtcIl9yb3RhdGVDb21wYXNzQXJyb3dcIl0sIHRoaXMpLCB0aGlzLl9jb21wYXNzID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwibWFwYm94Z2wtY3RybC1jb21wYXNzXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIG8ub3B0aW9ucy52aXN1YWxpemVQaXRjaCA/IG8uX21hcC5yZXNldE5vcnRoUGl0Y2goe30sIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgIH0pIDogby5fbWFwLnJlc2V0Tm9ydGgoe30sIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgIH0pO1xuICAgICAgfSksIHRoaXMuX2NvbXBhc3NJY29uID0gaS5jcmVhdGUoXCJzcGFuXCIsIFwibWFwYm94Z2wtY3RybC1pY29uXCIsIHRoaXMuX2NvbXBhc3MpLCB0aGlzLl9jb21wYXNzSWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCkpO1xuICAgIH07XG5cbiAgICBEci5wcm90b3R5cGUuX3VwZGF0ZVpvb21CdXR0b25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgIGUgPSB0ID09PSB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpLFxuICAgICAgICAgIGkgPSB0ID09PSB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpO1xuXG4gICAgICB0aGlzLl96b29tSW5CdXR0b24uZGlzYWJsZWQgPSBlLCB0aGlzLl96b29tT3V0QnV0dG9uLmRpc2FibGVkID0gaSwgdGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgZS50b1N0cmluZygpKSwgdGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgfSwgRHIucHJvdG90eXBlLl9yb3RhdGVDb21wYXNzQXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCA/IFwic2NhbGUoXCIgKyAxIC8gTWF0aC5wb3coTWF0aC5jb3ModGhpcy5fbWFwLnRyYW5zZm9ybS5waXRjaCAqIChNYXRoLlBJIC8gMTgwKSksIC41KSArIFwiKSByb3RhdGVYKFwiICsgdGhpcy5fbWFwLnRyYW5zZm9ybS5waXRjaCArIFwiZGVnKSByb3RhdGVaKFwiICsgdGhpcy5fbWFwLnRyYW5zZm9ybS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSArIFwiZGVnKVwiIDogXCJyb3RhdGUoXCIgKyB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICogKDE4MCAvIE1hdGguUEkpICsgXCJkZWcpXCI7XG4gICAgICB0aGlzLl9jb21wYXNzSWNvbi5zdHlsZS50cmFuc2Zvcm0gPSB0O1xuICAgIH0sIERyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID0gdCwgdGhpcy5vcHRpb25zLnNob3dab29tICYmICh0aGlzLl9zZXRCdXR0b25UaXRsZSh0aGlzLl96b29tSW5CdXR0b24sIFwiWm9vbUluXCIpLCB0aGlzLl9zZXRCdXR0b25UaXRsZSh0aGlzLl96b29tT3V0QnV0dG9uLCBcIlpvb21PdXRcIiksIHRoaXMuX21hcC5vbihcInpvb21cIiwgdGhpcy5fdXBkYXRlWm9vbUJ1dHRvbnMpLCB0aGlzLl91cGRhdGVab29tQnV0dG9ucygpKSwgdGhpcy5vcHRpb25zLnNob3dDb21wYXNzICYmICh0aGlzLl9zZXRCdXR0b25UaXRsZSh0aGlzLl9jb21wYXNzLCBcIlJlc2V0QmVhcmluZ1wiKSwgdGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoICYmIHRoaXMuX21hcC5vbihcInBpdGNoXCIsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdyksIHRoaXMuX21hcC5vbihcInJvdGF0ZVwiLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3cpLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3coKSwgdGhpcy5faGFuZGxlciA9IG5ldyBBcih0aGlzLl9tYXAsIHRoaXMuX2NvbXBhc3MsIHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCkpLCB0aGlzLl9jb250YWluZXI7XG4gICAgfSwgRHIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5vcHRpb25zLnNob3dab29tICYmIHRoaXMuX21hcC5vZmYoXCJ6b29tXCIsIHRoaXMuX3VwZGF0ZVpvb21CdXR0b25zKSwgdGhpcy5vcHRpb25zLnNob3dDb21wYXNzICYmICh0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggJiYgdGhpcy5fbWFwLm9mZihcInBpdGNoXCIsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdyksIHRoaXMuX21hcC5vZmYoXCJyb3RhdGVcIiwgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KSwgdGhpcy5faGFuZGxlci5vZmYoKSwgZGVsZXRlIHRoaXMuX2hhbmRsZXIpLCBkZWxldGUgdGhpcy5fbWFwO1xuICAgIH0sIERyLnByb3RvdHlwZS5fY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBvID0gaS5jcmVhdGUoXCJidXR0b25cIiwgdCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgIHJldHVybiBvLnR5cGUgPSBcImJ1dHRvblwiLCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlKSwgbztcbiAgICB9LCBEci5wcm90b3R5cGUuX3NldEJ1dHRvblRpdGxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIk5hdmlnYXRpb25Db250cm9sLlwiICsgZSk7XG5cbiAgICAgIHQudGl0bGUgPSBpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgaSk7XG4gICAgfTtcblxuICAgIHZhciBBciA9IGZ1bmN0aW9uIEFyKGUsIG8sIHIpIHtcbiAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9ICExKSwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgPSAxMCwgdGhpcy5lbGVtZW50ID0gbywgdGhpcy5tb3VzZVJvdGF0ZSA9IG5ldyBYbyh7XG4gICAgICAgIGNsaWNrVG9sZXJhbmNlOiBlLmRyYWdSb3RhdGUuX21vdXNlUm90YXRlLl9jbGlja1RvbGVyYW5jZVxuICAgICAgfSksIHRoaXMubWFwID0gZSwgciAmJiAodGhpcy5tb3VzZVBpdGNoID0gbmV3IEhvKHtcbiAgICAgICAgY2xpY2tUb2xlcmFuY2U6IGUuZHJhZ1JvdGF0ZS5fbW91c2VQaXRjaC5fY2xpY2tUb2xlcmFuY2VcbiAgICAgIH0pKSwgdC5iaW5kQWxsKFtcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIiwgXCJyZXNldFwiXSwgdGhpcyksIGkuYWRkRXZlbnRMaXN0ZW5lcihvLCBcIm1vdXNlZG93blwiLCB0aGlzLm1vdXNlZG93biksIGkuYWRkRXZlbnRMaXN0ZW5lcihvLCBcInRvdWNoc3RhcnRcIiwgdGhpcy50b3VjaHN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6ICExXG4gICAgICB9KSwgaS5hZGRFdmVudExpc3RlbmVyKG8sIFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlKSwgaS5hZGRFdmVudExpc3RlbmVyKG8sIFwidG91Y2hlbmRcIiwgdGhpcy50b3VjaGVuZCksIGkuYWRkRXZlbnRMaXN0ZW5lcihvLCBcInRvdWNoY2FuY2VsXCIsIHRoaXMucmVzZXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBNcihlLCBpLCBvKSB7XG4gICAgICBpZiAoZSA9IG5ldyB0LkxuZ0xhdChlLmxuZywgZS5sYXQpLCBpKSB7XG4gICAgICAgIHZhciByID0gbmV3IHQuTG5nTGF0KGUubG5nIC0gMzYwLCBlLmxhdCksXG4gICAgICAgICAgICBhID0gbmV3IHQuTG5nTGF0KGUubG5nICsgMzYwLCBlLmxhdCksXG4gICAgICAgICAgICBuID0gby5sb2NhdGlvblBvaW50KGUpLmRpc3RTcXIoaSk7XG4gICAgICAgIG8ubG9jYXRpb25Qb2ludChyKS5kaXN0U3FyKGkpIDwgbiA/IGUgPSByIDogby5sb2NhdGlvblBvaW50KGEpLmRpc3RTcXIoaSkgPCBuICYmIChlID0gYSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBNYXRoLmFicyhlLmxuZyAtIG8uY2VudGVyLmxuZykgPiAxODA7KSB7XG4gICAgICAgIHZhciBzID0gby5sb2NhdGlvblBvaW50KGUpO1xuICAgICAgICBpZiAocy54ID49IDAgJiYgcy55ID49IDAgJiYgcy54IDw9IG8ud2lkdGggJiYgcy55IDw9IG8uaGVpZ2h0KSBicmVhaztcbiAgICAgICAgZS5sbmcgPiBvLmNlbnRlci5sbmcgPyBlLmxuZyAtPSAzNjAgOiBlLmxuZyArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIEFyLnByb3RvdHlwZS5kb3duID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMubW91c2VSb3RhdGUubW91c2Vkb3duKHQsIGUpLCB0aGlzLm1vdXNlUGl0Y2ggJiYgdGhpcy5tb3VzZVBpdGNoLm1vdXNlZG93bih0LCBlKSwgaS5kaXNhYmxlRHJhZygpO1xuICAgIH0sIEFyLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5tYXAsXG4gICAgICAgICAgbyA9IHRoaXMubW91c2VSb3RhdGUubW91c2Vtb3ZlV2luZG93KHQsIGUpO1xuXG4gICAgICBpZiAobyAmJiBvLmJlYXJpbmdEZWx0YSAmJiBpLnNldEJlYXJpbmcoaS5nZXRCZWFyaW5nKCkgKyBvLmJlYXJpbmdEZWx0YSksIHRoaXMubW91c2VQaXRjaCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubW91c2VQaXRjaC5tb3VzZW1vdmVXaW5kb3codCwgZSk7XG4gICAgICAgIHIgJiYgci5waXRjaERlbHRhICYmIGkuc2V0UGl0Y2goaS5nZXRQaXRjaCgpICsgci5waXRjaERlbHRhKTtcbiAgICAgIH1cbiAgICB9LCBBci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZWRvd24pLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMudG91Y2hzdGFydCwge1xuICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgfSksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLnJlc2V0KSwgdGhpcy5vZmZUZW1wKCk7XG4gICAgfSwgQXIucHJvdG90eXBlLm9mZlRlbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLmVuYWJsZURyYWcoKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQud2luZG93LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LndpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMubW91c2V1cCk7XG4gICAgfSwgQXIucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLmRvd24odC5leHRlbmQoe30sIGUsIHtcbiAgICAgICAgY3RybEtleTogITAsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KSwgaS5tb3VzZVBvcyh0aGlzLmVsZW1lbnQsIGUpKSwgaS5hZGRFdmVudExpc3RlbmVyKHQud2luZG93LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSksIGkuYWRkRXZlbnRMaXN0ZW5lcih0LndpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMubW91c2V1cCk7XG4gICAgfSwgQXIucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLm1vdmUodCwgaS5tb3VzZVBvcyh0aGlzLmVsZW1lbnQsIHQpKTtcbiAgICB9LCBBci5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLm1vdXNlUm90YXRlLm1vdXNldXBXaW5kb3codCksIHRoaXMubW91c2VQaXRjaCAmJiB0aGlzLm1vdXNlUGl0Y2gubW91c2V1cFdpbmRvdyh0KSwgdGhpcy5vZmZUZW1wKCk7XG4gICAgfSwgQXIucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgMSAhPT0gdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA/IHRoaXMucmVzZXQoKSA6ICh0aGlzLl9zdGFydFBvcyA9IHRoaXMuX2xhc3RQb3MgPSBpLnRvdWNoUG9zKHRoaXMuZWxlbWVudCwgdC50YXJnZXRUb3VjaGVzKVswXSwgdGhpcy5kb3duKHtcbiAgICAgICAgdHlwZTogXCJtb3VzZWRvd25cIixcbiAgICAgICAgYnV0dG9uOiAwLFxuICAgICAgICBjdHJsS2V5OiAhMCxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX3N0YXJ0UG9zKSk7XG4gICAgfSwgQXIucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAxICE9PSB0LnRhcmdldFRvdWNoZXMubGVuZ3RoID8gdGhpcy5yZXNldCgpIDogKHRoaXMuX2xhc3RQb3MgPSBpLnRvdWNoUG9zKHRoaXMuZWxlbWVudCwgdC50YXJnZXRUb3VjaGVzKVswXSwgdGhpcy5tb3ZlKHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2xhc3RQb3MpKTtcbiAgICB9LCBBci5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgMCA9PT0gdC50YXJnZXRUb3VjaGVzLmxlbmd0aCAmJiB0aGlzLl9zdGFydFBvcyAmJiB0aGlzLl9sYXN0UG9zICYmIHRoaXMuX3N0YXJ0UG9zLmRpc3QodGhpcy5fbGFzdFBvcykgPCB0aGlzLl9jbGlja1RvbGVyYW5jZSAmJiB0aGlzLmVsZW1lbnQuY2xpY2soKSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIEFyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubW91c2VSb3RhdGUucmVzZXQoKSwgdGhpcy5tb3VzZVBpdGNoICYmIHRoaXMubW91c2VQaXRjaC5yZXNldCgpLCBkZWxldGUgdGhpcy5fc3RhcnRQb3MsIGRlbGV0ZSB0aGlzLl9sYXN0UG9zLCB0aGlzLm9mZlRlbXAoKTtcbiAgICB9O1xuICAgIHZhciBMciA9IHtcbiAgICAgIGNlbnRlcjogXCJ0cmFuc2xhdGUoLTUwJSwtNTAlKVwiLFxuICAgICAgdG9wOiBcInRyYW5zbGF0ZSgtNTAlLDApXCIsXG4gICAgICBcInRvcC1sZWZ0XCI6IFwidHJhbnNsYXRlKDAsMClcIixcbiAgICAgIFwidG9wLXJpZ2h0XCI6IFwidHJhbnNsYXRlKC0xMDAlLDApXCIsXG4gICAgICBib3R0b206IFwidHJhbnNsYXRlKC01MCUsLTEwMCUpXCIsXG4gICAgICBcImJvdHRvbS1sZWZ0XCI6IFwidHJhbnNsYXRlKDAsLTEwMCUpXCIsXG4gICAgICBcImJvdHRvbS1yaWdodFwiOiBcInRyYW5zbGF0ZSgtMTAwJSwtMTAwJSlcIixcbiAgICAgIGxlZnQ6IFwidHJhbnNsYXRlKDAsLTUwJSlcIixcbiAgICAgIHJpZ2h0OiBcInRyYW5zbGF0ZSgtMTAwJSwtNTAlKVwiXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJyKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdC5jbGFzc0xpc3Q7XG5cbiAgICAgIGZvciAodmFyIHIgaW4gTHIpIHtcbiAgICAgICAgby5yZW1vdmUoXCJtYXBib3hnbC1cIiArIGkgKyBcIi1hbmNob3ItXCIgKyByKTtcbiAgICAgIH1cblxuICAgICAgby5hZGQoXCJtYXBib3hnbC1cIiArIGkgKyBcIi1hbmNob3ItXCIgKyBlKTtcbiAgICB9XG5cbiAgICB2YXIga3IsXG4gICAgICAgIEJyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIG8obywgcikge1xuICAgICAgICBpZiAoZS5jYWxsKHRoaXMpLCAobyBpbnN0YW5jZW9mIHQud2luZG93LkhUTUxFbGVtZW50IHx8IHIpICYmIChvID0gdC5leHRlbmQoe1xuICAgICAgICAgIGVsZW1lbnQ6IG9cbiAgICAgICAgfSwgcikpLCB0LmJpbmRBbGwoW1wiX3VwZGF0ZVwiLCBcIl9vbk1vdmVcIiwgXCJfb25VcFwiLCBcIl9hZGREcmFnSGFuZGxlclwiLCBcIl9vbk1hcENsaWNrXCIsIFwiX29uS2V5UHJlc3NcIl0sIHRoaXMpLCB0aGlzLl9hbmNob3IgPSBvICYmIG8uYW5jaG9yIHx8IFwiY2VudGVyXCIsIHRoaXMuX2NvbG9yID0gbyAmJiBvLmNvbG9yIHx8IFwiIzNGQjFDRVwiLCB0aGlzLl9zY2FsZSA9IG8gJiYgby5zY2FsZSB8fCAxLCB0aGlzLl9kcmFnZ2FibGUgPSBvICYmIG8uZHJhZ2dhYmxlIHx8ICExLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IG8gJiYgby5jbGlja1RvbGVyYW5jZSB8fCAwLCB0aGlzLl9pc0RyYWdnaW5nID0gITEsIHRoaXMuX3N0YXRlID0gXCJpbmFjdGl2ZVwiLCB0aGlzLl9yb3RhdGlvbiA9IG8gJiYgby5yb3RhdGlvbiB8fCAwLCB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCA9IG8gJiYgby5yb3RhdGlvbkFsaWdubWVudCB8fCBcImF1dG9cIiwgdGhpcy5fcGl0Y2hBbGlnbm1lbnQgPSBvICYmIG8ucGl0Y2hBbGlnbm1lbnQgJiYgXCJhdXRvXCIgIT09IG8ucGl0Y2hBbGlnbm1lbnQgPyBvLnBpdGNoQWxpZ25tZW50IDogdGhpcy5fcm90YXRpb25BbGlnbm1lbnQsIG8gJiYgby5lbGVtZW50KSB0aGlzLl9lbGVtZW50ID0gby5lbGVtZW50LCB0aGlzLl9vZmZzZXQgPSB0LlBvaW50LmNvbnZlcnQobyAmJiBvLm9mZnNldCB8fCBbMCwgMF0pO2Vsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRNYXJrZXIgPSAhMCwgdGhpcy5fZWxlbWVudCA9IGkuY3JlYXRlKFwiZGl2XCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJNYXAgbWFya2VyXCIpO1xuICAgICAgICAgIHZhciBhID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgICAgICAgIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCI0MXB4XCIpLCBhLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgXCIyN3B4XCIpLCBhLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidmlld0JveFwiLCBcIjAgMCAyNyA0MVwiKTtcbiAgICAgICAgICB2YXIgbiA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZVwiLCBcIm5vbmVcIiksIG4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpLCBuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIiksIG4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgICAgIHZhciBzID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgICBzLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgICAgICB2YXIgbCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgzLjAsIDI5LjApXCIpLCBsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIiMwMDAwMDBcIik7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMCwgdSA9IFt7XG4gICAgICAgICAgICByeDogXCIxMC41XCIsXG4gICAgICAgICAgICByeTogXCI1LjI1MDAyMjczXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICByeDogXCIxMC41XCIsXG4gICAgICAgICAgICByeTogXCI1LjI1MDAyMjczXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICByeDogXCI5LjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjQuNzcyNzUwMDdcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJ4OiBcIjguNVwiLFxuICAgICAgICAgICAgcnk6IFwiNC4yOTU0OTkzNlwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcng6IFwiNy41XCIsXG4gICAgICAgICAgICByeTogXCIzLjgxODIyMzA4XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICByeDogXCI2LjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjMuMzQwOTQ2NzlcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJ4OiBcIjUuNVwiLFxuICAgICAgICAgICAgcnk6IFwiMi44NjM2NzA1MVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcng6IFwiNC41XCIsXG4gICAgICAgICAgICByeTogXCIyLjM4NjM2ODY0XCJcbiAgICAgICAgICB9XTsgYyA8IHUubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBoID0gdVtjXSxcbiAgICAgICAgICAgICAgICBwID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZWxsaXBzZVwiKTtcbiAgICAgICAgICAgIHAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJvcGFjaXR5XCIsIFwiMC4wNFwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN4XCIsIFwiMTAuNVwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIFwiNS44MDAyOTAwOFwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJ4XCIsIGgucngpLCBwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwicnlcIiwgaC5yeSksIGwuYXBwZW5kQ2hpbGQocCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGQgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgIGQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX2NvbG9yKTtcblxuICAgICAgICAgIHZhciBfID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcblxuICAgICAgICAgIF8uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIFwiTTI3LDEzLjUgQzI3LDE5LjA3NDY0NCAyMC4yNTAwMDEsMjcuMDAwMDAyIDE0Ljc1LDM0LjUwMDAwMiBDMTQuMDE2NjY1LDM1LjUwMDAwNCAxMi45ODMzMzUsMzUuNTAwMDA0IDEyLjI1LDM0LjUwMDAwMiBDNi43NDk5OTkzLDI3LjAwMDAwMiAwLDE5LjIyMjU2MiAwLDEzLjUgQzAsNi4wNDQxNTU5IDYuMDQ0MTU1OSwwIDEzLjUsMCBDMjAuOTU1ODQ0LDAgMjcsNi4wNDQxNTU5IDI3LDEzLjUgWlwiKSwgZC5hcHBlbmRDaGlsZChfKTtcbiAgICAgICAgICB2YXIgZiA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgZi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9wYWNpdHlcIiwgXCIwLjI1XCIpLCBmLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIiMwMDAwMDBcIik7XG4gICAgICAgICAgdmFyIG0gPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgICAgICAgIG0uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIFwiTTEzLjUsMCBDNi4wNDQxNTU5LDAgMCw2LjA0NDE1NTkgMCwxMy41IEMwLDE5LjIyMjU2MiA2Ljc0OTk5OTMsMjcgMTIuMjUsMzQuNSBDMTMsMzUuNTIyNzI3IDE0LjAxNjY2NCwzNS41MDAwMDQgMTQuNzUsMzQuNSBDMjAuMjUwMDAxLDI3IDI3LDE5LjA3NDY0NCAyNywxMy41IEMyNyw2LjA0NDE1NTkgMjAuOTU1ODQ0LDAgMTMuNSwwIFogTTEzLjUsMSBDMjAuNDE1NDA0LDEgMjYsNi41ODQ1OTYgMjYsMTMuNSBDMjYsMTUuODk4NjU3IDI0LjQ5NTU4NCwxOS4xODE0MzEgMjIuMjIwNzAzLDIyLjczODI4MSBDMTkuOTQ1ODIzLDI2LjI5NTEzMiAxNi43MDUxMTksMzAuMTQyMTY3IDEzLjk0MzM1OSwzMy45MDgyMDMgQzEzLjc0MzQ0NSwzNC4xODA4MTQgMTMuNjEyNzE1LDM0LjMyMjczOCAxMy41LDM0LjQ0MTQwNiBDMTMuMzg3Mjg1LDM0LjMyMjczOCAxMy4yNTY1NTUsMzQuMTgwODE0IDEzLjA1NjY0MSwzMy45MDgyMDMgQzEwLjI4NDQ4MSwzMC4xMjc5ODUgNy40MTQ4Njg0LDI2LjMxNDE1OSA1LjAxNTYyNSwyMi43NzM0MzggQzIuNjE2MzgxNiwxOS4yMzI3MTUgMSwxNS45NTM1MzggMSwxMy41IEMxLDYuNTg0NTk2IDYuNTg0NTk2LDEgMTMuNSwxIFpcIiksIGYuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgICAgdmFyIGcgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoNi4wLCA3LjApXCIpLCBnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIiNGRkZGRkZcIik7XG4gICAgICAgICAgdmFyIHYgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgIHYuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoOC4wLCA4LjApXCIpO1xuICAgICAgICAgIHZhciB5ID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xuICAgICAgICAgIHkuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKSwgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9wYWNpdHlcIiwgXCIwLjI1XCIpLCB5LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgXCI1LjVcIiksIHkuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBcIjUuNVwiKSwgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgXCI1LjQ5OTk5NjJcIik7XG4gICAgICAgICAgdmFyIHggPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIik7XG4gICAgICAgICAgeC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCIjRkZGRkZGXCIpLCB4LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgXCI1LjVcIiksIHguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBcIjUuNVwiKSwgeC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgXCI1LjQ5OTk5NjJcIiksIHYuYXBwZW5kQ2hpbGQoeSksIHYuYXBwZW5kQ2hpbGQoeCksIHMuYXBwZW5kQ2hpbGQobCksIHMuYXBwZW5kQ2hpbGQoZCksIHMuYXBwZW5kQ2hpbGQoZiksIHMuYXBwZW5kQ2hpbGQoZyksIHMuYXBwZW5kQ2hpbGQodiksIGEuYXBwZW5kQ2hpbGQocyksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgNDEgKiB0aGlzLl9zY2FsZSArIFwicHhcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCAyNyAqIHRoaXMuX3NjYWxlICsgXCJweFwiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZChhKSwgdGhpcy5fb2Zmc2V0ID0gdC5Qb2ludC5jb252ZXJ0KG8gJiYgby5vZmZzZXQgfHwgWzAsIC0xNF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLW1hcmtlclwiKSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KSwgUnIodGhpcy5fZWxlbWVudCwgdGhpcy5fYW5jaG9yLCBcIm1hcmtlclwiKSwgdGhpcy5fcG9wdXAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvLCBvLnByb3RvdHlwZS5hZGRUbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpLCB0aGlzLl9tYXAgPSB0LCB0LmdldENhbnZhc0NvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLCB0Lm9uKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0Lm9uKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLnNldERyYWdnYWJsZSh0aGlzLl9kcmFnZ2FibGUpLCB0aGlzLl91cGRhdGUoKSwgdGhpcy5fbWFwLm9uKFwiY2xpY2tcIiwgdGhpcy5fb25NYXBDbGljayksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAgJiYgKHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLCB0aGlzLl9vbk1hcENsaWNrKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVlbmRcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlZG93blwiLCB0aGlzLl9hZGREcmFnSGFuZGxlciksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNldXBcIiwgdGhpcy5fb25VcCksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaGVuZFwiLCB0aGlzLl9vblVwKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdmUpLCB0aGlzLl9tYXAub2ZmKFwidG91Y2htb3ZlXCIsIHRoaXMuX29uTW92ZSksIGRlbGV0ZSB0aGlzLl9tYXApLCBpLnJlbW92ZSh0aGlzLl9lbGVtZW50KSwgdGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAucmVtb3ZlKCksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRMbmdMYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sbmdMYXQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRMbmdMYXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0ID0gdC5MbmdMYXQuY29udmVydChlKSwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAuc2V0TG5nTGF0KHRoaXMuX2xuZ0xhdCksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRQb3B1cCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3B1cCAmJiAodGhpcy5fcG9wdXAucmVtb3ZlKCksIHRoaXMuX3BvcHVwID0gbnVsbCwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyksIHRoaXMuX29yaWdpbmFsVGFiSW5kZXggfHwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSksIHQpIHtcbiAgICAgICAgICBpZiAoIShcIm9mZnNldFwiIGluIHQub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBlID0gTWF0aC5zcXJ0KE1hdGgucG93KDEzLjUsIDIpIC8gMik7XG4gICAgICAgICAgICB0Lm9wdGlvbnMub2Zmc2V0ID0gdGhpcy5fZGVmYXVsdE1hcmtlciA/IHtcbiAgICAgICAgICAgICAgdG9wOiBbMCwgMF0sXG4gICAgICAgICAgICAgIFwidG9wLWxlZnRcIjogWzAsIDBdLFxuICAgICAgICAgICAgICBcInRvcC1yaWdodFwiOiBbMCwgMF0sXG4gICAgICAgICAgICAgIGJvdHRvbTogWzAsIC0zOC4xXSxcbiAgICAgICAgICAgICAgXCJib3R0b20tbGVmdFwiOiBbZSwgLTEgKiAoMjQuNiArIGUpXSxcbiAgICAgICAgICAgICAgXCJib3R0b20tcmlnaHRcIjogWy1lLCAtMSAqICgyNC42ICsgZSldLFxuICAgICAgICAgICAgICBsZWZ0OiBbMTMuNSwgLTI0LjZdLFxuICAgICAgICAgICAgICByaWdodDogWy0xMy41LCAtMjQuNl1cbiAgICAgICAgICAgIH0gOiB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcG9wdXAgPSB0LCB0aGlzLl9sbmdMYXQgJiYgdGhpcy5fcG9wdXAuc2V0TG5nTGF0KHRoaXMuX2xuZ0xhdCksIHRoaXMuX29yaWdpbmFsVGFiSW5kZXggPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4IHx8IHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCB0aGlzLl9vbktleVByZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uS2V5UHJlc3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQuY29kZSxcbiAgICAgICAgICAgIGkgPSB0LmNoYXJDb2RlIHx8IHQua2V5Q29kZTtcbiAgICAgICAgXCJTcGFjZVwiICE9PSBlICYmIFwiRW50ZXJcIiAhPT0gZSAmJiAzMiAhPT0gaSAmJiAxMyAhPT0gaSB8fCB0aGlzLnRvZ2dsZVBvcHVwKCk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25NYXBDbGljayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdC5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgIGkgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICB0aGlzLl9wb3B1cCAmJiAoZSA9PT0gaSB8fCBpLmNvbnRhaW5zKGUpKSAmJiB0aGlzLnRvZ2dsZVBvcHVwKCk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwO1xuICAgICAgfSwgby5wcm90b3R5cGUudG9nZ2xlUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5fcG9wdXA7XG4gICAgICAgIHJldHVybiB0ID8gKHQuaXNPcGVuKCkgPyB0LnJlbW92ZSgpIDogdC5hZGRUbyh0aGlzLl9tYXApLCB0aGlzKSA6IHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0ucmVuZGVyV29ybGRDb3BpZXMgJiYgKHRoaXMuX2xuZ0xhdCA9IE1yKHRoaXMuX2xuZ0xhdCwgdGhpcy5fcG9zLCB0aGlzLl9tYXAudHJhbnNmb3JtKSksIHRoaXMuX3BvcyA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2xuZ0xhdCkuX2FkZCh0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgIHZhciBlID0gXCJcIjtcbiAgICAgICAgICBcInZpZXdwb3J0XCIgPT09IHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50IHx8IFwiYXV0b1wiID09PSB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCA/IGUgPSBcInJvdGF0ZVooXCIgKyB0aGlzLl9yb3RhdGlvbiArIFwiZGVnKVwiIDogXCJtYXBcIiA9PT0gdGhpcy5fcm90YXRpb25BbGlnbm1lbnQgJiYgKGUgPSBcInJvdGF0ZVooXCIgKyAodGhpcy5fcm90YXRpb24gLSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpKSArIFwiZGVnKVwiKTtcbiAgICAgICAgICB2YXIgbyA9IFwiXCI7XG4gICAgICAgICAgXCJ2aWV3cG9ydFwiID09PSB0aGlzLl9waXRjaEFsaWdubWVudCB8fCBcImF1dG9cIiA9PT0gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgPyBvID0gXCJyb3RhdGVYKDBkZWcpXCIgOiBcIm1hcFwiID09PSB0aGlzLl9waXRjaEFsaWdubWVudCAmJiAobyA9IFwicm90YXRlWChcIiArIHRoaXMuX21hcC5nZXRQaXRjaCgpICsgXCJkZWcpXCIpLCB0ICYmIFwibW92ZWVuZFwiICE9PSB0LnR5cGUgfHwgKHRoaXMuX3BvcyA9IHRoaXMuX3Bvcy5yb3VuZCgpKSwgaS5zZXRUcmFuc2Zvcm0odGhpcy5fZWxlbWVudCwgTHJbdGhpcy5fYW5jaG9yXSArIFwiIHRyYW5zbGF0ZShcIiArIHRoaXMuX3Bvcy54ICsgXCJweCwgXCIgKyB0aGlzLl9wb3MueSArIFwicHgpIFwiICsgbyArIFwiIFwiICsgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG8ucHJvdG90eXBlLmdldE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPSB0LlBvaW50LmNvbnZlcnQoZSksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UgfHwgdGhpcy5fbWFwLl9jbGlja1RvbGVyYW5jZTtcbiAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZS5wb2ludC5kaXN0KHRoaXMuX3BvaW50ZXJkb3duUG9zKSA+PSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyAmJiAodGhpcy5fcG9zID0gZS5wb2ludC5zdWIodGhpcy5fcG9zaXRpb25EZWx0YSksIHRoaXMuX2xuZ0xhdCA9IHRoaXMuX21hcC51bnByb2plY3QodGhpcy5fcG9zKSwgdGhpcy5zZXRMbmdMYXQodGhpcy5fbG5nTGF0KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIsIFwicGVuZGluZ1wiID09PSB0aGlzLl9zdGF0ZSAmJiAodGhpcy5fc3RhdGUgPSBcImFjdGl2ZVwiLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkcmFnc3RhcnRcIikpKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZHJhZ1wiKSkpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiLCB0aGlzLl9wb3NpdGlvbkRlbHRhID0gbnVsbCwgdGhpcy5fcG9pbnRlcmRvd25Qb3MgPSBudWxsLCB0aGlzLl9pc0RyYWdnaW5nID0gITEsIHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fbWFwLm9mZihcInRvdWNobW92ZVwiLCB0aGlzLl9vbk1vdmUpLCBcImFjdGl2ZVwiID09PSB0aGlzLl9zdGF0ZSAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkcmFnZW5kXCIpKSwgdGhpcy5fc3RhdGUgPSBcImluYWN0aXZlXCI7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fYWRkRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKHQub3JpZ2luYWxFdmVudC50YXJnZXQpICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3Bvc2l0aW9uRGVsdGEgPSB0LnBvaW50LnN1Yih0aGlzLl9wb3MpLmFkZCh0aGlzLl9vZmZzZXQpLCB0aGlzLl9wb2ludGVyZG93blBvcyA9IHQucG9pbnQsIHRoaXMuX3N0YXRlID0gXCJwZW5kaW5nXCIsIHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdmUpLCB0aGlzLl9tYXAub24oXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fbWFwLm9uY2UoXCJtb3VzZXVwXCIsIHRoaXMuX29uVXApLCB0aGlzLl9tYXAub25jZShcInRvdWNoZW5kXCIsIHRoaXMuX29uVXApKTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmFnZ2FibGUgPSAhIXQsIHRoaXMuX21hcCAmJiAodCA/ICh0aGlzLl9tYXAub24oXCJtb3VzZWRvd25cIiwgdGhpcy5fYWRkRHJhZ0hhbmRsZXIpLCB0aGlzLl9tYXAub24oXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSkgOiAodGhpcy5fbWFwLm9mZihcIm1vdXNlZG93blwiLCB0aGlzLl9hZGREcmFnSGFuZGxlciksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSkpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuaXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmFnZ2FibGU7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbiA9IHQgfHwgMCwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0Um90YXRpb25BbGlnbm1lbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb25BbGlnbm1lbnQgPSB0IHx8IFwiYXV0b1wiLCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmdldFJvdGF0aW9uQWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb25BbGlnbm1lbnQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRQaXRjaEFsaWdubWVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXRjaEFsaWdubWVudCA9IHQgJiYgXCJhdXRvXCIgIT09IHQgPyB0IDogdGhpcy5fcm90YXRpb25BbGlnbm1lbnQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0UGl0Y2hBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXRjaEFsaWdubWVudDtcbiAgICAgIH0sIG87XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICBPciA9IHtcbiAgICAgIHBvc2l0aW9uT3B0aW9uczoge1xuICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6ICExLFxuICAgICAgICBtYXhpbXVtQWdlOiAwLFxuICAgICAgICB0aW1lb3V0OiA2ZTNcbiAgICAgIH0sXG4gICAgICBmaXRCb3VuZHNPcHRpb25zOiB7XG4gICAgICAgIG1heFpvb206IDE1XG4gICAgICB9LFxuICAgICAgdHJhY2tVc2VyTG9jYXRpb246ICExLFxuICAgICAgc2hvd0FjY3VyYWN5Q2lyY2xlOiAhMCxcbiAgICAgIHNob3dVc2VyTG9jYXRpb246ICEwXG4gICAgfSxcbiAgICAgICAgRnIgPSAwLFxuICAgICAgICBVciA9ICExLFxuICAgICAgICBOciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBvKGkpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgT3IsIGkpLCB0LmJpbmRBbGwoW1wiX29uU3VjY2Vzc1wiLCBcIl9vbkVycm9yXCIsIFwiX29uWm9vbVwiLCBcIl9maW5pc2hcIiwgXCJfc2V0dXBVSVwiLCBcIl91cGRhdGVDYW1lcmFcIiwgXCJfdXBkYXRlTWFya2VyXCJdLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbywgby5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbztcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IGUsIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIpLCBvID0gdGhpcy5fc2V0dXBVSSwgdm9pZCAwICE9PSBrciA/IG8oa3IpIDogdm9pZCAwICE9PSB0LndpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMgPyB0LndpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xuICAgICAgICAgIG5hbWU6IFwiZ2VvbG9jYXRpb25cIlxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgbyhrciA9IFwiZGVuaWVkXCIgIT09IHQuc3RhdGUpO1xuICAgICAgICB9KSA6IG8oa3IgPSAhIXQud2luZG93Lm5hdmlnYXRvci5nZW9sb2NhdGlvbiksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgIH0sIG8ucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2b2lkIDAgIT09IHRoaXMuX2dlb2xvY2F0aW9uV2F0Y2hJRCAmJiAodC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEKSwgdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEID0gdm9pZCAwKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyICYmIHRoaXMuX3VzZXJMb2NhdGlvbkRvdE1hcmtlci5yZW1vdmUoKSwgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlciAmJiB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlci5yZW1vdmUoKSwgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwLm9mZihcInpvb21cIiwgdGhpcy5fb25ab29tKSwgdGhpcy5fbWFwID0gdm9pZCAwLCBGciA9IDAsIFVyID0gITE7XG4gICAgICB9LCBvLnByb3RvdHlwZS5faXNPdXRPZk1hcE1heEJvdW5kcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fbWFwLmdldE1heEJvdW5kcygpLFxuICAgICAgICAgICAgaSA9IHQuY29vcmRzO1xuXG4gICAgICAgIHJldHVybiBlICYmIChpLmxvbmdpdHVkZSA8IGUuZ2V0V2VzdCgpIHx8IGkubG9uZ2l0dWRlID4gZS5nZXRFYXN0KCkgfHwgaS5sYXRpdHVkZSA8IGUuZ2V0U291dGgoKSB8fCBpLmxhdGl0dWRlID4gZS5nZXROb3J0aCgpKTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9zZXRFcnJvclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3dhdGNoU3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFwiV0FJVElOR19BQ1RJVkVcIjpcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkFDVElWRV9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0VSUk9SXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORFwiOlxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQkFDS0dST1VORF9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25TdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pc091dE9mTWFwTWF4Qm91bmRzKGUpKSByZXR1cm4gdGhpcy5fc2V0RXJyb3JTdGF0ZSgpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJvdXRvZm1heGJvdW5kc1wiLCBlKSksIHRoaXMuX3VwZGF0ZU1hcmtlcigpLCB2b2lkIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHN3aXRjaCAodGhpcy5fbGFzdEtub3duUG9zaXRpb24gPSBlLCB0aGlzLl93YXRjaFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiV0FJVElOR19BQ1RJVkVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9FUlJPUlwiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJBQ1RJVkVfTE9DS1wiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EXCI6XG4gICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIFwiT0ZGXCIgIT09IHRoaXMuX3dhdGNoU3RhdGUgJiYgdGhpcy5fdXBkYXRlTWFya2VyKGUpLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgXCJBQ1RJVkVfTE9DS1wiICE9PSB0aGlzLl93YXRjaFN0YXRlIHx8IHRoaXMuX3VwZGF0ZUNhbWVyYShlKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fZG90RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtdXNlci1sb2NhdGlvbi1kb3Qtc3RhbGVcIiksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImdlb2xvY2F0ZVwiLCBlKSksIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICB9LCBvLnByb3RvdHlwZS5fdXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSBuZXcgdC5MbmdMYXQoZS5jb29yZHMubG9uZ2l0dWRlLCBlLmNvb3Jkcy5sYXRpdHVkZSksXG4gICAgICAgICAgICBvID0gZS5jb29yZHMuYWNjdXJhY3ksXG4gICAgICAgICAgICByID0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIGEgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgYmVhcmluZzogclxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZml0Qm91bmRzT3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhpLnRvQm91bmRzKG8pLCBhLCB7XG4gICAgICAgICAgZ2VvbG9jYXRlU291cmNlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGVNYXJrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIHZhciBpID0gbmV3IHQuTG5nTGF0KGUuY29vcmRzLmxvbmdpdHVkZSwgZS5jb29yZHMubGF0aXR1ZGUpO1xuICAgICAgICAgIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyLnNldExuZ0xhdChpKS5hZGRUbyh0aGlzLl9tYXApLCB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIuc2V0TG5nTGF0KGkpLmFkZFRvKHRoaXMuX21hcCksIHRoaXMuX2FjY3VyYWN5ID0gZS5jb29yZHMuYWNjdXJhY3ksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIHRoaXMub3B0aW9ucy5zaG93QWNjdXJhY3lDaXJjbGUgJiYgdGhpcy5fdXBkYXRlQ2lyY2xlUmFkaXVzKCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIucmVtb3ZlKCksIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyLnJlbW92ZSgpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX3VwZGF0ZUNpcmNsZVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLl9tYXAuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAyLFxuICAgICAgICAgICAgZSA9IHRoaXMuX21hcC51bnByb2plY3QoWzAsIHRdKSxcbiAgICAgICAgICAgIGkgPSB0aGlzLl9tYXAudW5wcm9qZWN0KFsxLCB0XSksXG4gICAgICAgICAgICBvID0gZS5kaXN0YW5jZVRvKGkpLFxuICAgICAgICAgICAgciA9IE1hdGguY2VpbCgyICogdGhpcy5fYWNjdXJhY3kgLyBvKTtcblxuICAgICAgICB0aGlzLl9jaXJjbGVFbGVtZW50LnN0eWxlLndpZHRoID0gciArIFwicHhcIiwgdGhpcy5fY2lyY2xlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSByICsgXCJweFwiO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uWm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl91cGRhdGVDaXJjbGVSYWRpdXMoKTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIGlmICgxID09PSBlLmNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIk9GRlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5kaXNhYmxlZCA9ICEwO1xuXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuXG4gICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBpKSwgdm9pZCAwICE9PSB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQgJiYgdGhpcy5fY2xlYXJXYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoMyA9PT0gZS5jb2RlICYmIFVyKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEVycm9yU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJPRkZcIiAhPT0gdGhpcy5fd2F0Y2hTdGF0ZSAmJiB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLl9kb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC11c2VyLWxvY2F0aW9uLWRvdC1zdGFsZVwiKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZXJyb3JcIiwgZSkpLCB0aGlzLl9maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgfSwgby5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SWQpLCB0aGlzLl90aW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fc2V0dXBVSSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlXCIsIHRoaXMuX2NvbnRhaW5lciksIGkuY3JlYXRlKFwic3BhblwiLCBcIm1hcGJveGdsLWN0cmwtaWNvblwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCAhMSA9PT0gZSkge1xuICAgICAgICAgIHQud2Fybk9uY2UoXCJHZW9sb2NhdGlvbiBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUgc28gdGhlIEdlb2xvY2F0ZUNvbnRyb2wgd2lsbCBiZSBkaXNhYmxlZC5cIik7XG5cbiAgICAgICAgICB2YXIgciA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuXG4gICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmRpc2FibGVkID0gITAsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50aXRsZSA9IHIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkdlb2xvY2F0ZUNvbnRyb2wuRmluZE15TG9jYXRpb25cIik7XG5cbiAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBhLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpLCB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmICh0aGlzLl9kb3RFbGVtZW50ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBib3hnbC11c2VyLWxvY2F0aW9uLWRvdFwiKSwgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyID0gbmV3IEJyKHRoaXMuX2RvdEVsZW1lbnQpLCB0aGlzLl9jaXJjbGVFbGVtZW50ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBib3hnbC11c2VyLWxvY2F0aW9uLWFjY3VyYWN5LWNpcmNsZVwiKSwgdGhpcy5fYWNjdXJhY3lDaXJjbGVNYXJrZXIgPSBuZXcgQnIoe1xuICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX2NpcmNsZUVsZW1lbnQsXG4gICAgICAgICAgcGl0Y2hBbGlnbm1lbnQ6IFwibWFwXCJcbiAgICAgICAgfSksIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fd2F0Y2hTdGF0ZSA9IFwiT0ZGXCIpLCB0aGlzLl9tYXAub24oXCJ6b29tXCIsIHRoaXMuX29uWm9vbSkpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMpKSwgdGhpcy5fc2V0dXAgPSAhMCwgdGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmIHRoaXMuX21hcC5vbihcIm1vdmVzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuZ2VvbG9jYXRlU291cmNlIHx8IFwiQUNUSVZFX0xPQ0tcIiAhPT0gby5fd2F0Y2hTdGF0ZSB8fCBlLm9yaWdpbmFsRXZlbnQgJiYgXCJyZXNpemVcIiA9PT0gZS5vcmlnaW5hbEV2ZW50LnR5cGUgfHwgKG8uX3dhdGNoU3RhdGUgPSBcIkJBQ0tHUk9VTkRcIiwgby5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCBvLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgby5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBvLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NldHVwKSByZXR1cm4gdC53YXJuT25jZShcIkdlb2xvY2F0ZSBjb250cm9sIHRyaWdnZXJlZCBiZWZvcmUgYWRkZWQgdG8gYSBtYXBcIiksICExO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3dhdGNoU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiV0FJVElOR19BQ1RJVkVcIiwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25zdGFydFwiKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiV0FJVElOR19BQ1RJVkVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9FUlJPUlwiOlxuICAgICAgICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRfRVJST1JcIjpcbiAgICAgICAgICAgICAgRnItLSwgVXIgPSAhMSwgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiT0ZGXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRcIjpcbiAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0xPQ0tcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9sYXN0S25vd25Qb3NpdGlvbiAmJiB0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fbGFzdEtub3duUG9zaXRpb24pLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbnN0YXJ0XCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3dhdGNoU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJXQUlUSU5HX0FDVElWRVwiOlxuICAgICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9MT0NLXCI6XG4gICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiQUNUSVZFX0VSUk9SXCI6XG4gICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORFwiOlxuICAgICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIik7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EX0VSUk9SXCI6XG4gICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcIk9GRlwiID09PSB0aGlzLl93YXRjaFN0YXRlICYmIHZvaWQgMCAhPT0gdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEKSB0aGlzLl9jbGVhcldhdGNoKCk7ZWxzZSBpZiAodm9pZCAwID09PSB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpIHtcbiAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKSwgKytGciA+IDEgPyAoZSA9IHtcbiAgICAgICAgICAgICAgbWF4aW11bUFnZTogNmU1LFxuICAgICAgICAgICAgICB0aW1lb3V0OiAwXG4gICAgICAgICAgICB9LCBVciA9ICEwKSA6IChlID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uT3B0aW9ucywgVXIgPSAhMSksIHRoaXMuX2dlb2xvY2F0aW9uV2F0Y2hJRCA9IHQud2luZG93Lm5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKHRoaXMuX29uU3VjY2VzcywgdGhpcy5fb25FcnJvciwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgdC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbih0aGlzLl9vblN1Y2Nlc3MsIHRoaXMuX29uRXJyb3IsIHRoaXMub3B0aW9ucy5wb3NpdGlvbk9wdGlvbnMpLCB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX2ZpbmlzaCwgMWU0KTtcblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fY2xlYXJXYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEKSwgdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEID0gdm9pZCAwLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwgXCJmYWxzZVwiKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fdXBkYXRlTWFya2VyKG51bGwpO1xuICAgICAgfSwgbztcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIFpyID0ge1xuICAgICAgbWF4V2lkdGg6IDEwMCxcbiAgICAgIHVuaXQ6IFwibWV0cmljXCJcbiAgICB9LFxuICAgICAgICBxciA9IGZ1bmN0aW9uIHFyKGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCBaciwgZSksIHQuYmluZEFsbChbXCJfb25Nb3ZlXCIsIFwic2V0VW5pdFwiXSwgdGhpcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGpyKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gaSAmJiBpLm1heFdpZHRoIHx8IDEwMCxcbiAgICAgICAgICByID0gdC5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXG4gICAgICAgICAgYSA9IHQudW5wcm9qZWN0KFswLCByXSksXG4gICAgICAgICAgbiA9IHQudW5wcm9qZWN0KFtvLCByXSksXG4gICAgICAgICAgcyA9IGEuZGlzdGFuY2VUbyhuKTtcblxuICAgICAgaWYgKGkgJiYgXCJpbXBlcmlhbFwiID09PSBpLnVuaXQpIHtcbiAgICAgICAgdmFyIGwgPSAzLjI4MDggKiBzO1xuICAgICAgICBsID4gNTI4MCA/IFZyKGUsIG8sIGwgLyA1MjgwLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5NaWxlc1wiKSkgOiBWcihlLCBvLCBsLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5GZWV0XCIpKTtcbiAgICAgIH0gZWxzZSBpICYmIFwibmF1dGljYWxcIiA9PT0gaS51bml0ID8gVnIoZSwgbywgcyAvIDE4NTIsIHQuX2dldFVJU3RyaW5nKFwiU2NhbGVDb250cm9sLk5hdXRpY2FsTWlsZXNcIikpIDogcyA+PSAxZTMgPyBWcihlLCBvLCBzIC8gMWUzLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5LaWxvbWV0ZXJzXCIpKSA6IFZyKGUsIG8sIHMsIHQuX2dldFVJU3RyaW5nKFwiU2NhbGVDb250cm9sLk1ldGVyc1wiKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnIodCwgZSwgaSwgbykge1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSAociA9IGksIChhID0gTWF0aC5wb3coMTAsIChcIlwiICsgTWF0aC5mbG9vcihyKSkubGVuZ3RoIC0gMSkpICogKG4gPSAobiA9IHIgLyBhKSA+PSAxMCA/IDEwIDogbiA+PSA1ID8gNSA6IG4gPj0gMyA/IDMgOiBuID49IDIgPyAyIDogbiA+PSAxID8gMSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gTWF0aC5wb3coMTAsIE1hdGguY2VpbCgtTWF0aC5sb2codCkgLyBNYXRoLkxOMTApKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodCAqIGUpIC8gZTtcbiAgICAgIH0obikpKTtcbiAgICAgIHQuc3R5bGUud2lkdGggPSBlICogKHMgLyBpKSArIFwicHhcIiwgdC5pbm5lckhUTUwgPSBzICsgXCImbmJzcDtcIiArIG87XG4gICAgfVxuXG4gICAgcXIucHJvdG90eXBlLmdldERlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImJvdHRvbS1sZWZ0XCI7XG4gICAgfSwgcXIucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBqcih0aGlzLl9tYXAsIHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICB9LCBxci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IHQsIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLXNjYWxlXCIsIHQuZ2V0Q29udGFpbmVyKCkpLCB0aGlzLl9tYXAub24oXCJtb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX29uTW92ZSgpLCB0aGlzLl9jb250YWluZXI7XG4gICAgfSwgcXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgIH0sIHFyLnByb3RvdHlwZS5zZXRVbml0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51bml0ID0gdCwganIodGhpcy5fbWFwLCB0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBHciA9IGZ1bmN0aW9uIEdyKGUpIHtcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgZSAmJiBlLmNvbnRhaW5lciAmJiAoZS5jb250YWluZXIgaW5zdGFuY2VvZiB0LndpbmRvdy5IVE1MRWxlbWVudCA/IHRoaXMuX2NvbnRhaW5lciA9IGUuY29udGFpbmVyIDogdC53YXJuT25jZShcIkZ1bGwgc2NyZWVuIGNvbnRyb2wgJ2NvbnRhaW5lcicgbXVzdCBiZSBhIERPTSBlbGVtZW50LlwiKSksIHQuYmluZEFsbChbXCJfb25DbGlja0Z1bGxzY3JlZW5cIiwgXCJfY2hhbmdlSWNvblwiXSwgdGhpcyksIFwib25mdWxsc2NyZWVuY2hhbmdlXCIgaW4gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLl9mdWxsc2NyZWVuY2hhbmdlID0gXCJmdWxsc2NyZWVuY2hhbmdlXCIgOiBcIm9ubW96ZnVsbHNjcmVlbmNoYW5nZVwiIGluIHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5fZnVsbHNjcmVlbmNoYW5nZSA9IFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiIDogXCJvbndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiBpbiB0LndpbmRvdy5kb2N1bWVudCA/IHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UgPSBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiA6IFwib25tc2Z1bGxzY3JlZW5jaGFuZ2VcIiBpbiB0LndpbmRvdy5kb2N1bWVudCAmJiAodGhpcy5fZnVsbHNjcmVlbmNoYW5nZSA9IFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCIpO1xuICAgIH07XG5cbiAgICBHci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IGUsIHRoaXMuX2NvbnRhaW5lciB8fCAodGhpcy5fY29udGFpbmVyID0gdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKSwgdGhpcy5fY29udHJvbENvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIpLCB0aGlzLl9jaGVja0Z1bGxzY3JlZW5TdXBwb3J0KCkgPyB0aGlzLl9zZXR1cFVJKCkgOiAodGhpcy5fY29udHJvbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHQud2Fybk9uY2UoXCJUaGlzIGRldmljZSBkb2VzIG5vdCBzdXBwb3J0IGZ1bGxzY3JlZW4gbW9kZS5cIikpLCB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xuICAgIH0sIEdyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGkucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLCB0aGlzLl9tYXAgPSBudWxsLCB0LndpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UsIHRoaXMuX2NoYW5nZUljb24pO1xuICAgIH0sIEdyLnByb3RvdHlwZS5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhISh0LndpbmRvdy5kb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCB0LndpbmRvdy5kb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fCB0LndpbmRvdy5kb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkIHx8IHQud2luZG93LmRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkKTtcbiAgICB9LCBHci5wcm90b3R5cGUuX3NldHVwVUkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGJveGdsLWN0cmwtZnVsbHNjcmVlblwiLCB0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcbiAgICAgIGkuY3JlYXRlKFwic3BhblwiLCBcIm1hcGJveGdsLWN0cmwtaWNvblwiLCBlKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIGUudHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMuX3VwZGF0ZVRpdGxlKCksIHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2tGdWxsc2NyZWVuKSwgdC53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsc2NyZWVuY2hhbmdlLCB0aGlzLl9jaGFuZ2VJY29uKTtcbiAgICB9LCBHci5wcm90b3R5cGUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9nZXRUaXRsZSgpO1xuXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdCksIHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24udGl0bGUgPSB0O1xuICAgIH0sIEdyLnByb3RvdHlwZS5fZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyh0aGlzLl9pc0Z1bGxzY3JlZW4oKSA/IFwiRnVsbHNjcmVlbkNvbnRyb2wuRXhpdFwiIDogXCJGdWxsc2NyZWVuQ29udHJvbC5FbnRlclwiKTtcbiAgICB9LCBHci5wcm90b3R5cGUuX2lzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsc2NyZWVuO1xuICAgIH0sIEdyLnByb3RvdHlwZS5fY2hhbmdlSWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICh0LndpbmRvdy5kb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCB0LndpbmRvdy5kb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCB0LndpbmRvdy5kb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fCB0LndpbmRvdy5kb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSA9PT0gdGhpcy5fY29udGFpbmVyICE9PSB0aGlzLl9mdWxsc2NyZWVuICYmICh0aGlzLl9mdWxsc2NyZWVuID0gIXRoaXMuX2Z1bGxzY3JlZW4sIHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcIm1hcGJveGdsLWN0cmwtc2hyaW5rXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJtYXBib3hnbC1jdHJsLWZ1bGxzY3JlZW5cIiksIHRoaXMuX3VwZGF0ZVRpdGxlKCkpO1xuICAgIH0sIEdyLnByb3RvdHlwZS5fb25DbGlja0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4oKSA/IHQud2luZG93LmRvY3VtZW50LmV4aXRGdWxsc2NyZWVuID8gdC53aW5kb3cuZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKSA6IHQud2luZG93LmRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gPyB0LndpbmRvdy5kb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCkgOiB0LndpbmRvdy5kb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuID8gdC53aW5kb3cuZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpIDogdC53aW5kb3cuZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbiAmJiB0LndpbmRvdy5kb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKCkgOiB0aGlzLl9jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4gPyB0aGlzLl9jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oKSA6IHRoaXMuX2NvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/IHRoaXMuX2NvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpIDogdGhpcy5fY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4gPyB0aGlzLl9jb250YWluZXIubXNSZXF1ZXN0RnVsbHNjcmVlbigpIDogdGhpcy5fY29udGFpbmVyLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuICYmIHRoaXMuX2NvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIH07XG5cbiAgICB2YXIgV3IgPSB7XG4gICAgICBjbG9zZUJ1dHRvbjogITAsXG4gICAgICBjbG9zZU9uQ2xpY2s6ICEwLFxuICAgICAgZm9jdXNBZnRlck9wZW46ICEwLFxuICAgICAgY2xhc3NOYW1lOiBcIlwiLFxuICAgICAgbWF4V2lkdGg6IFwiMjQwcHhcIlxuICAgIH0sXG4gICAgICAgIFhyID0gW1wiYVtocmVmXVwiLCBcIlt0YWJpbmRleF06bm90KFt0YWJpbmRleD0nLTEnXSlcIiwgXCJbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT0nZmFsc2UnXSlcIiwgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pXCIsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLCBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiXS5qb2luKFwiLCBcIiksXG4gICAgICAgIEhyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIG8oaSkge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKE9iamVjdC5jcmVhdGUoV3IpLCBpKSwgdC5iaW5kQWxsKFtcIl91cGRhdGVcIiwgXCJfb25DbG9zZVwiLCBcInJlbW92ZVwiLCBcIl9vbk1vdXNlTW92ZVwiLCBcIl9vbk1vdXNlVXBcIiwgXCJfb25EcmFnXCJdLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbywgby5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwICYmIHRoaXMucmVtb3ZlKCksIHRoaXMuX21hcCA9IGUsIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5fbWFwLm9uKFwiY2xpY2tcIiwgdGhpcy5fb25DbG9zZSksIHRoaXMub3B0aW9ucy5jbG9zZU9uTW92ZSAmJiB0aGlzLl9tYXAub24oXCJtb3ZlXCIsIHRoaXMuX29uQ2xvc2UpLCB0aGlzLl9tYXAub24oXCJyZW1vdmVcIiwgdGhpcy5yZW1vdmUpLCB0aGlzLl91cGRhdGUoKSwgdGhpcy5fZm9jdXNGaXJzdEVsZW1lbnQoKSwgdGhpcy5fdHJhY2tQb2ludGVyID8gKHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX21hcC5vbihcIm1vdXNldXBcIiwgdGhpcy5fb25Nb3VzZVVwKSwgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtcG9wdXAtdHJhY2stcG9pbnRlclwiKSwgdGhpcy5fbWFwLl9jYW52YXNDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLXRyYWNrLXBvaW50ZXJcIikpIDogdGhpcy5fbWFwLm9uKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJvcGVuXCIpKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbWFwO1xuICAgICAgfSwgby5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudCAmJiBpLnJlbW92ZSh0aGlzLl9jb250ZW50KSwgdGhpcy5fY29udGFpbmVyICYmIChpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCBkZWxldGUgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwICYmICh0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl9vbkNsb3NlKSwgdGhpcy5fbWFwLm9mZihcImNsaWNrXCIsIHRoaXMuX29uQ2xvc2UpLCB0aGlzLl9tYXAub2ZmKFwicmVtb3ZlXCIsIHRoaXMucmVtb3ZlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX21hcC5vZmYoXCJtb3VzZXVwXCIsIHRoaXMuX29uTW91c2VVcCksIHRoaXMuX21hcC5vZmYoXCJkcmFnXCIsIHRoaXMuX29uRHJhZyksIGRlbGV0ZSB0aGlzLl9tYXApLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJjbG9zZVwiKSksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRMbmdMYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sbmdMYXQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRMbmdMYXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0ID0gdC5MbmdMYXQuY29udmVydChlKSwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fdHJhY2tQb2ludGVyID0gITEsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9tYXAgJiYgKHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGJveGdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiksIHRoaXMuX21hcC5fY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBib3hnbC10cmFjay1wb2ludGVyXCIpKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLnRyYWNrUG9pbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrUG9pbnRlciA9ICEwLCB0aGlzLl9wb3MgPSBudWxsLCB0aGlzLl91cGRhdGUoKSwgdGhpcy5fbWFwICYmICh0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUpLCB0aGlzLl9tYXAub24oXCJkcmFnXCIsIHRoaXMuX29uRHJhZyksIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiksIHRoaXMuX21hcC5fY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC10cmFjay1wb2ludGVyXCIpKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RE9NQ29udGVudCh0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlKSk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRIVE1MID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvID0gdC53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgciA9IHQud2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuXG4gICAgICAgIGZvciAoci5pbm5lckhUTUwgPSBlOyBpID0gci5maXJzdENoaWxkOykge1xuICAgICAgICAgIG8uYXBwZW5kQ2hpbGQoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXRET01Db250ZW50KG8pO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0TWF4V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnN0eWxlLm1heFdpZHRoO1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0TWF4V2lkdGggPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1heFdpZHRoID0gdCwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRET01Db250ZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQpIGZvciAoOyB0aGlzLl9jb250ZW50Lmhhc0NoaWxkTm9kZXMoKTspIHtcbiAgICAgICAgICB0aGlzLl9jb250ZW50LmZpcnN0Q2hpbGQgJiYgdGhpcy5fY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgdGhpcy5fY29udGVudCA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtcG9wdXAtY29udGVudFwiLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZCh0KSwgdGhpcy5fY3JlYXRlQ2xvc2VCdXR0b24oKSwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX2ZvY3VzRmlyc3RFbGVtZW50KCksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodCk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodCk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRPZmZzZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9mZnNldCA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUudG9nZ2xlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKHQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX2NyZWF0ZUNsb3NlQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24gJiYgKHRoaXMuX2Nsb3NlQnV0dG9uID0gaS5jcmVhdGUoXCJidXR0b25cIiwgXCJtYXBib3hnbC1wb3B1cC1jbG9zZS1idXR0b25cIiwgdGhpcy5fY29udGVudCksIHRoaXMuX2Nsb3NlQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl9jbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2UgcG9wdXBcIiksIHRoaXMuX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IFwiJiMyMTU7XCIsIHRoaXMuX2Nsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsb3NlKSk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0LnBvaW50KTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCAmJiAodGhpcy5fbG5nTGF0IHx8IHRoaXMuX3RyYWNrUG9pbnRlcikgJiYgdGhpcy5fY29udGVudCAmJiAodGhpcy5fY29udGFpbmVyIHx8ICh0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLXBvcHVwXCIsIHRoaXMuX21hcC5nZXRDb250YWluZXIoKSksIHRoaXMuX3RpcCA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwYm94Z2wtcG9wdXAtdGlwXCIsIHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jb250ZW50KSwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSAmJiB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG8uX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHQpO1xuICAgICAgICB9KSwgdGhpcy5fdHJhY2tQb2ludGVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtcG9wdXAtdHJhY2stcG9pbnRlclwiKSksIHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiB0aGlzLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGggIT09IHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiAodGhpcy5fY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gdGhpcy5vcHRpb25zLm1heFdpZHRoKSwgdGhpcy5fbWFwLnRyYW5zZm9ybS5yZW5kZXJXb3JsZENvcGllcyAmJiAhdGhpcy5fdHJhY2tQb2ludGVyICYmICh0aGlzLl9sbmdMYXQgPSBNcih0aGlzLl9sbmdMYXQsIHRoaXMuX3BvcywgdGhpcy5fbWFwLnRyYW5zZm9ybSkpLCAhdGhpcy5fdHJhY2tQb2ludGVyIHx8IGUpKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9wb3MgPSB0aGlzLl90cmFja1BvaW50ZXIgJiYgZSA/IGUgOiB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLFxuICAgICAgICAgICAgICBhID0gdGhpcy5vcHRpb25zLmFuY2hvcixcbiAgICAgICAgICAgICAgbiA9IGZ1bmN0aW9uIGUoaSkge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KC41ICogTWF0aC5wb3coaSwgMikpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2VudGVyOiBuZXcgdC5Qb2ludCgwLCAwKSxcbiAgICAgICAgICAgICAgICAgIHRvcDogbmV3IHQuUG9pbnQoMCwgaSksXG4gICAgICAgICAgICAgICAgICBcInRvcC1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIG8pLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogbmV3IHQuUG9pbnQoLW8sIG8pLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiBuZXcgdC5Qb2ludCgwLCAtaSksXG4gICAgICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIC1vKSxcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IG5ldyB0LlBvaW50KC1vLCAtbyksXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBuZXcgdC5Qb2ludChpLCAwKSxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXcgdC5Qb2ludCgtaSwgMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGkgaW5zdGFuY2VvZiB0LlBvaW50IHx8IEFycmF5LmlzQXJyYXkoaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQuUG9pbnQuY29udmVydChpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2VudGVyOiByLFxuICAgICAgICAgICAgICAgICAgdG9wOiByLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiByLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogcixcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogcixcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogcixcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiByLFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IHQuUG9pbnQuY29udmVydChpLmNlbnRlciB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIHRvcDogdC5Qb2ludC5jb252ZXJ0KGkudG9wIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB0LlBvaW50LmNvbnZlcnQoaVtcInRvcC1sZWZ0XCJdIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJ0b3AtcmlnaHRcIl0gfHwgWzAsIDBdKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHQuUG9pbnQuY29udmVydChpLmJvdHRvbSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJib3R0b20tbGVmdFwiXSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHQuUG9pbnQuY29udmVydChpW1wiYm90dG9tLXJpZ2h0XCJdIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgbGVmdDogdC5Qb2ludC5jb252ZXJ0KGkubGVmdCB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0LlBvaW50LmNvbnZlcnQoaS5yaWdodCB8fCBbMCwgMF0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlKG5ldyB0LlBvaW50KDAsIDApKTtcbiAgICAgICAgICB9KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xuXG4gICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICB2YXIgcyxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcyA9IHIueSArIG4uYm90dG9tLnkgPCBjID8gW1widG9wXCJdIDogci55ID4gdGhpcy5fbWFwLnRyYW5zZm9ybS5oZWlnaHQgLSBjID8gW1wiYm90dG9tXCJdIDogW10sIHIueCA8IGwgLyAyID8gcy5wdXNoKFwibGVmdFwiKSA6IHIueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSBsIC8gMiAmJiBzLnB1c2goXCJyaWdodFwiKSwgYSA9IDAgPT09IHMubGVuZ3RoID8gXCJib3R0b21cIiA6IHMuam9pbihcIi1cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHUgPSByLmFkZChuW2FdKS5yb3VuZCgpO1xuICAgICAgICAgIGkuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgTHJbYV0gKyBcIiB0cmFuc2xhdGUoXCIgKyB1LnggKyBcInB4LFwiICsgdS55ICsgXCJweClcIiksIFJyKHRoaXMuX2NvbnRhaW5lciwgYSwgXCJwb3B1cFwiKTtcbiAgICAgICAgfVxuICAgICAgfSwgby5wcm90b3R5cGUuX2ZvY3VzRmlyc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvY3VzQWZ0ZXJPcGVuICYmIHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoWHIpO1xuXG4gICAgICAgICAgdCAmJiB0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfSwgbztcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIEtyID0ge1xuICAgICAgdmVyc2lvbjogdC52ZXJzaW9uLFxuICAgICAgc3VwcG9ydGVkOiBlLFxuICAgICAgc2V0UlRMVGV4dFBsdWdpbjogdC5zZXRSVExUZXh0UGx1Z2luLFxuICAgICAgZ2V0UlRMVGV4dFBsdWdpblN0YXR1czogdC5nZXRSVExUZXh0UGx1Z2luU3RhdHVzLFxuICAgICAgTWFwOiBTcixcbiAgICAgIE5hdmlnYXRpb25Db250cm9sOiBEcixcbiAgICAgIEdlb2xvY2F0ZUNvbnRyb2w6IE5yLFxuICAgICAgQXR0cmlidXRpb25Db250cm9sOiB5cixcbiAgICAgIFNjYWxlQ29udHJvbDogcXIsXG4gICAgICBGdWxsc2NyZWVuQ29udHJvbDogR3IsXG4gICAgICBQb3B1cDogSHIsXG4gICAgICBNYXJrZXI6IEJyLFxuICAgICAgU3R5bGU6IGplLFxuICAgICAgTG5nTGF0OiB0LkxuZ0xhdCxcbiAgICAgIExuZ0xhdEJvdW5kczogdC5MbmdMYXRCb3VuZHMsXG4gICAgICBQb2ludDogdC5Qb2ludCxcbiAgICAgIE1lcmNhdG9yQ29vcmRpbmF0ZTogdC5NZXJjYXRvckNvb3JkaW5hdGUsXG4gICAgICBFdmVudGVkOiB0LkV2ZW50ZWQsXG4gICAgICBjb25maWc6IHQuY29uZmlnLFxuICAgICAgcHJld2FybTogZnVuY3Rpb24gcHJld2FybSgpIHtcbiAgICAgICAgRnQoKS5hY3F1aXJlKFJ0KTtcbiAgICAgIH0sXG4gICAgICBjbGVhclByZXdhcm1lZFJlc291cmNlczogZnVuY3Rpb24gY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXMoKSB7XG4gICAgICAgIHZhciB0ID0gQnQ7XG4gICAgICAgIHQgJiYgKHQuaXNQcmVsb2FkZWQoKSAmJiAxID09PSB0Lm51bUFjdGl2ZSgpID8gKHQucmVsZWFzZShSdCksIEJ0ID0gbnVsbCkgOiBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgY2xlYXIgV2ViV29ya2VycyBzaW5jZSB0aGVyZSBhcmUgYWN0aXZlIE1hcCBpbnN0YW5jZXMgdGhhdCBzdGlsbCByZWZlcmVuY2UgaXQuIFRoZSBwcmUtd2FybWVkIFdlYldvcmtlciBwb29sIGNhbiBvbmx5IGJlIGNsZWFyZWQgd2hlbiBhbGwgbWFwIGluc3RhbmNlcyBoYXZlIGJlZW4gcmVtb3ZlZCB3aXRoIG1hcC5yZW1vdmUoKVwiKSk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0LmNvbmZpZy5BQ0NFU1NfVE9LRU47XG4gICAgICB9LFxuXG4gICAgICBzZXQgYWNjZXNzVG9rZW4oZSkge1xuICAgICAgICB0LmNvbmZpZy5BQ0NFU1NfVE9LRU4gPSBlO1xuICAgICAgfSxcblxuICAgICAgZ2V0IGJhc2VBcGlVcmwoKSB7XG4gICAgICAgIHJldHVybiB0LmNvbmZpZy5BUElfVVJMO1xuICAgICAgfSxcblxuICAgICAgc2V0IGJhc2VBcGlVcmwoZSkge1xuICAgICAgICB0LmNvbmZpZy5BUElfVVJMID0gZTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB3b3JrZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGt0LndvcmtlckNvdW50O1xuICAgICAgfSxcblxuICAgICAgc2V0IHdvcmtlckNvdW50KHQpIHtcbiAgICAgICAga3Qud29ya2VyQ291bnQgPSB0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1heFBhcmFsbGVsSW1hZ2VSZXF1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuIHQuY29uZmlnLk1BWF9QQVJBTExFTF9JTUFHRV9SRVFVRVNUUztcbiAgICAgIH0sXG5cbiAgICAgIHNldCBtYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMoZSkge1xuICAgICAgICB0LmNvbmZpZy5NQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFMgPSBlO1xuICAgICAgfSxcblxuICAgICAgY2xlYXJTdG9yYWdlOiBmdW5jdGlvbiBjbGVhclN0b3JhZ2UoZSkge1xuICAgICAgICB0LmNsZWFyVGlsZUNhY2hlKGUpO1xuICAgICAgfSxcbiAgICAgIHdvcmtlclVybDogXCJcIlxuICAgIH07XG5cbiAgICByZXR1cm4gS3I7XG4gIH0pOyAvL1xuXG4gIHJldHVybiBtYXBib3hnbDtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2974\n')}}]);