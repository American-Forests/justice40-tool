(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[281],{3873:function(module){eval("/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  var limit = function limit(x, min, max) {\n    if (min === void 0) min = 0;\n    if (max === void 0) max = 1;\n    return x < min ? min : x > max ? max : x;\n  };\n\n  var clip_rgb = function clip_rgb(rgb) {\n    rgb._clipped = false;\n    rgb._unclipped = rgb.slice(0);\n\n    for (var i = 0; i <= 3; i++) {\n      if (i < 3) {\n        if (rgb[i] < 0 || rgb[i] > 255) {\n          rgb._clipped = true;\n        }\n\n        rgb[i] = limit(rgb[i], 0, 255);\n      } else if (i === 3) {\n        rgb[i] = limit(rgb[i], 0, 1);\n      }\n    }\n\n    return rgb;\n  }; // ported from jQuery's $.type\n\n\n  var classToType = {};\n\n  for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n    var name = list[i];\n    classToType[\"[object \" + name + \"]\"] = name.toLowerCase();\n  }\n\n  var type = function type(obj) {\n    return classToType[Object.prototype.toString.call(obj)] || \"object\";\n  };\n\n  var unpack = function unpack(args, keyOrder) {\n    if (keyOrder === void 0) keyOrder = null; // if called with more than 3 arguments, we return the arguments\n\n    if (args.length >= 3) {\n      return Array.prototype.slice.call(args);\n    } // with less than 3 args we check if first arg is object\n    // and use the keyOrder string to extract and sort properties\n\n\n    if (type(args[0]) == 'object' && keyOrder) {\n      return keyOrder.split('').filter(function (k) {\n        return args[0][k] !== undefined;\n      }).map(function (k) {\n        return args[0][k];\n      });\n    } // otherwise we just return the first argument\n    // (which we suppose is an array of args)\n\n\n    return args[0];\n  };\n\n  var last = function last(args) {\n    if (args.length < 2) {\n      return null;\n    }\n\n    var l = args.length - 1;\n\n    if (type(args[l]) == 'string') {\n      return args[l].toLowerCase();\n    }\n\n    return null;\n  };\n\n  var PI = Math.PI;\n  var utils = {\n    clip_rgb: clip_rgb,\n    limit: limit,\n    type: type,\n    unpack: unpack,\n    last: last,\n    PI: PI,\n    TWOPI: PI * 2,\n    PITHIRD: PI / 3,\n    DEG2RAD: PI / 180,\n    RAD2DEG: 180 / PI\n  };\n  var input = {\n    format: {},\n    autodetect: []\n  };\n  var last$1 = utils.last;\n  var clip_rgb$1 = utils.clip_rgb;\n  var type$1 = utils.type;\n\n  var Color = function Color() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var me = this;\n\n    if (type$1(args[0]) === 'object' && args[0].constructor && args[0].constructor === this.constructor) {\n      // the argument is already a Color instance\n      return args[0];\n    } // last argument could be the mode\n\n\n    var mode = last$1(args);\n    var autodetect = false;\n\n    if (!mode) {\n      autodetect = true;\n\n      if (!input.sorted) {\n        input.autodetect = input.autodetect.sort(function (a, b) {\n          return b.p - a.p;\n        });\n        input.sorted = true;\n      } // auto-detect format\n\n\n      for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n        var chk = list[i];\n        mode = chk.test.apply(chk, args);\n\n        if (mode) {\n          break;\n        }\n      }\n    }\n\n    if (input.format[mode]) {\n      var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));\n      me._rgb = clip_rgb$1(rgb);\n    } else {\n      throw new Error('unknown format: ' + args);\n    } // add alpha channel\n\n\n    if (me._rgb.length === 3) {\n      me._rgb.push(1);\n    }\n  };\n\n  Color.prototype.toString = function toString() {\n    if (type$1(this.hex) == 'function') {\n      return this.hex();\n    }\n\n    return \"[\" + this._rgb.join(',') + \"]\";\n  };\n\n  var Color_1 = Color;\n\n  var chroma = function chroma() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(chroma.Color, [null].concat(args)))();\n  };\n\n  chroma.Color = Color_1;\n  chroma.version = '2.1.2';\n  var chroma_1 = chroma;\n  var unpack$1 = utils.unpack;\n  var max = Math.max;\n\n  var rgb2cmyk = function rgb2cmyk() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$1(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r = r / 255;\n    g = g / 255;\n    b = b / 255;\n    var k = 1 - max(r, max(g, b));\n    var f = k < 1 ? 1 / (1 - k) : 0;\n    var c = (1 - r - k) * f;\n    var m = (1 - g - k) * f;\n    var y = (1 - b - k) * f;\n    return [c, m, y, k];\n  };\n\n  var rgb2cmyk_1 = rgb2cmyk;\n  var unpack$2 = utils.unpack;\n\n  var cmyk2rgb = function cmyk2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$2(args, 'cmyk');\n    var c = args[0];\n    var m = args[1];\n    var y = args[2];\n    var k = args[3];\n    var alpha = args.length > 4 ? args[4] : 1;\n\n    if (k === 1) {\n      return [0, 0, 0, alpha];\n    }\n\n    return [c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n    m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n    y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n    alpha];\n  };\n\n  var cmyk2rgb_1 = cmyk2rgb;\n  var unpack$3 = utils.unpack;\n  var type$2 = utils.type;\n\n  Color_1.prototype.cmyk = function () {\n    return rgb2cmyk_1(this._rgb);\n  };\n\n  chroma_1.cmyk = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['cmyk'])))();\n  };\n\n  input.format.cmyk = cmyk2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$3(args, 'cmyk');\n\n      if (type$2(args) === 'array' && args.length === 4) {\n        return 'cmyk';\n      }\n    }\n  });\n  var unpack$4 = utils.unpack;\n  var last$2 = utils.last;\n\n  var rnd = function rnd(a) {\n    return Math.round(a * 100) / 100;\n  };\n  /*\n   * supported arguments:\n   * - hsl2css(h,s,l)\n   * - hsl2css(h,s,l,a)\n   * - hsl2css([h,s,l], mode)\n   * - hsl2css([h,s,l,a], mode)\n   * - hsl2css({h,s,l,a}, mode)\n   */\n\n\n  var hsl2css = function hsl2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hsla = unpack$4(args, 'hsla');\n    var mode = last$2(args) || 'lsa';\n    hsla[0] = rnd(hsla[0] || 0);\n    hsla[1] = rnd(hsla[1] * 100) + '%';\n    hsla[2] = rnd(hsla[2] * 100) + '%';\n\n    if (mode === 'hsla' || hsla.length > 3 && hsla[3] < 1) {\n      hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n      mode = 'hsla';\n    } else {\n      hsla.length = 3;\n    }\n\n    return mode + \"(\" + hsla.join(',') + \")\";\n  };\n\n  var hsl2css_1 = hsl2css;\n  var unpack$5 = utils.unpack;\n  /*\n   * supported arguments:\n   * - rgb2hsl(r,g,b)\n   * - rgb2hsl(r,g,b,a)\n   * - rgb2hsl([r,g,b])\n   * - rgb2hsl([r,g,b,a])\n   * - rgb2hsl({r,g,b,a})\n   */\n\n  var rgb2hsl = function rgb2hsl() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$5(args, 'rgba');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var l = (max + min) / 2;\n    var s, h;\n\n    if (max === min) {\n      s = 0;\n      h = Number.NaN;\n    } else {\n      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n    }\n\n    if (r == max) {\n      h = (g - b) / (max - min);\n    } else if (g == max) {\n      h = 2 + (b - r) / (max - min);\n    } else if (b == max) {\n      h = 4 + (r - g) / (max - min);\n    }\n\n    h *= 60;\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    if (args.length > 3 && args[3] !== undefined) {\n      return [h, s, l, args[3]];\n    }\n\n    return [h, s, l];\n  };\n\n  var rgb2hsl_1 = rgb2hsl;\n  var unpack$6 = utils.unpack;\n  var last$3 = utils.last;\n  var round = Math.round;\n  /*\n   * supported arguments:\n   * - rgb2css(r,g,b)\n   * - rgb2css(r,g,b,a)\n   * - rgb2css([r,g,b], mode)\n   * - rgb2css([r,g,b,a], mode)\n   * - rgb2css({r,g,b,a}, mode)\n   */\n\n  var rgb2css = function rgb2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$6(args, 'rgba');\n    var mode = last$3(args) || 'rgb';\n\n    if (mode.substr(0, 3) == 'hsl') {\n      return hsl2css_1(rgb2hsl_1(rgba), mode);\n    }\n\n    rgba[0] = round(rgba[0]);\n    rgba[1] = round(rgba[1]);\n    rgba[2] = round(rgba[2]);\n\n    if (mode === 'rgba' || rgba.length > 3 && rgba[3] < 1) {\n      rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n      mode = 'rgba';\n    }\n\n    return mode + \"(\" + rgba.slice(0, mode === 'rgb' ? 3 : 4).join(',') + \")\";\n  };\n\n  var rgb2css_1 = rgb2css;\n  var unpack$7 = utils.unpack;\n  var round$1 = Math.round;\n\n  var hsl2rgb = function hsl2rgb() {\n    var assign;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$7(args, 'hsl');\n    var h = args[0];\n    var s = args[1];\n    var l = args[2];\n    var r, g, b;\n\n    if (s === 0) {\n      r = g = b = l * 255;\n    } else {\n      var t3 = [0, 0, 0];\n      var c = [0, 0, 0];\n      var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var t1 = 2 * l - t2;\n      var h_ = h / 360;\n      t3[0] = h_ + 1 / 3;\n      t3[1] = h_;\n      t3[2] = h_ - 1 / 3;\n\n      for (var i = 0; i < 3; i++) {\n        if (t3[i] < 0) {\n          t3[i] += 1;\n        }\n\n        if (t3[i] > 1) {\n          t3[i] -= 1;\n        }\n\n        if (6 * t3[i] < 1) {\n          c[i] = t1 + (t2 - t1) * 6 * t3[i];\n        } else if (2 * t3[i] < 1) {\n          c[i] = t2;\n        } else if (3 * t3[i] < 2) {\n          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;\n        } else {\n          c[i] = t1;\n        }\n      }\n\n      assign = [round$1(c[0] * 255), round$1(c[1] * 255), round$1(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];\n    }\n\n    if (args.length > 3) {\n      // keep alpha channel\n      return [r, g, b, args[3]];\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var hsl2rgb_1 = hsl2rgb;\n  var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n  var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var round$2 = Math.round;\n\n  var css2rgb = function css2rgb(css) {\n    css = css.toLowerCase().trim();\n    var m;\n\n    if (input.format.named) {\n      try {\n        return input.format.named(css);\n      } catch (e) {// eslint-disable-next-line\n      }\n    } // rgb(250,20,0)\n\n\n    if (m = css.match(RE_RGB)) {\n      var rgb = m.slice(1, 4);\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = +rgb[i];\n      }\n\n      rgb[3] = 1; // default alpha\n\n      return rgb;\n    } // rgba(250,20,0,0.4)\n\n\n    if (m = css.match(RE_RGBA)) {\n      var rgb$1 = m.slice(1, 5);\n\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        rgb$1[i$1] = +rgb$1[i$1];\n      }\n\n      return rgb$1;\n    } // rgb(100%,0%,0%)\n\n\n    if (m = css.match(RE_RGB_PCT)) {\n      var rgb$2 = m.slice(1, 4);\n\n      for (var i$2 = 0; i$2 < 3; i$2++) {\n        rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n      }\n\n      rgb$2[3] = 1; // default alpha\n\n      return rgb$2;\n    } // rgba(100%,0%,0%,0.4)\n\n\n    if (m = css.match(RE_RGBA_PCT)) {\n      var rgb$3 = m.slice(1, 5);\n\n      for (var i$3 = 0; i$3 < 3; i$3++) {\n        rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n      }\n\n      rgb$3[3] = +rgb$3[3];\n      return rgb$3;\n    } // hsl(0,100%,50%)\n\n\n    if (m = css.match(RE_HSL)) {\n      var hsl = m.slice(1, 4);\n      hsl[1] *= 0.01;\n      hsl[2] *= 0.01;\n      var rgb$4 = hsl2rgb_1(hsl);\n      rgb$4[3] = 1;\n      return rgb$4;\n    } // hsla(0,100%,50%,0.5)\n\n\n    if (m = css.match(RE_HSLA)) {\n      var hsl$1 = m.slice(1, 4);\n      hsl$1[1] *= 0.01;\n      hsl$1[2] *= 0.01;\n      var rgb$5 = hsl2rgb_1(hsl$1);\n      rgb$5[3] = +m[4]; // default alpha = 1\n\n      return rgb$5;\n    }\n  };\n\n  css2rgb.test = function (s) {\n    return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);\n  };\n\n  var css2rgb_1 = css2rgb;\n  var type$3 = utils.type;\n\n  Color_1.prototype.css = function (mode) {\n    return rgb2css_1(this._rgb, mode);\n  };\n\n  chroma_1.css = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['css'])))();\n  };\n\n  input.format.css = css2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n        return 'css';\n      }\n    }\n  });\n  var unpack$8 = utils.unpack;\n\n  input.format.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$8(args, 'rgba');\n    rgb[0] *= 255;\n    rgb[1] *= 255;\n    rgb[2] *= 255;\n    return rgb;\n  };\n\n  chroma_1.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['gl'])))();\n  };\n\n  Color_1.prototype.gl = function () {\n    var rgb = this._rgb;\n    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n  };\n\n  var unpack$9 = utils.unpack;\n\n  var rgb2hcg = function rgb2hcg() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$9(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var c = delta * 100 / 255;\n\n    var _g = min / (255 - delta) * 100;\n\n    var h;\n\n    if (delta === 0) {\n      h = Number.NaN;\n    } else {\n      if (r === max) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, c, _g];\n  };\n\n  var rgb2hcg_1 = rgb2hcg;\n  var unpack$a = utils.unpack;\n  var floor = Math.floor;\n  /*\n   * this is basically just HSV with some minor tweaks\n   *\n   * hue.. [0..360]\n   * chroma .. [0..1]\n   * grayness .. [0..1]\n   */\n\n  var hcg2rgb = function hcg2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$a(args, 'hcg');\n    var h = args[0];\n    var c = args[1];\n    var _g = args[2];\n    var r, g, b;\n    _g = _g * 255;\n\n    var _c = c * 255;\n\n    if (c === 0) {\n      r = g = b = _g;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor(h);\n      var f = h - i;\n      var p = _g * (1 - c);\n      var q = p + _c * (1 - f);\n      var t = p + _c * f;\n      var v = p + _c;\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hcg2rgb_1 = hcg2rgb;\n  var unpack$b = utils.unpack;\n  var type$4 = utils.type;\n\n  Color_1.prototype.hcg = function () {\n    return rgb2hcg_1(this._rgb);\n  };\n\n  chroma_1.hcg = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcg'])))();\n  };\n\n  input.format.hcg = hcg2rgb_1;\n  input.autodetect.push({\n    p: 1,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$b(args, 'hcg');\n\n      if (type$4(args) === 'array' && args.length === 3) {\n        return 'hcg';\n      }\n    }\n  });\n  var unpack$c = utils.unpack;\n  var last$4 = utils.last;\n  var round$3 = Math.round;\n\n  var rgb2hex = function rgb2hex() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$c(args, 'rgba');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var a = ref[3];\n    var mode = last$4(args) || 'auto';\n\n    if (a === undefined) {\n      a = 1;\n    }\n\n    if (mode === 'auto') {\n      mode = a < 1 ? 'rgba' : 'rgb';\n    }\n\n    r = round$3(r);\n    g = round$3(g);\n    b = round$3(b);\n    var u = r << 16 | g << 8 | b;\n    var str = \"000000\" + u.toString(16); //#.toUpperCase();\n\n    str = str.substr(str.length - 6);\n    var hxa = '0' + round$3(a * 255).toString(16);\n    hxa = hxa.substr(hxa.length - 2);\n\n    switch (mode.toLowerCase()) {\n      case 'rgba':\n        return \"#\" + str + hxa;\n\n      case 'argb':\n        return \"#\" + hxa + str;\n\n      default:\n        return \"#\" + str;\n    }\n  };\n\n  var rgb2hex_1 = rgb2hex;\n  var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n  var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n  var hex2rgb = function hex2rgb(hex) {\n    if (hex.match(RE_HEX)) {\n      // remove optional leading #\n      if (hex.length === 4 || hex.length === 7) {\n        hex = hex.substr(1);\n      } // expand short-notation to full six-digit\n\n\n      if (hex.length === 3) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n      }\n\n      var u = parseInt(hex, 16);\n      var r = u >> 16;\n      var g = u >> 8 & 0xFF;\n      var b = u & 0xFF;\n      return [r, g, b, 1];\n    } // match rgba hex format, eg #FF000077\n\n\n    if (hex.match(RE_HEXA)) {\n      if (hex.length === 5 || hex.length === 9) {\n        // remove optional leading #\n        hex = hex.substr(1);\n      } // expand short-notation to full eight-digit\n\n\n      if (hex.length === 4) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n      }\n\n      var u$1 = parseInt(hex, 16);\n      var r$1 = u$1 >> 24 & 0xFF;\n      var g$1 = u$1 >> 16 & 0xFF;\n      var b$1 = u$1 >> 8 & 0xFF;\n      var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n      return [r$1, g$1, b$1, a];\n    } // we used to check for css colors here\n    // if _input.css? and rgb = _input.css hex\n    //     return rgb\n\n\n    throw new Error(\"unknown hex color: \" + hex);\n  };\n\n  var hex2rgb_1 = hex2rgb;\n  var type$5 = utils.type;\n\n  Color_1.prototype.hex = function (mode) {\n    return rgb2hex_1(this._rgb, mode);\n  };\n\n  chroma_1.hex = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hex'])))();\n  };\n\n  input.format.hex = hex2rgb_1;\n  input.autodetect.push({\n    p: 4,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$5(h) === 'string' && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {\n        return 'hex';\n      }\n    }\n  });\n  var unpack$d = utils.unpack;\n  var TWOPI = utils.TWOPI;\n  var min = Math.min;\n  var sqrt = Math.sqrt;\n  var acos = Math.acos;\n\n  var rgb2hsi = function rgb2hsi() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n\n\n    var ref = unpack$d(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var h;\n    var min_ = min(r, g, b);\n    var i = (r + g + b) / 3;\n    var s = i > 0 ? 1 - min_ / i : 0;\n\n    if (s === 0) {\n      h = NaN;\n    } else {\n      h = (r - g + (r - b)) / 2;\n      h /= sqrt((r - g) * (r - g) + (r - b) * (g - b));\n      h = acos(h);\n\n      if (b > g) {\n        h = TWOPI - h;\n      }\n\n      h /= TWOPI;\n    }\n\n    return [h * 360, s, i];\n  };\n\n  var rgb2hsi_1 = rgb2hsi;\n  var unpack$e = utils.unpack;\n  var limit$1 = utils.limit;\n  var TWOPI$1 = utils.TWOPI;\n  var PITHIRD = utils.PITHIRD;\n  var cos = Math.cos;\n  /*\n   * hue [0..360]\n   * saturation [0..1]\n   * intensity [0..1]\n   */\n\n  var hsi2rgb = function hsi2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n\n\n    args = unpack$e(args, 'hsi');\n    var h = args[0];\n    var s = args[1];\n    var i = args[2];\n    var r, g, b;\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    if (isNaN(s)) {\n      s = 0;\n    } // normalize hue\n\n\n    if (h > 360) {\n      h -= 360;\n    }\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    h /= 360;\n\n    if (h < 1 / 3) {\n      b = (1 - s) / 3;\n      r = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n      h -= 1 / 3;\n      r = (1 - s) / 3;\n      g = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      b = 1 - (r + g);\n    } else {\n      h -= 2 / 3;\n      g = (1 - s) / 3;\n      b = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      r = 1 - (g + b);\n    }\n\n    r = limit$1(i * r * 3);\n    g = limit$1(i * g * 3);\n    b = limit$1(i * b * 3);\n    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsi2rgb_1 = hsi2rgb;\n  var unpack$f = utils.unpack;\n  var type$6 = utils.type;\n\n  Color_1.prototype.hsi = function () {\n    return rgb2hsi_1(this._rgb);\n  };\n\n  chroma_1.hsi = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsi'])))();\n  };\n\n  input.format.hsi = hsi2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$f(args, 'hsi');\n\n      if (type$6(args) === 'array' && args.length === 3) {\n        return 'hsi';\n      }\n    }\n  });\n  var unpack$g = utils.unpack;\n  var type$7 = utils.type;\n\n  Color_1.prototype.hsl = function () {\n    return rgb2hsl_1(this._rgb);\n  };\n\n  chroma_1.hsl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsl'])))();\n  };\n\n  input.format.hsl = hsl2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$g(args, 'hsl');\n\n      if (type$7(args) === 'array' && args.length === 3) {\n        return 'hsl';\n      }\n    }\n  });\n  var unpack$h = utils.unpack;\n  var min$1 = Math.min;\n  var max$1 = Math.max;\n  /*\n   * supported arguments:\n   * - rgb2hsv(r,g,b)\n   * - rgb2hsv([r,g,b])\n   * - rgb2hsv({r,g,b})\n   */\n\n  var rgb2hsl$1 = function rgb2hsl$1() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$h(args, 'rgb');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    var min_ = min$1(r, g, b);\n    var max_ = max$1(r, g, b);\n    var delta = max_ - min_;\n    var h, s, v;\n    v = max_ / 255.0;\n\n    if (max_ === 0) {\n      h = Number.NaN;\n      s = 0;\n    } else {\n      s = delta / max_;\n\n      if (r === max_) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max_) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max_) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, s, v];\n  };\n\n  var rgb2hsv = rgb2hsl$1;\n  var unpack$i = utils.unpack;\n  var floor$1 = Math.floor;\n\n  var hsv2rgb = function hsv2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$i(args, 'hsv');\n    var h = args[0];\n    var s = args[1];\n    var v = args[2];\n    var r, g, b;\n    v *= 255;\n\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor$1(h);\n      var f = h - i;\n      var p = v * (1 - s);\n      var q = v * (1 - s * f);\n      var t = v * (1 - s * (1 - f));\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsv2rgb_1 = hsv2rgb;\n  var unpack$j = utils.unpack;\n  var type$8 = utils.type;\n\n  Color_1.prototype.hsv = function () {\n    return rgb2hsv(this._rgb);\n  };\n\n  chroma_1.hsv = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsv'])))();\n  };\n\n  input.format.hsv = hsv2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$j(args, 'hsv');\n\n      if (type$8(args) === 'array' && args.length === 3) {\n        return 'hsv';\n      }\n    }\n  });\n  var labConstants = {\n    // Corresponds roughly to RGB brighter/darker\n    Kn: 18,\n    // D65 standard referent\n    Xn: 0.950470,\n    Yn: 1,\n    Zn: 1.088830,\n    t0: 0.137931034,\n    // 4 / 29\n    t1: 0.206896552,\n    // 6 / 29\n    t2: 0.12841855,\n    // 3 * t1 * t1\n    t3: 0.008856452 // t1 * t1 * t1\n\n  };\n  var unpack$k = utils.unpack;\n  var pow = Math.pow;\n\n  var rgb2lab = function rgb2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$k(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2xyz(r, g, b);\n    var x = ref$1[0];\n    var y = ref$1[1];\n    var z = ref$1[2];\n    var l = 116 * y - 16;\n    return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n  };\n\n  var rgb_xyz = function rgb_xyz(r) {\n    if ((r /= 255) <= 0.04045) {\n      return r / 12.92;\n    }\n\n    return pow((r + 0.055) / 1.055, 2.4);\n  };\n\n  var xyz_lab = function xyz_lab(t) {\n    if (t > labConstants.t3) {\n      return pow(t, 1 / 3);\n    }\n\n    return t / labConstants.t2 + labConstants.t0;\n  };\n\n  var rgb2xyz = function rgb2xyz(r, g, b) {\n    r = rgb_xyz(r);\n    g = rgb_xyz(g);\n    b = rgb_xyz(b);\n    var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n    var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n    var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n    return [x, y, z];\n  };\n\n  var rgb2lab_1 = rgb2lab;\n  var unpack$l = utils.unpack;\n  var pow$1 = Math.pow;\n  /*\n   * L* [0..100]\n   * a [-100..100]\n   * b [-100..100]\n   */\n\n  var lab2rgb = function lab2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$l(args, 'lab');\n    var l = args[0];\n    var a = args[1];\n    var b = args[2];\n    var x, y, z, r, g, b_;\n    y = (l + 16) / 116;\n    x = isNaN(a) ? y : y + a / 500;\n    z = isNaN(b) ? y : y - b / 200;\n    y = labConstants.Yn * lab_xyz(y);\n    x = labConstants.Xn * lab_xyz(x);\n    z = labConstants.Zn * lab_xyz(z);\n    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z); // D65 -> sRGB\n\n    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n    b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n    return [r, g, b_, args.length > 3 ? args[3] : 1];\n  };\n\n  var xyz_rgb = function xyz_rgb(r) {\n    return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055);\n  };\n\n  var lab_xyz = function lab_xyz(t) {\n    return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0);\n  };\n\n  var lab2rgb_1 = lab2rgb;\n  var unpack$m = utils.unpack;\n  var type$9 = utils.type;\n\n  Color_1.prototype.lab = function () {\n    return rgb2lab_1(this._rgb);\n  };\n\n  chroma_1.lab = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lab'])))();\n  };\n\n  input.format.lab = lab2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$m(args, 'lab');\n\n      if (type$9(args) === 'array' && args.length === 3) {\n        return 'lab';\n      }\n    }\n  });\n  var unpack$n = utils.unpack;\n  var RAD2DEG = utils.RAD2DEG;\n  var sqrt$1 = Math.sqrt;\n  var atan2 = Math.atan2;\n  var round$4 = Math.round;\n\n  var lab2lch = function lab2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$n(args, 'lab');\n    var l = ref[0];\n    var a = ref[1];\n    var b = ref[2];\n    var c = sqrt$1(a * a + b * b);\n    var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n\n    if (round$4(c * 10000) === 0) {\n      h = Number.NaN;\n    }\n\n    return [l, c, h];\n  };\n\n  var lab2lch_1 = lab2lch;\n  var unpack$o = utils.unpack;\n\n  var rgb2lch = function rgb2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$o(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2lab_1(r, g, b);\n    var l = ref$1[0];\n    var a = ref$1[1];\n    var b_ = ref$1[2];\n    return lab2lch_1(l, a, b_);\n  };\n\n  var rgb2lch_1 = rgb2lch;\n  var unpack$p = utils.unpack;\n  var DEG2RAD = utils.DEG2RAD;\n  var sin = Math.sin;\n  var cos$1 = Math.cos;\n\n  var lch2lab = function lch2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n     A saturation multiplier was added by Gregor Aisch\n    */\n\n\n    var ref = unpack$p(args, 'lch');\n    var l = ref[0];\n    var c = ref[1];\n    var h = ref[2];\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    h = h * DEG2RAD;\n    return [l, cos$1(h) * c, sin(h) * c];\n  };\n\n  var lch2lab_1 = lch2lab;\n  var unpack$q = utils.unpack;\n\n  var lch2rgb = function lch2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$q(args, 'lch');\n    var l = args[0];\n    var c = args[1];\n    var h = args[2];\n    var ref = lch2lab_1(l, c, h);\n    var L = ref[0];\n    var a = ref[1];\n    var b_ = ref[2];\n    var ref$1 = lab2rgb_1(L, a, b_);\n    var r = ref$1[0];\n    var g = ref$1[1];\n    var b = ref$1[2];\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var lch2rgb_1 = lch2rgb;\n  var unpack$r = utils.unpack;\n\n  var hcl2rgb = function hcl2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hcl = unpack$r(args, 'hcl').reverse();\n    return lch2rgb_1.apply(void 0, hcl);\n  };\n\n  var hcl2rgb_1 = hcl2rgb;\n  var unpack$s = utils.unpack;\n  var type$a = utils.type;\n\n  Color_1.prototype.lch = function () {\n    return rgb2lch_1(this._rgb);\n  };\n\n  Color_1.prototype.hcl = function () {\n    return rgb2lch_1(this._rgb).reverse();\n  };\n\n  chroma_1.lch = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lch'])))();\n  };\n\n  chroma_1.hcl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcl'])))();\n  };\n\n  input.format.lch = lch2rgb_1;\n  input.format.hcl = hcl2rgb_1;\n  ['lch', 'hcl'].forEach(function (m) {\n    return input.autodetect.push({\n      p: 2,\n      test: function test() {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) {\n          args[len] = arguments[len];\n        }\n\n        args = unpack$s(args, m);\n\n        if (type$a(args) === 'array' && args.length === 3) {\n          return m;\n        }\n      }\n    });\n  });\n  /**\n  \tX11 color names\n   \thttp://www.w3.org/TR/css3-color/#svg-color\n  */\n\n  var w3cx11 = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflower: '#6495ed',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    laserlemon: '#ffff54',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrod: '#fafad2',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    maroon2: '#7f0000',\n    maroon3: '#b03060',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    purple2: '#7f007f',\n    purple3: '#a020f0',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32'\n  };\n  var w3cx11_1 = w3cx11;\n  var type$b = utils.type;\n\n  Color_1.prototype.name = function () {\n    var hex = rgb2hex_1(this._rgb, 'rgb');\n\n    for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n      var n = list[i];\n\n      if (w3cx11_1[n] === hex) {\n        return n.toLowerCase();\n      }\n    }\n\n    return hex;\n  };\n\n  input.format.named = function (name) {\n    name = name.toLowerCase();\n\n    if (w3cx11_1[name]) {\n      return hex2rgb_1(w3cx11_1[name]);\n    }\n\n    throw new Error('unknown color name: ' + name);\n  };\n\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n        return 'named';\n      }\n    }\n  });\n  var unpack$t = utils.unpack;\n\n  var rgb2num = function rgb2num() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$t(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    return (r << 16) + (g << 8) + b;\n  };\n\n  var rgb2num_1 = rgb2num;\n  var type$c = utils.type;\n\n  var num2rgb = function num2rgb(num) {\n    if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n      var r = num >> 16;\n      var g = num >> 8 & 0xFF;\n      var b = num & 0xFF;\n      return [r, g, b, 1];\n    }\n\n    throw new Error(\"unknown num color: \" + num);\n  };\n\n  var num2rgb_1 = num2rgb;\n  var type$d = utils.type;\n\n  Color_1.prototype.num = function () {\n    return rgb2num_1(this._rgb);\n  };\n\n  chroma_1.num = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['num'])))();\n  };\n\n  input.format.num = num2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n        return 'num';\n      }\n    }\n  });\n  var unpack$u = utils.unpack;\n  var type$e = utils.type;\n  var round$5 = Math.round;\n\n  Color_1.prototype.rgb = function (rnd) {\n    if (rnd === void 0) rnd = true;\n\n    if (rnd === false) {\n      return this._rgb.slice(0, 3);\n    }\n\n    return this._rgb.slice(0, 3).map(round$5);\n  };\n\n  Color_1.prototype.rgba = function (rnd) {\n    if (rnd === void 0) rnd = true;\n    return this._rgb.slice(0, 4).map(function (v, i) {\n      return i < 3 ? rnd === false ? v : round$5(v) : v;\n    });\n  };\n\n  chroma_1.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['rgb'])))();\n  };\n\n  input.format.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$u(args, 'rgba');\n\n    if (rgba[3] === undefined) {\n      rgba[3] = 1;\n    }\n\n    return rgba;\n  };\n\n  input.autodetect.push({\n    p: 3,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$u(args, 'rgba');\n\n      if (type$e(args) === 'array' && (args.length === 3 || args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n        return 'rgb';\n      }\n    }\n  });\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   */\n\n  var log = Math.log;\n\n  var temperature2rgb = function temperature2rgb(kelvin) {\n    var temp = kelvin / 100;\n    var r, g, b;\n\n    if (temp < 66) {\n      r = 255;\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\n      b = 255;\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var temperature2rgb_1 = temperature2rgb;\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   **/\n\n  var unpack$v = utils.unpack;\n  var round$6 = Math.round;\n\n  var rgb2temperature = function rgb2temperature() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$v(args, 'rgb');\n    var r = rgb[0],\n        b = rgb[2];\n    var minTemp = 1000;\n    var maxTemp = 40000;\n    var eps = 0.4;\n    var temp;\n\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      var rgb$1 = temperature2rgb_1(temp);\n\n      if (rgb$1[2] / rgb$1[0] >= b / r) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n\n    return round$6(temp);\n  };\n\n  var rgb2temperature_1 = rgb2temperature;\n\n  Color_1.prototype.temp = Color_1.prototype.kelvin = Color_1.prototype.temperature = function () {\n    return rgb2temperature_1(this._rgb);\n  };\n\n  chroma_1.temp = chroma_1.kelvin = chroma_1.temperature = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['temp'])))();\n  };\n\n  input.format.temp = input.format.kelvin = input.format.temperature = temperature2rgb_1;\n  var type$f = utils.type;\n\n  Color_1.prototype.alpha = function (a, mutate) {\n    if (mutate === void 0) mutate = false;\n\n    if (a !== undefined && type$f(a) === 'number') {\n      if (mutate) {\n        this._rgb[3] = a;\n        return this;\n      }\n\n      return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n    }\n\n    return this._rgb[3];\n  };\n\n  Color_1.prototype.clipped = function () {\n    return this._rgb._clipped || false;\n  };\n\n  Color_1.prototype.darken = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lab = me.lab();\n    lab[0] -= labConstants.Kn * amount;\n    return new Color_1(lab, 'lab').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.brighten = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.darken(-amount);\n  };\n\n  Color_1.prototype.darker = Color_1.prototype.darken;\n  Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n  Color_1.prototype.get = function (mc) {\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        return src[i];\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var type$g = utils.type;\n  var pow$2 = Math.pow;\n  var EPS = 1e-7;\n  var MAX_ITER = 20;\n\n  Color_1.prototype.luminance = function (lum) {\n    if (lum !== undefined && type$g(lum) === 'number') {\n      if (lum === 0) {\n        // return pure black\n        return new Color_1([0, 0, 0, this._rgb[3]], 'rgb');\n      }\n\n      if (lum === 1) {\n        // return pure white\n        return new Color_1([255, 255, 255, this._rgb[3]], 'rgb');\n      } // compute new color using...\n\n\n      var cur_lum = this.luminance();\n      var mode = 'rgb';\n      var max_iter = MAX_ITER;\n\n      var test = function test(low, high) {\n        var mid = low.interpolate(high, 0.5, mode);\n        var lm = mid.luminance();\n\n        if (Math.abs(lum - lm) < EPS || !max_iter--) {\n          // close enough\n          return mid;\n        }\n\n        return lm > lum ? test(low, mid) : test(mid, high);\n      };\n\n      var rgb = (cur_lum > lum ? test(new Color_1([0, 0, 0]), this) : test(this, new Color_1([255, 255, 255]))).rgb();\n      return new Color_1(rgb.concat([this._rgb[3]]));\n    }\n\n    return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));\n  };\n\n  var rgb2luminance = function rgb2luminance(r, g, b) {\n    // relative luminance\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n  };\n\n  var luminance_x = function luminance_x(x) {\n    x /= 255;\n    return x <= 0.03928 ? x / 12.92 : pow$2((x + 0.055) / 1.055, 2.4);\n  };\n\n  var interpolator = {};\n  var type$h = utils.type;\n\n  var mix = function mix(col1, col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 3;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 3];\n    }\n\n    var mode = rest[0] || 'lrgb';\n\n    if (!interpolator[mode] && !rest.length) {\n      // fall back to the first supported mode\n      mode = Object.keys(interpolator)[0];\n    }\n\n    if (!interpolator[mode]) {\n      throw new Error(\"interpolation mode \" + mode + \" is not defined\");\n    }\n\n    if (type$h(col1) !== 'object') {\n      col1 = new Color_1(col1);\n    }\n\n    if (type$h(col2) !== 'object') {\n      col2 = new Color_1(col2);\n    }\n\n    return interpolator[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n  };\n\n  Color_1.prototype.mix = Color_1.prototype.interpolate = function (col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 2;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 2];\n    }\n\n    return mix.apply(void 0, [this, col2, f].concat(rest));\n  };\n\n  Color_1.prototype.premultiply = function (mutate) {\n    if (mutate === void 0) mutate = false;\n    var rgb = this._rgb;\n    var a = rgb[3];\n\n    if (mutate) {\n      this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n      return this;\n    } else {\n      return new Color_1([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n    }\n  };\n\n  Color_1.prototype.saturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lch = me.lch();\n    lch[1] += labConstants.Kn * amount;\n\n    if (lch[1] < 0) {\n      lch[1] = 0;\n    }\n\n    return new Color_1(lch, 'lch').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.desaturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.saturate(-amount);\n  };\n\n  var type$i = utils.type;\n\n  Color_1.prototype.set = function (mc, value, mutate) {\n    if (mutate === void 0) mutate = false;\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        if (type$i(value) == 'string') {\n          switch (value.charAt(0)) {\n            case '+':\n              src[i] += +value;\n              break;\n\n            case '-':\n              src[i] += +value;\n              break;\n\n            case '*':\n              src[i] *= +value.substr(1);\n              break;\n\n            case '/':\n              src[i] /= +value.substr(1);\n              break;\n\n            default:\n              src[i] = +value;\n          }\n        } else if (type$i(value) === 'number') {\n          src[i] = value;\n        } else {\n          throw new Error(\"unsupported value for Color.set\");\n        }\n\n        var out = new Color_1(src, mode);\n\n        if (mutate) {\n          this._rgb = out._rgb;\n          return this;\n        }\n\n        return out;\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var rgb$1 = function rgb$1(col1, col2, f) {\n    var xyz0 = col1._rgb;\n    var xyz1 = col2._rgb;\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.rgb = rgb$1;\n  var sqrt$2 = Math.sqrt;\n  var pow$3 = Math.pow;\n\n  var lrgb = function lrgb(col1, col2, f) {\n    var ref = col1._rgb;\n    var x1 = ref[0];\n    var y1 = ref[1];\n    var z1 = ref[2];\n    var ref$1 = col2._rgb;\n    var x2 = ref$1[0];\n    var y2 = ref$1[1];\n    var z2 = ref$1[2];\n    return new Color_1(sqrt$2(pow$3(x1, 2) * (1 - f) + pow$3(x2, 2) * f), sqrt$2(pow$3(y1, 2) * (1 - f) + pow$3(y2, 2) * f), sqrt$2(pow$3(z1, 2) * (1 - f) + pow$3(z2, 2) * f), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.lrgb = lrgb;\n\n  var lab$1 = function lab$1(col1, col2, f) {\n    var xyz0 = col1.lab();\n    var xyz1 = col2.lab();\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'lab');\n  }; // register interpolator\n\n\n  interpolator.lab = lab$1;\n\n  var _hsx = function _hsx(col1, col2, f, m) {\n    var assign, assign$1;\n    var xyz0, xyz1;\n\n    if (m === 'hsl') {\n      xyz0 = col1.hsl();\n      xyz1 = col2.hsl();\n    } else if (m === 'hsv') {\n      xyz0 = col1.hsv();\n      xyz1 = col2.hsv();\n    } else if (m === 'hcg') {\n      xyz0 = col1.hcg();\n      xyz1 = col2.hcg();\n    } else if (m === 'hsi') {\n      xyz0 = col1.hsi();\n      xyz1 = col2.hsi();\n    } else if (m === 'lch' || m === 'hcl') {\n      m = 'hcl';\n      xyz0 = col1.hcl();\n      xyz1 = col2.hcl();\n    }\n\n    var hue0, hue1, sat0, sat1, lbv0, lbv1;\n\n    if (m.substr(0, 1) === 'h') {\n      assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];\n      assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];\n    }\n\n    var sat, hue, lbv, dh;\n\n    if (!isNaN(hue0) && !isNaN(hue1)) {\n      // both colors have hue\n      if (hue1 > hue0 && hue1 - hue0 > 180) {\n        dh = hue1 - (hue0 + 360);\n      } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n        dh = hue1 + 360 - hue0;\n      } else {\n        dh = hue1 - hue0;\n      }\n\n      hue = hue0 + f * dh;\n    } else if (!isNaN(hue0)) {\n      hue = hue0;\n\n      if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') {\n        sat = sat0;\n      }\n    } else if (!isNaN(hue1)) {\n      hue = hue1;\n\n      if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') {\n        sat = sat1;\n      }\n    } else {\n      hue = Number.NaN;\n    }\n\n    if (sat === undefined) {\n      sat = sat0 + f * (sat1 - sat0);\n    }\n\n    lbv = lbv0 + f * (lbv1 - lbv0);\n    return new Color_1([hue, sat, lbv], m);\n  };\n\n  var lch$1 = function lch$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'lch');\n  }; // register interpolator\n\n\n  interpolator.lch = lch$1;\n  interpolator.hcl = lch$1;\n\n  var num$1 = function num$1(col1, col2, f) {\n    var c1 = col1.num();\n    var c2 = col2.num();\n    return new Color_1(c1 + f * (c2 - c1), 'num');\n  }; // register interpolator\n\n\n  interpolator.num = num$1;\n\n  var hcg$1 = function hcg$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hcg');\n  }; // register interpolator\n\n\n  interpolator.hcg = hcg$1;\n\n  var hsi$1 = function hsi$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsi');\n  }; // register interpolator\n\n\n  interpolator.hsi = hsi$1;\n\n  var hsl$1 = function hsl$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsl');\n  }; // register interpolator\n\n\n  interpolator.hsl = hsl$1;\n\n  var hsv$1 = function hsv$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsv');\n  }; // register interpolator\n\n\n  interpolator.hsv = hsv$1;\n  var clip_rgb$2 = utils.clip_rgb;\n  var pow$4 = Math.pow;\n  var sqrt$3 = Math.sqrt;\n  var PI$1 = Math.PI;\n  var cos$2 = Math.cos;\n  var sin$1 = Math.sin;\n  var atan2$1 = Math.atan2;\n\n  var average = function average(colors, mode, weights) {\n    if (mode === void 0) mode = 'lrgb';\n    if (weights === void 0) weights = null;\n    var l = colors.length;\n\n    if (!weights) {\n      weights = Array.from(new Array(l)).map(function () {\n        return 1;\n      });\n    } // normalize weights\n\n\n    var k = l / weights.reduce(function (a, b) {\n      return a + b;\n    });\n    weights.forEach(function (w, i) {\n      weights[i] *= k;\n    }); // convert colors to Color objects\n\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (mode === 'lrgb') {\n      return _average_lrgb(colors, weights);\n    }\n\n    var first = colors.shift();\n    var xyz = first.get(mode);\n    var cnt = [];\n    var dx = 0;\n    var dy = 0; // initial color\n\n    for (var i = 0; i < xyz.length; i++) {\n      xyz[i] = (xyz[i] || 0) * weights[0];\n      cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n\n      if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n        var A = xyz[i] / 180 * PI$1;\n        dx += cos$2(A) * weights[0];\n        dy += sin$1(A) * weights[0];\n      }\n    }\n\n    var alpha = first.alpha() * weights[0];\n    colors.forEach(function (c, ci) {\n      var xyz2 = c.get(mode);\n      alpha += c.alpha() * weights[ci + 1];\n\n      for (var i = 0; i < xyz.length; i++) {\n        if (!isNaN(xyz2[i])) {\n          cnt[i] += weights[ci + 1];\n\n          if (mode.charAt(i) === 'h') {\n            var A = xyz2[i] / 180 * PI$1;\n            dx += cos$2(A) * weights[ci + 1];\n            dy += sin$1(A) * weights[ci + 1];\n          } else {\n            xyz[i] += xyz2[i] * weights[ci + 1];\n          }\n        }\n      }\n    });\n\n    for (var i$1 = 0; i$1 < xyz.length; i$1++) {\n      if (mode.charAt(i$1) === 'h') {\n        var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n\n        while (A$1 < 0) {\n          A$1 += 360;\n        }\n\n        while (A$1 >= 360) {\n          A$1 -= 360;\n        }\n\n        xyz[i$1] = A$1;\n      } else {\n        xyz[i$1] = xyz[i$1] / cnt[i$1];\n      }\n    }\n\n    alpha /= l;\n    return new Color_1(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n  };\n\n  var _average_lrgb = function _average_lrgb(colors, weights) {\n    var l = colors.length;\n    var xyz = [0, 0, 0, 0];\n\n    for (var i = 0; i < colors.length; i++) {\n      var col = colors[i];\n      var f = weights[i] / l;\n      var rgb = col._rgb;\n      xyz[0] += pow$4(rgb[0], 2) * f;\n      xyz[1] += pow$4(rgb[1], 2) * f;\n      xyz[2] += pow$4(rgb[2], 2) * f;\n      xyz[3] += rgb[3] * f;\n    }\n\n    xyz[0] = sqrt$3(xyz[0]);\n    xyz[1] = sqrt$3(xyz[1]);\n    xyz[2] = sqrt$3(xyz[2]);\n\n    if (xyz[3] > 0.9999999) {\n      xyz[3] = 1;\n    }\n\n    return new Color_1(clip_rgb$2(xyz));\n  }; // minimal multi-purpose interface\n  // @requires utils color analyze\n\n\n  var type$j = utils.type;\n  var pow$5 = Math.pow;\n\n  var scale = function scale(colors) {\n    // constructor\n    var _mode = 'rgb';\n\n    var _nacol = chroma_1('#ccc');\n\n    var _spread = 0; // const _fixed = false;\n\n    var _domain = [0, 1];\n    var _pos = [];\n    var _padding = [0, 0];\n    var _classes = false;\n    var _colors = [];\n    var _out = false;\n    var _min = 0;\n    var _max = 1;\n    var _correctLightness = false;\n    var _colorCache = {};\n    var _useCache = true;\n    var _gamma = 1; // private methods\n\n    var setColors = function setColors(colors) {\n      colors = colors || ['#fff', '#000'];\n\n      if (colors && type$j(colors) === 'string' && chroma_1.brewer && chroma_1.brewer[colors.toLowerCase()]) {\n        colors = chroma_1.brewer[colors.toLowerCase()];\n      }\n\n      if (type$j(colors) === 'array') {\n        // handle single color\n        if (colors.length === 1) {\n          colors = [colors[0], colors[0]];\n        } // make a copy of the colors\n\n\n        colors = colors.slice(0); // convert to chroma classes\n\n        for (var c = 0; c < colors.length; c++) {\n          colors[c] = chroma_1(colors[c]);\n        } // auto-fill color position\n\n\n        _pos.length = 0;\n\n        for (var c$1 = 0; c$1 < colors.length; c$1++) {\n          _pos.push(c$1 / (colors.length - 1));\n        }\n      }\n\n      resetCache();\n      return _colors = colors;\n    };\n\n    var getClass = function getClass(value) {\n      if (_classes != null) {\n        var n = _classes.length - 1;\n        var i = 0;\n\n        while (i < n && value >= _classes[i]) {\n          i++;\n        }\n\n        return i - 1;\n      }\n\n      return 0;\n    };\n\n    var tMapLightness = function tMapLightness(t) {\n      return t;\n    };\n\n    var tMapDomain = function tMapDomain(t) {\n      return t;\n    }; // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n\n    var getColor = function getColor(val, bypassMap) {\n      var col, t;\n\n      if (bypassMap == null) {\n        bypassMap = false;\n      }\n\n      if (isNaN(val) || val === null) {\n        return _nacol;\n      }\n\n      if (!bypassMap) {\n        if (_classes && _classes.length > 2) {\n          // find the class\n          var c = getClass(val);\n          t = c / (_classes.length - 2);\n        } else if (_max !== _min) {\n          // just interpolate between min/max\n          t = (val - _min) / (_max - _min);\n        } else {\n          t = 1;\n        }\n      } else {\n        t = val;\n      } // domain map\n\n\n      t = tMapDomain(t);\n\n      if (!bypassMap) {\n        t = tMapLightness(t); // lightness correction\n      }\n\n      if (_gamma !== 1) {\n        t = pow$5(t, _gamma);\n      }\n\n      t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n      t = Math.min(1, Math.max(0, t));\n      var k = Math.floor(t * 10000);\n\n      if (_useCache && _colorCache[k]) {\n        col = _colorCache[k];\n      } else {\n        if (type$j(_colors) === 'array') {\n          //for i in [0.._pos.length-1]\n          for (var i = 0; i < _pos.length; i++) {\n            var p = _pos[i];\n\n            if (t <= p) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t >= p && i === _pos.length - 1) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t > p && t < _pos[i + 1]) {\n              t = (t - p) / (_pos[i + 1] - p);\n              col = chroma_1.interpolate(_colors[i], _colors[i + 1], t, _mode);\n              break;\n            }\n          }\n        } else if (type$j(_colors) === 'function') {\n          col = _colors(t);\n        }\n\n        if (_useCache) {\n          _colorCache[k] = col;\n        }\n      }\n\n      return col;\n    };\n\n    var resetCache = function resetCache() {\n      return _colorCache = {};\n    };\n\n    setColors(colors); // public interface\n\n    var f = function f(v) {\n      var c = chroma_1(getColor(v));\n\n      if (_out && c[_out]) {\n        return c[_out]();\n      } else {\n        return c;\n      }\n    };\n\n    f.classes = function (classes) {\n      if (classes != null) {\n        if (type$j(classes) === 'array') {\n          _classes = classes;\n          _domain = [classes[0], classes[classes.length - 1]];\n        } else {\n          var d = chroma_1.analyze(_domain);\n\n          if (classes === 0) {\n            _classes = [d.min, d.max];\n          } else {\n            _classes = chroma_1.limits(d, 'e', classes);\n          }\n        }\n\n        return f;\n      }\n\n      return _classes;\n    };\n\n    f.domain = function (domain) {\n      if (!arguments.length) {\n        return _domain;\n      }\n\n      _min = domain[0];\n      _max = domain[domain.length - 1];\n      _pos = [];\n      var k = _colors.length;\n\n      if (domain.length === k && _min !== _max) {\n        // update positions\n        for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n          var d = list[i];\n\n          _pos.push((d - _min) / (_max - _min));\n        }\n      } else {\n        for (var c = 0; c < k; c++) {\n          _pos.push(c / (k - 1));\n        }\n\n        if (domain.length > 2) {\n          // set domain map\n          var tOut = domain.map(function (d, i) {\n            return i / (domain.length - 1);\n          });\n          var tBreaks = domain.map(function (d) {\n            return (d - _min) / (_max - _min);\n          });\n\n          if (!tBreaks.every(function (val, i) {\n            return tOut[i] === val;\n          })) {\n            tMapDomain = function tMapDomain(t) {\n              if (t <= 0 || t >= 1) {\n                return t;\n              }\n\n              var i = 0;\n\n              while (t >= tBreaks[i + 1]) {\n                i++;\n              }\n\n              var f = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n              var out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n              return out;\n            };\n          }\n        }\n      }\n\n      _domain = [_min, _max];\n      return f;\n    };\n\n    f.mode = function (_m) {\n      if (!arguments.length) {\n        return _mode;\n      }\n\n      _mode = _m;\n      resetCache();\n      return f;\n    };\n\n    f.range = function (colors, _pos) {\n      setColors(colors, _pos);\n      return f;\n    };\n\n    f.out = function (_o) {\n      _out = _o;\n      return f;\n    };\n\n    f.spread = function (val) {\n      if (!arguments.length) {\n        return _spread;\n      }\n\n      _spread = val;\n      return f;\n    };\n\n    f.correctLightness = function (v) {\n      if (v == null) {\n        v = true;\n      }\n\n      _correctLightness = v;\n      resetCache();\n\n      if (_correctLightness) {\n        tMapLightness = function tMapLightness(t) {\n          var L0 = getColor(0, true).lab()[0];\n          var L1 = getColor(1, true).lab()[0];\n          var pol = L0 > L1;\n          var L_actual = getColor(t, true).lab()[0];\n          var L_ideal = L0 + (L1 - L0) * t;\n          var L_diff = L_actual - L_ideal;\n          var t0 = 0;\n          var t1 = 1;\n          var max_iter = 20;\n\n          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n            (function () {\n              if (pol) {\n                L_diff *= -1;\n              }\n\n              if (L_diff < 0) {\n                t0 = t;\n                t += (t1 - t) * 0.5;\n              } else {\n                t1 = t;\n                t += (t0 - t) * 0.5;\n              }\n\n              L_actual = getColor(t, true).lab()[0];\n              return L_diff = L_actual - L_ideal;\n            })();\n          }\n\n          return t;\n        };\n      } else {\n        tMapLightness = function tMapLightness(t) {\n          return t;\n        };\n      }\n\n      return f;\n    };\n\n    f.padding = function (p) {\n      if (p != null) {\n        if (type$j(p) === 'number') {\n          p = [p, p];\n        }\n\n        _padding = p;\n        return f;\n      } else {\n        return _padding;\n      }\n    };\n\n    f.colors = function (numColors, out) {\n      // If no arguments are given, return the original colors that were provided\n      if (arguments.length < 2) {\n        out = 'hex';\n      }\n\n      var result = [];\n\n      if (arguments.length === 0) {\n        result = _colors.slice(0);\n      } else if (numColors === 1) {\n        result = [f(0.5)];\n      } else if (numColors > 1) {\n        var dm = _domain[0];\n        var dd = _domain[1] - dm;\n        result = __range__(0, numColors, false).map(function (i) {\n          return f(dm + i / (numColors - 1) * dd);\n        });\n      } else {\n        // returns all colors based on the defined classes\n        colors = [];\n        var samples = [];\n\n        if (_classes && _classes.length > 2) {\n          for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n          }\n        } else {\n          samples = _domain;\n        }\n\n        result = samples.map(function (v) {\n          return f(v);\n        });\n      }\n\n      if (chroma_1[out]) {\n        result = result.map(function (c) {\n          return c[out]();\n        });\n      }\n\n      return result;\n    };\n\n    f.cache = function (c) {\n      if (c != null) {\n        _useCache = c;\n        return f;\n      } else {\n        return _useCache;\n      }\n    };\n\n    f.gamma = function (g) {\n      if (g != null) {\n        _gamma = g;\n        return f;\n      } else {\n        return _gamma;\n      }\n    };\n\n    f.nodata = function (d) {\n      if (d != null) {\n        _nacol = chroma_1(d);\n        return f;\n      } else {\n        return _nacol;\n      }\n    };\n\n    return f;\n  };\n\n  function __range__(left, right, inclusive) {\n    var range = [];\n    var ascending = left < right;\n    var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n    for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n      range.push(i);\n    }\n\n    return range;\n  } //\n  // interpolates between a set of colors uzing a bezier spline\n  //\n  // @requires utils lab\n\n\n  var bezier = function bezier(colors) {\n    var assign, assign$1, assign$2;\n    var I, lab0, lab1, lab2;\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (colors.length === 2) {\n      // linear interpolation\n      assign = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign[0], lab1 = assign[1];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return lab0[i] + t * (lab1[i] - lab0[i]);\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 3) {\n      // quadratic bezier interpolation\n      assign$1 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 4) {\n      // cubic bezier interpolation\n      var lab3;\n      assign$2 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 5) {\n      var I0 = bezier(colors.slice(0, 3));\n      var I1 = bezier(colors.slice(2, 5));\n\n      I = function I(t) {\n        if (t < 0.5) {\n          return I0(t * 2);\n        } else {\n          return I1((t - 0.5) * 2);\n        }\n      };\n    }\n\n    return I;\n  };\n\n  var bezier_1 = function bezier_1(colors) {\n    var f = bezier(colors);\n\n    f.scale = function () {\n      return scale(f);\n    };\n\n    return f;\n  };\n  /*\n   * interpolates between a set of colors uzing a bezier spline\n   * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n   */\n\n\n  var blend = function blend(bottom, top, mode) {\n    if (!blend[mode]) {\n      throw new Error('unknown blend mode ' + mode);\n    }\n\n    return blend[mode](bottom, top);\n  };\n\n  var blend_f = function blend_f(f) {\n    return function (bottom, top) {\n      var c0 = chroma_1(top).rgb();\n      var c1 = chroma_1(bottom).rgb();\n      return chroma_1.rgb(f(c0, c1));\n    };\n  };\n\n  var each = function each(f) {\n    return function (c0, c1) {\n      var out = [];\n      out[0] = f(c0[0], c1[0]);\n      out[1] = f(c0[1], c1[1]);\n      out[2] = f(c0[2], c1[2]);\n      return out;\n    };\n  };\n\n  var normal = function normal(a) {\n    return a;\n  };\n\n  var multiply = function multiply(a, b) {\n    return a * b / 255;\n  };\n\n  var darken$1 = function darken$1(a, b) {\n    return a > b ? b : a;\n  };\n\n  var lighten = function lighten(a, b) {\n    return a > b ? a : b;\n  };\n\n  var screen = function screen(a, b) {\n    return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n  };\n\n  var overlay = function overlay(a, b) {\n    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n  };\n\n  var burn = function burn(a, b) {\n    return 255 * (1 - (1 - b / 255) / (a / 255));\n  };\n\n  var dodge = function dodge(a, b) {\n    if (a === 255) {\n      return 255;\n    }\n\n    a = 255 * (b / 255) / (1 - a / 255);\n    return a > 255 ? 255 : a;\n  }; // # add = (a,b) ->\n  // #     if (a + b > 255) then 255 else a + b\n\n\n  blend.normal = blend_f(each(normal));\n  blend.multiply = blend_f(each(multiply));\n  blend.screen = blend_f(each(screen));\n  blend.overlay = blend_f(each(overlay));\n  blend.darken = blend_f(each(darken$1));\n  blend.lighten = blend_f(each(lighten));\n  blend.dodge = blend_f(each(dodge));\n  blend.burn = blend_f(each(burn)); // blend.add = blend_f(each(add));\n\n  var blend_1 = blend; // cubehelix interpolation\n  // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n  // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n  var type$k = utils.type;\n  var clip_rgb$3 = utils.clip_rgb;\n  var TWOPI$2 = utils.TWOPI;\n  var pow$6 = Math.pow;\n  var sin$2 = Math.sin;\n  var cos$3 = Math.cos;\n\n  var cubehelix = function cubehelix(start, rotations, hue, gamma, lightness) {\n    if (start === void 0) start = 300;\n    if (rotations === void 0) rotations = -1.5;\n    if (hue === void 0) hue = 1;\n    if (gamma === void 0) gamma = 1;\n    if (lightness === void 0) lightness = [0, 1];\n    var dh = 0,\n        dl;\n\n    if (type$k(lightness) === 'array') {\n      dl = lightness[1] - lightness[0];\n    } else {\n      dl = 0;\n      lightness = [lightness, lightness];\n    }\n\n    var f = function f(fract) {\n      var a = TWOPI$2 * ((start + 120) / 360 + rotations * fract);\n      var l = pow$6(lightness[0] + dl * fract, gamma);\n      var h = dh !== 0 ? hue[0] + fract * dh : hue;\n      var amp = h * l * (1 - l) / 2;\n      var cos_a = cos$3(a);\n      var sin_a = sin$2(a);\n      var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n      var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n      var b = l + amp * (+1.97294 * cos_a);\n      return chroma_1(clip_rgb$3([r * 255, g * 255, b * 255, 1]));\n    };\n\n    f.start = function (s) {\n      if (s == null) {\n        return start;\n      }\n\n      start = s;\n      return f;\n    };\n\n    f.rotations = function (r) {\n      if (r == null) {\n        return rotations;\n      }\n\n      rotations = r;\n      return f;\n    };\n\n    f.gamma = function (g) {\n      if (g == null) {\n        return gamma;\n      }\n\n      gamma = g;\n      return f;\n    };\n\n    f.hue = function (h) {\n      if (h == null) {\n        return hue;\n      }\n\n      hue = h;\n\n      if (type$k(hue) === 'array') {\n        dh = hue[1] - hue[0];\n\n        if (dh === 0) {\n          hue = hue[1];\n        }\n      } else {\n        dh = 0;\n      }\n\n      return f;\n    };\n\n    f.lightness = function (h) {\n      if (h == null) {\n        return lightness;\n      }\n\n      if (type$k(h) === 'array') {\n        lightness = h;\n        dl = h[1] - h[0];\n      } else {\n        lightness = [h, h];\n        dl = 0;\n      }\n\n      return f;\n    };\n\n    f.scale = function () {\n      return chroma_1.scale(f);\n    };\n\n    f.hue(hue);\n    return f;\n  };\n\n  var digits = '0123456789abcdef';\n  var floor$2 = Math.floor;\n  var random = Math.random;\n\n  var random_1 = function random_1() {\n    var code = '#';\n\n    for (var i = 0; i < 6; i++) {\n      code += digits.charAt(floor$2(random() * 16));\n    }\n\n    return new Color_1(code, 'hex');\n  };\n\n  var log$1 = Math.log;\n  var pow$7 = Math.pow;\n  var floor$3 = Math.floor;\n  var abs = Math.abs;\n\n  var analyze = function analyze(data, key) {\n    if (key === void 0) key = null;\n    var r = {\n      min: Number.MAX_VALUE,\n      max: Number.MAX_VALUE * -1,\n      sum: 0,\n      values: [],\n      count: 0\n    };\n\n    if (type(data) === 'object') {\n      data = Object.values(data);\n    }\n\n    data.forEach(function (val) {\n      if (key && type(val) === 'object') {\n        val = val[key];\n      }\n\n      if (val !== undefined && val !== null && !isNaN(val)) {\n        r.values.push(val);\n        r.sum += val;\n\n        if (val < r.min) {\n          r.min = val;\n        }\n\n        if (val > r.max) {\n          r.max = val;\n        }\n\n        r.count += 1;\n      }\n    });\n    r.domain = [r.min, r.max];\n\n    r.limits = function (mode, num) {\n      return limits(r, mode, num);\n    };\n\n    return r;\n  };\n\n  var limits = function limits(data, mode, num) {\n    if (mode === void 0) mode = 'equal';\n    if (num === void 0) num = 7;\n\n    if (type(data) == 'array') {\n      data = analyze(data);\n    }\n\n    var min = data.min;\n    var max = data.max;\n    var values = data.values.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (num === 1) {\n      return [min, max];\n    }\n\n    var limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n      // continuous\n      limits.push(min);\n      limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n      // equal interval\n      limits.push(min);\n\n      for (var i = 1; i < num; i++) {\n        limits.push(min + i / num * (max - min));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n      // log scale\n      if (min <= 0) {\n        throw new Error('Logarithmic scales are only possible for values > 0');\n      }\n\n      var min_log = Math.LOG10E * log$1(min);\n      var max_log = Math.LOG10E * log$1(max);\n      limits.push(min);\n\n      for (var i$1 = 1; i$1 < num; i$1++) {\n        limits.push(pow$7(10, min_log + i$1 / num * (max_log - min_log)));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n      // quantile scale\n      limits.push(min);\n\n      for (var i$2 = 1; i$2 < num; i$2++) {\n        var p = (values.length - 1) * i$2 / num;\n        var pb = floor$3(p);\n\n        if (pb === p) {\n          limits.push(values[pb]);\n        } else {\n          // p > pb\n          var pr = p - pb;\n          limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n        }\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n      // k-means clustering\n\n      /*\n      implementation based on\n      http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n      simplified for 1-d input values\n      */\n      var cluster;\n      var n = values.length;\n      var assignments = new Array(n);\n      var clusterSizes = new Array(num);\n      var repeat = true;\n      var nb_iters = 0;\n      var centroids = null; // get seed values\n\n      centroids = [];\n      centroids.push(min);\n\n      for (var i$3 = 1; i$3 < num; i$3++) {\n        centroids.push(min + i$3 / num * (max - min));\n      }\n\n      centroids.push(max);\n\n      while (repeat) {\n        // assignment step\n        for (var j = 0; j < num; j++) {\n          clusterSizes[j] = 0;\n        }\n\n        for (var i$4 = 0; i$4 < n; i$4++) {\n          var value = values[i$4];\n          var mindist = Number.MAX_VALUE;\n          var best = void 0;\n\n          for (var j$1 = 0; j$1 < num; j$1++) {\n            var dist = abs(centroids[j$1] - value);\n\n            if (dist < mindist) {\n              mindist = dist;\n              best = j$1;\n            }\n\n            clusterSizes[best]++;\n            assignments[i$4] = best;\n          }\n        } // update centroids step\n\n\n        var newCentroids = new Array(num);\n\n        for (var j$2 = 0; j$2 < num; j$2++) {\n          newCentroids[j$2] = null;\n        }\n\n        for (var i$5 = 0; i$5 < n; i$5++) {\n          cluster = assignments[i$5];\n\n          if (newCentroids[cluster] === null) {\n            newCentroids[cluster] = values[i$5];\n          } else {\n            newCentroids[cluster] += values[i$5];\n          }\n        }\n\n        for (var j$3 = 0; j$3 < num; j$3++) {\n          newCentroids[j$3] *= 1 / clusterSizes[j$3];\n        } // check convergence\n\n\n        repeat = false;\n\n        for (var j$4 = 0; j$4 < num; j$4++) {\n          if (newCentroids[j$4] !== centroids[j$4]) {\n            repeat = true;\n            break;\n          }\n        }\n\n        centroids = newCentroids;\n        nb_iters++;\n\n        if (nb_iters > 200) {\n          repeat = false;\n        }\n      } // finished k-means clustering\n      // the next part is borrowed from gabrielflor.it\n\n\n      var kClusters = {};\n\n      for (var j$5 = 0; j$5 < num; j$5++) {\n        kClusters[j$5] = [];\n      }\n\n      for (var i$6 = 0; i$6 < n; i$6++) {\n        cluster = assignments[i$6];\n        kClusters[cluster].push(values[i$6]);\n      }\n\n      var tmpKMeansBreaks = [];\n\n      for (var j$6 = 0; j$6 < num; j$6++) {\n        tmpKMeansBreaks.push(kClusters[j$6][0]);\n        tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);\n      }\n\n      tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {\n        return a - b;\n      });\n      limits.push(tmpKMeansBreaks[0]);\n\n      for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {\n        var v = tmpKMeansBreaks[i$7];\n\n        if (!isNaN(v) && limits.indexOf(v) === -1) {\n          limits.push(v);\n        }\n      }\n    }\n\n    return limits;\n  };\n\n  var analyze_1 = {\n    analyze: analyze,\n    limits: limits\n  };\n\n  var contrast = function contrast(a, b) {\n    // WCAG contrast ratio\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.luminance();\n    var l2 = b.luminance();\n    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n  };\n\n  var sqrt$4 = Math.sqrt;\n  var atan2$2 = Math.atan2;\n  var abs$1 = Math.abs;\n  var cos$4 = Math.cos;\n  var PI$2 = Math.PI;\n\n  var deltaE = function deltaE(a, b, L, C) {\n    if (L === void 0) L = 1;\n    if (C === void 0) C = 1; // Delta E (CMC)\n    // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var ref = Array.from(a.lab());\n    var L1 = ref[0];\n    var a1 = ref[1];\n    var b1 = ref[2];\n    var ref$1 = Array.from(b.lab());\n    var L2 = ref$1[0];\n    var a2 = ref$1[1];\n    var b2 = ref$1[2];\n    var c1 = sqrt$4(a1 * a1 + b1 * b1);\n    var c2 = sqrt$4(a2 * a2 + b2 * b2);\n    var sl = L1 < 16.0 ? 0.511 : 0.040975 * L1 / (1.0 + 0.01765 * L1);\n    var sc = 0.0638 * c1 / (1.0 + 0.0131 * c1) + 0.638;\n    var h1 = c1 < 0.000001 ? 0.0 : atan2$2(b1, a1) * 180.0 / PI$2;\n\n    while (h1 < 0) {\n      h1 += 360;\n    }\n\n    while (h1 >= 360) {\n      h1 -= 360;\n    }\n\n    var t = h1 >= 164.0 && h1 <= 345.0 ? 0.56 + abs$1(0.2 * cos$4(PI$2 * (h1 + 168.0) / 180.0)) : 0.36 + abs$1(0.4 * cos$4(PI$2 * (h1 + 35.0) / 180.0));\n    var c4 = c1 * c1 * c1 * c1;\n    var f = sqrt$4(c4 / (c4 + 1900.0));\n    var sh = sc * (f * t + 1.0 - f);\n    var delL = L1 - L2;\n    var delC = c1 - c2;\n    var delA = a1 - a2;\n    var delB = b1 - b2;\n    var dH2 = delA * delA + delB * delB - delC * delC;\n    var v1 = delL / (L * sl);\n    var v2 = delC / (C * sc);\n    var v3 = sh;\n    return sqrt$4(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));\n  }; // simple Euclidean distance\n\n\n  var distance = function distance(a, b, mode) {\n    if (mode === void 0) mode = 'lab'; // Delta E (CIE 1976)\n    // see http://www.brucelindbloom.com/index.html?Equations.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.get(mode);\n    var l2 = b.get(mode);\n    var sum_sq = 0;\n\n    for (var i in l1) {\n      var d = (l1[i] || 0) - (l2[i] || 0);\n      sum_sq += d * d;\n    }\n\n    return Math.sqrt(sum_sq);\n  };\n\n  var valid = function valid() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    try {\n      new (Function.prototype.bind.apply(Color_1, [null].concat(args)))();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // some pre-defined color scales:\n\n\n  var scales = {\n    cool: function cool() {\n      return scale([chroma_1.hsl(180, 1, .9), chroma_1.hsl(250, .7, .4)]);\n    },\n    hot: function hot() {\n      return scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');\n    }\n  };\n  /**\n      ColorBrewer colors for chroma.js\n       Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n      Pennsylvania State University.\n       Licensed under the Apache License, Version 2.0 (the \"License\");\n      you may not use this file except in compliance with the License.\n      You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n       Unless required by applicable law or agreed to in writing, software distributed\n      under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n      CONDITIONS OF ANY KIND, either express or implied. See the License for the\n      specific language governing permissions and limitations under the License.\n  */\n\n  var colorbrewer = {\n    // sequential\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n    // diverging\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n    // qualitative\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n  }; // add lowercase aliases for case-insensitive matches\n\n  for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n    var key = list$1[i$1];\n    colorbrewer[key.toLowerCase()] = colorbrewer[key];\n  }\n\n  var colorbrewer_1 = colorbrewer; // feel free to comment out anything to rollup\n  // a smaller chroma.js built\n  // io --\x3e convert colors\n  // operators --\x3e modify existing Colors\n  // interpolators\n  // generators -- > create new colors\n\n  chroma_1.average = average;\n  chroma_1.bezier = bezier_1;\n  chroma_1.blend = blend_1;\n  chroma_1.cubehelix = cubehelix;\n  chroma_1.mix = chroma_1.interpolate = mix;\n  chroma_1.random = random_1;\n  chroma_1.scale = scale; // other utility methods\n\n  chroma_1.analyze = analyze_1.analyze;\n  chroma_1.contrast = contrast;\n  chroma_1.deltaE = deltaE;\n  chroma_1.distance = distance;\n  chroma_1.limits = analyze_1.limits;\n  chroma_1.valid = valid; // scale\n\n  chroma_1.scales = scales; // colors\n\n  chroma_1.colors = w3cx11_1;\n  chroma_1.brewer = colorbrewer_1;\n  var chroma_js = chroma_1;\n  return chroma_js;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvY2hyb21hLmpzP2JmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBNEQsZ0NBQWdDLENBQXdGO0FBQ3RMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQSxxSEFBcUgsaUJBQWlCO0FBQ3RJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxFQUFFLGFBQWEsRUFBRTtBQUNqRCxpQ0FBaUMsRUFBRSxhQUFhLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxpQkFBaUI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWYsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1QsaUNBQWlDOztBQUVqQyx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUEseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUYsa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSx5QkFBeUI7QUFDekY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkMsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUEseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzg3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE5LCBHcmVnb3IgQWlzY2hcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHUkVHT1IgQUlTQ0ggT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuICogQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gKiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLFxuICogYW5kIFRoZSBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCxcbiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE5hbWVkIGNvbG9ycyBhcmUgdGFrZW4gZnJvbSBYMTEgQ29sb3IgTmFtZXMuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAqXG4gKiBAcHJlc2VydmVcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiBnbG9iYWwuY2hyb21hID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGxpbWl0ID0gZnVuY3Rpb24gbGltaXQoeCwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIG1pbiA9IDA7XG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSBtYXggPSAxO1xuICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG4gIH07XG5cbiAgdmFyIGNsaXBfcmdiID0gZnVuY3Rpb24gY2xpcF9yZ2IocmdiKSB7XG4gICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgIGlmIChpIDwgMykge1xuICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHtcbiAgICAgICAgICByZ2IuX2NsaXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmdiW2ldID0gbGltaXQocmdiW2ldLCAwLCAyNTUpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjtcbiAgfTsgLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG5cblxuICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IFsnQm9vbGVhbicsICdOdW1iZXInLCAnU3RyaW5nJywgJ0Z1bmN0aW9uJywgJ0FycmF5JywgJ0RhdGUnLCAnUmVnRXhwJywgJ1VuZGVmaW5lZCcsICdOdWxsJ107IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuICAgIGNsYXNzVG9UeXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIGNsYXNzVG9UeXBlW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiO1xuICB9O1xuXG4gIHZhciB1bnBhY2sgPSBmdW5jdGlvbiB1bnBhY2soYXJncywga2V5T3JkZXIpIHtcbiAgICBpZiAoa2V5T3JkZXIgPT09IHZvaWQgMCkga2V5T3JkZXIgPSBudWxsOyAvLyBpZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gMyBhcmd1bWVudHMsIHdlIHJldHVybiB0aGUgYXJndW1lbnRzXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIH0gLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG5cblxuICAgIGlmICh0eXBlKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgICByZXR1cm4ga2V5T3JkZXIuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdW2tdO1xuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgLy8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcblxuXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH07XG5cbiAgdmFyIGxhc3QgPSBmdW5jdGlvbiBsYXN0KGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0eXBlKGFyZ3NbbF0pID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBQSSA9IE1hdGguUEk7XG4gIHZhciB1dGlscyA9IHtcbiAgICBjbGlwX3JnYjogY2xpcF9yZ2IsXG4gICAgbGltaXQ6IGxpbWl0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdW5wYWNrOiB1bnBhY2ssXG4gICAgbGFzdDogbGFzdCxcbiAgICBQSTogUEksXG4gICAgVFdPUEk6IFBJICogMixcbiAgICBQSVRISVJEOiBQSSAvIDMsXG4gICAgREVHMlJBRDogUEkgLyAxODAsXG4gICAgUkFEMkRFRzogMTgwIC8gUElcbiAgfTtcbiAgdmFyIGlucHV0ID0ge1xuICAgIGZvcm1hdDoge30sXG4gICAgYXV0b2RldGVjdDogW11cbiAgfTtcbiAgdmFyIGxhc3QkMSA9IHV0aWxzLmxhc3Q7XG4gIHZhciBjbGlwX3JnYiQxID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciB0eXBlJDEgPSB1dGlscy50eXBlO1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAodHlwZSQxKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIC8vIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgQ29sb3IgaW5zdGFuY2VcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH0gLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuXG5cbiAgICB2YXIgbW9kZSA9IGxhc3QkMShhcmdzKTtcbiAgICB2YXIgYXV0b2RldGVjdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFtb2RlKSB7XG4gICAgICBhdXRvZGV0ZWN0ID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpbnB1dC5zb3J0ZWQpIHtcbiAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiLnAgLSBhLnA7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBhdXRvLWRldGVjdCBmb3JtYXRcblxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGlucHV0LmF1dG9kZXRlY3Q7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGsgPSBsaXN0W2ldO1xuICAgICAgICBtb2RlID0gY2hrLnRlc3QuYXBwbHkoY2hrLCBhcmdzKTtcblxuICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgdmFyIHJnYiA9IGlucHV0LmZvcm1hdFttb2RlXS5hcHBseShudWxsLCBhdXRvZGV0ZWN0ID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwgLTEpKTtcbiAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYiQxKHJnYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQ6ICcgKyBhcmdzKTtcbiAgICB9IC8vIGFkZCBhbHBoYSBjaGFubmVsXG5cblxuICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykge1xuICAgICAgbWUuX3JnYi5wdXNoKDEpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodHlwZSQxKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLl9yZ2Iuam9pbignLCcpICsgXCJdXCI7XG4gIH07XG5cbiAgdmFyIENvbG9yXzEgPSBDb2xvcjtcblxuICB2YXIgY2hyb21hID0gZnVuY3Rpb24gY2hyb21hKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGNocm9tYS5Db2xvciwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XG4gIH07XG5cbiAgY2hyb21hLkNvbG9yID0gQ29sb3JfMTtcbiAgY2hyb21hLnZlcnNpb24gPSAnMi4xLjInO1xuICB2YXIgY2hyb21hXzEgPSBjaHJvbWE7XG4gIHZhciB1bnBhY2skMSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuXG4gIHZhciByZ2IyY215ayA9IGZ1bmN0aW9uIHJnYjJjbXlrKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skMShhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciA9IHIgLyAyNTU7XG4gICAgZyA9IGcgLyAyNTU7XG4gICAgYiA9IGIgLyAyNTU7XG4gICAgdmFyIGsgPSAxIC0gbWF4KHIsIG1heChnLCBiKSk7XG4gICAgdmFyIGYgPSBrIDwgMSA/IDEgLyAoMSAtIGspIDogMDtcbiAgICB2YXIgYyA9ICgxIC0gciAtIGspICogZjtcbiAgICB2YXIgbSA9ICgxIC0gZyAtIGspICogZjtcbiAgICB2YXIgeSA9ICgxIC0gYiAtIGspICogZjtcbiAgICByZXR1cm4gW2MsIG0sIHksIGtdO1xuICB9O1xuXG4gIHZhciByZ2IyY215a18xID0gcmdiMmNteWs7XG4gIHZhciB1bnBhY2skMiA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgY215azJyZ2IgPSBmdW5jdGlvbiBjbXlrMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDIoYXJncywgJ2NteWsnKTtcbiAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgdmFyIG0gPSBhcmdzWzFdO1xuICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICB2YXIgayA9IGFyZ3NbM107XG4gICAgdmFyIGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCBhbHBoYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjID49IDEgPyAwIDogMjU1ICogKDEgLSBjKSAqICgxIC0gayksIC8vIHJcbiAgICBtID49IDEgPyAwIDogMjU1ICogKDEgLSBtKSAqICgxIC0gayksIC8vIGdcbiAgICB5ID49IDEgPyAwIDogMjU1ICogKDEgLSB5KSAqICgxIC0gayksIC8vIGJcbiAgICBhbHBoYV07XG4gIH07XG5cbiAgdmFyIGNteWsycmdiXzEgPSBjbXlrMnJnYjtcbiAgdmFyIHVucGFjayQzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSQyID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyY215a18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnY215ayddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmNteWsgPSBjbXlrMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJDMoYXJncywgJ2NteWsnKTtcblxuICAgICAgaWYgKHR5cGUkMihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ2NteWsnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skNCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkMiA9IHV0aWxzLmxhc3Q7XG5cbiAgdmFyIHJuZCA9IGZ1bmN0aW9uIHJuZChhKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7XG4gIH07XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICogLSBoc2wyY3NzKGgscyxsLGEpXG4gICAqIC0gaHNsMmNzcyhbaCxzLGxdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3Moe2gscyxsLGF9LCBtb2RlKVxuICAgKi9cblxuXG4gIHZhciBoc2wyY3NzID0gZnVuY3Rpb24gaHNsMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaHNsYSA9IHVucGFjayQ0KGFyZ3MsICdoc2xhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDIoYXJncykgfHwgJ2xzYSc7XG4gICAgaHNsYVswXSA9IHJuZChoc2xhWzBdIHx8IDApO1xuICAgIGhzbGFbMV0gPSBybmQoaHNsYVsxXSAqIDEwMCkgKyAnJSc7XG4gICAgaHNsYVsyXSA9IHJuZChoc2xhWzJdICogMTAwKSArICclJztcblxuICAgIGlmIChtb2RlID09PSAnaHNsYScgfHwgaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM10gPCAxKSB7XG4gICAgICBoc2xhWzNdID0gaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ2hzbGEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGUgKyBcIihcIiArIGhzbGEuam9pbignLCcpICsgXCIpXCI7XG4gIH07XG5cbiAgdmFyIGhzbDJjc3NfMSA9IGhzbDJjc3M7XG4gIHZhciB1bnBhY2skNSA9IHV0aWxzLnVucGFjaztcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyaHNsKHIsZyxiKVxuICAgKiAtIHJnYjJoc2wocixnLGIsYSlcbiAgICogLSByZ2IyaHNsKFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gICAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gICAqL1xuXG4gIHZhciByZ2IyaHNsID0gZnVuY3Rpb24gcmdiMmhzbCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDUoYXJncywgJ3JnYmEnKTtcbiAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIHZhciBzLCBoO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBzID0gMDtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gbCA8IDAuNSA/IChtYXggLSBtaW4pIC8gKG1heCArIG1pbikgOiAobWF4IC0gbWluKSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChiID09IG1heCkge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7XG4gICAgfVxuXG4gICAgaCAqPSA2MDtcblxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAzNjA7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMyAmJiBhcmdzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfTtcblxuICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbDtcbiAgdmFyIHVucGFjayQ2ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyY3NzKHIsZyxiKVxuICAgKiAtIHJnYjJjc3MocixnLGIsYSlcbiAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyhbcixnLGIsYV0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gICAqL1xuXG4gIHZhciByZ2IyY3NzID0gZnVuY3Rpb24gcmdiMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayQ2KGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDMoYXJncykgfHwgJ3JnYic7XG5cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT0gJ2hzbCcpIHtcbiAgICAgIHJldHVybiBoc2wyY3NzXzEocmdiMmhzbF8xKHJnYmEpLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZ2JhWzBdID0gcm91bmQocmdiYVswXSk7XG4gICAgcmdiYVsxXSA9IHJvdW5kKHJnYmFbMV0pO1xuICAgIHJnYmFbMl0gPSByb3VuZChyZ2JhWzJdKTtcblxuICAgIGlmIChtb2RlID09PSAncmdiYScgfHwgcmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM10gPCAxKSB7XG4gICAgICByZ2JhWzNdID0gcmdiYS5sZW5ndGggPiAzID8gcmdiYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ3JnYmEnO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlICsgXCIoXCIgKyByZ2JhLnNsaWNlKDAsIG1vZGUgPT09ICdyZ2InID8gMyA6IDQpLmpvaW4oJywnKSArIFwiKVwiO1xuICB9O1xuXG4gIHZhciByZ2IyY3NzXzEgPSByZ2IyY3NzO1xuICB2YXIgdW5wYWNrJDcgPSB1dGlscy51bnBhY2s7XG4gIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICB2YXIgaHNsMnJnYiA9IGZ1bmN0aW9uIGhzbDJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbjtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDcoYXJncywgJ2hzbCcpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIGwgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGwgKiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0MyA9IFswLCAwLCAwXTtcbiAgICAgIHZhciBjID0gWzAsIDAsIDBdO1xuICAgICAgdmFyIHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgIHZhciB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICB2YXIgaF8gPSBoIC8gMzYwO1xuICAgICAgdDNbMF0gPSBoXyArIDEgLyAzO1xuICAgICAgdDNbMV0gPSBoXztcbiAgICAgIHQzWzJdID0gaF8gLSAxIC8gMztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgaWYgKHQzW2ldIDwgMCkge1xuICAgICAgICAgIHQzW2ldICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodDNbaV0gPiAxKSB7XG4gICAgICAgICAgdDNbaV0gLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICg2ICogdDNbaV0gPCAxKSB7XG4gICAgICAgICAgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldO1xuICAgICAgICB9IGVsc2UgaWYgKDIgKiB0M1tpXSA8IDEpIHtcbiAgICAgICAgICBjW2ldID0gdDI7XG4gICAgICAgIH0gZWxzZSBpZiAoMyAqIHQzW2ldIDwgMikge1xuICAgICAgICAgIGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzW2ldKSAqIDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY1tpXSA9IHQxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbiA9IFtyb3VuZCQxKGNbMF0gKiAyNTUpLCByb3VuZCQxKGNbMV0gKiAyNTUpLCByb3VuZCQxKGNbMl0gKiAyNTUpXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgIHJldHVybiBbciwgZywgYiwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgfTtcblxuICB2YXIgaHNsMnJnYl8xID0gaHNsMnJnYjtcbiAgdmFyIFJFX1JHQiA9IC9ecmdiXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuICB2YXIgUkVfUkdCQSA9IC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIFJFX1JHQl9QQ1QgPSAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX1JHQkFfUENUID0gL15yZ2JhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuICB2YXIgUkVfSFNMID0gL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX0hTTEEgPSAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIHJvdW5kJDIgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciBjc3MycmdiID0gZnVuY3Rpb24gY3NzMnJnYihjc3MpIHtcbiAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgdmFyIG07XG5cbiAgICBpZiAoaW5wdXQuZm9ybWF0Lm5hbWVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB9XG4gICAgfSAvLyByZ2IoMjUwLDIwLDApXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQikpIHtcbiAgICAgIHZhciByZ2IgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgfVxuXG4gICAgICByZ2JbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG5cbiAgICAgIHJldHVybiByZ2I7XG4gICAgfSAvLyByZ2JhKDI1MCwyMCwwLDAuNClcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfUkdCQSkpIHtcbiAgICAgIHZhciByZ2IkMSA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7XG4gICAgICAgIHJnYiQxW2kkMV0gPSArcmdiJDFbaSQxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJnYiQxO1xuICAgIH0gLy8gcmdiKDEwMCUsMCUsMCUpXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1QpKSB7XG4gICAgICB2YXIgcmdiJDIgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAzOyBpJDIrKykge1xuICAgICAgICByZ2IkMltpJDJdID0gcm91bmQkMihyZ2IkMltpJDJdICogMi41NSk7XG4gICAgICB9XG5cbiAgICAgIHJnYiQyWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuXG4gICAgICByZXR1cm4gcmdiJDI7XG4gICAgfSAvLyByZ2JhKDEwMCUsMCUsMCUsMC40KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVCkpIHtcbiAgICAgIHZhciByZ2IkMyA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IDM7IGkkMysrKSB7XG4gICAgICAgIHJnYiQzW2kkM10gPSByb3VuZCQyKHJnYiQzW2kkM10gKiAyLjU1KTtcbiAgICAgIH1cblxuICAgICAgcmdiJDNbM10gPSArcmdiJDNbM107XG4gICAgICByZXR1cm4gcmdiJDM7XG4gICAgfSAvLyBoc2woMCwxMDAlLDUwJSlcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkge1xuICAgICAgdmFyIGhzbCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ0ID0gaHNsMnJnYl8xKGhzbCk7XG4gICAgICByZ2IkNFszXSA9IDE7XG4gICAgICByZXR1cm4gcmdiJDQ7XG4gICAgfSAvLyBoc2xhKDAsMTAwJSw1MCUsMC41KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9IU0xBKSkge1xuICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLCA0KTtcbiAgICAgIGhzbCQxWzFdICo9IDAuMDE7XG4gICAgICBoc2wkMVsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ1ID0gaHNsMnJnYl8xKGhzbCQxKTtcbiAgICAgIHJnYiQ1WzNdID0gK21bNF07IC8vIGRlZmF1bHQgYWxwaGEgPSAxXG5cbiAgICAgIHJldHVybiByZ2IkNTtcbiAgICB9XG4gIH07XG5cbiAgY3NzMnJnYi50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gUkVfUkdCLnRlc3QocykgfHwgUkVfUkdCQS50ZXN0KHMpIHx8IFJFX1JHQl9QQ1QudGVzdChzKSB8fCBSRV9SR0JBX1BDVC50ZXN0KHMpIHx8IFJFX0hTTC50ZXN0KHMpIHx8IFJFX0hTTEEudGVzdChzKTtcbiAgfTtcblxuICB2YXIgY3NzMnJnYl8xID0gY3NzMnJnYjtcbiAgdmFyIHR5cGUkMyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICByZXR1cm4gcmdiMmNzc18xKHRoaXMuX3JnYiwgbW9kZSk7XG4gIH07XG5cbiAgY2hyb21hXzEuY3NzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydjc3MnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5jc3MgPSBjc3MycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KGgpIHtcbiAgICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW4tLSA+IDApIHtcbiAgICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkMyhoKSA9PT0gJ3N0cmluZycgJiYgY3NzMnJnYl8xLnRlc3QoaCkpIHtcbiAgICAgICAgcmV0dXJuICdjc3MnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skOCA9IHV0aWxzLnVucGFjaztcblxuICBpbnB1dC5mb3JtYXQuZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayQ4KGFyZ3MsICdyZ2JhJyk7XG4gICAgcmdiWzBdICo9IDI1NTtcbiAgICByZ2JbMV0gKj0gMjU1O1xuICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgcmV0dXJuIHJnYjtcbiAgfTtcblxuICBjaHJvbWFfMS5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnZ2wnXSkpKSgpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmdsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUsIHJnYlsxXSAvIDI1NSwgcmdiWzJdIC8gMjU1LCByZ2JbM11dO1xuICB9O1xuXG4gIHZhciB1bnBhY2skOSA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmhjZyA9IGZ1bmN0aW9uIHJnYjJoY2coKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayQ5KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICB2YXIgYyA9IGRlbHRhICogMTAwIC8gMjU1O1xuXG4gICAgdmFyIF9nID0gbWluIC8gKDI1NSAtIGRlbHRhKSAqIDEwMDtcblxuICAgIHZhciBoO1xuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBjLCBfZ107XG4gIH07XG5cbiAgdmFyIHJnYjJoY2dfMSA9IHJnYjJoY2c7XG4gIHZhciB1bnBhY2skYSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgLypcbiAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgKlxuICAgKiBodWUuLiBbMC4uMzYwXVxuICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAqIGdyYXluZXNzIC4uIFswLi4xXVxuICAgKi9cblxuICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uIGhjZzJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skYShhcmdzLCAnaGNnJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgX2cgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIF9nID0gX2cgKiAyNTU7XG5cbiAgICB2YXIgX2MgPSBjICogMjU1O1xuXG4gICAgaWYgKGMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaCA9PT0gMzYwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA+IDM2MCkge1xuICAgICAgICBoIC09IDM2MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBoIC89IDYwO1xuICAgICAgdmFyIGkgPSBmbG9vcihoKTtcbiAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICB2YXIgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgIHZhciBxID0gcCArIF9jICogKDEgLSBmKTtcbiAgICAgIHZhciB0ID0gcCArIF9jICogZjtcbiAgICAgIHZhciB2ID0gcCArIF9jO1xuXG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoY2cycmdiXzEgPSBoY2cycmdiO1xuICB2YXIgdW5wYWNrJGIgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDQgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhjZ18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoY2cnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oY2cgPSBoY2cycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skYihhcmdzLCAnaGNnJyk7XG5cbiAgICAgIGlmICh0eXBlJDQoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoY2cnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skYyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkNCA9IHV0aWxzLmxhc3Q7XG4gIHZhciByb3VuZCQzID0gTWF0aC5yb3VuZDtcblxuICB2YXIgcmdiMmhleCA9IGZ1bmN0aW9uIHJnYjJoZXgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRjKGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgdmFyIG1vZGUgPSBsYXN0JDQoYXJncykgfHwgJ2F1dG8nO1xuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdhdXRvJykge1xuICAgICAgbW9kZSA9IGEgPCAxID8gJ3JnYmEnIDogJ3JnYic7XG4gICAgfVxuXG4gICAgciA9IHJvdW5kJDMocik7XG4gICAgZyA9IHJvdW5kJDMoZyk7XG4gICAgYiA9IHJvdW5kJDMoYik7XG4gICAgdmFyIHUgPSByIDw8IDE2IHwgZyA8PCA4IHwgYjtcbiAgICB2YXIgc3RyID0gXCIwMDAwMDBcIiArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcblxuICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgIHZhciBoeGEgPSAnMCcgKyByb3VuZCQzKGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcblxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgc3RyICsgaHhhO1xuXG4gICAgICBjYXNlICdhcmdiJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgaHhhICsgc3RyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjXCIgKyBzdHI7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZ2IyaGV4XzEgPSByZ2IyaGV4O1xuICB2YXIgUkVfSEVYID0gL14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLztcbiAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gIHZhciBoZXgycmdiID0gZnVuY3Rpb24gaGV4MnJnYihoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWCkpIHtcbiAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgc2l4LWRpZ2l0XG5cblxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgdmFyIHIgPSB1ID4+IDE2O1xuICAgICAgdmFyIGcgPSB1ID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSB1ICYgMHhGRjtcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfSAvLyBtYXRjaCByZ2JhIGhleCBmb3JtYXQsIGVnICNGRjAwMDA3N1xuXG5cbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWEEpKSB7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNSB8fCBoZXgubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcblxuXG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl0gKyBoZXhbM10gKyBoZXhbM107XG4gICAgICB9XG5cbiAgICAgIHZhciB1JDEgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgIHZhciByJDEgPSB1JDEgPj4gMjQgJiAweEZGO1xuICAgICAgdmFyIGckMSA9IHUkMSA+PiAxNiAmIDB4RkY7XG4gICAgICB2YXIgYiQxID0gdSQxID4+IDggJiAweEZGO1xuICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKCh1JDEgJiAweEZGKSAvIDB4RkYgKiAxMDApIC8gMTAwO1xuICAgICAgcmV0dXJuIFtyJDEsIGckMSwgYiQxLCBhXTtcbiAgICB9IC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgIC8vICAgICByZXR1cm4gcmdiXG5cblxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gaGV4IGNvbG9yOiBcIiArIGhleCk7XG4gIH07XG5cbiAgdmFyIGhleDJyZ2JfMSA9IGhleDJyZ2I7XG4gIHZhciB0eXBlJDUgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIHJnYjJoZXhfMSh0aGlzLl9yZ2IsIG1vZGUpO1xuICB9O1xuXG4gIGNocm9tYV8xLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnaGV4J10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDQsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdChoKSB7XG4gICAgICB2YXIgcmVzdCA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICAgIHJlc3RbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJDUoaCkgPT09ICdzdHJpbmcnICYmIFszLCA0LCA1LCA2LCA3LCA4LCA5XS5pbmRleE9mKGgubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgdW5wYWNrJGQgPSB1dGlscy51bnBhY2s7XG4gIHZhciBUV09QSSA9IHV0aWxzLlRXT1BJO1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYWNvcyA9IE1hdGguYWNvcztcblxuICB2YXIgcmdiMmhzaSA9IGZ1bmN0aW9uIHJnYjJoc2koKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9yZ2IyaHNpLmNwcFxuICAgICovXG5cblxuICAgIHZhciByZWYgPSB1bnBhY2skZChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgdmFyIGg7XG4gICAgdmFyIG1pbl8gPSBtaW4ociwgZywgYik7XG4gICAgdmFyIGkgPSAociArIGcgKyBiKSAvIDM7XG4gICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fIC8gaSA6IDA7XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgaCA9IE5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IChyIC0gZyArIChyIC0gYikpIC8gMjtcbiAgICAgIGggLz0gc3FydCgociAtIGcpICogKHIgLSBnKSArIChyIC0gYikgKiAoZyAtIGIpKTtcbiAgICAgIGggPSBhY29zKGgpO1xuXG4gICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgIH1cblxuICAgICAgaCAvPSBUV09QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2ggKiAzNjAsIHMsIGldO1xuICB9O1xuXG4gIHZhciByZ2IyaHNpXzEgPSByZ2IyaHNpO1xuICB2YXIgdW5wYWNrJGUgPSB1dGlscy51bnBhY2s7XG4gIHZhciBsaW1pdCQxID0gdXRpbHMubGltaXQ7XG4gIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gIHZhciBQSVRISVJEID0gdXRpbHMuUElUSElSRDtcbiAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAvKlxuICAgKiBodWUgWzAuLjM2MF1cbiAgICogc2F0dXJhdGlvbiBbMC4uMV1cbiAgICogaW50ZW5zaXR5IFswLi4xXVxuICAgKi9cblxuICB2YXIgaHNpMnJnYiA9IGZ1bmN0aW9uIGhzaTJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9oc2kycmdiLmNwcFxuICAgICovXG5cblxuICAgIGFyZ3MgPSB1bnBhY2skZShhcmdzLCAnaHNpJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICB2YXIgaSA9IGFyZ3NbMl07XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAoaXNOYU4oaCkpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihzKSkge1xuICAgICAgcyA9IDA7XG4gICAgfSAvLyBub3JtYWxpemUgaHVlXG5cblxuICAgIGlmIChoID4gMzYwKSB7XG4gICAgICBoIC09IDM2MDtcbiAgICB9XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMzYwO1xuICAgIH1cblxuICAgIGggLz0gMzYwO1xuXG4gICAgaWYgKGggPCAxIC8gMykge1xuICAgICAgYiA9ICgxIC0gcykgLyAzO1xuICAgICAgciA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgZyA9IDEgLSAoYiArIHIpO1xuICAgIH0gZWxzZSBpZiAoaCA8IDIgLyAzKSB7XG4gICAgICBoIC09IDEgLyAzO1xuICAgICAgciA9ICgxIC0gcykgLyAzO1xuICAgICAgZyA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgYiA9IDEgLSAociArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoIC09IDIgLyAzO1xuICAgICAgZyA9ICgxIC0gcykgLyAzO1xuICAgICAgYiA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgciA9IDEgLSAoZyArIGIpO1xuICAgIH1cblxuICAgIHIgPSBsaW1pdCQxKGkgKiByICogMyk7XG4gICAgZyA9IGxpbWl0JDEoaSAqIGcgKiAzKTtcbiAgICBiID0gbGltaXQkMShpICogYiAqIDMpO1xuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoc2kycmdiXzEgPSBoc2kycmdiO1xuICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDYgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhzaV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc2knXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc2kgPSBoc2kycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnaHNpJyk7XG5cbiAgICAgIGlmICh0eXBlJDYoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc2knO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skZyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkNyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHNsXzEodGhpcy5fcmdiKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hzbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmhzbCA9IGhzbDJyZ2JfMTtcbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IHVucGFjayRnKGFyZ3MsICdoc2wnKTtcblxuICAgICAgaWYgKHR5cGUkNyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayRoID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbWluJDEgPSBNYXRoLm1pbjtcbiAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gcmdiMmhzdihyLGcsYilcbiAgICogLSByZ2IyaHN2KFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgKi9cblxuICB2YXIgcmdiMmhzbCQxID0gZnVuY3Rpb24gcmdiMmhzbCQxKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skaChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgdmFyIG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heF8gLSBtaW5fO1xuICAgIHZhciBoLCBzLCB2O1xuICAgIHYgPSBtYXhfIC8gMjU1LjA7XG5cbiAgICBpZiAobWF4XyA9PT0gMCkge1xuICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4XztcblxuICAgICAgaWYgKHIgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiID09PSBtYXhfKSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbiAgfTtcblxuICB2YXIgcmdiMmhzdiA9IHJnYjJoc2wkMTtcbiAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIGhzdjJyZ2IgPSBmdW5jdGlvbiBoc3YycmdiKCkge1xuICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJGkoYXJncywgJ2hzdicpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIHYgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIHYgKj0gMjU1O1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoID09PSAzNjApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoID4gMzYwKSB7XG4gICAgICAgIGggLT0gMzYwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIGggLz0gNjA7XG4gICAgICB2YXIgaSA9IGZsb29yJDEoaCk7XG4gICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gIH07XG5cbiAgdmFyIGhzdjJyZ2JfMSA9IGhzdjJyZ2I7XG4gIHZhciB1bnBhY2skaiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkOCA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHN2KHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc3YnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc3YgPSBoc3YycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skaihhcmdzLCAnaHN2Jyk7XG5cbiAgICAgIGlmICh0eXBlJDgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBsYWJDb25zdGFudHMgPSB7XG4gICAgLy8gQ29ycmVzcG9uZHMgcm91Z2hseSB0byBSR0IgYnJpZ2h0ZXIvZGFya2VyXG4gICAgS246IDE4LFxuICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgIFhuOiAwLjk1MDQ3MCxcbiAgICBZbjogMSxcbiAgICBabjogMS4wODg4MzAsXG4gICAgdDA6IDAuMTM3OTMxMDM0LFxuICAgIC8vIDQgLyAyOVxuICAgIHQxOiAwLjIwNjg5NjU1MixcbiAgICAvLyA2IC8gMjlcbiAgICB0MjogMC4xMjg0MTg1NSxcbiAgICAvLyAzICogdDEgKiB0MVxuICAgIHQzOiAwLjAwODg1NjQ1MiAvLyB0MSAqIHQxICogdDFcblxuICB9O1xuICB2YXIgdW5wYWNrJGsgPSB1dGlscy51bnBhY2s7XG4gIHZhciBwb3cgPSBNYXRoLnBvdztcblxuICB2YXIgcmdiMmxhYiA9IGZ1bmN0aW9uIHJnYjJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRrKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IyeHl6KHIsIGcsIGIpO1xuICAgIHZhciB4ID0gcmVmJDFbMF07XG4gICAgdmFyIHkgPSByZWYkMVsxXTtcbiAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgIHZhciBsID0gMTE2ICogeSAtIDE2O1xuICAgIHJldHVybiBbbCA8IDAgPyAwIDogbCwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KV07XG4gIH07XG5cbiAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiByZ2JfeHl6KHIpIHtcbiAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7XG4gICAgICByZXR1cm4gciAvIDEyLjkyO1xuICAgIH1cblxuICAgIHJldHVybiBwb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgeHl6X2xhYiA9IGZ1bmN0aW9uIHh5el9sYWIodCkge1xuICAgIGlmICh0ID4gbGFiQ29uc3RhbnRzLnQzKSB7XG4gICAgICByZXR1cm4gcG93KHQsIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdCAvIGxhYkNvbnN0YW50cy50MiArIGxhYkNvbnN0YW50cy50MDtcbiAgfTtcblxuICB2YXIgcmdiMnh5eiA9IGZ1bmN0aW9uIHJnYjJ4eXoociwgZywgYikge1xuICAgIHIgPSByZ2JfeHl6KHIpO1xuICAgIGcgPSByZ2JfeHl6KGcpO1xuICAgIGIgPSByZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0geHl6X2xhYigoMC40MTI0NTY0ICogciArIDAuMzU3NTc2MSAqIGcgKyAwLjE4MDQzNzUgKiBiKSAvIGxhYkNvbnN0YW50cy5Ybik7XG4gICAgdmFyIHkgPSB4eXpfbGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gbGFiQ29uc3RhbnRzLlluKTtcbiAgICB2YXIgeiA9IHh5el9sYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBsYWJDb25zdGFudHMuWm4pO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH07XG5cbiAgdmFyIHJnYjJsYWJfMSA9IHJnYjJsYWI7XG4gIHZhciB1bnBhY2skbCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHBvdyQxID0gTWF0aC5wb3c7XG4gIC8qXG4gICAqIEwqIFswLi4xMDBdXG4gICAqIGEgWy0xMDAuLjEwMF1cbiAgICogYiBbLTEwMC4uMTAwXVxuICAgKi9cblxuICB2YXIgbGFiMnJnYiA9IGZ1bmN0aW9uIGxhYjJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgYXJncyA9IHVucGFjayRsKGFyZ3MsICdsYWInKTtcbiAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgdmFyIGEgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICB2YXIgeCwgeSwgeiwgciwgZywgYl87XG4gICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgIHggPSBpc05hTihhKSA/IHkgOiB5ICsgYSAvIDUwMDtcbiAgICB6ID0gaXNOYU4oYikgPyB5IDogeSAtIGIgLyAyMDA7XG4gICAgeSA9IGxhYkNvbnN0YW50cy5ZbiAqIGxhYl94eXooeSk7XG4gICAgeCA9IGxhYkNvbnN0YW50cy5YbiAqIGxhYl94eXooeCk7XG4gICAgeiA9IGxhYkNvbnN0YW50cy5abiAqIGxhYl94eXooeik7XG4gICAgciA9IHh5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KTsgLy8gRDY1IC0+IHNSR0JcblxuICAgIGcgPSB4eXpfcmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopO1xuICAgIGJfID0geHl6X3JnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopO1xuICAgIHJldHVybiBbciwgZywgYl8sIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgeHl6X3JnYiA9IGZ1bmN0aW9uIHh5el9yZ2Iocikge1xuICAgIHJldHVybiAyNTUgKiAociA8PSAwLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBwb3ckMShyLCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfTtcblxuICB2YXIgbGFiX3h5eiA9IGZ1bmN0aW9uIGxhYl94eXoodCkge1xuICAgIHJldHVybiB0ID4gbGFiQ29uc3RhbnRzLnQxID8gdCAqIHQgKiB0IDogbGFiQ29uc3RhbnRzLnQyICogKHQgLSBsYWJDb25zdGFudHMudDApO1xuICB9O1xuXG4gIHZhciBsYWIycmdiXzEgPSBsYWIycmdiO1xuICB2YXIgdW5wYWNrJG0gPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDkgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmxhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxhYl8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEubGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydsYWInXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5sYWIgPSBsYWIycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skbShhcmdzLCAnbGFiJyk7XG5cbiAgICAgIGlmICh0eXBlJDkoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skbiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICB2YXIgc3FydCQxID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICB2YXIgcm91bmQkNCA9IE1hdGgucm91bmQ7XG5cbiAgdmFyIGxhYjJsY2ggPSBmdW5jdGlvbiBsYWIybGNoKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skbihhcmdzLCAnbGFiJyk7XG4gICAgdmFyIGwgPSByZWZbMF07XG4gICAgdmFyIGEgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGMgPSBzcXJ0JDEoYSAqIGEgKyBiICogYik7XG4gICAgdmFyIGggPSAoYXRhbjIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcblxuICAgIGlmIChyb3VuZCQ0KGMgKiAxMDAwMCkgPT09IDApIHtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH1cblxuICAgIHJldHVybiBbbCwgYywgaF07XG4gIH07XG5cbiAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2g7XG4gIHZhciB1bnBhY2skbyA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmxjaCA9IGZ1bmN0aW9uIHJnYjJsY2goKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRvKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IybGFiXzEociwgZywgYik7XG4gICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBsYWIybGNoXzEobCwgYSwgYl8pO1xuICB9O1xuXG4gIHZhciByZ2IybGNoXzEgPSByZ2IybGNoO1xuICB2YXIgdW5wYWNrJHAgPSB1dGlscy51bnBhY2s7XG4gIHZhciBERUcyUkFEID0gdXRpbHMuREVHMlJBRDtcbiAgdmFyIHNpbiA9IE1hdGguc2luO1xuICB2YXIgY29zJDEgPSBNYXRoLmNvcztcblxuICB2YXIgbGNoMmxhYiA9IGZ1bmN0aW9uIGxjaDJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgQ29udmVydCBmcm9tIGEgcXVhbGl0YXRpdmUgcGFyYW1ldGVyIGggYW5kIGEgcXVhbnRpdGF0aXZlIHBhcmFtZXRlciBsIHRvIGEgMjQtYml0IHBpeGVsLlxuICAgIFRoZXNlIGZvcm11bGFzIHdlcmUgaW52ZW50ZWQgYnkgRGF2aWQgRGFscnltcGxlIHRvIG9idGFpbiBtYXhpbXVtIGNvbnRyYXN0IHdpdGhvdXQgZ29pbmdcbiAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG4gICAgIEEgc2F0dXJhdGlvbiBtdWx0aXBsaWVyIHdhcyBhZGRlZCBieSBHcmVnb3IgQWlzY2hcbiAgICAqL1xuXG5cbiAgICB2YXIgcmVmID0gdW5wYWNrJHAoYXJncywgJ2xjaCcpO1xuICAgIHZhciBsID0gcmVmWzBdO1xuICAgIHZhciBjID0gcmVmWzFdO1xuICAgIHZhciBoID0gcmVmWzJdO1xuXG4gICAgaWYgKGlzTmFOKGgpKSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICBoID0gaCAqIERFRzJSQUQ7XG4gICAgcmV0dXJuIFtsLCBjb3MkMShoKSAqIGMsIHNpbihoKSAqIGNdO1xuICB9O1xuXG4gIHZhciBsY2gybGFiXzEgPSBsY2gybGFiO1xuICB2YXIgdW5wYWNrJHEgPSB1dGlscy51bnBhY2s7XG5cbiAgdmFyIGxjaDJyZ2IgPSBmdW5jdGlvbiBsY2gycmdiKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skcShhcmdzLCAnbGNoJyk7XG4gICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgdmFyIHJlZiA9IGxjaDJsYWJfMShsLCBjLCBoKTtcbiAgICB2YXIgTCA9IHJlZlswXTtcbiAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gbGFiMnJnYl8xKEwsIGEsIGJfKTtcbiAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgbGNoMnJnYl8xID0gbGNoMnJnYjtcbiAgdmFyIHVucGFjayRyID0gdXRpbHMudW5wYWNrO1xuXG4gIHZhciBoY2wycmdiID0gZnVuY3Rpb24gaGNsMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaGNsID0gdW5wYWNrJHIoYXJncywgJ2hjbCcpLnJldmVyc2UoKTtcbiAgICByZXR1cm4gbGNoMnJnYl8xLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgfTtcblxuICB2YXIgaGNsMnJnYl8xID0gaGNsMnJnYjtcbiAgdmFyIHVucGFjayRzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRhID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJsY2hfMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxjaF8xKHRoaXMuX3JnYikucmV2ZXJzZSgpO1xuICB9O1xuXG4gIGNocm9tYV8xLmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbGNoJ10pKSkoKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hjbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmxjaCA9IGxjaDJyZ2JfMTtcbiAgaW5wdXQuZm9ybWF0LmhjbCA9IGhjbDJyZ2JfMTtcbiAgWydsY2gnLCAnaGNsJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgcDogMixcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRzKGFyZ3MsIG0pO1xuXG4gICAgICAgIGlmICh0eXBlJGEoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gIFx0WDExIGNvbG9yIG5hbWVzXG4gICBcdGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAqL1xuXG4gIHZhciB3M2N4MTEgPSB7XG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgYXF1YTogJyMwMGZmZmYnLFxuICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyOiAnIzY0OTVlZCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICBjeWFuOiAnIzAwZmZmZicsXG4gICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcbiAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcbiAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxuICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxuICAgIGRhcmtncmV5OiAnI2E5YTlhOScsXG4gICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICcjMmY0ZjRmJyxcbiAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXG4gICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxuICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcbiAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxuICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXG4gICAgZnVjaHNpYTogJyNmZjAwZmYnLFxuICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxuICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcbiAgICBnb2xkOiAnI2ZmZDcwMCcsXG4gICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXG4gICAgZ3JheTogJyM4MDgwODAnLFxuICAgIGdyZWVuOiAnIzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcbiAgICBncmV5OiAnIzgwODA4MCcsXG4gICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICBraGFraTogJyNmMGU2OGMnLFxuICAgIGxhc2VybGVtb246ICcjZmZmZjU0JyxcbiAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcbiAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcbiAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcbiAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXG4gICAgbGlnaHRnb2xkZW5yb2Q6ICcjZmFmYWQyJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgIGxpZ2h0Z3JheTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcbiAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAnIzc3ODg5OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgIGxpbWU6ICcjMDBmZjAwJyxcbiAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcbiAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICBtYXJvb24yOiAnIzdmMDAwMCcsXG4gICAgbWFyb29uMzogJyNiMDMwNjAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcbiAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkYicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxuICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcbiAgICBuYXZ5OiAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxuICAgIG9saXZlOiAnIzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXG4gICAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxuICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcbiAgICBwYWxldmlvbGV0cmVkOiAnI2RiNzA5MycsXG4gICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxuICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxuICAgIHBlcnU6ICcjY2Q4NTNmJyxcbiAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgcGx1bTogJyNkZGEwZGQnLFxuICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcbiAgICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgICBwdXJwbGUyOiAnIzdmMDA3ZicsXG4gICAgcHVycGxlMzogJyNhMDIwZjAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JyxcbiAgICByZWQ6ICcjZmYwMDAwJyxcbiAgICByb3N5YnJvd246ICcjYmM4ZjhmJyxcbiAgICByb3lhbGJsdWU6ICcjNDE2OWUxJyxcbiAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLFxuICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJyxcbiAgICBzZWFncmVlbjogJyMyZThiNTcnLFxuICAgIHNlYXNoZWxsOiAnI2ZmZjVlZScsXG4gICAgc2llbm5hOiAnI2EwNTIyZCcsXG4gICAgc2lsdmVyOiAnI2MwYzBjMCcsXG4gICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLFxuICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxuICAgIHNub3c6ICcjZmZmYWZhJyxcbiAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLFxuICAgIHRhbjogJyNkMmI0OGMnLFxuICAgIHRlYWw6ICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsXG4gICAgdG9tYXRvOiAnI2ZmNjM0NycsXG4gICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgdmlvbGV0OiAnI2VlODJlZScsXG4gICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICB3aGl0ZTogJyNmZmZmZmYnLFxuICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JyxcbiAgICB5ZWxsb3c6ICcjZmZmZjAwJyxcbiAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInXG4gIH07XG4gIHZhciB3M2N4MTFfMSA9IHczY3gxMTtcbiAgdmFyIHR5cGUkYiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGV4ID0gcmdiMmhleF8xKHRoaXMuX3JnYiwgJ3JnYicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh3M2N4MTFfMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IGxpc3RbaV07XG5cbiAgICAgIGlmICh3M2N4MTFfMVtuXSA9PT0gaGV4KSB7XG4gICAgICAgIHJldHVybiBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodzNjeDExXzFbbmFtZV0pIHtcbiAgICAgIHJldHVybiBoZXgycmdiXzEodzNjeDExXzFbbmFtZV0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb2xvciBuYW1lOiAnICsgbmFtZSk7XG4gIH07XG5cbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiA1LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaCkge1xuICAgICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRiKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFfMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiAnbmFtZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skdCA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMm51bSA9IGZ1bmN0aW9uIHJnYjJudW0oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayR0KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xuICB9O1xuXG4gIHZhciByZ2IybnVtXzEgPSByZ2IybnVtO1xuICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICB2YXIgbnVtMnJnYiA9IGZ1bmN0aW9uIG51bTJyZ2IobnVtKSB7XG4gICAgaWYgKHR5cGUkYyhudW0pID09IFwibnVtYmVyXCIgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4RkZGRkZGKSB7XG4gICAgICB2YXIgciA9IG51bSA+PiAxNjtcbiAgICAgIHZhciBnID0gbnVtID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSBudW0gJiAweEZGO1xuICAgICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG51bSBjb2xvcjogXCIgKyBudW0pO1xuICB9O1xuXG4gIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuICB2YXIgdHlwZSRkID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5udW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJudW1fMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIGNocm9tYV8xLm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbnVtJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZSRkKGFyZ3NbMF0pID09PSAnbnVtYmVyJyAmJiBhcmdzWzBdID49IDAgJiYgYXJnc1swXSA8PSAweEZGRkZGRikge1xuICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayR1ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRlID0gdXRpbHMudHlwZTtcbiAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uIChybmQpIHtcbiAgICBpZiAocm5kID09PSB2b2lkIDApIHJuZCA9IHRydWU7XG5cbiAgICBpZiAocm5kID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDMpLm1hcChyb3VuZCQ1KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24gKHJuZCkge1xuICAgIGlmIChybmQgPT09IHZvaWQgMCkgcm5kID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDQpLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIGkgPCAzID8gcm5kID09PSBmYWxzZSA/IHYgOiByb3VuZCQ1KHYpIDogdjtcbiAgICB9KTtcbiAgfTtcblxuICBjaHJvbWFfMS5yZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ3JnYiddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayR1KGFyZ3MsICdyZ2JhJyk7XG5cbiAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZ2JhWzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiYTtcbiAgfTtcblxuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDMsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJHUoYXJncywgJ3JnYmEnKTtcblxuICAgICAgaWYgKHR5cGUkZShhcmdzKSA9PT0gJ2FycmF5JyAmJiAoYXJncy5sZW5ndGggPT09IDMgfHwgYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZSRlKGFyZ3NbM10pID09ICdudW1iZXInICYmIGFyZ3NbM10gPj0gMCAmJiBhcmdzWzNdIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiAncmdiJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICovXG5cbiAgdmFyIGxvZyA9IE1hdGgubG9nO1xuXG4gIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSBmdW5jdGlvbiB0ZW1wZXJhdHVyZTJyZ2Ioa2VsdmluKSB7XG4gICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICByID0gMjU1O1xuICAgICAgZyA9IC0xNTUuMjU0ODU1NjI3MDkxNzkgLSAwLjQ0NTk2OTUwNDY5NTc5MTMzICogKGcgPSB0ZW1wIC0gMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAgLSAxMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2coYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nKHIpO1xuICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcCAtIDUwKSAtIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2coZyk7XG4gICAgICBiID0gMjU1O1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gIH07XG5cbiAgdmFyIHRlbXBlcmF0dXJlMnJnYl8xID0gdGVtcGVyYXR1cmUycmdiO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICoqL1xuXG4gIHZhciB1bnBhY2skdiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmUgPSBmdW5jdGlvbiByZ2IydGVtcGVyYXR1cmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayR2KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJnYlswXSxcbiAgICAgICAgYiA9IHJnYlsyXTtcbiAgICB2YXIgbWluVGVtcCA9IDEwMDA7XG4gICAgdmFyIG1heFRlbXAgPSA0MDAwMDtcbiAgICB2YXIgZXBzID0gMC40O1xuICAgIHZhciB0ZW1wO1xuXG4gICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYl8xKHRlbXApO1xuXG4gICAgICBpZiAocmdiJDFbMl0gLyByZ2IkMVswXSA+PSBiIC8gcikge1xuICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3VuZCQ2KHRlbXApO1xuICB9O1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmVfMSA9IHJnYjJ0ZW1wZXJhdHVyZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS50ZW1wID0gQ29sb3JfMS5wcm90b3R5cGUua2VsdmluID0gQ29sb3JfMS5wcm90b3R5cGUudGVtcGVyYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJ0ZW1wZXJhdHVyZV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEudGVtcCA9IGNocm9tYV8xLmtlbHZpbiA9IGNocm9tYV8xLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWyd0ZW1wJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQudGVtcCA9IGlucHV0LmZvcm1hdC5rZWx2aW4gPSBpbnB1dC5mb3JtYXQudGVtcGVyYXR1cmUgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcbiAgdmFyIHR5cGUkZiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoYSwgbXV0YXRlKSB7XG4gICAgaWYgKG11dGF0ZSA9PT0gdm9pZCAwKSBtdXRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZSRmKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFt0aGlzLl9yZ2JbMF0sIHRoaXMuX3JnYlsxXSwgdGhpcy5fcmdiWzJdLCBhXSwgJ3JnYicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZ2JbM107XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkIHx8IGZhbHNlO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGFiID0gbWUubGFiKCk7XG4gICAgbGFiWzBdIC09IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSBhbW91bnQgPSAxO1xuICAgIHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZXIgPSBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZW47XG4gIENvbG9yXzEucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG1jKSB7XG4gICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcblxuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICByZXR1cm4gc3JjW2ldO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHlwZSRnID0gdXRpbHMudHlwZTtcbiAgdmFyIHBvdyQyID0gTWF0aC5wb3c7XG4gIHZhciBFUFMgPSAxZS03O1xuICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sdW1pbmFuY2UgPSBmdW5jdGlvbiAobHVtKSB7XG4gICAgaWYgKGx1bSAhPT0gdW5kZWZpbmVkICYmIHR5cGUkZyhsdW0pID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGx1bSA9PT0gMCkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSBibGFja1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzAsIDAsIDAsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGx1bSA9PT0gMSkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzI1NSwgMjU1LCAyNTUsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cblxuXG4gICAgICB2YXIgY3VyX2x1bSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgICB2YXIgbW9kZSA9ICdyZ2InO1xuICAgICAgdmFyIG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gdGVzdChsb3csIGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICB2YXIgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yXzEoWzAsIDAsIDBdKSwgdGhpcykgOiB0ZXN0KHRoaXMsIG5ldyBDb2xvcl8xKFsyNTUsIDI1NSwgMjU1XSkpKS5yZ2IoKTtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShyZ2IuY29uY2F0KFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCB0aGlzLl9yZ2Iuc2xpY2UoMCwgMykpO1xuICB9O1xuXG4gIHZhciByZ2IybHVtaW5hbmNlID0gZnVuY3Rpb24gcmdiMmx1bWluYW5jZShyLCBnLCBiKSB7XG4gICAgLy8gcmVsYXRpdmUgbHVtaW5hbmNlXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICByID0gbHVtaW5hbmNlX3gocik7XG4gICAgZyA9IGx1bWluYW5jZV94KGcpO1xuICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICB9O1xuXG4gIHZhciBsdW1pbmFuY2VfeCA9IGZ1bmN0aW9uIGx1bWluYW5jZV94KHgpIHtcbiAgICB4IC89IDI1NTtcbiAgICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogcG93JDIoKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgaW50ZXJwb2xhdG9yID0ge307XG4gIHZhciB0eXBlJGggPSB1dGlscy50eXBlO1xuXG4gIHZhciBtaXggPSBmdW5jdGlvbiBtaXgoY29sMSwgY29sMiwgZikge1xuICAgIGlmIChmID09PSB2b2lkIDApIGYgPSAwLjU7XG4gICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDM7XG5cbiAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgM107XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcblxuICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdICYmICFyZXN0Lmxlbmd0aCkge1xuICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGludGVycG9sYXRvcilbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSRoKGNvbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29sMSA9IG5ldyBDb2xvcl8xKGNvbDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJGgoY29sMikgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb2wyID0gbmV3IENvbG9yXzEoY29sMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRvclttb2RlXShjb2wxLCBjb2wyLCBmKS5hbHBoYShjb2wxLmFscGhhKCkgKyBmICogKGNvbDIuYWxwaGEoKSAtIGNvbDEuYWxwaGEoKSkpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLm1peCA9IENvbG9yXzEucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGNvbDIsIGYpIHtcbiAgICBpZiAoZiA9PT0gdm9pZCAwKSBmID0gMC41O1xuICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDJdO1xuICAgIH1cblxuICAgIHJldHVybiBtaXguYXBwbHkodm9pZCAwLCBbdGhpcywgY29sMiwgZl0uY29uY2F0KHJlc3QpKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uIChtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgdmFyIGEgPSByZ2JbM107XG5cbiAgICBpZiAobXV0YXRlKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBbcmdiWzBdICogYSwgcmdiWzFdICogYSwgcmdiWzJdICogYSwgYV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtyZ2JbMF0gKiBhLCByZ2JbMV0gKiBhLCByZ2JbMl0gKiBhLCBhXSwgJ3JnYicpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGNoID0gbWUubGNoKCk7XG4gICAgbGNoWzFdICs9IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcblxuICAgIGlmIChsY2hbMV0gPCAwKSB7XG4gICAgICBsY2hbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sb3JfMShsY2gsICdsY2gnKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkgYW1vdW50ID0gMTtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0ZSgtYW1vdW50KTtcbiAgfTtcblxuICB2YXIgdHlwZSRpID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG5cbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgaWYgKHR5cGUkaSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICBzcmNbaV0gKj0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRpKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzcmNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB2YWx1ZSBmb3IgQ29sb3Iuc2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvcl8xKHNyYywgbW9kZSk7XG5cbiAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJnYiQxID0gZnVuY3Rpb24gcmdiJDEoY29sMSwgY29sMiwgZikge1xuICAgIHZhciB4eXowID0gY29sMS5fcmdiO1xuICAgIHZhciB4eXoxID0gY29sMi5fcmdiO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLnJnYiA9IHJnYiQxO1xuICB2YXIgc3FydCQyID0gTWF0aC5zcXJ0O1xuICB2YXIgcG93JDMgPSBNYXRoLnBvdztcblxuICB2YXIgbHJnYiA9IGZ1bmN0aW9uIGxyZ2IoY29sMSwgY29sMiwgZikge1xuICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgdmFyIHgxID0gcmVmWzBdO1xuICAgIHZhciB5MSA9IHJlZlsxXTtcbiAgICB2YXIgejEgPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gY29sMi5fcmdiO1xuICAgIHZhciB4MiA9IHJlZiQxWzBdO1xuICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgIHZhciB6MiA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShzcXJ0JDIocG93JDMoeDEsIDIpICogKDEgLSBmKSArIHBvdyQzKHgyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoeTEsIDIpICogKDEgLSBmKSArIHBvdyQzKHkyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoejEsIDIpICogKDEgLSBmKSArIHBvdyQzKHoyLCAyKSAqIGYpLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxyZ2IgPSBscmdiO1xuXG4gIHZhciBsYWIkMSA9IGZ1bmN0aW9uIGxhYiQxKGNvbDEsIGNvbDIsIGYpIHtcbiAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgdmFyIHh5ejEgPSBjb2wyLmxhYigpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAnbGFiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxhYiA9IGxhYiQxO1xuXG4gIHZhciBfaHN4ID0gZnVuY3Rpb24gX2hzeChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG4gICAgdmFyIHh5ejAsIHh5ejE7XG5cbiAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaHN2Jykge1xuICAgICAgeHl6MCA9IGNvbDEuaHN2KCk7XG4gICAgICB4eXoxID0gY29sMi5oc3YoKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoY2cnKSB7XG4gICAgICB4eXowID0gY29sMS5oY2coKTtcbiAgICAgIHh5ejEgPSBjb2wyLmhjZygpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnbGNoJyB8fCBtID09PSAnaGNsJykge1xuICAgICAgbSA9ICdoY2wnO1xuICAgICAgeHl6MCA9IGNvbDEuaGNsKCk7XG4gICAgICB4eXoxID0gY29sMi5oY2woKTtcbiAgICB9XG5cbiAgICB2YXIgaHVlMCwgaHVlMSwgc2F0MCwgc2F0MSwgbGJ2MCwgbGJ2MTtcblxuICAgIGlmIChtLnN1YnN0cigwLCAxKSA9PT0gJ2gnKSB7XG4gICAgICBhc3NpZ24gPSB4eXowLCBodWUwID0gYXNzaWduWzBdLCBzYXQwID0gYXNzaWduWzFdLCBsYnYwID0gYXNzaWduWzJdO1xuICAgICAgYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdO1xuICAgIH1cblxuICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgaWYgKGh1ZTEgPiBodWUwICYmIGh1ZTEgLSBodWUwID4gMTgwKSB7XG4gICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgZGggPSBodWUxICsgMzYwIC0gaHVlMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICB9XG5cbiAgICAgIGh1ZSA9IGh1ZTAgKyBmICogZGg7XG4gICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgIGh1ZSA9IGh1ZTA7XG5cbiAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2Jykge1xuICAgICAgICBzYXQgPSBzYXQwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTEpKSB7XG4gICAgICBodWUgPSBodWUxO1xuXG4gICAgICBpZiAoKGxidjAgPT0gMSB8fCBsYnYwID09IDApICYmIG0gIT0gJ2hzdicpIHtcbiAgICAgICAgc2F0ID0gc2F0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaHVlID0gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTtcbiAgICB9XG5cbiAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtodWUsIHNhdCwgbGJ2XSwgbSk7XG4gIH07XG5cbiAgdmFyIGxjaCQxID0gZnVuY3Rpb24gbGNoJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubGNoID0gbGNoJDE7XG4gIGludGVycG9sYXRvci5oY2wgPSBsY2gkMTtcblxuICB2YXIgbnVtJDEgPSBmdW5jdGlvbiBudW0kMShjb2wxLCBjb2wyLCBmKSB7XG4gICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICB2YXIgYzIgPSBjb2wyLm51bSgpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShjMSArIGYgKiAoYzIgLSBjMSksICdudW0nKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubnVtID0gbnVtJDE7XG5cbiAgdmFyIGhjZyQxID0gZnVuY3Rpb24gaGNnJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoY2cnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaGNnID0gaGNnJDE7XG5cbiAgdmFyIGhzaSQxID0gZnVuY3Rpb24gaHNpJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNpID0gaHNpJDE7XG5cbiAgdmFyIGhzbCQxID0gZnVuY3Rpb24gaHNsJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2wnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNsID0gaHNsJDE7XG5cbiAgdmFyIGhzdiQxID0gZnVuY3Rpb24gaHN2JDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc3YnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHN2ID0gaHN2JDE7XG4gIHZhciBjbGlwX3JnYiQyID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICB2YXIgc3FydCQzID0gTWF0aC5zcXJ0O1xuICB2YXIgUEkkMSA9IE1hdGguUEk7XG4gIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgdmFyIGF0YW4yJDEgPSBNYXRoLmF0YW4yO1xuXG4gIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gYXZlcmFnZShjb2xvcnMsIG1vZGUsIHdlaWdodHMpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xyZ2InO1xuICAgIGlmICh3ZWlnaHRzID09PSB2b2lkIDApIHdlaWdodHMgPSBudWxsO1xuICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGlmICghd2VpZ2h0cykge1xuICAgICAgd2VpZ2h0cyA9IEFycmF5LmZyb20obmV3IEFycmF5KGwpKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH0gLy8gbm9ybWFsaXplIHdlaWdodHNcblxuXG4gICAgdmFyIGsgPSBsIC8gd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9KTtcbiAgICB3ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHcsIGkpIHtcbiAgICAgIHdlaWdodHNbaV0gKj0gaztcbiAgICB9KTsgLy8gY29udmVydCBjb2xvcnMgdG8gQ29sb3Igb2JqZWN0c1xuXG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGMpO1xuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgPT09ICdscmdiJykge1xuICAgICAgcmV0dXJuIF9hdmVyYWdlX2xyZ2IoY29sb3JzLCB3ZWlnaHRzKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3QgPSBjb2xvcnMuc2hpZnQoKTtcbiAgICB2YXIgeHl6ID0gZmlyc3QuZ2V0KG1vZGUpO1xuICAgIHZhciBjbnQgPSBbXTtcbiAgICB2YXIgZHggPSAwO1xuICAgIHZhciBkeSA9IDA7IC8vIGluaXRpYWwgY29sb3JcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG5cbiAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnICYmICFpc05hTih4eXpbaV0pKSB7XG4gICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGMsIGNpKSB7XG4gICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSArIDFdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgY250W2ldICs9IHdlaWdodHNbY2kgKyAxXTtcblxuICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHh5ejJbaV0gLyAxODAgKiBQSSQxO1xuICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHl6W2ldICs9IHh5ejJbaV0gKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICB2YXIgQSQxID0gYXRhbjIkMShkeSAvIGNudFtpJDFdLCBkeCAvIGNudFtpJDFdKSAvIFBJJDEgKiAxODA7XG5cbiAgICAgICAgd2hpbGUgKEEkMSA8IDApIHtcbiAgICAgICAgICBBJDEgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHtcbiAgICAgICAgICBBJDEgLT0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgeHl6W2kkMV0gPSBBJDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdIC8gY250W2kkMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWxwaGEgLz0gbDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEoeHl6LCBtb2RlKS5hbHBoYShhbHBoYSA+IDAuOTk5OTkgPyAxIDogYWxwaGEsIHRydWUpO1xuICB9O1xuXG4gIHZhciBfYXZlcmFnZV9scmdiID0gZnVuY3Rpb24gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpIHtcbiAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgdmFyIHh5eiA9IFswLCAwLCAwLCAwXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sID0gY29sb3JzW2ldO1xuICAgICAgdmFyIGYgPSB3ZWlnaHRzW2ldIC8gbDtcbiAgICAgIHZhciByZ2IgPSBjb2wuX3JnYjtcbiAgICAgIHh5elswXSArPSBwb3ckNChyZ2JbMF0sIDIpICogZjtcbiAgICAgIHh5elsxXSArPSBwb3ckNChyZ2JbMV0sIDIpICogZjtcbiAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sIDIpICogZjtcbiAgICAgIHh5elszXSArPSByZ2JbM10gKiBmO1xuICAgIH1cblxuICAgIHh5elswXSA9IHNxcnQkMyh4eXpbMF0pO1xuICAgIHh5elsxXSA9IHNxcnQkMyh4eXpbMV0pO1xuICAgIHh5elsyXSA9IHNxcnQkMyh4eXpbMl0pO1xuXG4gICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkge1xuICAgICAgeHl6WzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbG9yXzEoY2xpcF9yZ2IkMih4eXopKTtcbiAgfTsgLy8gbWluaW1hbCBtdWx0aS1wdXJwb3NlIGludGVyZmFjZVxuICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG5cbiAgdmFyIHR5cGUkaiA9IHV0aWxzLnR5cGU7XG4gIHZhciBwb3ckNSA9IE1hdGgucG93O1xuXG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGNvbG9ycykge1xuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgdmFyIF9tb2RlID0gJ3JnYic7XG5cbiAgICB2YXIgX25hY29sID0gY2hyb21hXzEoJyNjY2MnKTtcblxuICAgIHZhciBfc3ByZWFkID0gMDsgLy8gY29uc3QgX2ZpeGVkID0gZmFsc2U7XG5cbiAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICB2YXIgX3BvcyA9IFtdO1xuICAgIHZhciBfcGFkZGluZyA9IFswLCAwXTtcbiAgICB2YXIgX2NsYXNzZXMgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgIHZhciBfb3V0ID0gZmFsc2U7XG4gICAgdmFyIF9taW4gPSAwO1xuICAgIHZhciBfbWF4ID0gMTtcbiAgICB2YXIgX2NvcnJlY3RMaWdodG5lc3MgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICB2YXIgX2dhbW1hID0gMTsgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICB2YXIgc2V0Q29sb3JzID0gZnVuY3Rpb24gc2V0Q29sb3JzKGNvbG9ycykge1xuICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG5cbiAgICAgIGlmIChjb2xvcnMgJiYgdHlwZSRqKGNvbG9ycykgPT09ICdzdHJpbmcnICYmIGNocm9tYV8xLmJyZXdlciAmJiBjaHJvbWFfMS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIGNvbG9ycyA9IGNocm9tYV8xLmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGooY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAvLyBoYW5kbGUgc2luZ2xlIGNvbG9yXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29sb3JzID0gW2NvbG9yc1swXSwgY29sb3JzWzBdXTtcbiAgICAgICAgfSAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG5cblxuICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCk7IC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbG9ycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYV8xKGNvbG9yc1tjXSk7XG4gICAgICAgIH0gLy8gYXV0by1maWxsIGNvbG9yIHBvc2l0aW9uXG5cblxuICAgICAgICBfcG9zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgYyQxID0gMDsgYyQxIDwgY29sb3JzLmxlbmd0aDsgYyQxKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyQxIC8gKGNvbG9ycy5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgcmV0dXJuIF9jb2xvcnMgPSBjb2xvcnM7XG4gICAgfTtcblxuICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzKHZhbHVlKSB7XG4gICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IF9jbGFzc2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IG4gJiYgdmFsdWUgPj0gX2NsYXNzZXNbaV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9OyAvLyBjb25zdCBjbGFzc2lmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgIC8vICAgICAgICAgY29uc3QgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAvLyAgICAgICAgIGNvbnN0IG1heGMgPSBfY2xhc3Nlc1tuLTFdICsgKChfY2xhc3Nlc1tuXS1fY2xhc3Nlc1tuLTFdKSAqICgxIC0gKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgbGFzdCBjbGFzc1xuICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gdmFsO1xuICAgIC8vIH07XG5cblxuICAgIHZhciBnZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yKHZhbCwgYnlwYXNzTWFwKSB7XG4gICAgICB2YXIgY29sLCB0O1xuXG4gICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHtcbiAgICAgICAgYnlwYXNzTWFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICBpZiAoX2NsYXNzZXMgJiYgX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgIC8vIGZpbmQgdGhlIGNsYXNzXG4gICAgICAgICAgdmFyIGMgPSBnZXRDbGFzcyh2YWwpO1xuICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAvLyBqdXN0IGludGVycG9sYXRlIGJldHdlZW4gbWluL21heFxuICAgICAgICAgIHQgPSAodmFsIC0gX21pbikgLyAoX21heCAtIF9taW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdmFsO1xuICAgICAgfSAvLyBkb21haW4gbWFwXG5cblxuICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgIHQgPSB0TWFwTGlnaHRuZXNzKHQpOyAvLyBsaWdodG5lc3MgY29ycmVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoX2dhbW1hICE9PSAxKSB7XG4gICAgICAgIHQgPSBwb3ckNSh0LCBfZ2FtbWEpO1xuICAgICAgfVxuXG4gICAgICB0ID0gX3BhZGRpbmdbMF0gKyB0ICogKDEgLSBfcGFkZGluZ1swXSAtIF9wYWRkaW5nWzFdKTtcbiAgICAgIHQgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0KSk7XG4gICAgICB2YXIgayA9IE1hdGguZmxvb3IodCAqIDEwMDAwKTtcblxuICAgICAgaWYgKF91c2VDYWNoZSAmJiBfY29sb3JDYWNoZVtrXSkge1xuICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlJGooX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuXG4gICAgICAgICAgICBpZiAodCA8PSBwKSB7XG4gICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodCA+PSBwICYmIGkgPT09IF9wb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2kgKyAxXSkge1xuICAgICAgICAgICAgICB0ID0gKHQgLSBwKSAvIChfcG9zW2kgKyAxXSAtIHApO1xuICAgICAgICAgICAgICBjb2wgPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2kgKyAxXSwgdCwgX21vZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRqKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29sID0gX2NvbG9ycyh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdXNlQ2FjaGUpIHtcbiAgICAgICAgICBfY29sb3JDYWNoZVtrXSA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH07XG5cbiAgICB2YXIgcmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgICByZXR1cm4gX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAgc2V0Q29sb3JzKGNvbG9ycyk7IC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgIHZhciBmID0gZnVuY3Rpb24gZih2KSB7XG4gICAgICB2YXIgYyA9IGNocm9tYV8xKGdldENvbG9yKHYpKTtcblxuICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkge1xuICAgICAgICByZXR1cm4gY1tfb3V0XSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICBpZiAoY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlJGooY2xhc3NlcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICBfY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gY2hyb21hXzEuYW5hbHl6ZShfZG9tYWluKTtcblxuICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IGNocm9tYV8xLmxpbWl0cyhkLCAnZScsIGNsYXNzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NsYXNzZXM7XG4gICAgfTtcblxuICAgIGYuZG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfZG9tYWluO1xuICAgICAgfVxuXG4gICAgICBfbWluID0gZG9tYWluWzBdO1xuICAgICAgX21heCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgICBfcG9zID0gW107XG4gICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gayAmJiBfbWluICE9PSBfbWF4KSB7XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgX3Bvcy5wdXNoKChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyAvIChrIC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgLy8gc2V0IGRvbWFpbiBtYXBcbiAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC8gKGRvbWFpbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdEJyZWFrcyA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdE91dFtpXSA9PT0gdmFsO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICAgICAgICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZiA9ICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpICsgMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgdmFyIG91dCA9IHRPdXRbaV0gKyBmICogKHRPdXRbaSArIDFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZG9tYWluID0gW19taW4sIF9tYXhdO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYubW9kZSA9IGZ1bmN0aW9uIChfbSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgIH1cblxuICAgICAgX21vZGUgPSBfbTtcbiAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnJhbmdlID0gZnVuY3Rpb24gKGNvbG9ycywgX3Bvcykge1xuICAgICAgc2V0Q29sb3JzKGNvbG9ycywgX3Bvcyk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5vdXQgPSBmdW5jdGlvbiAoX28pIHtcbiAgICAgIF9vdXQgPSBfbztcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnNwcmVhZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX3NwcmVhZDtcbiAgICAgIH1cblxuICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX2NvcnJlY3RMaWdodG5lc3MgPSB2O1xuICAgICAgcmVzZXRDYWNoZSgpO1xuXG4gICAgICBpZiAoX2NvcnJlY3RMaWdodG5lc3MpIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMMSA9IGdldENvbG9yKDEsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBwb2wgPSBMMCA+IEwxO1xuICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMX2lkZWFsID0gTDAgKyAoTDEgLSBMMCkgKiB0O1xuICAgICAgICAgIHZhciBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgdmFyIHQwID0gMDtcbiAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgIHZhciBtYXhfaXRlciA9IDIwO1xuXG4gICAgICAgICAgd2hpbGUgKE1hdGguYWJzKExfZGlmZikgPiAxZS0yICYmIG1heF9pdGVyLS0gPiAwKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAocG9sKSB7XG4gICAgICAgICAgICAgICAgTF9kaWZmICo9IC0xO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICB0MCA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDEgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIExfYWN0dWFsID0gZ2V0Q29sb3IodCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgIHJldHVybiBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5wYWRkaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUkaihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwID0gW3AsIHBdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhZGRpbmcgPSBwO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5jb2xvcnMgPSBmdW5jdGlvbiAobnVtQ29sb3JzLCBvdXQpIHtcbiAgICAgIC8vIElmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW4sIHJldHVybiB0aGUgb3JpZ2luYWwgY29sb3JzIHRoYXQgd2VyZSBwcm92aWRlZFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIG91dCA9ICdoZXgnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG4gICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICByZXN1bHQgPSBbZigwLjUpXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICB2YXIgZG0gPSBfZG9tYWluWzBdO1xuICAgICAgICB2YXIgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gZihkbSArIGkgLyAobnVtQ29sb3JzIC0gMSkgKiBkZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgY29sb3JzID0gW107XG4gICAgICAgIHZhciBzYW1wbGVzID0gW107XG5cbiAgICAgICAgaWYgKF9jbGFzc2VzICYmIF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpIC0gMV0gKyBfY2xhc3Nlc1tpXSkgKiAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1wbGVzID0gX2RvbWFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGYodik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hyb21hXzFbb3V0XSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGNbb3V0XSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZi5jYWNoZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIF91c2VDYWNoZSA9IGM7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nYW1tYTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5ub2RhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICBfbmFjb2wgPSBjaHJvbWFfMShkKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICBmdW5jdGlvbiBfX3JhbmdlX18obGVmdCwgcmlnaHQsIGluY2x1c2l2ZSkge1xuICAgIHZhciByYW5nZSA9IFtdO1xuICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgdmFyIGVuZCA9ICFpbmNsdXNpdmUgPyByaWdodCA6IGFzY2VuZGluZyA/IHJpZ2h0ICsgMSA6IHJpZ2h0IC0gMTtcblxuICAgIGZvciAodmFyIGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICByYW5nZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfSAvL1xuICAvLyBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gIC8vXG4gIC8vIEByZXF1aXJlcyB1dGlscyBsYWJcblxuXG4gIHZhciBiZXppZXIgPSBmdW5jdGlvbiBiZXppZXIoY29sb3JzKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyO1xuICAgIHZhciBJLCBsYWIwLCBsYWIxLCBsYWIyO1xuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShjKTtcbiAgICB9KTtcblxuICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduWzBdLCBsYWIxID0gYXNzaWduWzFdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYjBbaV0gKyB0ICogKGxhYjFbaV0gLSBsYWIwW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShsYWIsICdsYWInKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIGFzc2lnbiQxID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogbGFiMFtpXSArIDIgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyB0ICogdCAqIGxhYjJbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIHZhciBsYWIzO1xuICAgICAgYXNzaWduJDIgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLmxhYigpO1xuICAgICAgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICB2YXIgbGFiID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgKiBsYWIwW2ldICsgMyAqICgxIC0gdCkgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyAzICogKDEgLSB0KSAqIHQgKiB0ICogbGFiMltpXSArIHQgKiB0ICogdCAqIGxhYjNbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdmFyIEkwID0gYmV6aWVyKGNvbG9ycy5zbGljZSgwLCAzKSk7XG4gICAgICB2YXIgSTEgPSBiZXppZXIoY29sb3JzLnNsaWNlKDIsIDUpKTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICAgIHJldHVybiBJMCh0ICogMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEkxKCh0IC0gMC41KSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBJO1xuICB9O1xuXG4gIHZhciBiZXppZXJfMSA9IGZ1bmN0aW9uIGJlemllcl8xKGNvbG9ycykge1xuICAgIHZhciBmID0gYmV6aWVyKGNvbG9ycyk7XG5cbiAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNjYWxlKGYpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcbiAgLypcbiAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgKi9cblxuXG4gIHZhciBibGVuZCA9IGZ1bmN0aW9uIGJsZW5kKGJvdHRvbSwgdG9wLCBtb2RlKSB7XG4gICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gIH07XG5cbiAgdmFyIGJsZW5kX2YgPSBmdW5jdGlvbiBibGVuZF9mKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICB2YXIgYzAgPSBjaHJvbWFfMSh0b3ApLnJnYigpO1xuICAgICAgdmFyIGMxID0gY2hyb21hXzEoYm90dG9tKS5yZ2IoKTtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5yZ2IoZihjMCwgYzEpKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBlYWNoID0gZnVuY3Rpb24gZWFjaChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gbm9ybWFsKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICB2YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiIC8gMjU1O1xuICB9O1xuXG4gIHZhciBkYXJrZW4kMSA9IGZ1bmN0aW9uIGRhcmtlbiQxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyBiIDogYTtcbiAgfTtcblxuICB2YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIGxpZ2h0ZW4oYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xuICB9O1xuXG4gIHZhciBzY3JlZW4gPSBmdW5jdGlvbiBzY3JlZW4oYSwgYikge1xuICAgIHJldHVybiAyNTUgKiAoMSAtICgxIC0gYSAvIDI1NSkgKiAoMSAtIGIgLyAyNTUpKTtcbiAgfTtcblxuICB2YXIgb3ZlcmxheSA9IGZ1bmN0aW9uIG92ZXJsYXkoYSwgYikge1xuICAgIHJldHVybiBiIDwgMTI4ID8gMiAqIGEgKiBiIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1KSAqICgxIC0gYiAvIDI1NSkpO1xuICB9O1xuXG4gIHZhciBidXJuID0gZnVuY3Rpb24gYnVybihhLCBiKSB7XG4gICAgcmV0dXJuIDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhIC8gMjU1KSk7XG4gIH07XG5cbiAgdmFyIGRvZGdlID0gZnVuY3Rpb24gZG9kZ2UoYSwgYikge1xuICAgIGlmIChhID09PSAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuXG4gICAgYSA9IDI1NSAqIChiIC8gMjU1KSAvICgxIC0gYSAvIDI1NSk7XG4gICAgcmV0dXJuIGEgPiAyNTUgPyAyNTUgOiBhO1xuICB9OyAvLyAjIGFkZCA9IChhLGIpIC0+XG4gIC8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG5cbiAgYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuICBibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuICBibGVuZC5zY3JlZW4gPSBibGVuZF9mKGVhY2goc2NyZWVuKSk7XG4gIGJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuICBibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuJDEpKTtcbiAgYmxlbmQubGlnaHRlbiA9IGJsZW5kX2YoZWFjaChsaWdodGVuKSk7XG4gIGJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG4gIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpOyAvLyBibGVuZC5hZGQgPSBibGVuZF9mKGVhY2goYWRkKSk7XG5cbiAgdmFyIGJsZW5kXzEgPSBibGVuZDsgLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbiAgLy8gYmFzZWQgb24gRC5BLiBHcmVlbiBcIkEgY29sb3VyIHNjaGVtZSBmb3IgdGhlIGRpc3BsYXkgb2YgYXN0cm9ub21pY2FsIGludGVuc2l0eSBpbWFnZXNcIlxuICAvLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuXG4gIHZhciB0eXBlJGsgPSB1dGlscy50eXBlO1xuICB2YXIgY2xpcF9yZ2IkMyA9IHV0aWxzLmNsaXBfcmdiO1xuICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICB2YXIgcG93JDYgPSBNYXRoLnBvdztcbiAgdmFyIHNpbiQyID0gTWF0aC5zaW47XG4gIHZhciBjb3MkMyA9IE1hdGguY29zO1xuXG4gIHZhciBjdWJlaGVsaXggPSBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIHJvdGF0aW9ucywgaHVlLCBnYW1tYSwgbGlnaHRuZXNzKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHN0YXJ0ID0gMzAwO1xuICAgIGlmIChyb3RhdGlvbnMgPT09IHZvaWQgMCkgcm90YXRpb25zID0gLTEuNTtcbiAgICBpZiAoaHVlID09PSB2b2lkIDApIGh1ZSA9IDE7XG4gICAgaWYgKGdhbW1hID09PSB2b2lkIDApIGdhbW1hID0gMTtcbiAgICBpZiAobGlnaHRuZXNzID09PSB2b2lkIDApIGxpZ2h0bmVzcyA9IFswLCAxXTtcbiAgICB2YXIgZGggPSAwLFxuICAgICAgICBkbDtcblxuICAgIGlmICh0eXBlJGsobGlnaHRuZXNzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRsID0gMDtcbiAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgfVxuXG4gICAgdmFyIGYgPSBmdW5jdGlvbiBmKGZyYWN0KSB7XG4gICAgICB2YXIgYSA9IFRXT1BJJDIgKiAoKHN0YXJ0ICsgMTIwKSAvIDM2MCArIHJvdGF0aW9ucyAqIGZyYWN0KTtcbiAgICAgIHZhciBsID0gcG93JDYobGlnaHRuZXNzWzBdICsgZGwgKiBmcmFjdCwgZ2FtbWEpO1xuICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIGZyYWN0ICogZGggOiBodWU7XG4gICAgICB2YXIgYW1wID0gaCAqIGwgKiAoMSAtIGwpIC8gMjtcbiAgICAgIHZhciBjb3NfYSA9IGNvcyQzKGEpO1xuICAgICAgdmFyIHNpbl9hID0gc2luJDIoYSk7XG4gICAgICB2YXIgciA9IGwgKyBhbXAgKiAoLTAuMTQ4NjEgKiBjb3NfYSArIDEuNzgyNzcgKiBzaW5fYSk7XG4gICAgICB2YXIgZyA9IGwgKyBhbXAgKiAoLTAuMjkyMjcgKiBjb3NfYSAtIDAuOTA2NDkgKiBzaW5fYSk7XG4gICAgICB2YXIgYiA9IGwgKyBhbXAgKiAoKzEuOTcyOTQgKiBjb3NfYSk7XG4gICAgICByZXR1cm4gY2hyb21hXzEoY2xpcF9yZ2IkMyhbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgMV0pKTtcbiAgICB9O1xuXG4gICAgZi5zdGFydCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBzO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYucm90YXRpb25zID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9ucztcbiAgICAgIH1cblxuICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmdhbW1hID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIGlmIChnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdhbW1hO1xuICAgICAgfVxuXG4gICAgICBnYW1tYSA9IGc7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5odWUgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgaWYgKGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaHVlO1xuICAgICAgfVxuXG4gICAgICBodWUgPSBoO1xuXG4gICAgICBpZiAodHlwZSRrKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG5cbiAgICAgICAgaWYgKGRoID09PSAwKSB7XG4gICAgICAgICAgaHVlID0gaHVlWzFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICBpZiAoaCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaWdodG5lc3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGsoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgbGlnaHRuZXNzID0gaDtcbiAgICAgICAgZGwgPSBoWzFdIC0gaFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpZ2h0bmVzcyA9IFtoLCBoXTtcbiAgICAgICAgZGwgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5zY2FsZShmKTtcbiAgICB9O1xuXG4gICAgZi5odWUoaHVlKTtcbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICB2YXIgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICB2YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG4gIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICB2YXIgcmFuZG9tXzEgPSBmdW5jdGlvbiByYW5kb21fMSgpIHtcbiAgICB2YXIgY29kZSA9ICcjJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb2RlICs9IGRpZ2l0cy5jaGFyQXQoZmxvb3IkMihyYW5kb20oKSAqIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKGNvZGUsICdoZXgnKTtcbiAgfTtcblxuICB2YXIgbG9nJDEgPSBNYXRoLmxvZztcbiAgdmFyIHBvdyQ3ID0gTWF0aC5wb3c7XG4gIHZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gIHZhciBhbmFseXplID0gZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSB2b2lkIDApIGtleSA9IG51bGw7XG4gICAgdmFyIHIgPSB7XG4gICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUgKiAtMSxcbiAgICAgIHN1bTogMCxcbiAgICAgIHZhbHVlczogW10sXG4gICAgICBjb3VudDogMFxuICAgIH07XG5cbiAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgIH1cblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsID0gdmFsW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgci52YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICByLnN1bSArPSB2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7XG4gICAgICAgICAgci5taW4gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID4gci5tYXgpIHtcbiAgICAgICAgICByLm1heCA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgci5saW1pdHMgPSBmdW5jdGlvbiAobW9kZSwgbnVtKSB7XG4gICAgICByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7XG4gICAgfTtcblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIHZhciBsaW1pdHMgPSBmdW5jdGlvbiBsaW1pdHMoZGF0YSwgbW9kZSwgbnVtKSB7XG4gICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgbW9kZSA9ICdlcXVhbCc7XG4gICAgaWYgKG51bSA9PT0gdm9pZCAwKSBudW0gPSA3O1xuXG4gICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgZGF0YSA9IGFuYWx5emUoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IGRhdGEubWluO1xuICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bSA9PT0gMSkge1xuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0cyA9IFtdO1xuXG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnYycpIHtcbiAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH1cblxuICAgIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2UnKSB7XG4gICAgICAvLyBlcXVhbCBpbnRlcnZhbFxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICBsaW1pdHMucHVzaChtaW4gKyBpIC8gbnVtICogKG1heCAtIG1pbikpO1xuICAgICAgfVxuXG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdsJykge1xuICAgICAgLy8gbG9nIHNjYWxlXG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbl9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyQxKG1pbik7XG4gICAgICB2YXIgbWF4X2xvZyA9IE1hdGguTE9HMTBFICogbG9nJDEobWF4KTtcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG51bTsgaSQxKyspIHtcbiAgICAgICAgbGltaXRzLnB1c2gocG93JDcoMTAsIG1pbl9sb2cgKyBpJDEgLyBudW0gKiAobWF4X2xvZyAtIG1pbl9sb2cpKSk7XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ3EnKSB7XG4gICAgICAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgbnVtOyBpJDIrKykge1xuICAgICAgICB2YXIgcCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBpJDIgLyBudW07XG4gICAgICAgIHZhciBwYiA9IGZsb29yJDMocCk7XG5cbiAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcCA+IHBiXG4gICAgICAgICAgdmFyIHByID0gcCAtIHBiO1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0gKiAoMSAtIHByKSArIHZhbHVlc1twYiArIDFdICogcHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2snKSB7XG4gICAgICAvLyBrLW1lYW5zIGNsdXN0ZXJpbmdcblxuICAgICAgLypcbiAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICovXG4gICAgICB2YXIgY2x1c3RlcjtcbiAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsOyAvLyBnZXQgc2VlZCB2YWx1ZXNcblxuICAgICAgY2VudHJvaWRzID0gW107XG4gICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxOyBpJDMgPCBudW07IGkkMysrKSB7XG4gICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArIGkkMyAvIG51bSAqIChtYXggLSBtaW4pKTtcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgIGNsdXN0ZXJTaXplc1tqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBuOyBpJDQrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpJDRdO1xuICAgICAgICAgIHZhciBtaW5kaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICB2YXIgYmVzdCA9IHZvaWQgMDtcblxuICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzKGNlbnRyb2lkc1tqJDFdIC0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgYXNzaWdubWVudHNbaSQ0XSA9IGJlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBjZW50cm9pZHMgc3RlcFxuXG5cbiAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuXG4gICAgICAgIGZvciAodmFyIGokMiA9IDA7IGokMiA8IG51bTsgaiQyKyspIHtcbiAgICAgICAgICBuZXdDZW50cm9pZHNbaiQyXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBuOyBpJDUrKykge1xuICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpJDVdO1xuXG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSArPSB2YWx1ZXNbaSQ1XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqJDMgPSAwOyBqJDMgPCBudW07IGokMysrKSB7XG4gICAgICAgICAgbmV3Q2VudHJvaWRzW2okM10gKj0gMSAvIGNsdXN0ZXJTaXplc1tqJDNdO1xuICAgICAgICB9IC8vIGNoZWNrIGNvbnZlcmdlbmNlXG5cblxuICAgICAgICByZXBlYXQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqJDQgPSAwOyBqJDQgPCBudW07IGokNCsrKSB7XG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqJDRdICE9PSBjZW50cm9pZHNbaiQ0XSkge1xuICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgbmJfaXRlcnMrKztcblxuICAgICAgICBpZiAobmJfaXRlcnMgPiAyMDApIHtcbiAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuXG5cbiAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiQ1ID0gMDsgaiQ1IDwgbnVtOyBqJDUrKykge1xuICAgICAgICBrQ2x1c3RlcnNbaiQ1XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBuOyBpJDYrKykge1xuICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2kkNl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG5cbiAgICAgIGZvciAodmFyIGokNiA9IDA7IGokNiA8IG51bTsgaiQ2KyspIHtcbiAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVtrQ2x1c3RlcnNbaiQ2XS5sZW5ndGggLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgbGltaXRzLnB1c2godG1wS01lYW5zQnJlYWtzWzBdKTtcblxuICAgICAgZm9yICh2YXIgaSQ3ID0gMTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3ICs9IDIpIHtcbiAgICAgICAgdmFyIHYgPSB0bXBLTWVhbnNCcmVha3NbaSQ3XTtcblxuICAgICAgICBpZiAoIWlzTmFOKHYpICYmIGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbWl0cztcbiAgfTtcblxuICB2YXIgYW5hbHl6ZV8xID0ge1xuICAgIGFuYWx5emU6IGFuYWx5emUsXG4gICAgbGltaXRzOiBsaW1pdHNcbiAgfTtcblxuICB2YXIgY29udHJhc3QgPSBmdW5jdGlvbiBjb250cmFzdChhLCBiKSB7XG4gICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgbDEgPSBhLmx1bWluYW5jZSgpO1xuICAgIHZhciBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgfTtcblxuICB2YXIgc3FydCQ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuICB2YXIgY29zJDQgPSBNYXRoLmNvcztcbiAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gIHZhciBkZWx0YUUgPSBmdW5jdGlvbiBkZWx0YUUoYSwgYiwgTCwgQykge1xuICAgIGlmIChMID09PSB2b2lkIDApIEwgPSAxO1xuICAgIGlmIChDID09PSB2b2lkIDApIEMgPSAxOyAvLyBEZWx0YSBFIChDTUMpXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DTUMuaHRtbFxuXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgcmVmID0gQXJyYXkuZnJvbShhLmxhYigpKTtcbiAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgdmFyIGExID0gcmVmWzFdO1xuICAgIHZhciBiMSA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgIHZhciBMMiA9IHJlZiQxWzBdO1xuICAgIHZhciBhMiA9IHJlZiQxWzFdO1xuICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgIHZhciBjMSA9IHNxcnQkNChhMSAqIGExICsgYjEgKiBiMSk7XG4gICAgdmFyIGMyID0gc3FydCQ0KGEyICogYTIgKyBiMiAqIGIyKTtcbiAgICB2YXIgc2wgPSBMMSA8IDE2LjAgPyAwLjUxMSA6IDAuMDQwOTc1ICogTDEgLyAoMS4wICsgMC4wMTc2NSAqIEwxKTtcbiAgICB2YXIgc2MgPSAwLjA2MzggKiBjMSAvICgxLjAgKyAwLjAxMzEgKiBjMSkgKyAwLjYzODtcbiAgICB2YXIgaDEgPSBjMSA8IDAuMDAwMDAxID8gMC4wIDogYXRhbjIkMihiMSwgYTEpICogMTgwLjAgLyBQSSQyO1xuXG4gICAgd2hpbGUgKGgxIDwgMCkge1xuICAgICAgaDEgKz0gMzYwO1xuICAgIH1cblxuICAgIHdoaWxlIChoMSA+PSAzNjApIHtcbiAgICAgIGgxIC09IDM2MDtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGgxID49IDE2NC4wICYmIGgxIDw9IDM0NS4wID8gMC41NiArIGFicyQxKDAuMiAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAxNjguMCkgLyAxODAuMCkpIDogMC4zNiArIGFicyQxKDAuNCAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAzNS4wKSAvIDE4MC4wKSk7XG4gICAgdmFyIGM0ID0gYzEgKiBjMSAqIGMxICogYzE7XG4gICAgdmFyIGYgPSBzcXJ0JDQoYzQgLyAoYzQgKyAxOTAwLjApKTtcbiAgICB2YXIgc2ggPSBzYyAqIChmICogdCArIDEuMCAtIGYpO1xuICAgIHZhciBkZWxMID0gTDEgLSBMMjtcbiAgICB2YXIgZGVsQyA9IGMxIC0gYzI7XG4gICAgdmFyIGRlbEEgPSBhMSAtIGEyO1xuICAgIHZhciBkZWxCID0gYjEgLSBiMjtcbiAgICB2YXIgZEgyID0gZGVsQSAqIGRlbEEgKyBkZWxCICogZGVsQiAtIGRlbEMgKiBkZWxDO1xuICAgIHZhciB2MSA9IGRlbEwgLyAoTCAqIHNsKTtcbiAgICB2YXIgdjIgPSBkZWxDIC8gKEMgKiBzYyk7XG4gICAgdmFyIHYzID0gc2g7XG4gICAgcmV0dXJuIHNxcnQkNCh2MSAqIHYxICsgdjIgKiB2MiArIGRIMiAvICh2MyAqIHYzKSk7XG4gIH07IC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcblxuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIsIG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xhYic7IC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG5cbiAgICBhID0gbmV3IENvbG9yXzEoYSk7XG4gICAgYiA9IG5ldyBDb2xvcl8xKGIpO1xuICAgIHZhciBsMSA9IGEuZ2V0KG1vZGUpO1xuICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgIHZhciBzdW1fc3EgPSAwO1xuXG4gICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICBzdW1fc3EgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xuICB9O1xuXG4gIHZhciB2YWxpZCA9IGZ1bmN0aW9uIHZhbGlkKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTsgLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG5cblxuICB2YXIgc2NhbGVzID0ge1xuICAgIGNvb2w6IGZ1bmN0aW9uIGNvb2woKSB7XG4gICAgICByZXR1cm4gc2NhbGUoW2Nocm9tYV8xLmhzbCgxODAsIDEsIC45KSwgY2hyb21hXzEuaHNsKDI1MCwgLjcsIC40KV0pO1xuICAgIH0sXG4gICAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgICByZXR1cm4gc2NhbGUoWycjMDAwJywgJyNmMDAnLCAnI2ZmMCcsICcjZmZmJ10sIFswLCAuMjUsIC43NSwgMV0pLm1vZGUoJ3JnYicpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG4gICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZFxuICAgICAgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbiAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAqL1xuXG4gIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAvLyBzZXF1ZW50aWFsXG4gICAgT3JSZDogWycjZmZmN2VjJywgJyNmZWU4YzgnLCAnI2ZkZDQ5ZScsICcjZmRiYjg0JywgJyNmYzhkNTknLCAnI2VmNjU0OCcsICcjZDczMDFmJywgJyNiMzAwMDAnLCAnIzdmMDAwMCddLFxuICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICBCdVB1OiBbJyNmN2ZjZmQnLCAnI2UwZWNmNCcsICcjYmZkM2U2JywgJyM5ZWJjZGEnLCAnIzhjOTZjNicsICcjOGM2YmIxJywgJyM4ODQxOWQnLCAnIzgxMGY3YycsICcjNGQwMDRiJ10sXG4gICAgT3JhbmdlczogWycjZmZmNWViJywgJyNmZWU2Y2UnLCAnI2ZkZDBhMicsICcjZmRhZTZiJywgJyNmZDhkM2MnLCAnI2YxNjkxMycsICcjZDk0ODAxJywgJyNhNjM2MDMnLCAnIzdmMjcwNCddLFxuICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbE9yQnI6IFsnI2ZmZmZlNScsICcjZmZmN2JjJywgJyNmZWUzOTEnLCAnI2ZlYzQ0ZicsICcjZmU5OTI5JywgJyNlYzcwMTQnLCAnI2NjNGMwMicsICcjOTkzNDA0JywgJyM2NjI1MDYnXSxcbiAgICBZbEduOiBbJyNmZmZmZTUnLCAnI2Y3ZmNiOScsICcjZDlmMGEzJywgJyNhZGRkOGUnLCAnIzc4YzY3OScsICcjNDFhYjVkJywgJyMyMzg0NDMnLCAnIzAwNjgzNycsICcjMDA0NTI5J10sXG4gICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgIFJkUHU6IFsnI2ZmZjdmMycsICcjZmRlMGRkJywgJyNmY2M1YzAnLCAnI2ZhOWZiNScsICcjZjc2OGExJywgJyNkZDM0OTcnLCAnI2FlMDE3ZScsICcjN2EwMTc3JywgJyM0OTAwNmEnXSxcbiAgICBHcmVlbnM6IFsnI2Y3ZmNmNScsICcjZTVmNWUwJywgJyNjN2U5YzAnLCAnI2ExZDk5YicsICcjNzRjNDc2JywgJyM0MWFiNWQnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICBQdXJwbGVzOiBbJyNmY2ZiZmQnLCAnI2VmZWRmNScsICcjZGFkYWViJywgJyNiY2JkZGMnLCAnIzllOWFjOCcsICcjODA3ZGJhJywgJyM2YTUxYTMnLCAnIzU0Mjc4ZicsICcjM2YwMDdkJ10sXG4gICAgR25CdTogWycjZjdmY2YwJywgJyNlMGYzZGInLCAnI2NjZWJjNScsICcjYThkZGI1JywgJyM3YmNjYzQnLCAnIzRlYjNkMycsICcjMmI4Y2JlJywgJyMwODY4YWMnLCAnIzA4NDA4MSddLFxuICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgWWxPclJkOiBbJyNmZmZmY2MnLCAnI2ZmZWRhMCcsICcjZmVkOTc2JywgJyNmZWIyNGMnLCAnI2ZkOGQzYycsICcjZmM0ZTJhJywgJyNlMzFhMWMnLCAnI2JkMDAyNicsICcjODAwMDI2J10sXG4gICAgUHVSZDogWycjZjdmNGY5JywgJyNlN2UxZWYnLCAnI2Q0YjlkYScsICcjYzk5NGM3JywgJyNkZjY1YjAnLCAnI2U3Mjk4YScsICcjY2UxMjU2JywgJyM5ODAwNDMnLCAnIzY3MDAxZiddLFxuICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgUHVCdUduOiBbJyNmZmY3ZmInLCAnI2VjZTJmMCcsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzY3YTljZicsICcjMzY5MGMwJywgJyMwMjgxOGEnLCAnIzAxNmM1OScsICcjMDE0NjM2J10sXG4gICAgVmlyaWRpczogWycjNDQwMTU0JywgJyM0ODI3NzcnLCAnIzNmNGE4YScsICcjMzE2NzhlJywgJyMyNjgzOGYnLCAnIzFmOWQ4YScsICcjNmNjZTVhJywgJyNiNmRlMmInLCAnI2ZlZTgyNSddLFxuICAgIC8vIGRpdmVyZ2luZ1xuICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG4gICAgLy8gcXVhbGl0YXRpdmVcbiAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgIEFjY2VudDogWycjN2ZjOTdmJywgJyNiZWFlZDQnLCAnI2ZkYzA4NicsICcjZmZmZjk5JywgJyMzODZjYjAnLCAnI2YwMDI3ZicsICcjYmY1YjE3JywgJyM2NjY2NjYnXSxcbiAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgIERhcmsyOiBbJyMxYjllNzcnLCAnI2Q5NWYwMicsICcjNzU3MGIzJywgJyNlNzI5OGEnLCAnIzY2YTYxZScsICcjZTZhYjAyJywgJyNhNjc2MWQnLCAnIzY2NjY2NiddLFxuICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgUGFzdGVsMTogWycjZmJiNGFlJywgJyNiM2NkZTMnLCAnI2NjZWJjNScsICcjZGVjYmU0JywgJyNmZWQ5YTYnLCAnI2ZmZmZjYycsICcjZTVkOGJkJywgJyNmZGRhZWMnLCAnI2YyZjJmMiddXG4gIH07IC8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgIHZhciBrZXkgPSBsaXN0JDFbaSQxXTtcbiAgICBjb2xvcmJyZXdlcltrZXkudG9Mb3dlckNhc2UoKV0gPSBjb2xvcmJyZXdlcltrZXldO1xuICB9XG5cbiAgdmFyIGNvbG9yYnJld2VyXzEgPSBjb2xvcmJyZXdlcjsgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAvLyBhIHNtYWxsZXIgY2hyb21hLmpzIGJ1aWx0XG4gIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuICAvLyBvcGVyYXRvcnMgLS0+IG1vZGlmeSBleGlzdGluZyBDb2xvcnNcbiAgLy8gaW50ZXJwb2xhdG9yc1xuICAvLyBnZW5lcmF0b3JzIC0tID4gY3JlYXRlIG5ldyBjb2xvcnNcblxuICBjaHJvbWFfMS5hdmVyYWdlID0gYXZlcmFnZTtcbiAgY2hyb21hXzEuYmV6aWVyID0gYmV6aWVyXzE7XG4gIGNocm9tYV8xLmJsZW5kID0gYmxlbmRfMTtcbiAgY2hyb21hXzEuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICBjaHJvbWFfMS5taXggPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZSA9IG1peDtcbiAgY2hyb21hXzEucmFuZG9tID0gcmFuZG9tXzE7XG4gIGNocm9tYV8xLnNjYWxlID0gc2NhbGU7IC8vIG90aGVyIHV0aWxpdHkgbWV0aG9kc1xuXG4gIGNocm9tYV8xLmFuYWx5emUgPSBhbmFseXplXzEuYW5hbHl6ZTtcbiAgY2hyb21hXzEuY29udHJhc3QgPSBjb250cmFzdDtcbiAgY2hyb21hXzEuZGVsdGFFID0gZGVsdGFFO1xuICBjaHJvbWFfMS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBjaHJvbWFfMS5saW1pdHMgPSBhbmFseXplXzEubGltaXRzO1xuICBjaHJvbWFfMS52YWxpZCA9IHZhbGlkOyAvLyBzY2FsZVxuXG4gIGNocm9tYV8xLnNjYWxlcyA9IHNjYWxlczsgLy8gY29sb3JzXG5cbiAgY2hyb21hXzEuY29sb3JzID0gdzNjeDExXzE7XG4gIGNocm9tYV8xLmJyZXdlciA9IGNvbG9yYnJld2VyXzE7XG4gIHZhciBjaHJvbWFfanMgPSBjaHJvbWFfMTtcbiAgcmV0dXJuIGNocm9tYV9qcztcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3873\n")},5087:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanM/ZWJmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFNBQVM7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLFVBQVU7QUFDcko7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEs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QUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDs7QUFFQSxvR0FBb0c7O0FBRXBHOztBQUVBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxtQ0FBTztBQUNYO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDIiwiZmlsZSI6IjUwODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xuICB2YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICB2YXIgbm93ID0gRGF0ZS5ub3c7XG4gIC8qKlxuICAgKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICAgKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAgICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcblxuICAgICAgaWYgKGxvZykge1xuICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgdmFyIGFzc2lnbjtcblxuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICB9XG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cblxuXG4gIHZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKCFtZXJnZSB8fCBtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcbiAgLyoqXG4gICAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cblxuICB2YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xuICB9LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuICAvKipcbiAgICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKi9cblxuICBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICAgKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKlxuICAgKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0geyp9IHZhbDFcbiAgICogQHBhcmFtIHsqfSB2YWwyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gdmFsMSA9PT0gdW5kZWZpbmVkID8gdmFsMiA6IHZhbDE7XG4gIH1cbiAgLyoqXG4gICAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQG1ldGhvZCBoYXNQYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9XG4gIC8qKlxuICAgKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9XG4gIC8qKlxuICAgKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gICAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcblxuICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBpZiAoIWtleSkge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgIHByb3AgPSBwcmVmaXggPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogZ2V0IGEgdW5pcXVlIGlkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gICAqL1xuXG5cbiAgdmFyIF91bmlxdWVJZCA9IDE7XG5cbiAgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xuICB9XG5cbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbiAgdmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuICB2YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbiAgdmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuICB2YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcbiAgdmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcbiAgdmFyIElOUFVUX1NUQVJUID0gMTtcbiAgdmFyIElOUFVUX01PVkUgPSAyO1xuICB2YXIgSU5QVVRfRU5EID0gNDtcbiAgdmFyIElOUFVUX0NBTkNFTCA9IDg7XG4gIHZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG4gIHZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG4gIHZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xuICB2YXIgRElSRUNUSU9OX1VQID0gODtcbiAgdmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG4gIHZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xuICB2YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG4gIHZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG4gIHZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG4gIHZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDsgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIElucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTsgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG5cbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcblxuXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7IC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG5cbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG5cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgIHk6IGNlbnRlci55XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xuICB9XG4gIC8qKlxuICAgKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eVgsXG4gICAgICAgIHZlbG9jaXR5WSxcbiAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgIHZlbG9jaXR5ID0gYWJzKHYueCkgPiBhYnModi55KSA/IHYueCA6IHYueTtcbiAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG5cbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cblxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9XG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cblxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuXG4gIHZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG4gIH07XG4gIHZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xuICB2YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG4gIC8qKlxuICAgKiBNb3VzZSBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICB9IC8vIG1vdXNlIG11c3QgYmUgZG93blxuXG5cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbiAgfTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxuICB2YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbiAgfTtcbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbiAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuICAvKipcbiAgICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdG9yZSA9IHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgfVxuXG4gIGluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIOyAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG4gICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpOyAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgfSAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcblxuXG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG5cbiAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBUb3VjaCBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG5cbiAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTsgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbiAgfVxuXG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7IC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDsgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7IC8vIGNvbGxlY3QgdG91Y2hlc1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcblxuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgIH0gLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcblxuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG4gIH1cbiAgLyoqXG4gICAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICAgKlxuICAgKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAgICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cblxuICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gIHZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG4gIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgfVxuXG4gIGluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0U7XG5cbiAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblxuXG4gICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICB2YXIgbGFzdFRvdWNoID0ge1xuICAgICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgICB5OiB0b3VjaC5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcblxuICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RUb3VjaCgpIHtcbiAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLFxuICAgICAgICB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG5cbiAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbiAgdmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDsgLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxuXG4gIHZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbiAgdmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcblxuICB2YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbiAgdmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgfVxuXG4gIFRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbiBjb21wdXRlKCkge1xuICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247IC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuXG4gICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTm9uZSB8fCBoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMIHx8IGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbiBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAgICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAgICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gICAqXG4gICAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAgICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAgICpcbiAgICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICAgKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICAgKlxuICAgKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gICAqICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICAgKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gICAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gICAqL1xuXG5cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcbiAgLyoqXG4gICAqIFJlY29nbml6ZXJcbiAgICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG5cbiAgUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuXG4gICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbiByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24gZHJvcFJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiByZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24gZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG5cbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uIGhhc1JlcXVpcmVGYWlsdXJlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24gY2FuUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgfSAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcblxuXG4gICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG5cbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICB9IC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG5cblxuICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24gdHJ5RW1pdChpbnB1dCkge1xuICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgfSAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG5cblxuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24gY2FuRW1pdCgpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fSxcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7fVxuICB9O1xuICAvKipcbiAgICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gICAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICAgKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcblxuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcbiAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTsgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuXG4gICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbiBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZOyAvLyBsb2NrIHRvIGF4aXM/XG5cbiAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBQaW5jaFxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogUHJlc3NcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSxcbiAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcblxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcbiAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cbiAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIFJvdGF0ZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTd2lwZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiYgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJiBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAgICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gICAqIGEgc2luZ2xlIHRhcC5cbiAgICpcbiAgICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gICAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcblxuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0YXBzOiAxLFxuICAgICAgaW50ZXJ2YWw6IDMwMCxcbiAgICAgIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICB0aW1lOiAyNTAsXG4gICAgICAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgdGhyZXNob2xkOiA5LFxuICAgICAgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG4gICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH0gLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuXG4gICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG5cbiAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cblxuXG4gIEhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcbiAgLyoqXG4gICAqIGRlZmF1bHQgc2V0dGluZ3NcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICBIYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9XSwgW1BpbmNoUmVjb2duaXplciwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfSwgWydzd2lwZSddXSwgW1RhcFJlY29nbml6ZXJdLCBbVGFwUmVjb2duaXplciwge1xuICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgICAgdGFwczogMlxuICAgIH0sIFsndGFwJ11dLCBbUHJlc3NSZWNvZ25pemVyXV0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgKi9cbiAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG4gIH07XG4gIHZhciBTVE9QID0gMTtcbiAgdmFyIEZPUkNFRF9TVE9QID0gMjtcbiAgLyoqXG4gICAqIE1hbmFnZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcChmb3JjZSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG4gICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07IC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgICAgLy8gM1xuICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICB9IC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuXG5cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChyZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyByZW1vdmUgZXhpc3RpbmdcblxuXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgfSAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcblxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiB0cmlnZ2VyIGRvbSBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG5cblxuICBmdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbiAgfVxuXG4gIGFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxuICB9KTsgLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbiAgLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG5cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG4gIH1cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5087\n")},5438:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("var $ = __webpack_require__(2109);\n\n// eslint-disable-next-line es/no-math-hypot -- required for testing\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$({ target: 'Math', stat: true, forced: BUGGY }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qcz80MDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNTQzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC1oeXBvdCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLy8gQ2hyb21lIDc3IGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTU0NlxudmFyIEJVR0dZID0gISEkaHlwb3QgJiYgJGh5cG90KEluZmluaXR5LCBOYU4pICE9PSBJbmZpbml0eTtcblxuLy8gYE1hdGguaHlwb3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLmh5cG90XG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogQlVHR1kgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIHNxcnQoc3VtKTtcbiAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5438\n")},9693:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": function() { return /* binding */ cejst; }\n});\n\n// NAMESPACE OBJECT: ./src/components/J40Map.module.scss\nvar J40Map_module_namespaceObject = {};\n__webpack_require__.r(J40Map_module_namespaceObject);\n__webpack_require__.d(J40Map_module_namespaceObject, {\n  "wU": function() { return navigationControls; },\n  "lU": function() { return zoomButton; },\n  "MI": function() { return zoomContainer; }\n});\n\n// NAMESPACE OBJECT: ./src/components/mapLegend.module.scss\nvar mapLegend_module_namespaceObject = {};\n__webpack_require__.r(mapLegend_module_namespaceObject);\n__webpack_require__.d(mapLegend_module_namespaceObject, {\n  "Ww": function() { return colorSwatch; },\n  "nm": function() { return legendContainer; },\n  "oI": function() { return legendItem; },\n  "KW": function() { return nonPrioritized; },\n  "ah": function() { return prioritized; },\n  "VV": function() { return swatchContainer; },\n  "Lj": function() { return threshold; }\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./src/components/layout.tsx + 8 modules\nvar layout = __webpack_require__(6515);\n// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js\nvar chroma = __webpack_require__(3873);\nvar chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);\n;// CONCATENATED MODULE: ./src/data/constants.tsx\n// Properties\nvar SCORE_PROPERTY=\'Score D (percentile)\';var GEOID_PROPERTY=\'GEOID10\';var SCORE_LAYER=\'score\';// Zoom\nvar GLOBAL_MIN_ZOOM=3;var GLOBAL_MAX_ZOOM=22;var GLOBAL_MIN_ZOOM_LOW=3;var GLOBAL_MAX_ZOOM_LOW=9;var GLOBAL_MIN_ZOOM_HIGH=9;var GLOBAL_MAX_ZOOM_HIGH=12;// Bounds --\n// From https://anthonylouisdagostino.com/bounding-boxes-for-all-us-states/\nvar GLOBAL_MAX_BOUNDS=(/* unused pure expression or super */ null && ([[-180.118306,5.499550],[-65.0,83.162102]]));var LOWER_48_BOUNDS=[[-124.7844079,24.7433195],[-66.9513812,49.3457868]];var ALASKA_BOUNDS=[[-183.856888,50.875311],[-140.932617,71.958797]];var HAWAII_BOUNDS=[[-168.118306,18.748115],[-154.757881,22.378413]];var PUERTO_RICO_BOUNDS=[[-67.945404,17.88328],[-65.220703,18.515683]];var GUAM_BOUNDS=(/* unused pure expression or super */ null && ([[-215.389709,13.225909],[-215.040894,13.663335]]));var MARIANA_ISLAND_BOUNDS=(/* unused pure expression or super */ null && ([[-215.313449,14.007801],[-213.742404,19.750326]]));var AMERICAN_SAMOA_BOUNDS=(/* unused pure expression or super */ null && ([[-171.089874,-14.548699],[-168.1433,-11.046934]]));var DEFAULT_CENTER=[32.4687126,-86.502136];// Opacity\nvar DEFAULT_LAYER_OPACITY=0.6;// Colors\nvar DEFAULT_OUTLINE_COLOR=\'#4EA5CF\';var MIN_COLOR=\'#FFFFFF\';var MED_COLOR=\'#D1DAE6\';var MAX_COLOR=\'#768FB3\';var BORDER_HIGHLIGHT_COLOR=\'#00BDE3\';\n;// CONCATENATED MODULE: ./src/data/mapStyle.tsx\n// eslint-disable-next-line require-jsdoc\nfunction hexToHSLA(hex,alpha){return chroma_default()(hex).alpha(alpha).css(\'hsl\');}/**\n * `MakePaint` generates a zoom-faded Maplibre style formatted layer given a set of parameters.\n *\n * @param {string} field : the field within the data to consult\n * @param {number} minRamp : the minimum value this can assume\n * @param {number} medRamp : the medium value this can assume\n * @param {number} maxRamp : the maximum value this can assume\n * @return {FillPaint} a maplibregl fill layer\n **/function makePaint(_ref){var field=_ref.field,minRamp=_ref.minRamp,medRamp=_ref.medRamp,maxRamp=_ref.maxRamp;var paintDescriptor={\'fill-color\':[\'step\',[\'to-number\',[\'get\',field]],hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),minRamp,hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),medRamp,hexToHSLA(MED_COLOR,DEFAULT_LAYER_OPACITY),maxRamp,hexToHSLA(MAX_COLOR,DEFAULT_LAYER_OPACITY)]};return paintDescriptor;}var mapStyle={\'version\':8,\'sources\':{\'carto\':{\'type\':\'raster\',\'tiles\':[\'https://a.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png\',\'https://b.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png\',\'https://c.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png\',\'https://d.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png\']},\'geo\':{\'type\':\'raster\',\'tiles\':[\'https://mt0.google.com/vt/lyrs=p&hl=en&x={x}&y={y}&z={z}\']},\'score\':{\'type\':\'vector\',\'promoteId\':\'GEOID10\',\'tiles\':[\'https://d2zjid6n5ja2pt.cloudfront.net/0629_demo/{z}/{x}/{y}.pbf\'// For local development, use:\n// \'http://localhost:8080/data/tl_2010_bg_with_data/{z}/{x}/{y}.pbf\',\n]},\'labels\':{\'type\':\'raster\',\'tiles\':[\'https://cartodb-basemaps-a.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}@2x.png\',\'https://cartodb-basemaps-b.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}@2x.png\',\'https://cartodb-basemaps-c.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}@2x.png\',\'https://cartodb-basemaps-d.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}@2x.png\']}},\'layers\':[{\'id\':\'carto\',\'source\':\'carto\',\'type\':\'raster\'// \'minzoom\': constants.GLOBAL_MIN_ZOOM - 1,\n},{\'id\':\'geo\',\'source\':\'geo\',\'type\':\'raster\',// \'minzoom\': constants.GLOBAL_MIN_ZOOM - 1,\n\'layout\':{// Make the layer visible by default.\n\'visibility\':\'none\'}},{\'id\':\'score\',\'source\':\'score\',\'source-layer\':\'blocks\',\'type\':\'fill\',\'filter\':[\'all\',[\'>\',SCORE_PROPERTY,0.6]// [\'in\', \'STATEFP10\', \'01\', \'30\', \'34\', \'35\', \'36\'],\n],\'paint\':makePaint({field:SCORE_PROPERTY,minRamp:0,medRamp:0.6,maxRamp:0.75})// \'minzoom\': constants.GLOBAL_MIN_ZOOM,\n// \'maxzoom\': constants.GLOBAL_MAX_ZOOM,\n},{\'id\':\'score-highlights\',\'source\':\'score\',\'source-layer\':\'blocks\',\'type\':\'line\',\'minzoom\':GLOBAL_MIN_ZOOM_HIGH,\'layout\':{\'visibility\':\'visible\',\'line-join\':\'round\',\'line-cap\':\'round\'},\'paint\':{\'line-color\':DEFAULT_OUTLINE_COLOR,\'line-width\':0.8,\'line-opacity\':0.5}},{\'id\':\'score-border-highlight\',\'type\':\'line\',\'source\':\'score\',\'source-layer\':\'blocks\',\'layout\':{},\'paint\':{\'line-color\':BORDER_HIGHLIGHT_COLOR,\'line-width\':[\'case\',[\'boolean\',[\'feature-state\',\'selected\'],false],5.0,0]}},{\'id\':\'labels-only\',\'type\':\'raster\',\'source\':\'labels\'// \'minzoom\': constants.GLOBAL_MIN_ZOOM,\n}]};/* harmony default export */ var data_mapStyle = (mapStyle);\n;// CONCATENATED MODULE: ./src/components/zoomWarning.module.scss\n// extracted by mini-css-extract-plugin\nvar zoomWarning = "zoomWarning-module--zoomWarning--jGeOk";\n;// CONCATENATED MODULE: ./node_modules/uswds/dist/img/usa-icons/zoom_in.svg\n/* harmony default export */ var zoom_in = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48cGF0aCBkPSJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QzE1LjQxIDEyLjU5IDE2IDExLjExIDE2IDkuNSAxNiA1LjkxIDEzLjA5IDMgOS41IDNTMyA1LjkxIDMgOS41IDUuOTEgMTYgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHoiLz48cGF0aCBkPSJNMTIgMTBoLTJ2Mkg5di0ySDdWOWgyVjdoMXYyaDJ2MXoiLz48L3N2Zz4=");\n;// CONCATENATED MODULE: ./src/components/zoomWarning.tsx\n// @ts-ignore\nvar ZoomWarning=function ZoomWarning(_ref){var zoomLevel=_ref.zoomLevel;return/*#__PURE__*/react.createElement(react.Fragment,null,zoomLevel<=5?/*#__PURE__*/react.createElement("div",{className:zoomWarning},/*#__PURE__*/react.createElement("img",{src:zoom_in,alt:\'zoom icon\'}),"Zoom in to the state or regional level to see prioritized communities on the map."):\'\');};/* harmony default export */ var components_zoomWarning = (ZoomWarning);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(7329);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(6156);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(5697);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__(2961);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction slicedToArray_slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || (0,unsupportedIterableToArray/* default */.Z)(arr, i) || _nonIterableRest();\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(6610);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(5991);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.math.hypot.js\nvar es_math_hypot = __webpack_require__(5438);\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js\n\n\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== \'undefined\' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec4.js\n\n\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec4_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {ReadonlyVec4} result the receiving vector\r\n * @param {ReadonlyVec4} U the first vector\r\n * @param {ReadonlyVec4} V the second vector\r\n * @param {ReadonlyVec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec4_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nvar sub = (/* unused pure expression or super */ null && (subtract));\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nvar mul = (/* unused pure expression or super */ null && (multiply));\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nvar div = (/* unused pure expression or super */ null && (divide));\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nvar dist = (/* unused pure expression or super */ null && (distance));\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nvar len = (/* unused pure expression or super */ null && (vec4_length));\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  var result = transformMat4([], vector, matrix);\n  scale(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat4.js\n\n\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction mat4_create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction mat4_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\nfunction mat4_fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nfunction mat4_scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {ReadonlyQuat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {ReadonlyMat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction mat4_str(a) {\n  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\r\n * Adds two mat4\'s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix\'s elements by\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4\'s after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @param {Number} scale the amount to scale b\'s elements by before adding\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction mat4_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction mat4_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\nvar mat4_mul = (/* unused pure expression or super */ null && (mat4_multiply));\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nvar mat4_sub = (/* unused pure expression or super */ null && (mat4_subtract));\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js\n\n\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_create() {\n  var out = new ARRAY_TYPE(2);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction vec2_distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction vec2_squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec2_length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction vec2_squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction vec2_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2\'s\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec2_cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly \'1\'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly \'0\'\r\n * 4th vector component is implicitly \'1\'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {ReadonlyVec2} a The vec2 point to rotate\r\n * @param {ReadonlyVec2} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {ReadonlyVec2} a The first operand\r\n * @param {ReadonlyVec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction vec2_str(a) {\n  return "vec2(" + a[0] + ", " + a[1] + ")";\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec2_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec2_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\nvar vec2_len = (/* unused pure expression or super */ null && (vec2_length));\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nvar vec2_sub = vec2_subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nvar vec2_mul = (/* unused pure expression or super */ null && (vec2_multiply));\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nvar vec2_div = (/* unused pure expression or super */ null && (vec2_divide));\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nvar vec2_dist = (/* unused pure expression or super */ null && (vec2_distance));\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nvar vec2_sqrDist = (/* unused pure expression or super */ null && (vec2_squaredDistance));\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nvar vec2_sqrLen = (/* unused pure expression or super */ null && (vec2_squaredLength));\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar vec2_forEach = function () {\n  var vec = vec2_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js\n\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec3_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction vec3_distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction vec3_squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction vec3_squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction vec3_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly \'1\'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction vec3_angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && vec3_dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction vec3_str(a) {\n  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec3_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec3_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nvar vec3_mul = vec3_multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nvar vec3_div = (/* unused pure expression or super */ null && (vec3_divide));\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nvar vec3_dist = (/* unused pure expression or super */ null && (vec3_distance));\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nvar vec3_sqrDist = (/* unused pure expression or super */ null && (vec3_squaredDistance));\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nvar vec3_len = (/* unused pure expression or super */ null && (vec3_length));\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nvar vec3_sqrLen = (/* unused pure expression or super */ null && (vec3_squaredLength));\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar vec3_forEach = function () {\n  var vec = vec3_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'@math.gl/web-mercator: assertion failed.\');\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\n\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar EARTH_CIRCUMFERENCE = 40.03e6;\nvar DEFAULT_ALTITUDE = 1.5;\nfunction zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction scaleToZoom(scale) {\n  return Math.log2(scale);\n}\nfunction lngLatToWorld(_ref) {\n  var _ref2 = slicedToArray_slicedToArray(_ref, 2),\n      lng = _ref2[0],\n      lat = _ref2[1];\n\n  assert_assert(Number.isFinite(lng));\n  assert_assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, \'invalid latitude\');\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  var y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction worldToLngLat(_ref3) {\n  var _ref4 = slicedToArray_slicedToArray(_ref3, 2),\n      x = _ref4[0],\n      y = _ref4[1];\n\n  var lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(_ref5) {\n  var latitude = _ref5.latitude;\n  assert(Number.isFinite(latitude));\n  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction getDistanceScales(_ref6) {\n  var latitude = _ref6.latitude,\n      longitude = _ref6.longitude,\n      _ref6$highPrecision = _ref6.highPrecision,\n      highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;\n  assert_assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  var result = {};\n  var worldSize = TILE_SIZE;\n  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  var unitsPerDegreeX = worldSize / 360;\n  var unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  var altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  result.unitsPerMeter = [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter];\n  result.metersPerUnit = [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter];\n  result.unitsPerDegree = [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter];\n  result.degreesPerUnit = [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter];\n\n  if (highPrecision) {\n    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    var unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    var altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    var altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  var _lngLatZ = _slicedToArray(lngLatZ, 3),\n      longitude = _lngLatZ[0],\n      latitude = _lngLatZ[1],\n      z0 = _lngLatZ[2];\n\n  var _xyz = _slicedToArray(xyz, 3),\n      x = _xyz[0],\n      y = _xyz[1],\n      z = _xyz[2];\n\n  var _getDistanceScales = getDistanceScales({\n    longitude: longitude,\n    latitude: latitude,\n    highPrecision: true\n  }),\n      unitsPerMeter = _getDistanceScales.unitsPerMeter,\n      unitsPerMeter2 = _getDistanceScales.unitsPerMeter2;\n\n  var worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  var newLngLat = worldToLngLat(worldspace);\n  var newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction getViewMatrix(_ref7) {\n  var height = _ref7.height,\n      pitch = _ref7.pitch,\n      bearing = _ref7.bearing,\n      altitude = _ref7.altitude,\n      scale = _ref7.scale,\n      _ref7$center = _ref7.center,\n      center = _ref7$center === void 0 ? null : _ref7$center;\n  var vm = createMat4();\n  translate(vm, vm, [0, 0, -altitude]);\n  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n  scale /= height;\n  mat4_scale(vm, vm, [scale, scale, scale]);\n\n  if (center) {\n    translate(vm, vm, vec3_negate([], center));\n  }\n\n  return vm;\n}\nfunction getProjectionParameters(_ref8) {\n  var width = _ref8.width,\n      height = _ref8.height,\n      _ref8$altitude = _ref8.altitude,\n      altitude = _ref8$altitude === void 0 ? DEFAULT_ALTITUDE : _ref8$altitude,\n      _ref8$pitch = _ref8.pitch,\n      pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch,\n      _ref8$nearZMultiplier = _ref8.nearZMultiplier,\n      nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier,\n      _ref8$farZMultiplier = _ref8.farZMultiplier,\n      farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n  var halfFov = Math.atan(0.5 / altitude);\n  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.min(Math.max(Math.PI / 2 - pitchRadians - halfFov, 0.01), Math.PI - 0.01));\n  var farZ = Math.sin(pitchRadians) * topHalfSurfaceDistance + altitude;\n  return {\n    fov: 2 * halfFov,\n    aspect: width / height,\n    focalDistance: altitude,\n    near: nearZMultiplier,\n    far: farZ * farZMultiplier\n  };\n}\nfunction getProjectionMatrix(_ref9) {\n  var width = _ref9.width,\n      height = _ref9.height,\n      pitch = _ref9.pitch,\n      altitude = _ref9.altitude,\n      nearZMultiplier = _ref9.nearZMultiplier,\n      farZMultiplier = _ref9.farZMultiplier;\n\n  var _getProjectionParamet = getProjectionParameters({\n    width: width,\n    height: height,\n    altitude: altitude,\n    pitch: pitch,\n    nearZMultiplier: nearZMultiplier,\n    farZMultiplier: farZMultiplier\n  }),\n      fov = _getProjectionParamet.fov,\n      aspect = _getProjectionParamet.aspect,\n      near = _getProjectionParamet.near,\n      far = _getProjectionParamet.far;\n\n  var projectionMatrix = perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction worldToPixels(xyz, pixelProjectionMatrix) {\n  var _xyz2 = slicedToArray_slicedToArray(xyz, 3),\n      x = _xyz2[0],\n      y = _xyz2[1],\n      _xyz2$ = _xyz2[2],\n      z = _xyz2$ === void 0 ? 0 : _xyz2$;\n\n  assert_assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction pixelsToWorld(xyz, pixelUnprojectionMatrix) {\n  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  var _xyz3 = slicedToArray_slicedToArray(xyz, 3),\n      x = _xyz3[0],\n      y = _xyz3[1],\n      z = _xyz3[2];\n\n  assert_assert(Number.isFinite(x) && Number.isFinite(y), \'invalid pixel coordinate\');\n\n  if (Number.isFinite(z)) {\n    var coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  var coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  var coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  var z0 = coord0[2];\n  var z1 = coord1[2];\n  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2_lerp([], coord0, coord1, t);\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\nfunction fit_bounds_fitBounds(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      bounds = _ref.bounds,\n      _ref$minExtent = _ref.minExtent,\n      minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;\n\n  var _bounds = slicedToArray_slicedToArray(bounds, 2),\n      _bounds$ = slicedToArray_slicedToArray(_bounds[0], 2),\n      west = _bounds$[0],\n      south = _bounds$[1],\n      _bounds$2 = slicedToArray_slicedToArray(_bounds[1], 2),\n      east = _bounds$2[0],\n      north = _bounds$2[1];\n\n  if (Number.isFinite(padding)) {\n    var p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    assert_assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  }\n\n  var viewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: 0,\n    latitude: 0,\n    zoom: 0\n  });\n  var nw = viewport.project([west, north]);\n  var se = viewport.project([east, south]);\n  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert_assert(targetSize[0] > 0 && targetSize[1] > 0);\n  var scaleX = targetSize[0] / size[0];\n  var scaleY = targetSize[1] / size[1];\n  var offsetX = (padding.right - padding.left) / 2 / scaleX;\n  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  var centerLngLat = viewport.unproject(center);\n  var zoom = Math.min(maxZoom, viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert_assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nvar get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction getBounds(viewport) {\n  var z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var width = viewport.width,\n      height = viewport.height,\n      unproject = viewport.unproject;\n  var unprojectOps = {\n    targetZ: z\n  };\n  var bottomLeft = unproject([0, height], unprojectOps);\n  var bottomRight = unproject([width, height], unprojectOps);\n  var topLeft;\n  var topRight;\n  var halfFov = Math.atan(0.5 / viewport.altitude);\n  var angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  var coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  var coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  var z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  var t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  var coord = vec2_lerp([], coord0, coord1, t);\n  var result = worldToLngLat(coord);\n  result[2] = targetZ;\n  return result;\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\n\n\n\n\nvar WebMercatorViewport = function () {\n  function WebMercatorViewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    },\n        width = _ref.width,\n        height = _ref.height,\n        _ref$latitude = _ref.latitude,\n        latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,\n        _ref$longitude = _ref.longitude,\n        longitude = _ref$longitude === void 0 ? 0 : _ref$longitude,\n        _ref$zoom = _ref.zoom,\n        zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude,\n        _ref$position = _ref.position,\n        position = _ref$position === void 0 ? null : _ref$position,\n        _ref$nearZMultiplier = _ref.nearZMultiplier,\n        nearZMultiplier = _ref$nearZMultiplier === void 0 ? 0.02 : _ref$nearZMultiplier,\n        _ref$farZMultiplier = _ref.farZMultiplier,\n        farZMultiplier = _ref$farZMultiplier === void 0 ? 1.01 : _ref$farZMultiplier;\n\n    (0,classCallCheck/* default */.Z)(this, WebMercatorViewport);\n\n    width = width || 1;\n    height = height || 1;\n    var scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    var distanceScales = getDistanceScales({\n      longitude: longitude,\n      latitude: latitude\n    });\n    var center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n\n    if (position) {\n      vec3_add(center, center, vec3_mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width: width,\n      height: height,\n      pitch: pitch,\n      altitude: altitude,\n      nearZMultiplier: nearZMultiplier,\n      farZMultiplier: farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height: height,\n      scale: scale,\n      center: center,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    Object.freeze(this);\n  }\n\n  (0,createClass/* default */.Z)(WebMercatorViewport, [{\n    key: "_initMatrices",\n    value: function _initMatrices() {\n      var width = this.width,\n          height = this.height,\n          projectionMatrix = this.projectionMatrix,\n          viewMatrix = this.viewMatrix;\n      var vpm = createMat4();\n      mat4_multiply(vpm, vpm, projectionMatrix);\n      mat4_multiply(vpm, vpm, viewMatrix);\n      this.viewProjectionMatrix = vpm;\n      var m = createMat4();\n      mat4_scale(m, m, [width / 2, -height / 2, 1]);\n      translate(m, m, [1, -1, 0]);\n      mat4_multiply(m, m, vpm);\n      var mInverse = invert(createMat4(), m);\n\n      if (!mInverse) {\n        throw new Error(\'Pixel project matrix not invertible\');\n      }\n\n      this.pixelProjectionMatrix = m;\n      this.pixelUnprojectionMatrix = mInverse;\n    }\n  }, {\n    key: "equals",\n    value: function equals(viewport) {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4_equals(viewport.projectionMatrix, this.projectionMatrix) && mat4_equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: "project",\n    value: function project(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$topLeft = _ref2.topLeft,\n          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;\n\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n      var _coord = slicedToArray_slicedToArray(coord, 2),\n          x = _coord[0],\n          y = _coord[1];\n\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: "unproject",\n    value: function unproject(xyz) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$topLeft = _ref3.topLeft,\n          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,\n          _ref3$targetZ = _ref3.targetZ,\n          targetZ = _ref3$targetZ === void 0 ? undefined : _ref3$targetZ;\n\n      var _xyz = slicedToArray_slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          z = _xyz[2];\n\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n          _this$unprojectPositi2 = slicedToArray_slicedToArray(_this$unprojectPositi, 3),\n          X = _this$unprojectPositi2[0],\n          Y = _this$unprojectPositi2[1],\n          Z = _this$unprojectPositi2[2];\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: "projectPosition",\n    value: function projectPosition(xyz) {\n      var _lngLatToWorld = lngLatToWorld(xyz),\n          _lngLatToWorld2 = slicedToArray_slicedToArray(_lngLatToWorld, 2),\n          X = _lngLatToWorld2[0],\n          Y = _lngLatToWorld2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: "unprojectPosition",\n    value: function unprojectPosition(xyz) {\n      var _worldToLngLat = worldToLngLat(xyz),\n          _worldToLngLat2 = slicedToArray_slicedToArray(_worldToLngLat, 2),\n          X = _worldToLngLat2[0],\n          Y = _worldToLngLat2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: "projectFlat",\n    value: function projectFlat(lngLat) {\n      return lngLatToWorld(lngLat);\n    }\n  }, {\n    key: "unprojectFlat",\n    value: function unprojectFlat(xy) {\n      return worldToLngLat(xy);\n    }\n  }, {\n    key: "getMapCenterByLngLatPosition",\n    value: function getMapCenterByLngLatPosition(_ref4) {\n      var lngLat = _ref4.lngLat,\n          pos = _ref4.pos;\n      var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n      var toLocation = lngLatToWorld(lngLat);\n      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n      var newCenter = vec2_add([], this.center, translate);\n      return worldToLngLat(newCenter);\n    }\n  }, {\n    key: "getLocationAtPoint",\n    value: function getLocationAtPoint(_ref5) {\n      var lngLat = _ref5.lngLat,\n          pos = _ref5.pos;\n      return this.getMapCenterByLngLatPosition({\n        lngLat: lngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: "fitBounds",\n    value: function fitBounds(bounds) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var width = this.width,\n          height = this.height;\n\n      var _fitBounds2 = fit_bounds_fitBounds(Object.assign({\n        width: width,\n        height: height,\n        bounds: bounds\n      }, options)),\n          longitude = _fitBounds2.longitude,\n          latitude = _fitBounds2.latitude,\n          zoom = _fitBounds2.zoom;\n\n      return new WebMercatorViewport({\n        width: width,\n        height: height,\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom\n      });\n    }\n  }, {\n    key: "getBounds",\n    value: function getBounds(options) {\n      var corners = this.getBoundingRegion(options);\n      var west = Math.min.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[0];\n      })));\n      var east = Math.max.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[0];\n      })));\n      var south = Math.min.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[1];\n      })));\n      var north = Math.max.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[1];\n      })));\n      return [[west, south], [east, north]];\n    }\n  }, {\n    key: "getBoundingRegion",\n    value: function getBoundingRegion() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return getBounds(this, options.z || 0);\n    }\n  }]);\n\n  return WebMercatorViewport;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nvar MAX_LATITUDE = 85.05113;\nvar MIN_LATITUDE = -85.05113;\nfunction normalizeViewportProps(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      longitude = _ref.longitude,\n      latitude = _ref.latitude,\n      zoom = _ref.zoom,\n      _ref$pitch = _ref.pitch,\n      pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n      _ref$bearing = _ref.bearing,\n      bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;\n\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n\n  var flatViewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];\n  var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];\n  var shiftY = 0;\n\n  if (bottomY - topY < height) {\n    zoom += Math.log2(height / (bottomY - topY));\n    flatViewport = new WebMercatorViewport({\n      width: width,\n      height: height,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom\n    });\n    topY = flatViewport.project([longitude, MAX_LATITUDE])[1];\n    bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];\n  }\n\n  if (topY > 0) {\n    shiftY = topY;\n  } else if (bottomY < height) {\n    shiftY = bottomY - height;\n  }\n\n  if (shiftY) {\n    latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];\n  }\n\n  return {\n    width: width,\n    height: height,\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom,\n    pitch: pitch,\n    bearing: bearing\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\n\n\nvar fly_to_viewport_EPSILON = 0.01;\nvar VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\'];\nvar DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var viewport = {};\n\n  var _getFlyToTransitionPa = getFlyToTransitionParams(startProps, endProps, opts),\n      startZoom = _getFlyToTransitionPa.startZoom,\n      startCenterXY = _getFlyToTransitionPa.startCenterXY,\n      uDelta = _getFlyToTransitionPa.uDelta,\n      w0 = _getFlyToTransitionPa.w0,\n      u1 = _getFlyToTransitionPa.u1,\n      S = _getFlyToTransitionPa.S,\n      rho = _getFlyToTransitionPa.rho,\n      rho2 = _getFlyToTransitionPa.rho2,\n      r0 = _getFlyToTransitionPa.r0;\n\n  if (u1 < fly_to_viewport_EPSILON) {\n    var _iterator = _createForOfIteratorHelper(VIEWPORT_TRANSITION_PROPS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n        var startValue = startProps[key];\n        var endValue = endProps[key];\n        viewport[key] = math_utils_lerp(startValue, endValue, t);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return viewport;\n  }\n\n  var s = t * S;\n  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  var scaleIncrement = 1 / w;\n  var newZoom = startZoom + scaleToZoom(scaleIncrement);\n  var newCenterWorld = vec2_scale([], uDelta, u);\n  vec2_add(newCenterWorld, newCenterWorld, startCenterXY);\n  var newCenter = worldToLngLat(newCenterWorld);\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\nfunction getFlyToDuration(startProps, endProps) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var _opts = opts,\n      screenSpeed = _opts.screenSpeed,\n      speed = _opts.speed,\n      maxDuration = _opts.maxDuration;\n\n  var _getFlyToTransitionPa2 = getFlyToTransitionParams(startProps, endProps, opts),\n      S = _getFlyToTransitionPa2.S,\n      rho = _getFlyToTransitionPa2.rho;\n\n  var length = 1000 * S;\n  var duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var rho = opts.curve;\n  var startZoom = startProps.zoom;\n  var startCenter = [startProps.longitude, startProps.latitude];\n  var startScale = zoomToScale(startZoom);\n  var endZoom = endProps.zoom;\n  var endCenter = [endProps.longitude, endProps.latitude];\n  var scale = zoomToScale(endZoom - startZoom);\n  var startCenterXY = lngLatToWorld(startCenter);\n  var endCenterXY = lngLatToWorld(endCenter);\n  var uDelta = vec2_sub([], endCenterXY, startCenterXY);\n  var w0 = Math.max(startProps.width, startProps.height);\n  var w1 = w0 / scale;\n  var u1 = vec2_length(uDelta) * startScale;\n\n  var _u1 = Math.max(u1, fly_to_viewport_EPSILON);\n\n  var rho2 = rho * rho;\n  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  var S = (r1 - r0) / rho;\n  return {\n    startZoom: startZoom,\n    startCenterXY: startCenterXY,\n    uDelta: uDelta,\n    w0: w0,\n    u1: u1,\n    S: S,\n    rho: rho,\n    rho2: rho2,\n    r0: r0,\n    r1: r1\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/viewport-mercator-project/module.js\n\n\n;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = function () {\n  if (typeof Map !== \'undefined\') {\n    return Map;\n  }\n  /**\r\n   * Returns index in provided array that matches the specified key.\r\n   *\r\n   * @param {Array<Array>} arr\r\n   * @param {*} key\r\n   * @returns {number}\r\n   */\n\n\n  function getIndex(arr, key) {\n    var result = -1;\n    arr.some(function (entry, index) {\n      if (entry[0] === key) {\n        result = index;\n        return true;\n      }\n\n      return false;\n    });\n    return result;\n  }\n\n  return (\n    /** @class */\n    function () {\n      function class_1() {\n        this.__entries__ = [];\n      }\n\n      Object.defineProperty(class_1.prototype, "size", {\n        /**\r\n         * @returns {boolean}\r\n         */\n        get: function get() {\n          return this.__entries__.length;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      /**\r\n       * @param {*} key\r\n       * @returns {*}\r\n       */\n\n      class_1.prototype.get = function (key) {\n        var index = getIndex(this.__entries__, key);\n        var entry = this.__entries__[index];\n        return entry && entry[1];\n      };\n      /**\r\n       * @param {*} key\r\n       * @param {*} value\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.set = function (key, value) {\n        var index = getIndex(this.__entries__, key);\n\n        if (~index) {\n          this.__entries__[index][1] = value;\n        } else {\n          this.__entries__.push([key, value]);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.delete = function (key) {\n        var entries = this.__entries__;\n        var index = getIndex(entries, key);\n\n        if (~index) {\n          entries.splice(index, 1);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.has = function (key) {\n        return !!~getIndex(this.__entries__, key);\n      };\n      /**\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.clear = function () {\n        this.__entries__.splice(0);\n      };\n      /**\r\n       * @param {Function} callback\r\n       * @param {*} [ctx=null]\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.forEach = function (callback, ctx) {\n        if (ctx === void 0) {\n          ctx = null;\n        }\n\n        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n          var entry = _a[_i];\n          callback.call(ctx, entry[1], entry[0]);\n        }\n      };\n\n      return class_1;\n    }()\n  );\n}();\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\n\n\nvar isBrowser = typeof window !== \'undefined\' && typeof document !== \'undefined\' && window.document === document; // Returns global object of a current environment.\n\nvar global$1 = function () {\n  if (typeof __webpack_require__.g !== \'undefined\' && __webpack_require__.g.Math === Math) {\n    return __webpack_require__.g;\n  }\n\n  if (typeof self !== \'undefined\' && self.Math === Math) {\n    return self;\n  }\n\n  if (typeof window !== \'undefined\' && window.Math === Math) {\n    return window;\n  } // eslint-disable-next-line no-new-func\n\n\n  return Function(\'return this\')();\n}();\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests\' identifier.\r\n */\n\n\nvar requestAnimationFrame$1 = function () {\n  if (typeof requestAnimationFrame === \'function\') {\n    // It\'s required to use a bounded function because IE sometimes throws\n    // an "Invalid calling object" error if rAF is invoked without the global\n    // object on the left hand side.\n    return requestAnimationFrame.bind(global$1);\n  }\n\n  return function (callback) {\n    return setTimeout(function () {\n      return callback(Date.now());\n    }, 1000 / 60);\n  };\n}(); // Defines minimum timeout before adding a trailing call.\n\n\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\n\nfunction throttle(callback, delay) {\n  var leadingCall = false,\n      trailingCall = false,\n      lastCallTime = 0;\n  /**\r\n   * Invokes the original callback function and schedules new invocation if\r\n   * the "proxy" was called during current request.\r\n   *\r\n   * @returns {void}\r\n   */\n\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  /**\r\n   * Callback invoked after the specified delay. It will further postpone\r\n   * invocation of the original function delegating it to the\r\n   * requestAnimationFrame.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  /**\r\n   * Schedules invocation of the original function.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function proxy() {\n    var timeStamp = Date.now();\n\n    if (leadingCall) {\n      // Reject immediately following calls.\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      } // Schedule new call to be in invoked when the pending one is resolved.\n      // This is important for "transitions" which never actually start\n      // immediately so there is a chance that we might miss one if change\n      // happens amids the pending invocation.\n\n\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n\n    lastCallTime = timeStamp;\n  }\n\n  return proxy;\n} // Minimum delay before invoking the update of observers.\n\n\nvar REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\n\nvar transitionKeys = [\'top\', \'right\', \'bottom\', \'left\', \'width\', \'height\', \'size\', \'weight\']; // Check if MutationObserver is available.\n\nvar mutationObserverSupported = typeof MutationObserver !== \'undefined\';\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\n\nvar ResizeObserverController =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserverController.\r\n   *\r\n   * @private\r\n   */\n  function ResizeObserverController() {\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.connected_ = false;\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\n\n    this.mutationEventsAdded_ = false;\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\n\n    this.mutationsObserver_ = null;\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\n\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  /**\r\n   * Adds observer to observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be added.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    } // Add listeners if they haven\'t been added yet.\n\n\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  /**\r\n   * Removes observer from observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer); // Remove observer if it\'s present in registry.\n\n    if (~index) {\n      observers.splice(index, 1);\n    } // Remove listeners if controller has no connected observers.\n\n\n    if (!observers.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  /**\r\n   * Invokes the update of observers. It will continue running updates insofar\r\n   * it detects changes.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Updates every observer from observers list and notifies them of queued\r\n   * entries.\r\n   *\r\n   * @private\r\n   * @returns {boolean} Returns "true" if any observer has detected changes in\r\n   *      dimensions of it\'s elements.\r\n   */\n\n\n  ResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n      return observer.gatherActive(), observer.hasActive();\n    }); // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n\n    activeObservers.forEach(function (observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  /**\r\n   * Initializes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n      return;\n    } // Subscription to the "Transitionend" event is used as a workaround for\n    // delayed transitions. This way it\'s possible to capture at least the\n    // final state of an element.\n\n\n    document.addEventListener(\'transitionend\', this.onTransitionEnd_);\n    window.addEventListener(\'resize\', this.refresh);\n\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener(\'DOMSubtreeModified\', this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n  };\n  /**\r\n   * Removes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n\n    document.removeEventListener(\'transitionend\', this.onTransitionEnd_);\n    window.removeEventListener(\'resize\', this.refresh);\n\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener(\'DOMSubtreeModified\', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  /**\r\n   * "Transitionend" event handler.\r\n   *\r\n   * @private\r\n   * @param {TransitionEvent} event\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n    var _b = _a.propertyName,\n        propertyName = _b === void 0 ? \'\' : _b; // Detect whether transition may affect dimensions of an element.\n\n    var isReflowProperty = transitionKeys.some(function (key) {\n      return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Returns instance of the ResizeObserverController.\r\n   *\r\n   * @returns {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n  };\n  /**\r\n   * Holds reference to the controller\'s instance.\r\n   *\r\n   * @private {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.instance_ = null;\n  return ResizeObserverController;\n}();\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\n\n\nvar defineConfigurable = function defineConfigurable(target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n    Object.defineProperty(target, key, {\n      value: props[key],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n\n  return target;\n};\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\n\n\nvar getWindowOf = function getWindowOf(target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the "ownerDocument" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it\'s not possible extract one from\n  // provided element.\n\n  return ownerGlobal || global$1;\n}; // Placeholder of an empty content rectangle.\n\n\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\n\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\n\n\nfunction getBordersSize(styles) {\n  var positions = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n\n  return positions.reduce(function (size, position) {\n    var value = styles[\'border-\' + position + \'-width\'];\n    return size + toFloat(value);\n  }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\n\n\nfunction getPaddings(styles) {\n  var positions = [\'top\', \'right\', \'bottom\', \'left\'];\n  var paddings = {};\n\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles[\'padding-\' + position];\n    paddings[position] = toFloat(value);\n  }\n\n  return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getHTMLElementContentRect(target) {\n  // Client width & height properties can\'t be\n  // used exclusively as they provide rounded values.\n  var clientWidth = target.clientWidth,\n      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and\n  // detached elements. Though elements with width & height properties less\n  // than 0.5 will be discarded as well.\n  //\n  // Without it we would need to implement separate methods for each of\n  // those cases and it\'s not possible to perform a precise and performance\n  // effective test for hidden elements. E.g. even jQuery\'s \':visible\' filter\n  // gives wrong results for elements with width & height less than 0.5.\n\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the\n  // only dimensions available to JS that contain non-rounded values. It could\n  // be possible to utilize the getBoundingClientRect if only it\'s data wasn\'t\n  // affected by CSS transformations let alone paddings, borders and scroll bars.\n\n  var width = toFloat(styles.width),\n      height = toFloat(styles.height); // Width & height include paddings and borders when the \'border-box\' box\n  // model is applied (except for IE).\n\n  if (styles.boxSizing === \'border-box\') {\n    // Following conditions are required to handle Internet Explorer which\n    // doesn\'t include paddings and borders to computed CSS dimensions.\n    //\n    // We can say that if CSS dimensions + paddings are equal to the "client"\n    // properties then it\'s either IE, and thus we don\'t need to subtract\n    // anything, or an element merely doesn\'t have paddings/borders styles.\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, \'left\', \'right\') + horizPad;\n    }\n\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, \'top\', \'bottom\') + vertPad;\n    }\n  } // Following steps can\'t be applied to the document\'s root element as its\n  // client[Width/Height] properties represent viewport area of the window.\n  // Besides, it\'s as well not necessary as the <html> itself neither has\n  // rendered scroll bars nor it can be clipped.\n\n\n  if (!isDocumentElement(target)) {\n    // In some browsers (only in Firefox, actually) CSS width & height\n    // include scroll bars size which can be removed at this step as scroll\n    // bars are the only difference between rounded dimensions + paddings\n    // and "client" properties, though that is not always true in Chrome.\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.\n    // E.g. for an element with content width of 314.2px it sometimes gives\n    // the client width of 315px and for the width of 314.7px it may give\n    // 314px. And it doesn\'t happen all the time. So just ignore this delta\n    // as a non-relevant.\n\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nvar isSVGGraphicsElement = function () {\n  // Some browsers, namely IE and Edge, don\'t have the SVGGraphicsElement\n  // interface.\n  if (typeof SVGGraphicsElement !== \'undefined\') {\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  } // If it\'s so, then check that element is at least an instance of the\n  // SVGElement and that it has the "getBBox" method.\n  // eslint-disable-next-line no-extra-parens\n\n\n  return function (target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \'function\';\n  };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n\n  return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle\'s x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\n\n\nfunction createReadOnlyRect(_a) {\n  var x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n\n  var Constr = typeof DOMRectReadOnly !== \'undefined\' ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype); // Rectangle\'s properties are not writable and non-enumerable.\n\n  defineConfigurable(rect, {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle\'s width.\r\n * @param {number} height - Rectangle\'s height.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction createRectInit(x, y, width, height) {\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n}\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it\'s changes.\r\n */\n\n\nvar ResizeObservation =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObservation.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   */\n  function ResizeObservation(target) {\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastWidth = 0;\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.broadcastHeight = 0;\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\n\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  /**\r\n   * Updates content rectangle and tells whether it\'s width or height properties\r\n   * have changed since the last broadcast.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  /**\r\n   * Updates \'broadcastWidth\' and \'broadcastHeight\' properties with a data\r\n   * from the corresponding properties of the last observed content rectangle.\r\n   *\r\n   * @returns {DOMRectInit} Last observed content rectangle.\r\n   */\n\n\n  ResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n\n  return ResizeObservation;\n}();\n\nvar ResizeObserverEntry =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObserverEntry.\r\n   *\r\n   * @param {Element} target - Element that is being observed.\r\n   * @param {DOMRectInit} rectInit - Data of the element\'s content rectangle.\r\n   */\n  function ResizeObserverEntry(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they\'d require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don\'t support this type of collections.\n\n    defineConfigurable(this, {\n      target: target,\n      contentRect: contentRect\n    });\n  }\n\n  return ResizeObserverEntry;\n}();\n\nvar ResizeObserverSPI =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n   *      when one of the observed elements changes it\'s content dimensions.\r\n   * @param {ResizeObserverController} controller - Controller instance which\r\n   *      is responsible for the updates of observer.\r\n   * @param {ResizeObserver} callbackCtx - Reference to the public\r\n   *      ResizeObserver instance which will be passed to callback function.\r\n   */\n  function ResizeObserverSPI(callback, controller, callbackCtx) {\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\n    this.activeObservations_ = [];\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\n\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== \'function\') {\n      throw new TypeError(\'The callback provided as parameter 1 is not a function.\');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  /**\r\n   * Starts observing provided element.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    } // Do nothing if current environment doesn\'t have the Element interface.\n\n\n    if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError(\'parameter 1 is not of type "Element".\');\n    }\n\n    var observations = this.observations_; // Do nothing if element is already being observed.\n\n    if (observations.has(target)) {\n      return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this); // Force the update of observations.\n\n    this.controller_.refresh();\n  };\n  /**\r\n   * Stops observing provided element.\r\n   *\r\n   * @param {Element} target - Element to stop observing.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    } // Do nothing if current environment doesn\'t have the Element interface.\n\n\n    if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError(\'parameter 1 is not of type "Element".\');\n    }\n\n    var observations = this.observations_; // Do nothing if element is not being observed.\n\n    if (!observations.has(target)) {\n      return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  /**\r\n   * Stops observing all elements.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  /**\r\n   * Collects observation instances the associated element of which has changed\r\n   * it\'s content rectangle.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.gatherActive = function () {\n    var _this = this;\n\n    this.clearActive();\n    this.observations_.forEach(function (observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  /**\r\n   * Invokes initial callback function with a list of ResizeObserverEntry\r\n   * instances collected from active resize observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn\'t have active observations.\n    if (!this.hasActive()) {\n      return;\n    }\n\n    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.\n\n    var entries = this.activeObservations_.map(function (observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  /**\r\n   * Clears the collection of active observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n  };\n  /**\r\n   * Tells whether observer has active observations.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n  };\n\n  return ResizeObserverSPI;\n}(); // Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can\'t be fully polyfilled anyway.\n\n\nvar observers = typeof WeakMap !== \'undefined\' ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\n\nvar ResizeObserver =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n   *      dimensions of the observed elements change.\r\n   */\n  function ResizeObserver(callback) {\n    if (!(this instanceof ResizeObserver)) {\n      throw new TypeError(\'Cannot call a class as a function.\');\n    }\n\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n\n  return ResizeObserver;\n}(); // Expose public methods of ResizeObserver.\n\n\n[\'observe\', \'unobserve\', \'disconnect\'].forEach(function (method) {\n  ResizeObserver.prototype[method] = function () {\n    var _a;\n\n    return (_a = observers.get(this))[method].apply(_a, arguments);\n  };\n});\n\nvar index = function () {\n  // Export existing implementation if available.\n  if (typeof global$1.ResizeObserver !== \'undefined\') {\n    return global$1.ResizeObserver;\n  }\n\n  return ResizeObserver;\n}();\n\n/* harmony default export */ var ResizeObserver_es = (index);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/globals.js\nvar window_ = typeof window !== \'undefined\' ? window : __webpack_require__.g;\nvar global_ = typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : window;\nvar document_ = typeof document !== \'undefined\' ? document : {};\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/style-utils.js\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction style_utils_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = style_utils_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction style_utils_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return style_utils_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return style_utils_arrayLikeToArray(o, minLen);\n}\n\nfunction style_utils_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar refProps = [\'type\', \'source\', \'source-layer\', \'minzoom\', \'maxzoom\', \'filter\', \'layout\'];\nfunction normalizeStyle(style) {\n  if (!style) {\n    return null;\n  }\n\n  if (typeof style === \'string\') {\n    return style;\n  }\n\n  if (style.toJS) {\n    style = style.toJS();\n  }\n\n  var layerIndex = {};\n\n  var _iterator = style_utils_createForOfIteratorHelper(style.layers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      layerIndex[layer.id] = layer;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var layers = style.layers.map(function (layer) {\n    var layerRef = layerIndex[layer.ref];\n    var normalizedLayer = null;\n\n    if (\'interactive\' in layer) {\n      normalizedLayer = _objectSpread({}, layer);\n      delete normalizedLayer.interactive;\n    }\n\n    if (layerRef) {\n      normalizedLayer = normalizedLayer || _objectSpread({}, layer);\n      delete normalizedLayer.ref;\n\n      var _iterator2 = style_utils_createForOfIteratorHelper(refProps),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n\n          if (propName in layerRef) {\n            normalizedLayer[propName] = layerRef[propName];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    return normalizedLayer || layer;\n  });\n  return _objectSpread(_objectSpread({}, style), {}, {\n    layers: layers\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\n\n\n\n\n\n\n\nfunction noop() {}\n\nfunction defaultOnError(event) {\n  if (event) {\n    console.error(event.error);\n  }\n}\n\nvar propTypes = {\n  container: prop_types.object,\n  gl: prop_types.object,\n  mapboxApiAccessToken: prop_types.string,\n  mapboxApiUrl: prop_types.string,\n  attributionControl: prop_types.bool,\n  preserveDrawingBuffer: prop_types.bool,\n  reuseMaps: prop_types.bool,\n  transformRequest: prop_types.func,\n  mapOptions: prop_types.object,\n  mapStyle: prop_types.oneOfType([prop_types.string, prop_types.object]),\n  preventStyleDiffing: prop_types.bool,\n  visible: prop_types.bool,\n  asyncRender: prop_types.bool,\n  onLoad: prop_types.func,\n  onError: prop_types.func,\n  width: prop_types.number,\n  height: prop_types.number,\n  viewState: prop_types.object,\n  longitude: prop_types.number,\n  latitude: prop_types.number,\n  zoom: prop_types.number,\n  bearing: prop_types.number,\n  pitch: prop_types.number,\n  altitude: prop_types.number\n};\nvar defaultProps = {\n  container: document_.body,\n  mapboxApiAccessToken: getAccessToken(),\n  mapboxApiUrl: \'https://api.mapbox.com\',\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  reuseMaps: false,\n  mapOptions: {},\n  mapStyle: \'mapbox://styles/mapbox/light-v8\',\n  preventStyleDiffing: false,\n  visible: true,\n  asyncRender: false,\n  onLoad: noop,\n  onError: defaultOnError,\n  width: 0,\n  height: 0,\n  longitude: 0,\n  latitude: 0,\n  zoom: 0,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5\n};\nfunction getAccessToken() {\n  var accessToken = null;\n\n  if (typeof window !== \'undefined\' && window.location) {\n    var match = window.location.search.match(/access_token=([^&\\/]*)/);\n    accessToken = match && match[1];\n  }\n\n  if (!accessToken && typeof process !== \'undefined\') {\n    accessToken = accessToken || ({}).MapboxAccessToken || ({}).REACT_APP_MAPBOX_ACCESS_TOKEN;\n  }\n\n  return accessToken || \'no-token\';\n}\n\nfunction checkPropTypes(props) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \'component\';\n\n  if (props.debug) {\n    prop_types.checkPropTypes(propTypes, props, \'prop\', component);\n  }\n}\n\nvar Mapbox = function () {\n  function Mapbox(props) {\n    var _this = this;\n\n    (0,classCallCheck/* default */.Z)(this, Mapbox);\n\n    (0,defineProperty/* default */.Z)(this, "props", defaultProps);\n\n    (0,defineProperty/* default */.Z)(this, "width", 0);\n\n    (0,defineProperty/* default */.Z)(this, "height", 0);\n\n    (0,defineProperty/* default */.Z)(this, "_fireLoadEvent", function () {\n      _this.props.onLoad({\n        type: \'load\',\n        target: _this._map\n      });\n    });\n\n    if (!props.mapboxgl) {\n      throw new Error(\'Mapbox not available\');\n    }\n\n    this.mapboxgl = props.mapboxgl;\n\n    if (!Mapbox.initialized) {\n      Mapbox.initialized = true;\n\n      this._checkStyleSheet(this.mapboxgl.version);\n    }\n\n    this._initialize(props);\n  }\n\n  (0,createClass/* default */.Z)(Mapbox, [{\n    key: "finalize",\n    value: function finalize() {\n      this._destroy();\n\n      return this;\n    }\n  }, {\n    key: "setProps",\n    value: function setProps(props) {\n      this._update(this.props, props);\n\n      return this;\n    }\n  }, {\n    key: "redraw",\n    value: function redraw() {\n      var map = this._map;\n\n      if (map.style) {\n        if (map._frame) {\n          map._frame.cancel();\n\n          map._frame = null;\n        }\n\n        map._render();\n      }\n    }\n  }, {\n    key: "getMap",\n    value: function getMap() {\n      return this._map;\n    }\n  }, {\n    key: "_reuse",\n    value: function _reuse(props) {\n      this._map = Mapbox.savedMap;\n\n      var oldContainer = this._map.getContainer();\n\n      var newContainer = props.container;\n      newContainer.classList.add(\'mapboxgl-map\');\n\n      while (oldContainer.childNodes.length > 0) {\n        newContainer.appendChild(oldContainer.childNodes[0]);\n      }\n\n      this._map._container = newContainer;\n      Mapbox.savedMap = null;\n\n      if (props.mapStyle) {\n        this._map.setStyle(normalizeStyle(props.mapStyle), {\n          diff: false\n        });\n      }\n\n      if (this._map.isStyleLoaded()) {\n        this._fireLoadEvent();\n      } else {\n        this._map.once(\'styledata\', this._fireLoadEvent);\n      }\n    }\n  }, {\n    key: "_create",\n    value: function _create(props) {\n      if (props.reuseMaps && Mapbox.savedMap) {\n        this._reuse(props);\n      } else {\n        if (props.gl) {\n          var getContext = HTMLCanvasElement.prototype.getContext;\n\n          HTMLCanvasElement.prototype.getContext = function () {\n            HTMLCanvasElement.prototype.getContext = getContext;\n            return props.gl;\n          };\n        }\n\n        var mapOptions = {\n          container: props.container,\n          center: [0, 0],\n          zoom: 8,\n          pitch: 0,\n          bearing: 0,\n          maxZoom: 24,\n          style: normalizeStyle(props.mapStyle),\n          interactive: false,\n          trackResize: false,\n          attributionControl: props.attributionControl,\n          preserveDrawingBuffer: props.preserveDrawingBuffer\n        };\n\n        if (props.transformRequest) {\n          mapOptions.transformRequest = props.transformRequest;\n        }\n\n        this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));\n\n        this._map.once(\'load\', props.onLoad);\n\n        this._map.on(\'error\', props.onError);\n      }\n\n      return this;\n    }\n  }, {\n    key: "_destroy",\n    value: function _destroy() {\n      if (!this._map) {\n        return;\n      }\n\n      if (!Mapbox.savedMap) {\n        Mapbox.savedMap = this._map;\n\n        this._map.off(\'load\', this.props.onLoad);\n\n        this._map.off(\'error\', this.props.onError);\n\n        this._map.off(\'styledata\', this._fireLoadEvent);\n      } else {\n        this._map.remove();\n      }\n\n      this._map = null;\n    }\n  }, {\n    key: "_initialize",\n    value: function _initialize(props) {\n      var _this2 = this;\n\n      props = Object.assign({}, defaultProps, props);\n      checkPropTypes(props, \'Mapbox\');\n      this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps.mapboxApiAccessToken;\n      this.mapboxgl.baseApiUrl = props.mapboxApiUrl;\n\n      this._create(props);\n\n      var _props = props,\n          container = _props.container;\n      Object.defineProperty(container, \'offsetWidth\', {\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, \'clientWidth\', {\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, \'offsetHeight\', {\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      Object.defineProperty(container, \'clientHeight\', {\n        get: function get() {\n          return _this2.height;\n        }\n      });\n\n      var canvas = this._map.getCanvas();\n\n      if (canvas) {\n        canvas.style.outline = \'none\';\n      }\n\n      this._updateMapViewport({}, props);\n\n      this._updateMapSize({}, props);\n\n      this.props = props;\n    }\n  }, {\n    key: "_update",\n    value: function _update(oldProps, newProps) {\n      if (!this._map) {\n        return;\n      }\n\n      newProps = Object.assign({}, this.props, newProps);\n      checkPropTypes(newProps, \'Mapbox\');\n\n      var viewportChanged = this._updateMapViewport(oldProps, newProps);\n\n      var sizeChanged = this._updateMapSize(oldProps, newProps);\n\n      this._updateMapStyle(oldProps, newProps);\n\n      if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {\n        this.redraw();\n      }\n\n      this.props = newProps;\n    }\n  }, {\n    key: "_updateMapStyle",\n    value: function _updateMapStyle(oldProps, newProps) {\n      var styleChanged = oldProps.mapStyle !== newProps.mapStyle;\n\n      if (styleChanged) {\n        this._map.setStyle(normalizeStyle(newProps.mapStyle), {\n          diff: !newProps.preventStyleDiffing\n        });\n      }\n    }\n  }, {\n    key: "_updateMapSize",\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n\n      if (sizeChanged) {\n        this.width = newProps.width;\n        this.height = newProps.height;\n\n        this._map.resize();\n      }\n\n      return sizeChanged;\n    }\n  }, {\n    key: "_updateMapViewport",\n    value: function _updateMapViewport(oldProps, newProps) {\n      var oldViewState = this._getViewState(oldProps);\n\n      var newViewState = this._getViewState(newProps);\n\n      var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;\n\n      if (viewportChanged) {\n        this._map.jumpTo(this._viewStateToMapboxProps(newViewState));\n\n        if (newViewState.altitude !== oldViewState.altitude) {\n          this._map.transform.altitude = newViewState.altitude;\n        }\n      }\n\n      return viewportChanged;\n    }\n  }, {\n    key: "_getViewState",\n    value: function _getViewState(props) {\n      var _ref = props.viewState || props,\n          longitude = _ref.longitude,\n          latitude = _ref.latitude,\n          zoom = _ref.zoom,\n          _ref$pitch = _ref.pitch,\n          pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n          _ref$bearing = _ref.bearing,\n          bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n          _ref$altitude = _ref.altitude,\n          altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;\n\n      return {\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom,\n        pitch: pitch,\n        bearing: bearing,\n        altitude: altitude\n      };\n    }\n  }, {\n    key: "_checkStyleSheet",\n    value: function _checkStyleSheet() {\n      var mapboxVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'0.47.0\';\n\n      if (typeof document_ === \'undefined\') {\n        return;\n      }\n\n      try {\n        var testElement = document_.createElement(\'div\');\n        testElement.className = \'mapboxgl-map\';\n        testElement.style.display = \'none\';\n        document_.body.appendChild(testElement);\n        var isCssLoaded = window.getComputedStyle(testElement).position !== \'static\';\n\n        if (!isCssLoaded) {\n          var link = document_.createElement(\'link\');\n          link.setAttribute(\'rel\', \'stylesheet\');\n          link.setAttribute(\'type\', \'text/css\');\n          link.setAttribute(\'href\', "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(mapboxVersion, "/mapbox-gl.css"));\n          document_.head.appendChild(link);\n        }\n      } catch (error) {}\n    }\n  }, {\n    key: "_viewStateToMapboxProps",\n    value: function _viewStateToMapboxProps(viewState) {\n      return {\n        center: [viewState.longitude, viewState.latitude],\n        zoom: viewState.zoom,\n        bearing: viewState.bearing,\n        pitch: viewState.pitch\n      };\n    }\n  }]);\n\n  return Mapbox;\n}();\n\n(0,defineProperty/* default */.Z)(Mapbox, "initialized", false);\n\n(0,defineProperty/* default */.Z)(Mapbox, "propTypes", propTypes);\n\n(0,defineProperty/* default */.Z)(Mapbox, "defaultProps", defaultProps);\n\n(0,defineProperty/* default */.Z)(Mapbox, "savedMap", null);\n\n\n// EXTERNAL MODULE: ./node_modules/maplibre-gl/dist/maplibre-gl.js\nvar maplibre_gl = __webpack_require__(9910);\nvar maplibre_gl_default = /*#__PURE__*/__webpack_require__.n(maplibre_gl);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/mapboxgl.browser.js\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/math-utils.js\nvar math_utils_EPSILON = 1e-7;\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nfunction math_utils_equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n      if (!math_utils_equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return Math.abs(a - b) <= math_utils_EPSILON;\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction utils_math_utils_lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map(function (ai, i) {\n      return utils_math_utils_lerp(ai, b[i], t);\n    });\n  }\n\n  return t * b + (1 - t) * a;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/assert.js\nfunction utils_assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'react-map-gl: assertion failed.\');\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-state.js\n\n\n\n\n\nfunction map_state_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_state_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_state_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_state_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 24,\n  minPitch: 0,\n  maxPitch: 85\n};\nvar DEFAULT_STATE = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\nvar PITCH_MOUSE_THRESHOLD = 5;\nvar PITCH_ACCEL = 1.2;\n\nvar MapState = function () {\n  function MapState(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,\n        _ref$maxZoom = _ref.maxZoom,\n        maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,\n        _ref$minZoom = _ref.minZoom,\n        minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,\n        _ref$maxPitch = _ref.maxPitch,\n        maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,\n        _ref$minPitch = _ref.minPitch,\n        minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,\n        transitionDuration = _ref.transitionDuration,\n        transitionEasing = _ref.transitionEasing,\n        transitionInterpolator = _ref.transitionInterpolator,\n        transitionInterruption = _ref.transitionInterruption,\n        startPanLngLat = _ref.startPanLngLat,\n        startZoomLngLat = _ref.startZoomLngLat,\n        startRotatePos = _ref.startRotatePos,\n        startBearing = _ref.startBearing,\n        startPitch = _ref.startPitch,\n        startZoom = _ref.startZoom;\n\n    (0,classCallCheck/* default */.Z)(this, MapState);\n\n    utils_assert_assert(Number.isFinite(width), \'`width` must be supplied\');\n    utils_assert_assert(Number.isFinite(height), \'`height` must be supplied\');\n    utils_assert_assert(Number.isFinite(longitude), \'`longitude` must be supplied\');\n    utils_assert_assert(Number.isFinite(latitude), \'`latitude` must be supplied\');\n    utils_assert_assert(Number.isFinite(zoom), \'`zoom` must be supplied\');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: bearing,\n      pitch: pitch,\n      altitude: altitude,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      maxPitch: maxPitch,\n      minPitch: minPitch,\n      transitionDuration: transitionDuration,\n      transitionEasing: transitionEasing,\n      transitionInterpolator: transitionInterpolator,\n      transitionInterruption: transitionInterruption\n    });\n    this._state = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startRotatePos: startRotatePos,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n  }\n\n  (0,createClass/* default */.Z)(MapState, [{\n    key: "getViewportProps",\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: "getState",\n    value: function getState() {\n      return this._state;\n    }\n  }, {\n    key: "panStart",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedMapState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n  }, {\n    key: "pan",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n          startPos = _ref3.startPos;\n\n      var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);\n\n      if (!startPanLngLat) {\n        return this;\n      }\n\n      var _this$_calculateNewLn = this._calculateNewLngLat({\n        startPanLngLat: startPanLngLat,\n        pos: pos\n      }),\n          _this$_calculateNewLn2 = slicedToArray_slicedToArray(_this$_calculateNewLn, 2),\n          longitude = _this$_calculateNewLn2[0],\n          latitude = _this$_calculateNewLn2[1];\n\n      return this._getUpdatedMapState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: "panEnd",\n    value: function panEnd() {\n      return this._getUpdatedMapState({\n        startPanLngLat: null\n      });\n    }\n  }, {\n    key: "rotateStart",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedMapState({\n        startRotatePos: pos,\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n  }, {\n    key: "rotate",\n    value: function rotate(_ref5) {\n      var pos = _ref5.pos,\n          _ref5$deltaAngleX = _ref5.deltaAngleX,\n          deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX,\n          _ref5$deltaAngleY = _ref5.deltaAngleY,\n          deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;\n      var _this$_state = this._state,\n          startRotatePos = _this$_state.startRotatePos,\n          startBearing = _this$_state.startBearing,\n          startPitch = _this$_state.startPitch;\n\n      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {\n        return this;\n      }\n\n      var newRotation;\n\n      if (pos) {\n        newRotation = this._calculateNewPitchAndBearing(map_state_objectSpread(map_state_objectSpread({}, this._getRotationParams(pos, startRotatePos)), {}, {\n          startBearing: startBearing,\n          startPitch: startPitch\n        }));\n      } else {\n        newRotation = {\n          bearing: startBearing + deltaAngleX,\n          pitch: startPitch + deltaAngleY\n        };\n      }\n\n      return this._getUpdatedMapState(newRotation);\n    }\n  }, {\n    key: "rotateEnd",\n    value: function rotateEnd() {\n      return this._getUpdatedMapState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n  }, {\n    key: "zoomStart",\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedMapState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n  }, {\n    key: "zoom",\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n          startPos = _ref7.startPos,\n          scale = _ref7.scale;\n      utils_assert_assert(scale > 0, \'`scale` must be a positive number\');\n      var _this$_state2 = this._state,\n          startZoom = _this$_state2.startZoom,\n          startZoomLngLat = _this$_state2.startZoomLngLat;\n\n      if (!Number.isFinite(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n      }\n\n      utils_assert_assert(startZoomLngLat, \'`startZoomLngLat` prop is required \' + \'for zoom behavior to calculate where to position the map.\');\n\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom || 0\n      });\n\n      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {\n        zoom: zoom\n      }));\n\n      var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({\n        lngLat: startZoomLngLat,\n        pos: pos\n      }),\n          _zoomedViewport$getMa2 = slicedToArray_slicedToArray(_zoomedViewport$getMa, 2),\n          longitude = _zoomedViewport$getMa2[0],\n          latitude = _zoomedViewport$getMa2[1];\n\n      return this._getUpdatedMapState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: "zoomEnd",\n    value: function zoomEnd() {\n      return this._getUpdatedMapState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n  }, {\n    key: "_getUpdatedMapState",\n    value: function _getUpdatedMapState(newProps) {\n      return new MapState(Object.assign({}, this._viewportProps, this._state, newProps));\n    }\n  }, {\n    key: "_applyConstraints",\n    value: function _applyConstraints(props) {\n      var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          zoom = props.zoom;\n      props.zoom = clamp(zoom, minZoom, maxZoom);\n      var maxPitch = props.maxPitch,\n          minPitch = props.minPitch,\n          pitch = props.pitch;\n      props.pitch = clamp(pitch, minPitch, maxPitch);\n      Object.assign(props, normalizeViewportProps(props));\n      return props;\n    }\n  }, {\n    key: "_unproject",\n    value: function _unproject(pos) {\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos);\n    }\n  }, {\n    key: "_calculateNewLngLat",\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n          pos = _ref8.pos;\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return viewport.getMapCenterByLngLatPosition({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: "_calculateNewZoom",\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n          startZoom = _ref9.startZoom;\n      var _this$_viewportProps = this._viewportProps,\n          maxZoom = _this$_viewportProps.maxZoom,\n          minZoom = _this$_viewportProps.minZoom;\n      var zoom = startZoom + Math.log2(scale);\n      return clamp(zoom, minZoom, maxZoom);\n    }\n  }, {\n    key: "_calculateNewPitchAndBearing",\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n          deltaScaleY = _ref10.deltaScaleY,\n          startBearing = _ref10.startBearing,\n          startPitch = _ref10.startPitch;\n      deltaScaleY = clamp(deltaScaleY, -1, 1);\n      var _this$_viewportProps2 = this._viewportProps,\n          minPitch = _this$_viewportProps2.minPitch,\n          maxPitch = _this$_viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n\n      if (deltaScaleY > 0) {\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }, {\n    key: "_getRotationParams",\n    value: function _getRotationParams(pos, startPos) {\n      var deltaX = pos[0] - startPos[0];\n      var deltaY = pos[1] - startPos[1];\n      var centerY = pos[1];\n      var startY = startPos[1];\n      var _this$_viewportProps3 = this._viewportProps,\n          width = _this$_viewportProps3.width,\n          height = _this$_viewportProps3.height;\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      return {\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      };\n    }\n  }]);\n\n  return MapState;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-constraints.js\n\n\nfunction decapitalize(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\n\nfunction checkVisibilityConstraints(props) {\n  var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAPBOX_LIMITS;\n\n  for (var constraintName in constraints) {\n    var type = constraintName.slice(0, 3);\n    var propName = decapitalize(constraintName.slice(3));\n\n    if (type === \'min\' && props[propName] < constraints[constraintName]) {\n      return false;\n    }\n\n    if (type === \'max\' && props[propName] > constraints[constraintName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/map-context.js\n\n\n\nfunction map_context_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_context_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_context_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_context_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar map_context_MapContext = (0,react.createContext)({\n  viewport: null,\n  map: null,\n  container: null,\n  onViewportChange: null,\n  onViewStateChange: null,\n  eventManager: null\n});\nvar MapContextProvider = map_context_MapContext.Provider;\n\nfunction WrappedProvider(_ref) {\n  var value = _ref.value,\n      children = _ref.children;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      map = _useState2[0],\n      setMap = _useState2[1];\n\n  var context = (0,react.useContext)(map_context_MapContext);\n  value = map_context_objectSpread(map_context_objectSpread({\n    setMap: setMap\n  }, context), {}, {\n    map: context && context.map || map\n  }, value);\n  return react.createElement(MapContextProvider, {\n    value: value\n  }, children);\n}\n\nmap_context_MapContext.Provider = WrappedProvider;\n/* harmony default export */ var map_context = (map_context_MapContext);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\n\nvar useIsomorphicLayoutEffect = typeof window !== \'undefined\' ? react.useLayoutEffect : react.useEffect;\n/* harmony default export */ var use_isomorphic_layout_effect = (useIsomorphicLayoutEffect);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/terrain.js\nfunction getTerrainElevation(map, _ref) {\n  var longitude = _ref.longitude,\n      latitude = _ref.latitude;\n\n  if (map && map.queryTerrainElevation) {\n    return map.queryTerrainElevation([longitude, latitude]) || 0;\n  }\n\n  return 0;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/static-map.js\n\n\n\nfunction static_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction static_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      static_map_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      static_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvar TOKEN_DOC_URL = \'https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens\';\nvar NO_TOKEN_WARNING = \'A valid API access token is required to use Mapbox data\';\n\nfunction static_map_noop() {}\n\nfunction getViewport(_ref) {\n  var map = _ref.map,\n      props = _ref.props,\n      width = _ref.width,\n      height = _ref.height;\n\n  var viewportProps = static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), props.viewState), {}, {\n    width: width,\n    height: height\n  });\n\n  viewportProps.position = [0, 0, getTerrainElevation(map, viewportProps)];\n  return new WebMercatorViewport(viewportProps);\n}\nvar UNAUTHORIZED_ERROR_CODE = 401;\nvar CONTAINER_STYLE = {\n  position: \'absolute\',\n  width: \'100%\',\n  height: \'100%\',\n  overflow: \'hidden\'\n};\nvar static_map_defaultProps = Object.assign({}, Mapbox.defaultProps, {\n  disableTokenWarning: false,\n  visible: true,\n  onResize: static_map_noop,\n  className: \'\',\n  style: null,\n  visibilityConstraints: MAPBOX_LIMITS\n});\n\nfunction NoTokenWarning() {\n  var style = {\n    position: \'absolute\',\n    left: 0,\n    top: 0\n  };\n  return react.createElement("div", {\n    key: "warning",\n    id: "no-token-warning",\n    style: style\n  }, react.createElement("h3", {\n    key: "header"\n  }, NO_TOKEN_WARNING), react.createElement("div", {\n    key: "text"\n  }, "For information on setting up your basemap, read"), react.createElement("a", {\n    key: "link",\n    href: TOKEN_DOC_URL\n  }, "Note on Map Tokens"));\n}\n\nfunction getRefHandles(mapboxRef) {\n  return {\n    getMap: function getMap() {\n      return mapboxRef.current && mapboxRef.current.getMap();\n    },\n    queryRenderedFeatures: function queryRenderedFeatures(geometry) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var map = mapboxRef.current && mapboxRef.current.getMap();\n      return map && map.queryRenderedFeatures(geometry, options);\n    }\n  };\n}\n\nvar StaticMap = (0,react.forwardRef)(function (props, ref) {\n  var _useState = (0,react.useState)(true),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      accessTokenValid = _useState2[0],\n      setTokenState = _useState2[1];\n\n  var _useState3 = (0,react.useState)({\n    width: 0,\n    height: 0\n  }),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var mapboxRef = (0,react.useRef)(null);\n  var mapDivRef = (0,react.useRef)(null);\n  var containerRef = (0,react.useRef)(null);\n  var overlayRef = (0,react.useRef)(null);\n  var context = (0,react.useContext)(map_context);\n  use_isomorphic_layout_effect(function () {\n    if (!StaticMap.supported()) {\n      return undefined;\n    }\n\n    var mapbox = new Mapbox(static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), size), {}, {\n      mapboxgl: (maplibre_gl_default()),\n      container: mapDivRef.current,\n      onError: function onError(evt) {\n        var statusCode = evt.error && evt.error.status || evt.status;\n\n        if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {\n          console.error(NO_TOKEN_WARNING);\n          setTokenState(false);\n        }\n\n        props.onError(evt);\n      }\n    }));\n    mapboxRef.current = mapbox;\n\n    if (context && context.setMap) {\n      context.setMap(mapbox.getMap());\n    }\n\n    var resizeObserver = new ResizeObserver_es(function (entries) {\n      if (entries[0].contentRect) {\n        var _entries$0$contentRec = entries[0].contentRect,\n            _width = _entries$0$contentRec.width,\n            _height = _entries$0$contentRec.height;\n        setSize({\n          width: _width,\n          height: _height\n        });\n        props.onResize({\n          width: _width,\n          height: _height\n        });\n      }\n    });\n    resizeObserver.observe(containerRef.current);\n    return function () {\n      mapbox.finalize();\n      mapboxRef.current = null;\n      resizeObserver.disconnect();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (mapboxRef.current) {\n      mapboxRef.current.setProps(static_map_objectSpread(static_map_objectSpread({}, props), size));\n    }\n  });\n  var map = mapboxRef.current && mapboxRef.current.getMap();\n  (0,react.useImperativeHandle)(ref, function () {\n    return getRefHandles(mapboxRef);\n  }, []);\n  var preventScroll = (0,react.useCallback)(function (_ref2) {\n    var target = _ref2.target;\n\n    if (target === overlayRef.current) {\n      target.scrollTo(0, 0);\n    }\n  }, []);\n  var overlays = map && react.createElement(MapContextProvider, {\n    value: static_map_objectSpread(static_map_objectSpread({}, context), {}, {\n      viewport: context.viewport || getViewport(static_map_objectSpread({\n        map: map,\n        props: props\n      }, size)),\n      map: map,\n      container: context.container || containerRef.current\n    })\n  }, react.createElement("div", {\n    key: "map-overlays",\n    className: "overlays",\n    ref: overlayRef,\n    style: CONTAINER_STYLE,\n    onScroll: preventScroll\n  }, props.children));\n  var className = props.className,\n      width = props.width,\n      height = props.height,\n      style = props.style,\n      visibilityConstraints = props.visibilityConstraints;\n  var mapContainerStyle = Object.assign({\n    position: \'relative\'\n  }, style, {\n    width: width,\n    height: height\n  });\n  var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);\n  var mapStyle = Object.assign({}, CONTAINER_STYLE, {\n    visibility: visible ? \'inherit\' : \'hidden\'\n  });\n  return react.createElement("div", {\n    key: "map-container",\n    ref: containerRef,\n    style: mapContainerStyle\n  }, react.createElement("div", {\n    key: "map-mapbox",\n    ref: mapDivRef,\n    style: mapStyle,\n    className: className\n  }), overlays, !accessTokenValid && !props.disableTokenWarning && react.createElement(NoTokenWarning, null));\n});\n\nStaticMap.supported = function () {\n  return (maplibre_gl_default()) && maplibre_gl_default().supported();\n};\n\nStaticMap.defaultProps = static_map_defaultProps;\n/* harmony default export */ var static_map = (StaticMap);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/transition-interpolator.js\n\n\n\n\nfunction transition_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = transition_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction transition_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return transition_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transition_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction transition_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\n\n\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    (0,classCallCheck/* default */.Z)(this, TransitionInterpolator);\n\n    (0,defineProperty/* default */.Z)(this, "propNames", []);\n  }\n\n  (0,createClass/* default */.Z)(TransitionInterpolator, [{\n    key: "arePropsEqual",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iterator = transition_interpolator_createForOfIteratorHelper(this.propNames || []),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (!math_utils_equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      return {\n        start: startProps,\n        end: endProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      utils_assert_assert(false, \'interpolateProps is not implemented\');\n    }\n  }, {\n    key: "getDuration",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }]);\n\n  return TransitionInterpolator;\n}();\n\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nvar assertThisInitialized = __webpack_require__(3349);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\nvar inherits = __webpack_require__(379);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\nvar possibleConstructorReturn = __webpack_require__(6070);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nvar getPrototypeOf = __webpack_require__(7608);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/transition-utils.js\nvar WRAPPED_ANGULAR_PROPS = {\n  longitude: 1,\n  bearing: 1\n};\nfunction transition_utils_mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction isValid(prop) {\n  return Number.isFinite(prop) || Array.isArray(prop);\n}\n\nfunction isWrappedAngularProp(propName) {\n  return propName in WRAPPED_ANGULAR_PROPS;\n}\n\nfunction getEndValueByShortestPath(propName, startValue, endValue) {\n  if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {\n    endValue = endValue < 0 ? endValue + 360 : endValue - 360;\n  }\n\n  return endValue;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator.js\n\n\n\n\n\n\n\n\nfunction viewport_fly_to_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = viewport_fly_to_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction viewport_fly_to_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction viewport_fly_to_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0,getPrototypeOf/* default */.Z)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0,getPrototypeOf/* default */.Z)(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0,possibleConstructorReturn/* default */.Z)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\n\nvar viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\', \'bearing\', \'pitch\'];\nvar REQUIRED_PROPS = [\'latitude\', \'longitude\', \'zoom\', \'width\', \'height\'];\nvar LINEARLY_INTERPOLATED_PROPS = [\'bearing\', \'pitch\'];\nvar viewport_fly_to_interpolator_DEFAULT_OPTS = {\n  speed: 1.2,\n  curve: 1.414\n};\n\nvar ViewportFlyToInterpolator = function (_TransitionInterpolat) {\n  (0,inherits/* default */.Z)(ViewportFlyToInterpolator, _TransitionInterpolat);\n\n  var _super = _createSuper(ViewportFlyToInterpolator);\n\n  function ViewportFlyToInterpolator() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    (0,classCallCheck/* default */.Z)(this, ViewportFlyToInterpolator);\n\n    _this = _super.call(this);\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "propNames", viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS);\n\n    _this.props = Object.assign({}, viewport_fly_to_interpolator_DEFAULT_OPTS, props);\n    return _this;\n  }\n\n  (0,createClass/* default */.Z)(ViewportFlyToInterpolator, [{\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n\n      var _iterator = viewport_fly_to_interpolator_createForOfIteratorHelper(REQUIRED_PROPS),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _key = _step2.value;\n\n          var _startValue = startProps[_key] || 0;\n\n          var _endValue = endProps[_key] || 0;\n\n          startViewportProps[_key] = _startValue;\n          endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = flyToViewport(startProps, endProps, t, this.props);\n\n      var _iterator3 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return viewport;\n    }\n  }, {\n    key: "getDuration",\n    value: function getDuration(startProps, endProps) {\n      var transitionDuration = endProps.transitionDuration;\n\n      if (transitionDuration === \'auto\') {\n        transitionDuration = getFlyToDuration(startProps, endProps, this.props);\n      }\n\n      return transitionDuration;\n    }\n  }]);\n\n  return ViewportFlyToInterpolator;\n}(TransitionInterpolator);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/linear-interpolator.js\n\n\n\n\n\n\n\nfunction linear_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = linear_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction linear_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return linear_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return linear_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction linear_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction linear_interpolator_createSuper(Derived) {\n  var hasNativeReflectConstruct = linear_interpolator_isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0,getPrototypeOf/* default */.Z)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0,getPrototypeOf/* default */.Z)(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0,possibleConstructorReturn/* default */.Z)(this, result);\n  };\n}\n\nfunction linear_interpolator_isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\n\nvar linear_interpolator_VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\', \'bearing\', \'pitch\'];\n\nvar LinearInterpolator = function (_TransitionInterpolat) {\n  (0,inherits/* default */.Z)(LinearInterpolator, _TransitionInterpolat);\n\n  var _super = linear_interpolator_createSuper(LinearInterpolator);\n\n  function LinearInterpolator() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    (0,classCallCheck/* default */.Z)(this, LinearInterpolator);\n\n    _this = _super.call(this);\n\n    if (Array.isArray(opts)) {\n      opts = {\n        transitionProps: opts\n      };\n    }\n\n    _this.propNames = opts.transitionProps || linear_interpolator_VIEWPORT_TRANSITION_PROPS;\n\n    if (opts.around) {\n      _this.around = opts.around;\n    }\n\n    return _this;\n  }\n\n  (0,createClass/* default */.Z)(LinearInterpolator, [{\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n\n      if (this.around) {\n        startViewportProps.around = this.around;\n        var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);\n        Object.assign(endViewportProps, endProps, {\n          around: new WebMercatorViewport(endProps).project(aroundLngLat),\n          aroundLngLat: aroundLngLat\n        });\n      }\n\n      var _iterator = linear_interpolator_createForOfIteratorHelper(this.propNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = {};\n\n      var _iterator2 = linear_interpolator_createForOfIteratorHelper(this.propNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (endProps.around) {\n        var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({\n          lngLat: endProps.aroundLngLat,\n          pos: utils_math_utils_lerp(startProps.around, endProps.around, t)\n        }),\n            _WebMercatorViewport$2 = slicedToArray_slicedToArray(_WebMercatorViewport$, 2),\n            longitude = _WebMercatorViewport$2[0],\n            latitude = _WebMercatorViewport$2[1];\n\n        viewport.longitude = longitude;\n        viewport.latitude = latitude;\n      }\n\n      return viewport;\n    }\n  }]);\n\n  return LinearInterpolator;\n}(TransitionInterpolator);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/index.js\n\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition-manager.js\n\n\n\n\n\n\n\nvar transition_manager_noop = function noop() {};\n\nfunction cropEasingFunction(easing, x0) {\n  var y0 = easing(x0);\n  return function (t) {\n    return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);\n  };\n}\nvar TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3,\n  UPDATE: 4\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: transition_manager_noop,\n  onTransitionInterrupt: transition_manager_noop,\n  onTransitionEnd: transition_manager_noop\n};\n\nvar TransitionManager = function () {\n  function TransitionManager() {\n    var _this = this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    (0,classCallCheck/* default */.Z)(this, TransitionManager);\n\n    (0,defineProperty/* default */.Z)(this, "_animationFrame", null);\n\n    (0,defineProperty/* default */.Z)(this, "_onTransitionFrame", function () {\n      _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);\n\n      _this._updateViewport();\n    });\n\n    this.props = null;\n    this.onViewportChange = opts.onViewportChange || transition_manager_noop;\n    this.onStateChange = opts.onStateChange || transition_manager_noop;\n    this.time = opts.getTime || Date.now;\n  }\n\n  (0,createClass/* default */.Z)(TransitionManager, [{\n    key: "getViewportInTransition",\n    value: function getViewportInTransition() {\n      return this._animationFrame ? this.state.propsInTransition : null;\n    }\n  }, {\n    key: "processViewportChange",\n    value: function processViewportChange(nextProps) {\n      var currentProps = this.props;\n      this.props = nextProps;\n\n      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return false;\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps);\n        var endProps = Object.assign({}, nextProps);\n\n        if (this._isTransitionInProgress()) {\n          currentProps.onTransitionInterrupt();\n\n          if (this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END) {\n            Object.assign(startProps, this.state.endProps);\n          } else {\n            Object.assign(startProps, this.state.propsInTransition);\n          }\n\n          if (this.state.interruption === TRANSITION_EVENTS.UPDATE) {\n            var currentTime = this.time();\n            var x0 = (currentTime - this.state.startTime) / this.state.duration;\n            endProps.transitionDuration = this.state.duration - (currentTime - this.state.startTime);\n            endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);\n            endProps.transitionInterpolator = startProps.transitionInterpolator;\n          }\n        }\n\n        endProps.onTransitionStart();\n\n        this._triggerTransition(startProps, endProps);\n\n        return true;\n      }\n\n      if (this._isTransitionInProgress()) {\n        currentProps.onTransitionInterrupt();\n\n        this._endTransition();\n      }\n\n      return false;\n    }\n  }, {\n    key: "_isTransitionInProgress",\n    value: function _isTransitionInProgress() {\n      return Boolean(this._animationFrame);\n    }\n  }, {\n    key: "_isTransitionEnabled",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n          transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === \'auto\') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: "_isUpdateDueToCurrentTransition",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.state.propsInTransition) {\n        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n      }\n\n      return false;\n    }\n  }, {\n    key: "_shouldIgnoreViewportChange",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (!currentProps) {\n        return true;\n      }\n\n      if (this._isTransitionInProgress()) {\n        return this.state.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n\n      return true;\n    }\n  }, {\n    key: "_triggerTransition",\n    value: function _triggerTransition(startProps, endProps) {\n      utils_assert_assert(this._isTransitionEnabled(endProps));\n\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n\n      if (duration === 0) {\n        return;\n      }\n\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n      var interactionState = {\n        inTransition: true,\n        isZooming: startProps.zoom !== endProps.zoom,\n        isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,\n        isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch\n      };\n      this.state = {\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startTime: this.time(),\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        animation: null,\n        propsInTransition: {}\n      };\n\n      this._onTransitionFrame();\n\n      this.onStateChange(interactionState);\n    }\n  }, {\n    key: "_endTransition",\n    value: function _endTransition() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n        this._animationFrame = null;\n      }\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n    }\n  }, {\n    key: "_updateViewport",\n    value: function _updateViewport() {\n      var currentTime = this.time();\n      var _this$state = this.state,\n          startTime = _this$state.startTime,\n          duration = _this$state.duration,\n          easing = _this$state.easing,\n          interpolator = _this$state.interpolator,\n          startProps = _this$state.startProps,\n          endProps = _this$state.endProps;\n      var shouldEnd = false;\n      var t = (currentTime - startTime) / duration;\n\n      if (t >= 1) {\n        t = 1;\n        shouldEnd = true;\n      }\n\n      t = easing(t);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      var mapState = new MapState(Object.assign({}, this.props, viewport));\n      this.state.propsInTransition = mapState.getViewportProps();\n      this.onViewportChange(this.state.propsInTransition, this.props);\n\n      if (shouldEnd) {\n        this._endTransition();\n\n        this.props.onTransitionEnd();\n      }\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\n(0,defineProperty/* default */.Z)(TransitionManager, "defaultProps", DEFAULT_PROPS);\n\n\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(5087);\nvar hammer_default = /*#__PURE__*/__webpack_require__.n(hammer);\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nfunction some(array, predict) {\n  for (var i = 0; i < array.length; i++) {\n    if (predict(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction enhancePointerEventInput(PointerEventInput) {\n  var oldHandler = PointerEventInput.prototype.handler;\n\n  PointerEventInput.prototype.handler = function handler(ev) {\n    var store = this.store;\n\n    if (ev.button > 0 && ev.type === \'pointerdown\') {\n      if (!some(store, function (e) {\n        return e.pointerId === ev.pointerId;\n      })) {\n        store.push(ev);\n      }\n    }\n\n    oldHandler.call(this, ev);\n  };\n}\nfunction enhanceMouseInput(MouseInput) {\n  MouseInput.prototype.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type];\n\n    if (eventType & INPUT_START && ev.button >= 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which === 0) {\n      eventType = INPUT_END;\n    }\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: \'mouse\',\n      srcEvent: ev\n    });\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js\n\n\nenhancePointerEventInput((hammer_default()).PointerEventInput);\nenhanceMouseInput((hammer_default()).MouseInput);\nvar Manager = (hammer_default()).Manager;\n/* harmony default export */ var hammer_browser = ((hammer_default()));\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/constants.js\n\nvar RECOGNIZERS = hammer_browser ? [[hammer_browser.Pan, {\n  event: \'tripan\',\n  pointers: 3,\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Rotate, {\n  enable: false\n}], [hammer_browser.Pinch, {\n  enable: false\n}], [hammer_browser.Swipe, {\n  enable: false\n}], [hammer_browser.Pan, {\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Press, {\n  enable: false\n}], [hammer_browser.Tap, {\n  event: \'doubletap\',\n  taps: 2,\n  enable: false\n}], [hammer_browser.Tap, {\n  event: \'anytap\',\n  enable: false\n}], [hammer_browser.Tap, {\n  enable: false\n}]] : null;\nvar RECOGNIZER_COMPATIBLE_MAP = {\n  tripan: [\'rotate\', \'pinch\', \'pan\'],\n  rotate: [\'pinch\'],\n  pinch: [\'pan\'],\n  pan: [\'press\', \'doubletap\', \'anytap\', \'tap\'],\n  doubletap: [\'anytap\'],\n  anytap: [\'tap\']\n};\nvar RECOGNIZER_FALLBACK_MAP = {\n  doubletap: [\'tap\']\n};\nvar BASIC_EVENT_ALIASES = {\n  pointerdown: \'pointerdown\',\n  pointermove: \'pointermove\',\n  pointerup: \'pointerup\',\n  touchstart: \'pointerdown\',\n  touchmove: \'pointermove\',\n  touchend: \'pointerup\',\n  mousedown: \'pointerdown\',\n  mousemove: \'pointermove\',\n  mouseup: \'pointerup\'\n};\nvar INPUT_EVENT_TYPES = {\n  KEY_EVENTS: [\'keydown\', \'keyup\'],\n  MOUSE_EVENTS: [\'mousedown\', \'mousemove\', \'mouseup\', \'mouseover\', \'mouseout\', \'mouseleave\'],\n  WHEEL_EVENTS: [\'wheel\', \'mousewheel\']\n};\nvar EVENT_RECOGNIZER_MAP = {\n  tap: \'tap\',\n  anytap: \'anytap\',\n  doubletap: \'doubletap\',\n  press: \'press\',\n  pinch: \'pinch\',\n  pinchin: \'pinch\',\n  pinchout: \'pinch\',\n  pinchstart: \'pinch\',\n  pinchmove: \'pinch\',\n  pinchend: \'pinch\',\n  pinchcancel: \'pinch\',\n  rotate: \'rotate\',\n  rotatestart: \'rotate\',\n  rotatemove: \'rotate\',\n  rotateend: \'rotate\',\n  rotatecancel: \'rotate\',\n  tripan: \'tripan\',\n  tripanstart: \'tripan\',\n  tripanmove: \'tripan\',\n  tripanup: \'tripan\',\n  tripandown: \'tripan\',\n  tripanleft: \'tripan\',\n  tripanright: \'tripan\',\n  tripanend: \'tripan\',\n  tripancancel: \'tripan\',\n  pan: \'pan\',\n  panstart: \'pan\',\n  panmove: \'pan\',\n  panup: \'pan\',\n  pandown: \'pan\',\n  panleft: \'pan\',\n  panright: \'pan\',\n  panend: \'pan\',\n  pancancel: \'pan\',\n  swipe: \'swipe\',\n  swipeleft: \'swipe\',\n  swiperight: \'swipe\',\n  swipeup: \'swipe\',\n  swipedown: \'swipe\'\n};\nvar GESTURE_EVENT_ALIASES = {\n  click: \'tap\',\n  anyclick: \'anytap\',\n  dblclick: \'doubletap\',\n  mousedown: \'pointerdown\',\n  mousemove: \'pointermove\',\n  mouseup: \'pointerup\',\n  mouseover: \'pointerover\',\n  mouseout: \'pointerout\',\n  mouseleave: \'pointerleave\'\n};\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/globals.js\nvar userAgent = typeof navigator !== \'undefined\' && navigator.userAgent ? navigator.userAgent.toLowerCase() : \'\';\nvar globals_window_ = typeof window !== \'undefined\' ? window : __webpack_require__.g;\nvar globals_global_ = typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : window;\nvar globals_document_ = typeof document !== \'undefined\' ? document : {};\n\nvar passiveSupported = false;\n\ntry {\n  var options = {\n    get passive() {\n      passiveSupported = true;\n      return true;\n    }\n\n  };\n  globals_window_.addEventListener(\'test\', options, options);\n  globals_window_.removeEventListener(\'test\', options, options);\n} catch (err) {}\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js\n\n\n\n\nvar firefox = userAgent.indexOf(\'firefox\') !== -1;\nvar WHEEL_EVENTS = INPUT_EVENT_TYPES.WHEEL_EVENTS;\nvar EVENT_TYPE = \'wheel\';\nvar WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nvar WHEEL_DELTA_PER_LINE = 40;\nvar SHIFT_MULTIPLIER = 0.25;\n\nvar WheelInput = /*#__PURE__*/function () {\n  function WheelInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    (0,classCallCheck/* default */.Z)(this, WheelInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.events = WHEEL_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent, passiveSupported ? {\n        passive: false\n      } : false);\n    });\n  }\n\n  (0,createClass/* default */.Z)(WheelInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      var value = event.deltaY;\n\n      if (globals_window_.WheelEvent) {\n        if (firefox && event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= globals_window_.devicePixelRatio;\n        }\n\n        if (event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n\n      var wheelPosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      }\n\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      }\n\n      this._onWheel(event, -value, wheelPosition);\n    }\n  }, {\n    key: "_onWheel",\n    value: function _onWheel(srcEvent, delta, position) {\n      this.callback({\n        type: EVENT_TYPE,\n        center: position,\n        delta: delta,\n        srcEvent: srcEvent,\n        pointerType: \'mouse\',\n        target: srcEvent.target\n      });\n    }\n  }]);\n\n  return WheelInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/move-input.js\n\n\n\nvar MOUSE_EVENTS = INPUT_EVENT_TYPES.MOUSE_EVENTS;\nvar MOVE_EVENT_TYPE = \'pointermove\';\nvar OVER_EVENT_TYPE = \'pointerover\';\nvar OUT_EVENT_TYPE = \'pointerout\';\nvar LEAVE_EVENT_TYPE = \'pointerleave\';\n\nvar MoveInput = /*#__PURE__*/function () {\n  function MoveInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    (0,classCallCheck/* default */.Z)(this, MoveInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.pressed = false;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.enableMoveEvent = this.options.enable;\n    this.enableLeaveEvent = this.options.enable;\n    this.enableOutEvent = this.options.enable;\n    this.enableOverEvent = this.options.enable;\n    this.events = MOUSE_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  (0,createClass/* default */.Z)(MoveInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === MOVE_EVENT_TYPE) {\n        this.enableMoveEvent = enabled;\n      }\n\n      if (eventType === OVER_EVENT_TYPE) {\n        this.enableOverEvent = enabled;\n      }\n\n      if (eventType === OUT_EVENT_TYPE) {\n        this.enableOutEvent = enabled;\n      }\n\n      if (eventType === LEAVE_EVENT_TYPE) {\n        this.enableLeaveEvent = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    }\n  }, {\n    key: "handleOverEvent",\n    value: function handleOverEvent(event) {\n      if (this.enableOverEvent) {\n        if (event.type === \'mouseover\') {\n          this.callback({\n            type: OVER_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleOutEvent",\n    value: function handleOutEvent(event) {\n      if (this.enableOutEvent) {\n        if (event.type === \'mouseout\') {\n          this.callback({\n            type: OUT_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleLeaveEvent",\n    value: function handleLeaveEvent(event) {\n      if (this.enableLeaveEvent) {\n        if (event.type === \'mouseleave\') {\n          this.callback({\n            type: LEAVE_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleMoveEvent",\n    value: function handleMoveEvent(event) {\n      if (this.enableMoveEvent) {\n        switch (event.type) {\n          case \'mousedown\':\n            if (event.button >= 0) {\n              this.pressed = true;\n            }\n\n            break;\n\n          case \'mousemove\':\n            if (event.which === 0) {\n              this.pressed = false;\n            }\n\n            if (!this.pressed) {\n              this.callback({\n                type: MOVE_EVENT_TYPE,\n                srcEvent: event,\n                pointerType: \'mouse\',\n                target: event.target\n              });\n            }\n\n            break;\n\n          case \'mouseup\':\n            this.pressed = false;\n            break;\n\n          default:\n        }\n      }\n    }\n  }]);\n\n  return MoveInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/key-input.js\n\n\n\nvar KEY_EVENTS = INPUT_EVENT_TYPES.KEY_EVENTS;\nvar DOWN_EVENT_TYPE = \'keydown\';\nvar UP_EVENT_TYPE = \'keyup\';\n\nvar KeyInput = /*#__PURE__*/function () {\n  function KeyInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    (0,classCallCheck/* default */.Z)(this, KeyInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n    this.events = KEY_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    element.tabIndex = options.tabIndex || 0;\n    element.style.outline = \'none\';\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  (0,createClass/* default */.Z)(KeyInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === DOWN_EVENT_TYPE) {\n        this.enableDownEvent = enabled;\n      }\n\n      if (eventType === UP_EVENT_TYPE) {\n        this.enableUpEvent = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      var targetElement = event.target || event.srcElement;\n\n      if (targetElement.tagName === \'INPUT\' && targetElement.type === \'text\' || targetElement.tagName === \'TEXTAREA\') {\n        return;\n      }\n\n      if (this.enableDownEvent && event.type === \'keydown\') {\n        this.callback({\n          type: DOWN_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n\n      if (this.enableUpEvent && event.type === \'keyup\') {\n        this.callback({\n          type: UP_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n    }\n  }]);\n\n  return KeyInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js\n\n\nvar contextmenu_input_EVENT_TYPE = \'contextmenu\';\n\nvar ContextmenuInput = /*#__PURE__*/function () {\n  function ContextmenuInput(element, callback) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    (0,classCallCheck/* default */.Z)(this, ContextmenuInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.handleEvent = this.handleEvent.bind(this);\n    element.addEventListener(\'contextmenu\', this.handleEvent);\n  }\n\n  (0,createClass/* default */.Z)(ContextmenuInput, [{\n    key: "destroy",\n    value: function destroy() {\n      this.element.removeEventListener(\'contextmenu\', this.handleEvent);\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === contextmenu_input_EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      this.callback({\n        type: contextmenu_input_EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: \'mouse\',\n        target: event.target\n      });\n    }\n  }]);\n\n  return ContextmenuInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/event-utils.js\nvar DOWN_EVENT = 1;\nvar MOVE_EVENT = 2;\nvar UP_EVENT = 4;\nvar event_utils_MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\nvar MOUSE_EVENT_WHICH_LEFT = 1;\nvar MOUSE_EVENT_WHICH_MIDDLE = 2;\nvar MOUSE_EVENT_WHICH_RIGHT = 3;\nvar MOUSE_EVENT_BUTTON_LEFT = 0;\nvar MOUSE_EVENT_BUTTON_MIDDLE = 1;\nvar MOUSE_EVENT_BUTTON_RIGHT = 2;\nvar MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nvar MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nvar MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\nfunction whichButtons(event) {\n  var eventType = event_utils_MOUSE_EVENTS[event.srcEvent.type];\n\n  if (!eventType) {\n    return null;\n  }\n\n  var _event$srcEvent = event.srcEvent,\n      buttons = _event$srcEvent.buttons,\n      button = _event$srcEvent.button,\n      which = _event$srcEvent.which;\n  var leftButton = false;\n  var middleButton = false;\n  var rightButton = false;\n\n  if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {\n    leftButton = which === MOUSE_EVENT_WHICH_LEFT;\n    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;\n    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;\n  } else if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else if (eventType === DOWN_EVENT) {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {\n    leftButton: leftButton,\n    middleButton: middleButton,\n    rightButton: rightButton\n  };\n}\nfunction getOffsetPosition(event, rootElement) {\n  var srcEvent = event.srcEvent;\n\n  if (!event.center && !Number.isFinite(srcEvent.clientX)) {\n    return null;\n  }\n\n  var center = event.center || {\n    x: srcEvent.clientX,\n    y: srcEvent.clientY\n  };\n  var rect = rootElement.getBoundingClientRect();\n  var scaleX = rect.width / rootElement.offsetWidth || 1;\n  var scaleY = rect.height / rootElement.offsetHeight || 1;\n  var offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n  return {\n    center: center,\n    offsetCenter: offsetCenter\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js\n\n\n\nvar DEFAULT_OPTIONS = {\n  srcElement: \'root\',\n  priority: 0\n};\n\nvar EventRegistrar = /*#__PURE__*/function () {\n  function EventRegistrar(eventManager) {\n    (0,classCallCheck/* default */.Z)(this, EventRegistrar);\n\n    this.eventManager = eventManager;\n    this.handlers = [];\n    this.handlersByElement = new Map();\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  (0,createClass/* default */.Z)(EventRegistrar, [{\n    key: "isEmpty",\n    value: function isEmpty() {\n      return !this._active;\n    }\n  }, {\n    key: "add",\n    value: function add(type, handler, opts) {\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      if (opts && (typeof opts !== \'object\' || opts.addEventListener)) {\n        opts = {\n          srcElement: opts\n        };\n      }\n\n      opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n      var entries = handlersByElement.get(opts.srcElement);\n\n      if (!entries) {\n        entries = [];\n        handlersByElement.set(opts.srcElement, entries);\n      }\n\n      var entry = {\n        type: type,\n        handler: handler,\n        srcElement: opts.srcElement,\n        priority: opts.priority\n      };\n\n      if (once) {\n        entry.once = true;\n      }\n\n      if (passive) {\n        entry.passive = true;\n      }\n\n      handlers.push(entry);\n      this._active = this._active || !entry.passive;\n      var insertPosition = entries.length - 1;\n\n      while (insertPosition >= 0) {\n        if (entries[insertPosition].priority >= entry.priority) {\n          break;\n        }\n\n        insertPosition--;\n      }\n\n      entries.splice(insertPosition + 1, 0, entry);\n    }\n  }, {\n    key: "remove",\n    value: function remove(type, handler) {\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      for (var i = handlers.length - 1; i >= 0; i--) {\n        var entry = handlers[i];\n\n        if (entry.type === type && entry.handler === handler) {\n          handlers.splice(i, 1);\n          var entries = handlersByElement.get(entry.srcElement);\n          entries.splice(entries.indexOf(entry), 1);\n\n          if (entries.length === 0) {\n            handlersByElement.delete(entry.srcElement);\n          }\n        }\n      }\n\n      this._active = handlers.some(function (entry) {\n        return !entry.passive;\n      });\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (this.isEmpty()) {\n        return;\n      }\n\n      var mjolnirEvent = this._normalizeEvent(event);\n\n      var target = event.srcEvent.target;\n\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n\n        if (mjolnirEvent.handled) {\n          return;\n        }\n\n        target = target.parentNode;\n      }\n\n      this._emit(mjolnirEvent, \'root\');\n    }\n  }, {\n    key: "_emit",\n    value: function _emit(event, srcElement) {\n      var entries = this.handlersByElement.get(srcElement);\n\n      if (entries) {\n        var immediatePropagationStopped = false;\n\n        var stopPropagation = function stopPropagation() {\n          event.handled = true;\n        };\n\n        var stopImmediatePropagation = function stopImmediatePropagation() {\n          event.handled = true;\n          immediatePropagationStopped = true;\n        };\n\n        var entriesToRemove = [];\n\n        for (var i = 0; i < entries.length; i++) {\n          var _entries$i = entries[i],\n              type = _entries$i.type,\n              handler = _entries$i.handler,\n              once = _entries$i.once;\n          handler(Object.assign({}, event, {\n            type: type,\n            stopPropagation: stopPropagation,\n            stopImmediatePropagation: stopImmediatePropagation\n          }));\n\n          if (once) {\n            entriesToRemove.push(entries[i]);\n          }\n\n          if (immediatePropagationStopped) {\n            break;\n          }\n        }\n\n        for (var _i = 0; _i < entriesToRemove.length; _i++) {\n          var _entriesToRemove$_i = entriesToRemove[_i],\n              _type = _entriesToRemove$_i.type,\n              _handler = _entriesToRemove$_i.handler;\n          this.remove(_type, _handler);\n        }\n      }\n    }\n  }, {\n    key: "_normalizeEvent",\n    value: function _normalizeEvent(event) {\n      var rootElement = this.eventManager.element;\n      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n        handled: false,\n        rootElement: rootElement\n      });\n    }\n  }]);\n\n  return EventRegistrar;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/event-manager.js\n\n\n\n\nfunction event_manager_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = event_manager_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction event_manager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return event_manager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return event_manager_arrayLikeToArray(o, minLen); }\n\nfunction event_manager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n\n\n\nvar event_manager_DEFAULT_OPTIONS = {\n  events: null,\n  recognizers: null,\n  recognizerOptions: {},\n  Manager: Manager,\n  touchAction: \'none\',\n  tabIndex: 0\n};\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager() {\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,classCallCheck/* default */.Z)(this, EventManager);\n\n    this.options = Object.assign({}, event_manager_DEFAULT_OPTIONS, options);\n    this.events = new Map();\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.setElement(element);\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  (0,createClass/* default */.Z)(EventManager, [{\n    key: "setElement",\n    value: function setElement(element) {\n      var _this = this;\n\n      if (this.element) {\n        this.destroy();\n      }\n\n      this.element = element;\n\n      if (!element) {\n        return;\n      }\n\n      var options = this.options;\n      var ManagerClass = options.Manager;\n      this.manager = new ManagerClass(element, {\n        touchAction: options.touchAction,\n        recognizers: options.recognizers || RECOGNIZERS\n      }).on(\'hammer.input\', this._onBasicInput);\n\n      if (!options.recognizers) {\n        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {\n          var recognizer = _this.manager.get(name);\n\n          if (recognizer) {\n            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {\n              recognizer.recognizeWith(otherName);\n            });\n          }\n        });\n      }\n\n      for (var recognizerName in options.recognizerOptions) {\n        var recognizer = this.manager.get(recognizerName);\n\n        if (recognizer) {\n          var recognizerOption = options.recognizerOptions[recognizerName];\n          delete recognizerOption.enable;\n          recognizer.set(recognizerOption);\n        }\n      }\n\n      this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.moveInput = new MoveInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.keyInput = new KeyInput(element, this._onOtherEvent, {\n        enable: false,\n        tabIndex: options.tabIndex\n      });\n      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n        enable: false\n      });\n\n      var _iterator = event_manager_createForOfIteratorHelper(this.events),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = slicedToArray_slicedToArray(_step.value, 2),\n              eventAlias = _step$value[0],\n              eventRegistrar = _step$value[1];\n\n          if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n            this.manager.on(eventAlias, eventRegistrar.handleEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.element) {\n        this.wheelInput.destroy();\n        this.moveInput.destroy();\n        this.keyInput.destroy();\n        this.contextmenuInput.destroy();\n        this.manager.destroy();\n        this.wheelInput = null;\n        this.moveInput = null;\n        this.keyInput = null;\n        this.contextmenuInput = null;\n        this.manager = null;\n        this.element = null;\n      }\n    }\n  }, {\n    key: "on",\n    value: function on(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false);\n    }\n  }, {\n    key: "once",\n    value: function once(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, true);\n    }\n  }, {\n    key: "watch",\n    value: function watch(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false, true);\n    }\n  }, {\n    key: "off",\n    value: function off(event, handler) {\n      this._removeEventHandler(event, handler);\n    }\n  }, {\n    key: "_toggleRecognizer",\n    value: function _toggleRecognizer(name, enabled) {\n      var manager = this.manager;\n\n      if (!manager) {\n        return;\n      }\n\n      var recognizer = manager.get(name);\n\n      if (recognizer && recognizer.options.enable !== enabled) {\n        recognizer.set({\n          enable: enabled\n        });\n        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n        if (fallbackRecognizers && !this.options.recognizers) {\n          fallbackRecognizers.forEach(function (otherName) {\n            var otherRecognizer = manager.get(otherName);\n\n            if (enabled) {\n              otherRecognizer.requireFailure(name);\n              recognizer.dropRequireFailure(otherName);\n            } else {\n              otherRecognizer.dropRequireFailure(name);\n            }\n          });\n        }\n      }\n\n      this.wheelInput.enableEventType(name, enabled);\n      this.moveInput.enableEventType(name, enabled);\n      this.keyInput.enableEventType(name, enabled);\n      this.contextmenuInput.enableEventType(name, enabled);\n    }\n  }, {\n    key: "_addEventHandler",\n    value: function _addEventHandler(event, handler, opts, once, passive) {\n      if (typeof event !== \'string\') {\n        opts = handler;\n\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName], opts, once, passive);\n        }\n\n        return;\n      }\n\n      var manager = this.manager,\n          events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        eventRegistrar = new EventRegistrar(this);\n        events.set(eventAlias, eventRegistrar);\n        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n\n        if (manager) {\n          manager.on(eventAlias, eventRegistrar.handleEvent);\n        }\n      }\n\n      eventRegistrar.add(event, handler, opts, once, passive);\n\n      if (!eventRegistrar.isEmpty()) {\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n      }\n    }\n  }, {\n    key: "_removeEventHandler",\n    value: function _removeEventHandler(event, handler) {\n      if (typeof event !== \'string\') {\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n\n        return;\n      }\n\n      var events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        return;\n      }\n\n      eventRegistrar.remove(event, handler);\n\n      if (eventRegistrar.isEmpty()) {\n        var recognizerName = eventRegistrar.recognizerName;\n        var isRecognizerUsed = false;\n\n        var _iterator2 = event_manager_createForOfIteratorHelper(events.values()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var eh = _step2.value;\n\n            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n              isRecognizerUsed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n  }, {\n    key: "_onBasicInput",\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        this.manager.emit(alias, event);\n      }\n    }\n  }, {\n    key: "_onOtherEvent",\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n\n  return EventManager;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/index.js\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-controller.js\n\n\n\n\nfunction map_controller_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_controller_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_controller_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_controller_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar NO_TRANSITION_PROPS = {\n  transitionDuration: 0\n};\nvar LINEAR_TRANSITION_PROPS = {\n  transitionDuration: 300,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK\n};\nvar DEFAULT_INERTIA = 300;\n\nvar INERTIA_EASING = function INERTIA_EASING(t) {\n  return 1 - (1 - t) * (1 - t);\n};\n\nvar EVENT_TYPES = {\n  WHEEL: [\'wheel\'],\n  PAN: [\'panstart\', \'panmove\', \'panend\'],\n  PINCH: [\'pinchstart\', \'pinchmove\', \'pinchend\'],\n  TRIPLE_PAN: [\'tripanstart\', \'tripanmove\', \'tripanend\'],\n  DOUBLE_TAP: [\'doubletap\'],\n  KEYBOARD: [\'keydown\']\n};\n\nvar MapController = function () {\n  function MapController() {\n    var _this = this;\n\n    (0,classCallCheck/* default */.Z)(this, MapController);\n\n    (0,defineProperty/* default */.Z)(this, "events", []);\n\n    (0,defineProperty/* default */.Z)(this, "scrollZoom", true);\n\n    (0,defineProperty/* default */.Z)(this, "dragPan", true);\n\n    (0,defineProperty/* default */.Z)(this, "dragRotate", true);\n\n    (0,defineProperty/* default */.Z)(this, "doubleClickZoom", true);\n\n    (0,defineProperty/* default */.Z)(this, "touchZoom", true);\n\n    (0,defineProperty/* default */.Z)(this, "touchRotate", false);\n\n    (0,defineProperty/* default */.Z)(this, "keyboard", true);\n\n    (0,defineProperty/* default */.Z)(this, "_interactionState", {\n      isDragging: false\n    });\n\n    (0,defineProperty/* default */.Z)(this, "_events", {});\n\n    (0,defineProperty/* default */.Z)(this, "_setInteractionState", function (newState) {\n      Object.assign(_this._interactionState, newState);\n\n      if (_this.onStateChange) {\n        _this.onStateChange(_this._interactionState);\n      }\n    });\n\n    (0,defineProperty/* default */.Z)(this, "_onTransition", function (newViewport, oldViewport) {\n      _this.onViewportChange(newViewport, _this._interactionState, oldViewport);\n    });\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this._transitionManager = new TransitionManager({\n      onViewportChange: this._onTransition,\n      onStateChange: this._setInteractionState\n    });\n  }\n\n  (0,createClass/* default */.Z)(MapController, [{\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      this.mapState = this.getMapState();\n      var eventStartBlocked = this._eventStartBlocked;\n\n      switch (event.type) {\n        case \'panstart\':\n          return eventStartBlocked ? false : this._onPanStart(event);\n\n        case \'panmove\':\n          return this._onPan(event);\n\n        case \'panend\':\n          return this._onPanEnd(event);\n\n        case \'pinchstart\':\n          return eventStartBlocked ? false : this._onPinchStart(event);\n\n        case \'pinchmove\':\n          return this._onPinch(event);\n\n        case \'pinchend\':\n          return this._onPinchEnd(event);\n\n        case \'tripanstart\':\n          return eventStartBlocked ? false : this._onTriplePanStart(event);\n\n        case \'tripanmove\':\n          return this._onTriplePan(event);\n\n        case \'tripanend\':\n          return this._onTriplePanEnd(event);\n\n        case \'doubletap\':\n          return this._onDoubleTap(event);\n\n        case \'wheel\':\n          return this._onWheel(event);\n\n        case \'keydown\':\n          return this._onKeyDown(event);\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: "getCenter",\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n          x = _event$offsetCenter.x,\n          y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: "isFunctionKeyPressed",\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: "blockEvents",\n    value: function blockEvents(timeout) {\n      var _this2 = this;\n\n      var timer = setTimeout(function () {\n        if (_this2._eventStartBlocked === timer) {\n          _this2._eventStartBlocked = null;\n        }\n      }, timeout);\n      this._eventStartBlocked = timer;\n    }\n  }, {\n    key: "updateViewport",\n    value: function updateViewport(newMapState, extraProps, interactionState) {\n      var oldViewport = this.mapState instanceof MapState ? this.mapState.getViewportProps() : this.mapState;\n\n      var newViewport = map_controller_objectSpread(map_controller_objectSpread({}, newMapState.getViewportProps()), extraProps);\n\n      var viewStateChanged = Object.keys(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      });\n      this._state = newMapState.getState();\n\n      this._setInteractionState(interactionState);\n\n      if (viewStateChanged) {\n        this.onViewportChange(newViewport, this._interactionState, oldViewport);\n      }\n    }\n  }, {\n    key: "getMapState",\n    value: function getMapState(overrides) {\n      return new MapState(map_controller_objectSpread(map_controller_objectSpread(map_controller_objectSpread({}, this.mapStateProps), this._state), overrides));\n    }\n  }, {\n    key: "isDragging",\n    value: function isDragging() {\n      return this._interactionState.isDragging;\n    }\n  }, {\n    key: "setOptions",\n    value: function setOptions(options) {\n      var onViewportChange = options.onViewportChange,\n          onStateChange = options.onStateChange,\n          _options$eventManager = options.eventManager,\n          eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager,\n          _options$isInteractiv = options.isInteractive,\n          isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv,\n          _options$scrollZoom = options.scrollZoom,\n          scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom,\n          _options$dragPan = options.dragPan,\n          dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan,\n          _options$dragRotate = options.dragRotate,\n          dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate,\n          _options$doubleClickZ = options.doubleClickZoom,\n          doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ,\n          _options$touchZoom = options.touchZoom,\n          touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom,\n          _options$touchRotate = options.touchRotate,\n          touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate,\n          _options$keyboard = options.keyboard,\n          keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;\n      this.onViewportChange = onViewportChange;\n      this.onStateChange = onStateChange;\n      var prevOptions = this.mapStateProps || {};\n      var dimensionChanged = prevOptions.height !== options.height || prevOptions.width !== options.width;\n      this.mapStateProps = options;\n\n      if (dimensionChanged) {\n        this.mapState = prevOptions;\n        this.updateViewport(new MapState(options));\n      }\n\n      this._transitionManager.processViewportChange(options);\n\n      if (this.eventManager !== eventManager) {\n        this.eventManager = eventManager;\n        this._events = {};\n        this.toggleEvents(this.events, true);\n      }\n\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && Boolean(scrollZoom));\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && Boolean(dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && Boolean(touchZoom || touchRotate));\n      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && Boolean(touchRotate));\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));\n      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && Boolean(keyboard));\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoom = touchZoom;\n      this.touchRotate = touchRotate;\n      this.keyboard = keyboard;\n    }\n  }, {\n    key: "toggleEvents",\n    value: function toggleEvents(eventNames, enabled) {\n      var _this3 = this;\n\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this3._events[eventName] !== enabled) {\n            _this3._events[eventName] = enabled;\n\n            if (enabled) {\n              _this3.eventManager.on(eventName, _this3.handleEvent);\n            } else {\n              _this3.eventManager.off(eventName, _this3.handleEvent);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: "_onPanStart",\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;\n      var newMapState = this._panRotate ? this.mapState.rotateStart({\n        pos: pos\n      }) : this.mapState.panStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPan",\n    value: function _onPan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);\n    }\n  }, {\n    key: "_onPanEnd",\n    value: function _onPanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);\n    }\n  }, {\n    key: "_onPanMove",\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.pan({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isPanning: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanMoveEnd",\n    value: function _onPanMoveEnd(event) {\n      if (this.dragPan) {\n        var _this$dragPan$inertia = this.dragPan.inertia,\n            inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA : _this$dragPan$inertia;\n\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.pan({\n            pos: endPos\n          }).panEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: true\n          });\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanRotate",\n    value: function _onPanRotate(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanRotateEnd",\n    value: function _onPanRotateEnd(event) {\n      if (this.dragRotate) {\n        var _this$dragRotate$iner = this.dragRotate.inertia,\n            inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA : _this$dragRotate$iner;\n\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.rotate({\n            pos: endPos\n          }).rotateEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onWheel",\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n\n      var _this$scrollZoom = this.scrollZoom,\n          _this$scrollZoom$spee = _this$scrollZoom.speed,\n          speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee,\n          _this$scrollZoom$smoo = _this$scrollZoom.smooth,\n          smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;\n      event.preventDefault();\n      var pos = this.getCenter(event);\n      var delta = event.delta;\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      this.updateViewport(newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        }),\n        transitionDuration: smooth ? 250 : 1\n      }), {\n        isPanning: true,\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPinchStart",\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.zoomStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      this._startPinchRotation = event.rotation;\n      this._lastPinchEvent = event;\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPinch",\n    value: function _onPinch(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (!this.touchZoom && !this.touchRotate) {\n        return false;\n      }\n\n      var newMapState = this.mapState;\n\n      if (this.touchZoom) {\n        var scale = event.scale;\n        var pos = this.getCenter(event);\n        newMapState = newMapState.zoom({\n          pos: pos,\n          scale: scale\n        });\n      }\n\n      if (this.touchRotate) {\n        var rotation = event.rotation;\n        newMapState = newMapState.rotate({\n          deltaAngleX: this._startPinchRotation - rotation\n        });\n      }\n\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true,\n        isPanning: Boolean(this.touchZoom),\n        isZooming: Boolean(this.touchZoom),\n        isRotating: Boolean(this.touchRotate)\n      });\n      this._lastPinchEvent = event;\n      return true;\n    }\n  }, {\n    key: "_onPinchEnd",\n    value: function _onPinchEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (this.touchZoom) {\n        var _this$touchZoom$inert = this.touchZoom.inertia,\n            inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA : _this$touchZoom$inert;\n        var _lastPinchEvent = this._lastPinchEvent;\n\n        if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n          var pos = this.getCenter(event);\n\n          var _newMapState = this.mapState.rotateEnd();\n\n          var z = Math.log2(event.scale);\n\n          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n\n          var endScale = Math.pow(2, z + velocityZ * inertia / 2);\n          _newMapState = _newMapState.zoom({\n            pos: pos,\n            scale: endScale\n          }).zoomEnd();\n          this.updateViewport(_newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionInterpolator: new LinearInterpolator({\n              around: pos\n            }),\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: Boolean(this.touchZoom),\n            isZooming: Boolean(this.touchZoom),\n            isRotating: false\n          });\n          this.blockEvents(inertia);\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.zoomEnd().rotateEnd();\n      this._state.startPinchRotation = 0;\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false,\n        isZooming: false,\n        isRotating: false\n      });\n      this._startPinchRotation = null;\n      this._lastPinchEvent = null;\n      return true;\n    }\n  }, {\n    key: "_onTriplePanStart",\n    value: function _onTriplePanStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotateStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onTriplePan",\n    value: function _onTriplePan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (!this.touchRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      pos[0] -= event.deltaX;\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onTriplePanEnd",\n    value: function _onTriplePanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (this.touchRotate) {\n        var _this$touchRotate$ine = this.touchRotate.inertia,\n            inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA : _this$touchRotate$ine;\n\n        if (inertia && event.velocityY) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];\n\n          var _newMapState2 = this.mapState.rotate({\n            pos: endPos\n          });\n\n          this.updateViewport(_newMapState2, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          this.blockEvents(inertia);\n          return false;\n        }\n      }\n\n      var newMapState = this.mapState.rotateEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onDoubleTap",\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        })\n      }), {\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onKeyDown",\n    value: function _onKeyDown(event) {\n      if (!this.keyboard) {\n        return false;\n      }\n\n      var funcKey = this.isFunctionKeyPressed(event);\n      var _this$keyboard = this.keyboard,\n          _this$keyboard$zoomSp = _this$keyboard.zoomSpeed,\n          zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp,\n          _this$keyboard$moveSp = _this$keyboard.moveSpeed,\n          moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp,\n          _this$keyboard$rotate = _this$keyboard.rotateSpeedX,\n          rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate,\n          _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY,\n          rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;\n      var mapStateProps = this.mapStateProps;\n      var newMapState;\n\n      switch (event.srcEvent.keyCode) {\n        case 189:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed)\n            });\n          }\n\n          break;\n\n        case 187:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed)\n            });\n          }\n\n          break;\n\n        case 37:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing - rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 39:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing + rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [-moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 38:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch + rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 40:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch - rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, -moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        default:\n          return false;\n      }\n\n      return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);\n    }\n  }]);\n\n  return MapController;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/interactive-map.js\n\n\n\n\nfunction interactive_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction interactive_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      interactive_map_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      interactive_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvar interactive_map_propTypes = Object.assign({}, static_map.propTypes, {\n  maxZoom: prop_types.number,\n  minZoom: prop_types.number,\n  maxPitch: prop_types.number,\n  minPitch: prop_types.number,\n  onViewStateChange: prop_types.func,\n  onViewportChange: prop_types.func,\n  onInteractionStateChange: prop_types.func,\n  transitionDuration: prop_types.oneOfType([prop_types.number, prop_types.string]),\n  transitionInterpolator: prop_types.object,\n  transitionInterruption: prop_types.number,\n  transitionEasing: prop_types.func,\n  onTransitionStart: prop_types.func,\n  onTransitionInterrupt: prop_types.func,\n  onTransitionEnd: prop_types.func,\n  scrollZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragPan: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  doubleClickZoom: prop_types.bool,\n  touchZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  touchRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  keyboard: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  onHover: prop_types.func,\n  onClick: prop_types.func,\n  onDblClick: prop_types.func,\n  onContextMenu: prop_types.func,\n  onMouseDown: prop_types.func,\n  onMouseMove: prop_types.func,\n  onMouseUp: prop_types.func,\n  onTouchStart: prop_types.func,\n  onTouchMove: prop_types.func,\n  onTouchEnd: prop_types.func,\n  onMouseEnter: prop_types.func,\n  onMouseLeave: prop_types.func,\n  onMouseOut: prop_types.func,\n  onWheel: prop_types.func,\n  touchAction: prop_types.string,\n  eventRecognizerOptions: prop_types.object,\n  clickRadius: prop_types.number,\n  interactiveLayerIds: prop_types.array,\n  getCursor: prop_types.func,\n  controller: prop_types.instanceOf(MapController)\n});\n\nvar getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n      isHovering = _ref.isHovering;\n  return isDragging ? \'grabbing\' : isHovering ? \'pointer\' : \'grab\';\n};\n\nvar interactive_map_defaultProps = Object.assign({}, static_map.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onNativeClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: true,\n  dragPan: true,\n  dragRotate: true,\n  doubleClickZoom: true,\n  touchZoom: true,\n  touchRotate: false,\n  keyboard: true,\n  touchAction: \'none\',\n  eventRecognizerOptions: {},\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n});\n\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n\n  var _event$offsetCenter = event.offsetCenter,\n      x = _event$offsetCenter.x,\n      y = _event$offsetCenter.y;\n\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n\n  var pos = [x, y];\n  event.point = pos;\n  var viewport = this.viewport;\n  var location = viewport.unproject(pos, {\n    targetZ: viewport.meterOffset[2]\n  });\n  event.lngLat = [location[0], location[1]];\n  return event;\n}\n\nfunction getFeatures(pos) {\n  var map = this.map;\n\n  if (!map || !pos) {\n    return null;\n  }\n\n  var queryParams = {};\n  var size = this.props.clickRadius;\n\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n\n  try {\n    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);\n  } catch (_unused) {\n    return null;\n  }\n}\n\nfunction onEvent(callbackName, event) {\n  var func = this.props[callbackName];\n\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\n\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchStart\' : \'onMouseDown\', event);\n}\n\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchEnd\' : \'onMouseUp\', event);\n}\n\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchMove\' : \'onMouseMove\', event);\n\n  if (!this.state.isDragging) {\n    var _this$props = this.props,\n        onHover = _this$props.onHover,\n        interactiveLayerIds = _this$props.interactiveLayerIds;\n    var features;\n    event = normalizeEvent.call(this, event);\n\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n\n    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    var isEntering = isHovering && !this.state.isHovering;\n    var isExiting = !isHovering && this.state.isHovering;\n\n    if (onHover || isEntering) {\n      event.features = features;\n\n      if (onHover) {\n        onHover(event);\n      }\n    }\n\n    if (isEntering) {\n      onEvent.call(this, \'onMouseEnter\', event);\n    }\n\n    if (isExiting) {\n      onEvent.call(this, \'onMouseLeave\', event);\n    }\n\n    if (isEntering || isExiting) {\n      this.setState({\n        isHovering: isHovering\n      });\n    }\n  }\n}\n\nfunction onPointerClick(event) {\n  var _this$props2 = this.props,\n      onClick = _this$props2.onClick,\n      onNativeClick = _this$props2.onNativeClick,\n      onDblClick = _this$props2.onDblClick,\n      doubleClickZoom = _this$props2.doubleClickZoom;\n  var callbacks = [];\n  var isDoubleClickEnabled = onDblClick || doubleClickZoom;\n\n  switch (event.type) {\n    case \'anyclick\':\n      callbacks.push(onNativeClick);\n\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    case \'click\':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    default:\n  }\n\n  callbacks = callbacks.filter(Boolean);\n\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(function (cb) {\n      return cb(event);\n    });\n  }\n}\n\nfunction interactive_map_getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\n\nvar InteractiveMap = (0,react.forwardRef)(function (props, ref) {\n  var parentContext = (0,react.useContext)(map_context);\n  var controller = (0,react.useMemo)(function () {\n    return props.controller || new MapController();\n  }, []);\n  var eventManager = (0,react.useMemo)(function () {\n    return new EventManager(null, {\n      touchAction: props.touchAction,\n      recognizerOptions: props.eventRecognizerOptions\n    });\n  }, []);\n  var eventCanvasRef = (0,react.useRef)(null);\n  var staticMapRef = (0,react.useRef)(null);\n\n  var _thisRef = (0,react.useRef)({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n\n  thisRef.setState = function (newState) {\n    thisRef.state = interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.state), newState);\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n\n  var inRender = true;\n  var viewportUpdateRequested;\n  var stateUpdateRequested;\n\n  var handleViewportChange = function handleViewportChange(viewState, interactionState, oldViewState) {\n    if (inRender) {\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n\n    var _thisRef$props = thisRef.props,\n        onViewStateChange = _thisRef$props.onViewStateChange,\n        onViewportChange = _thisRef$props.onViewportChange;\n    Object.defineProperty(viewState, \'position\', {\n      get: function get() {\n        return [0, 0, getTerrainElevation(thisRef.map, viewState)];\n      }\n    });\n\n    if (onViewStateChange) {\n      onViewStateChange({\n        viewState: viewState,\n        interactionState: interactionState,\n        oldViewState: oldViewState\n      });\n    }\n\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return interactive_map_getRefHandles(staticMapRef);\n  }, []);\n  var context = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({}, parentContext), {}, {\n      eventManager: eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    });\n  }, [parentContext, eventCanvasRef.current]);\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n\n  var handleInteractionStateChange = function handleInteractionStateChange(interactionState) {\n    var _interactionState$isD = interactionState.isDragging,\n        isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;\n\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({\n        isDragging: isDragging\n      });\n    }\n\n    if (inRender) {\n      stateUpdateRequested = interactionState;\n      return;\n    }\n\n    var onInteractionStateChange = thisRef.props.onInteractionStateChange;\n\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n\n  var updateControllerOpts = function updateControllerOpts() {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions(interactive_map_objectSpread(interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.props), thisRef.props.viewState), {}, {\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager: eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      }));\n    }\n  };\n\n  var onResize = function onResize(_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({\n      width: width,\n      height: height\n    });\n  };\n\n  (0,react.useEffect)(function () {\n    eventManager.setElement(eventCanvasRef.current);\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, \'onMouseOut\'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, \'onDblClick\'),\n      wheel: onEvent.bind(thisRef, \'onWheel\'),\n      contextmenu: onEvent.bind(thisRef, \'onContextMenu\')\n    });\n    return function () {\n      eventManager.destroy();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (viewportUpdateRequested) {\n      handleViewportChange.apply(void 0, (0,toConsumableArray/* default */.Z)(viewportUpdateRequested));\n    }\n\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n  updateControllerOpts();\n  var width = props.width,\n      height = props.height,\n      style = props.style,\n      getCursor = props.getCursor;\n  var eventCanvasStyle = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({\n      position: \'relative\'\n    }, style), {}, {\n      width: width,\n      height: height,\n      cursor: getCursor(thisRef.state)\n    });\n  }, [style, width, height, getCursor, thisRef.state]);\n\n  if (!viewportUpdateRequested || !thisRef._child) {\n    thisRef._child = react.createElement(MapContextProvider, {\n      value: context\n    }, react.createElement("div", {\n      key: "event-canvas",\n      ref: eventCanvasRef,\n      style: eventCanvasStyle\n    }, react.createElement(static_map, _extends({}, props, {\n      width: "100%",\n      height: "100%",\n      style: null,\n      onResize: onResize,\n      ref: staticMapRef\n    }))));\n  }\n\n  inRender = false;\n  return thisRef._child;\n});\nInteractiveMap.supported = static_map.supported;\nInteractiveMap.propTypes = interactive_map_propTypes;\nInteractiveMap.defaultProps = interactive_map_defaultProps;\n/* harmony default export */ var interactive_map = (InteractiveMap);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/source.js\n\n\n\nfunction source_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction source_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      source_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      source_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\nvar sourceCounter = 0;\n\nfunction createSource(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = source_objectSpread({}, props);\n\n    delete options.id;\n    delete options.children;\n    map.addSource(id, options);\n    return map.getSource(id);\n  }\n\n  return null;\n}\n\nfunction updateSource(source, props, prevProps) {\n  assert(props.id === prevProps.id, \'source id changed\');\n  assert(props.type === prevProps.type, \'source type changed\');\n  var changedKey = \'\';\n  var changedKeyCount = 0;\n\n  for (var key in props) {\n    if (key !== \'children\' && key !== \'id\' && !deepEqual(prevProps[key], props[key])) {\n      changedKey = key;\n      changedKeyCount++;\n    }\n  }\n\n  if (!changedKeyCount) {\n    return;\n  }\n\n  var type = props.type;\n\n  if (type === \'geojson\') {\n    source.setData(props.data);\n  } else if (type === \'image\') {\n    source.updateImage({\n      url: props.url,\n      coordinates: props.coordinates\n    });\n  } else if ((type === \'canvas\' || type === \'video\') && changedKeyCount === 1 && changedKey === \'coordinates\') {\n    source.setCoordinates(props.coordinates);\n  } else if (type === \'vector\' && source.setUrl) {\n    switch (changedKey) {\n      case \'url\':\n        source.setUrl(props.url);\n        break;\n\n      case \'tiles\':\n        source.setTiles(props.tiles);\n        break;\n\n      default:\n    }\n  } else {\n    console.warn("Unable to update <Source> prop: ".concat(changedKey));\n  }\n}\n\nfunction Source(props) {\n  var context = useContext(MapContext);\n  var propsRef = useRef({\n    id: props.id,\n    type: props.type\n  });\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      setStyleLoaded = _useState2[1];\n\n  var id = useMemo(function () {\n    return props.id || "jsx-source-".concat(sourceCounter++);\n  }, []);\n  var map = context.map;\n  useEffect(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n\n      map.on(\'styledata\', forceUpdate);\n      return function () {\n        map.off(\'styledata\', forceUpdate);\n        requestAnimationFrame(function () {\n          if (map.style && map.style._loaded && map.getSource(id)) {\n            map.removeSource(id);\n          }\n        });\n      };\n    }\n\n    return undefined;\n  }, [map, id]);\n  var source = map && map.style && map.getSource(id);\n\n  if (source) {\n    updateSource(source, props, propsRef.current);\n  } else {\n    source = createSource(map, id, props);\n  }\n\n  propsRef.current = props;\n  return source && React.Children.map(props.children, function (child) {\n    return child && cloneElement(child, {\n      source: id\n    });\n  }) || null;\n}\n\n/* harmony default export */ var source = ((/* unused pure expression or super */ null && (Source)));\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\n\nfunction deep_equal_deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (!deep_equal_deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (Array.isArray(b)) {\n    return false;\n  }\n\n  if (_typeof(a) === \'object\' && _typeof(b) === \'object\') {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {\n      var key = _aKeys[_i];\n\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n\n      if (!deep_equal_deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/layer.js\n\n\n\n\nfunction layer_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction layer_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      layer_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      layer_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\nvar LAYER_TYPES = [\'fill\', \'line\', \'symbol\', \'circle\', \'fill-extrusion\', \'raster\', \'background\', \'heatmap\', \'hillshade\', \'sky\'];\nvar layer_propTypes = {\n  type: prop_types.oneOf(LAYER_TYPES).isRequired,\n  id: prop_types.string,\n  source: prop_types.string,\n  beforeId: prop_types.string\n};\n\nfunction diffLayerStyles(map, id, props, prevProps) {\n  var _props$layout = props.layout,\n      layout = _props$layout === void 0 ? {} : _props$layout,\n      _props$paint = props.paint,\n      paint = _props$paint === void 0 ? {} : _props$paint,\n      filter = props.filter,\n      minzoom = props.minzoom,\n      maxzoom = props.maxzoom,\n      beforeId = props.beforeId,\n      otherProps = _objectWithoutProperties(props, ["layout", "paint", "filter", "minzoom", "maxzoom", "beforeId"]);\n\n  if (beforeId !== prevProps.beforeId) {\n    map.moveLayer(id, beforeId);\n  }\n\n  if (layout !== prevProps.layout) {\n    var prevLayout = prevProps.layout || {};\n\n    for (var key in layout) {\n      if (!deep_equal_deepEqual(layout[key], prevLayout[key])) {\n        map.setLayoutProperty(id, key, layout[key]);\n      }\n    }\n\n    for (var _key in prevLayout) {\n      if (!layout.hasOwnProperty(_key)) {\n        map.setLayoutProperty(id, _key, undefined);\n      }\n    }\n  }\n\n  if (paint !== prevProps.paint) {\n    var prevPaint = prevProps.paint || {};\n\n    for (var _key2 in paint) {\n      if (!deep_equal_deepEqual(paint[_key2], prevPaint[_key2])) {\n        map.setPaintProperty(id, _key2, paint[_key2]);\n      }\n    }\n\n    for (var _key3 in prevPaint) {\n      if (!paint.hasOwnProperty(_key3)) {\n        map.setPaintProperty(id, _key3, undefined);\n      }\n    }\n  }\n\n  if (!deep_equal_deepEqual(filter, prevProps.filter)) {\n    map.setFilter(id, filter);\n  }\n\n  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n    map.setLayerZoomRange(id, minzoom, maxzoom);\n  }\n\n  for (var _key4 in otherProps) {\n    if (!deep_equal_deepEqual(otherProps[_key4], prevProps[_key4])) {\n      map.setLayerProperty(id, _key4, otherProps[_key4]);\n    }\n  }\n}\n\nfunction createLayer(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = layer_objectSpread(layer_objectSpread({}, props), {}, {\n      id: id\n    });\n\n    delete options.beforeId;\n    map.addLayer(options, props.beforeId);\n  }\n}\n\nfunction updateLayer(map, id, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, \'layer id changed\');\n  utils_assert_assert(props.type === prevProps.type, \'layer type changed\');\n\n  try {\n    diffLayerStyles(map, id, props, prevProps);\n  } catch (error) {\n    console.warn(error);\n  }\n}\n\nvar layerCounter = 0;\n\nfunction Layer(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n\n  var _useState = (0,react.useState)(0),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      setStyleLoaded = _useState2[1];\n\n  var id = (0,react.useMemo)(function () {\n    return props.id || "jsx-layer-".concat(layerCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n\n      map.on(\'styledata\', forceUpdate);\n      return function () {\n        map.off(\'styledata\', forceUpdate);\n\n        if (map.style && map.style._loaded) {\n          map.removeLayer(id);\n        }\n      };\n    }\n\n    return undefined;\n  }, [map]);\n  var layer = map && map.style && map.getLayer(id);\n\n  if (layer) {\n    updateLayer(map, id, props, propsRef.current);\n  } else {\n    createLayer(map, id, props);\n  }\n\n  propsRef.current = props;\n  return null;\n}\n\nLayer.propTypes = layer_propTypes;\n/* harmony default export */ var components_layer = ((/* unused pure expression or super */ null && (Layer)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/use-map-control.js\n\n\n\nvar mapControlDefaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\nvar mapControlPropTypes = {\n  captureScroll: prop_types.bool,\n  captureDrag: prop_types.bool,\n  captureClick: prop_types.bool,\n  captureDoubleClick: prop_types.bool,\n  capturePointerMove: prop_types.bool\n};\n\nfunction onMount(thisRef) {\n  var ref = thisRef.containerRef.current;\n  var eventManager = thisRef.context.eventManager;\n\n  if (!ref || !eventManager) {\n    return undefined;\n  }\n\n  var events = {\n    wheel: function wheel(evt) {\n      var props = thisRef.props;\n\n      if (props.captureScroll) {\n        evt.stopPropagation();\n      }\n\n      if (props.onScroll) {\n        props.onScroll(evt, thisRef);\n      }\n    },\n    panstart: function panstart(evt) {\n      var props = thisRef.props;\n\n      if (props.captureDrag) {\n        evt.stopPropagation();\n      }\n\n      if (props.onDragStart) {\n        props.onDragStart(evt, thisRef);\n      }\n    },\n    anyclick: function anyclick(evt) {\n      var props = thisRef.props;\n\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    click: function click(evt) {\n      var props = thisRef.props;\n\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    dblclick: function dblclick(evt) {\n      var props = thisRef.props;\n\n      if (props.captureDoubleClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onDoubleClick) {\n        props.onDoubleClick(evt, thisRef);\n      }\n    },\n    pointermove: function pointermove(evt) {\n      var props = thisRef.props;\n\n      if (props.capturePointerMove) {\n        evt.stopPropagation();\n      }\n\n      if (props.onPointerMove) {\n        props.onPointerMove(evt, thisRef);\n      }\n    }\n  };\n  eventManager.watch(events, ref);\n  return function () {\n    eventManager.off(events);\n  };\n}\n\nfunction useMapControl() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = (0,react.useContext)(map_context);\n  var containerRef = (0,react.useRef)(null);\n\n  var _thisRef = (0,react.useRef)({\n    props: props,\n    state: {},\n    context: context,\n    containerRef: containerRef\n  });\n\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.context = context;\n  (0,react.useEffect)(function () {\n    return onMount(thisRef);\n  }, [context.eventManager]);\n  return thisRef;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/base-control.js\n\n\n\n\n\n\n\n\n\nfunction base_control_createSuper(Derived) {\n  var hasNativeReflectConstruct = base_control_isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0,getPrototypeOf/* default */.Z)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0,getPrototypeOf/* default */.Z)(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0,possibleConstructorReturn/* default */.Z)(this, result);\n  };\n}\n\nfunction base_control_isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nfunction Control(props) {\n  var instance = props.instance;\n\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  instance._context = context;\n  instance._containerRef = containerRef;\n  return instance._render();\n}\n\nvar BaseControl = function (_PureComponent) {\n  (0,inherits/* default */.Z)(BaseControl, _PureComponent);\n\n  var _super = base_control_createSuper(BaseControl);\n\n  function BaseControl() {\n    var _this;\n\n    (0,classCallCheck/* default */.Z)(this, BaseControl);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_context", {});\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_containerRef", (0,react.createRef)());\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_onScroll", function (evt) {});\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_onDragStart", function (evt) {});\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_onDblClick", function (evt) {});\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_onClick", function (evt) {});\n\n    (0,defineProperty/* default */.Z)((0,assertThisInitialized/* default */.Z)(_this), "_onPointerMove", function (evt) {});\n\n    return _this;\n  }\n\n  (0,createClass/* default */.Z)(BaseControl, [{\n    key: "_render",\n    value: function _render() {\n      throw new Error(\'_render() not implemented\');\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react.createElement(Control, _extends({\n        instance: this\n      }, this.props, {\n        onScroll: this._onScroll,\n        onDragStart: this._onDragStart,\n        onDblClick: this._onDblClick,\n        onClick: this._onClick,\n        onPointerMove: this._onPointerMove\n      }));\n    }\n  }]);\n\n  return BaseControl;\n}(react.PureComponent);\n\n(0,defineProperty/* default */.Z)(BaseControl, "propTypes", mapControlPropTypes);\n\n(0,defineProperty/* default */.Z)(BaseControl, "defaultProps", mapControlDefaultProps);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/draggable-control.js\n\n\n\nfunction draggable_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction draggable_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      draggable_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      draggable_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {\n  draggable: prop_types.bool,\n  onDrag: prop_types.func,\n  onDragEnd: prop_types.func,\n  onDragStart: prop_types.func,\n  offsetLeft: prop_types.number,\n  offsetTop: prop_types.number\n});\nvar draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {\n  draggable: false,\n  offsetLeft: 0,\n  offsetTop: 0\n});\n\nfunction getDragEventPosition(event) {\n  var _event$offsetCenter = event.offsetCenter,\n      x = _event$offsetCenter.x,\n      y = _event$offsetCenter.y;\n  return [x, y];\n}\n\nfunction getDragEventOffset(event, container) {\n  var _event$center = event.center,\n      x = _event$center.x,\n      y = _event$center.y;\n\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    return [rect.left - x, rect.top - y];\n  }\n\n  return null;\n}\n\nfunction getDragLngLat(dragPos, dragOffset, props, context) {\n  var x = dragPos[0] + dragOffset[0] - props.offsetLeft;\n  var y = dragPos[1] + dragOffset[1] - props.offsetTop;\n  return context.viewport.unproject([x, y]);\n}\n\nfunction onDragStart(event, _ref) {\n  var props = _ref.props,\n      callbacks = _ref.callbacks,\n      state = _ref.state,\n      context = _ref.context,\n      containerRef = _ref.containerRef;\n  var draggable = props.draggable;\n\n  if (!draggable) {\n    return;\n  }\n\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  var dragOffset = getDragEventOffset(event, containerRef.current);\n  state.setDragPos(dragPos);\n  state.setDragOffset(dragOffset);\n\n  if (callbacks.onDragStart && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragStart(callbackEvent);\n  }\n}\n\nfunction onDrag(event, _ref2) {\n  var props = _ref2.props,\n      callbacks = _ref2.callbacks,\n      state = _ref2.state,\n      context = _ref2.context;\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  state.setDragPos(dragPos);\n  var dragOffset = state.dragOffset;\n\n  if (callbacks.onDrag && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDrag(callbackEvent);\n  }\n}\n\nfunction onDragEnd(event, _ref3) {\n  var props = _ref3.props,\n      callbacks = _ref3.callbacks,\n      state = _ref3.state,\n      context = _ref3.context;\n  event.stopPropagation();\n  var dragPos = state.dragPos,\n      dragOffset = state.dragOffset;\n  state.setDragPos(null);\n  state.setDragOffset(null);\n\n  if (callbacks.onDragEnd && dragPos && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragEnd(callbackEvent);\n  }\n}\n\nfunction onDragCancel(event, _ref4) {\n  var state = _ref4.state;\n  event.stopPropagation();\n  state.setDragPos(null);\n  state.setDragOffset(null);\n}\n\nfunction registerEvents(thisRef) {\n  var eventManager = thisRef.context.eventManager;\n\n  if (!eventManager || !thisRef.state.dragPos) {\n    return undefined;\n  }\n\n  var events = {\n    panmove: function panmove(evt) {\n      return onDrag(evt, thisRef);\n    },\n    panend: function panend(evt) {\n      return onDragEnd(evt, thisRef);\n    },\n    pancancel: function pancancel(evt) {\n      return onDragCancel(evt, thisRef);\n    }\n  };\n  eventManager.watch(events);\n  return function () {\n    eventManager.off(events);\n  };\n}\n\nfunction useDraggableControl(props) {\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      dragPos = _useState2[0],\n      setDragPos = _useState2[1];\n\n  var _useState3 = (0,react.useState)(null),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      dragOffset = _useState4[0],\n      setDragOffset = _useState4[1];\n\n  var thisRef = useMapControl(draggable_control_objectSpread(draggable_control_objectSpread({}, props), {}, {\n    onDragStart: onDragStart\n  }));\n  thisRef.callbacks = props;\n  thisRef.state.dragPos = dragPos;\n  thisRef.state.setDragPos = setDragPos;\n  thisRef.state.dragOffset = dragOffset;\n  thisRef.state.setDragOffset = setDragOffset;\n  (0,react.useEffect)(function () {\n    return registerEvents(thisRef);\n  }, [thisRef.context.eventManager, Boolean(dragPos)]);\n  return thisRef;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/crisp-pixel.js\nvar pixelRatio = typeof window !== \'undefined\' && window.devicePixelRatio || 1;\nvar crispPixel = function crispPixel(size) {\n  return Math.round(size * pixelRatio) / pixelRatio;\n};\nvar crispPercentage = function crispPercentage(el, percentage) {\n  var dimension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'x\';\n\n  if (el === null) {\n    return percentage;\n  }\n\n  var origSize = dimension === \'x\' ? el.offsetWidth : el.offsetHeight;\n  return crispPixel(percentage / 100 * origSize) / origSize * 100;\n};\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/marker.js\n\n\n\n\n\n\nvar marker_defaultProps = Object.assign({}, draggableControlDefaultProps, {\n  className: \'\'\n});\n\nfunction getPosition(_ref) {\n  var props = _ref.props,\n      state = _ref.state,\n      context = _ref.context;\n  var longitude = props.longitude,\n      latitude = props.latitude,\n      offsetLeft = props.offsetLeft,\n      offsetTop = props.offsetTop;\n  var dragPos = state.dragPos,\n      dragOffset = state.dragOffset;\n  var viewport = context.viewport,\n      map = context.map;\n\n  if (dragPos && dragOffset) {\n    return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];\n  }\n\n  var altitude = getTerrainElevation(map, {\n    longitude: longitude,\n    latitude: latitude\n  });\n\n  var _viewport$project = viewport.project([longitude, latitude, altitude]),\n      _viewport$project2 = slicedToArray_slicedToArray(_viewport$project, 2),\n      x = _viewport$project2[0],\n      y = _viewport$project2[1];\n\n  x += offsetLeft;\n  y += offsetTop;\n  return [x, y];\n}\n\nfunction Marker(props) {\n  var thisRef = useDraggableControl(props);\n  var state = thisRef.state,\n      containerRef = thisRef.containerRef;\n  var children = props.children,\n      className = props.className,\n      draggable = props.draggable;\n  var dragPos = state.dragPos;\n\n  var _getPosition = getPosition(thisRef),\n      _getPosition2 = slicedToArray_slicedToArray(_getPosition, 2),\n      x = _getPosition2[0],\n      y = _getPosition2[1];\n\n  var transform = "translate(".concat(crispPixel(x), "px, ").concat(crispPixel(y), "px)");\n  var cursor = draggable ? dragPos ? \'grabbing\' : \'grab\' : \'auto\';\n  var control = (0,react.useMemo)(function () {\n    var containerStyle = {\n      position: \'absolute\',\n      left: 0,\n      top: 0,\n      transform: transform,\n      cursor: cursor\n    };\n    return react.createElement("div", {\n      className: "mapboxgl-marker ".concat(className),\n      ref: thisRef.containerRef,\n      style: containerStyle\n    }, children);\n  }, [children, className]);\n  var container = containerRef.current;\n\n  if (container) {\n    container.style.transform = transform;\n    container.style.cursor = cursor;\n  }\n\n  return control;\n}\n\nMarker.defaultProps = marker_defaultProps;\n/* harmony default export */ var marker = (react.memo(Marker));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/dynamic-position.js\nvar ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  \'top-left\': {\n    x: 0,\n    y: 0\n  },\n  \'top-right\': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  \'bottom-left\': {\n    x: 0,\n    y: 1\n  },\n  \'bottom-right\': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nfunction getDynamicPosition(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      selfWidth = _ref.selfWidth,\n      selfHeight = _ref.selfHeight,\n      anchor = _ref.anchor,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n      anchorX = _ANCHOR_POSITION$anch.x,\n      anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n  if (cutoffY > 0) {\n    var bestAnchorY = anchorY;\n    var minCutoff = cutoffY;\n\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n\n    anchorY = bestAnchorY;\n  }\n\n  var xStep = 0.5;\n\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n  if (cutoffX > 0) {\n    var bestAnchorX = anchorX;\n    var _minCutoff = cutoffX;\n\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n      if (cutoffX < _minCutoff) {\n        _minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n\n    anchorX = bestAnchorX;\n  }\n\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/popup.js\n\n\n\nfunction popup_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction popup_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      popup_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      popup_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\nvar popup_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  offsetLeft: 0,\n  offsetTop: 0,\n  tipSize: 10,\n  anchor: \'bottom\',\n  dynamicPosition: true,\n  sortByDepth: false,\n  closeButton: true,\n  closeOnClick: true,\n  onClose: function onClose() {}\n});\n\nfunction popup_getPosition(props, viewport, el, _ref) {\n  var _ref2 = slicedToArray_slicedToArray(_ref, 2),\n      x = _ref2[0],\n      y = _ref2[1];\n\n  var anchor = props.anchor,\n      dynamicPosition = props.dynamicPosition,\n      tipSize = props.tipSize;\n\n  if (el) {\n    return dynamicPosition ? getDynamicPosition({\n      x: x,\n      y: y,\n      anchor: anchor,\n      padding: tipSize,\n      width: viewport.width,\n      height: viewport.height,\n      selfWidth: el.clientWidth,\n      selfHeight: el.clientHeight\n    }) : anchor;\n  }\n\n  return anchor;\n}\n\nfunction getContainerStyle(props, viewport, el, _ref3, positionType) {\n  var _ref4 = slicedToArray_slicedToArray(_ref3, 3),\n      x = _ref4[0],\n      y = _ref4[1],\n      z = _ref4[2];\n\n  var offsetLeft = props.offsetLeft,\n      offsetTop = props.offsetTop,\n      sortByDepth = props.sortByDepth;\n  var anchorPosition = ANCHOR_POSITION[positionType];\n  var left = x + offsetLeft;\n  var top = y + offsetTop;\n  var xPercentage = crispPercentage(el, -anchorPosition.x * 100);\n  var yPercentage = crispPercentage(el, -anchorPosition.y * 100, \'y\');\n  var style = {\n    position: \'absolute\',\n    transform: "\\n      translate(".concat(xPercentage, "%, ").concat(yPercentage, "%)\\n      translate(").concat(crispPixel(left), "px, ").concat(crispPixel(top), "px)\\n    "),\n    display: undefined,\n    zIndex: undefined\n  };\n\n  if (!sortByDepth) {\n    return style;\n  }\n\n  if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {\n    style.display = \'none\';\n  } else {\n    style.zIndex = Math.floor((1 - z) / 2 * 100000);\n  }\n\n  return style;\n}\n\nfunction onClick(evt, _ref5) {\n  var props = _ref5.props,\n      context = _ref5.context;\n\n  if (props.closeOnClick || evt.target.className === \'mapboxgl-popup-close-button\') {\n    props.onClose();\n\n    if (context.eventManager) {\n      context.eventManager.once(\'click\', function (e) {\n        return e.stopPropagation();\n      }, evt.target);\n    }\n  }\n}\n\nfunction Popup(props) {\n  var contentRef = (0,react.useRef)(null);\n  var thisRef = useMapControl(popup_objectSpread(popup_objectSpread({}, props), {}, {\n    onClick: onClick\n  }));\n  var context = thisRef.context,\n      containerRef = thisRef.containerRef;\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      setLoaded = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    setLoaded(true);\n  }, [contentRef.current]);\n  var viewport = context.viewport,\n      map = context.map;\n  var className = props.className,\n      longitude = props.longitude,\n      latitude = props.latitude,\n      tipSize = props.tipSize,\n      closeButton = props.closeButton,\n      children = props.children;\n  var altitude = props.altitude;\n\n  if (altitude === undefined) {\n    altitude = getTerrainElevation(map, {\n      longitude: longitude,\n      latitude: latitude\n    });\n  }\n\n  var position = viewport.project([longitude, latitude, altitude]);\n  var positionType = popup_getPosition(props, viewport, contentRef.current, position);\n  var containerStyle = getContainerStyle(props, viewport, containerRef.current, position, positionType);\n  var onReactClick = (0,react.useCallback)(function (e) {\n    return !context.eventManager && onClick(e, thisRef);\n  }, [context.eventManager]);\n  return react.createElement("div", {\n    className: "mapboxgl-popup mapboxgl-popup-anchor-".concat(positionType, " ").concat(className),\n    style: containerStyle,\n    ref: containerRef\n  }, react.createElement("div", {\n    key: "tip",\n    className: "mapboxgl-popup-tip",\n    style: {\n      borderWidth: tipSize\n    }\n  }), react.createElement("div", {\n    key: "content",\n    ref: contentRef,\n    className: "mapboxgl-popup-content",\n    onClick: onReactClick\n  }, closeButton && react.createElement("button", {\n    key: "close-button",\n    className: "mapboxgl-popup-close-button",\n    type: "button"\n  }, "\\xD7"), children));\n}\n\nPopup.defaultProps = popup_defaultProps;\n/* harmony default export */ var popup = (react.memo(Popup));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/attribution-control.js\n\n\n\nfunction attribution_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction attribution_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      attribution_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      attribution_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\nvar attribution_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  toggleLabel: \'Toggle Attribution\'\n});\n\nfunction setupAttributioncontrol(opts, map, container, attributionContainer) {\n  var control = new (maplibre_gl_default()).AttributionControl(opts);\n  control._map = map;\n  control._container = container;\n  control._innerContainer = attributionContainer;\n\n  control._updateAttributions();\n\n  control._updateEditLink();\n\n  map.on(\'styledata\', control._updateData);\n  map.on(\'sourcedata\', control._updateData);\n  return control;\n}\n\nfunction removeAttributionControl(control) {\n  control._map.off(\'styledata\', control._updateData);\n\n  control._map.off(\'sourcedata\', control._updateData);\n}\n\nfunction AttributionControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var innerContainerRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      showCompact = _useState2[0],\n      setShowCompact = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    var control;\n\n    if (context.map) {\n      control = setupAttributioncontrol({\n        customAttribution: props.customAttribution\n      }, context.map, containerRef.current, innerContainerRef.current);\n    }\n\n    return function () {\n      return control && removeAttributionControl(control);\n    };\n  }, [context.map]);\n  var compact = props.compact === undefined ? context.viewport.width <= 640 : props.compact;\n  (0,react.useEffect)(function () {\n    if (!compact && showCompact) {\n      setShowCompact(false);\n    }\n  }, [compact]);\n  var toggleAttribution = (0,react.useCallback)(function () {\n    return setShowCompact(function (value) {\n      return !value;\n    });\n  }, []);\n  var style = (0,react.useMemo)(function () {\n    return attribution_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: props.className\n  }, react.createElement("div", {\n    ref: containerRef,\n    "aria-pressed": showCompact,\n    className: "mapboxgl-ctrl mapboxgl-ctrl-attrib ".concat(compact ? \'mapboxgl-compact\' : \'\', " ").concat(showCompact ? \'mapboxgl-compact-show\' : \'\')\n  }, react.createElement("button", {\n    type: "button",\n    className: "mapboxgl-ctrl-attrib-button",\n    title: props.toggleLabel,\n    onClick: toggleAttribution\n  }), react.createElement("div", {\n    ref: innerContainerRef,\n    className: "mapboxgl-ctrl-attrib-inner",\n    role: "list"\n  })));\n}\n\nAttributionControl.defaultProps = attribution_control_defaultProps;\n/* harmony default export */ var attribution_control = (react.memo(AttributionControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\n\n\n\nfunction fullscreen_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction fullscreen_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      fullscreen_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      fullscreen_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\nvar fullscreen_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  container: null,\n  label: \'Toggle fullscreen\'\n});\n\nfunction FullscreenControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      isFullscreen = _useState2[0],\n      setIsFullscreen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      showButton = _useState4[0],\n      setShowButton = _useState4[1];\n\n  var _useState5 = (0,react.useState)(null),\n      _useState6 = slicedToArray_slicedToArray(_useState5, 2),\n      mapboxFullscreenControl = _useState6[0],\n      createMapboxFullscreenControl = _useState6[1];\n\n  (0,react.useEffect)(function () {\n    var control = new (maplibre_gl_default()).FullscreenControl();\n    createMapboxFullscreenControl(control);\n    setShowButton(control._checkFullscreenSupport());\n\n    var onFullscreenChange = function onFullscreenChange() {\n      var nextState = !control._fullscreen;\n      control._fullscreen = nextState;\n      setIsFullscreen(nextState);\n    };\n\n    document_.addEventListener(control._fullscreenchange, onFullscreenChange);\n    return function () {\n      document_.removeEventListener(control._fullscreenchange, onFullscreenChange);\n    };\n  }, []);\n\n  var onClickFullscreen = function onClickFullscreen() {\n    if (mapboxFullscreenControl) {\n      mapboxFullscreenControl._container = props.container || context.container;\n\n      mapboxFullscreenControl._onClickFullscreen();\n    }\n  };\n\n  var style = (0,react.useMemo)(function () {\n    return fullscreen_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n\n  if (!showButton) {\n    return null;\n  }\n\n  var className = props.className,\n      label = props.label;\n  var type = isFullscreen ? \'shrink\' : \'fullscreen\';\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, react.createElement("button", {\n    key: type,\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),\n    type: "button",\n    title: label,\n    onClick: onClickFullscreen\n  }, react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }))));\n}\n\nFullscreenControl.defaultProps = fullscreen_control_defaultProps;\n/* harmony default export */ var fullscreen_control = (react.memo(FullscreenControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/geolocate-utils.js\nvar supported;\nfunction isGeolocationSupported() {\n  if (supported !== undefined) {\n    return Promise.resolve(supported);\n  }\n\n  if (window.navigator.permissions !== undefined) {\n    return window.navigator.permissions.query({\n      name: \'geolocation\'\n    }).then(function (p) {\n      supported = p.state !== \'denied\';\n      return supported;\n    });\n  }\n\n  supported = Boolean(window.navigator.geolocation);\n  return Promise.resolve(supported);\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\n\n\n\nfunction geolocate_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction geolocate_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      geolocate_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      geolocate_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\nvar geolocate_control_noop = function noop() {};\n\nvar geolocate_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  label: \'Find My Location\',\n  disabledLabel: \'Location Not Available\',\n  auto: false,\n  positionOptions: {\n    enableHighAccuracy: false,\n    timeout: 6000\n  },\n  fitBoundsOptions: {\n    maxZoom: 15\n  },\n  trackUserLocation: false,\n  showUserLocation: true,\n  showAccuracyCircle: true,\n  onGeolocate: function onGeolocate() {}\n});\n\nfunction geolocate_control_getBounds(position) {\n  var center = new (maplibre_gl_default()).LngLat(position.coords.longitude, position.coords.latitude);\n  var radius = position.coords.accuracy;\n  var bounds = center.toBounds(radius);\n  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n}\n\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  var control = new (maplibre_gl_default()).GeolocateControl(props);\n  control._container = document_.createElement(\'div\');\n  control._map = {\n    on: function on() {},\n    _getUIString: function _getUIString() {\n      return \'\';\n    }\n  };\n\n  control._setupUI(true);\n\n  control._map = context.map;\n  control._geolocateButton = geolocateButton;\n  var eventManager = context.eventManager;\n\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on(\'panstart\', function () {\n      if (control._watchState === \'ACTIVE_LOCK\') {\n        control._watchState = \'BACKGROUND\';\n        geolocateButton.classList.add(\'mapboxgl-ctrl-geolocate-background\');\n        geolocateButton.classList.remove(\'mapboxgl-ctrl-geolocate-active\');\n      }\n    });\n  }\n\n  control.on(\'geolocate\', props.onGeolocate);\n  return control;\n}\n\nfunction updateCamera(position, _ref) {\n  var context = _ref.context,\n      props = _ref.props;\n  var bounds = geolocate_control_getBounds(position);\n\n  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions),\n      longitude = _context$viewport$fit.longitude,\n      latitude = _context$viewport$fit.latitude,\n      zoom = _context$viewport$fit.zoom;\n\n  var newViewState = Object.assign({}, context.viewport, {\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var mapState = new MapState(newViewState);\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || geolocate_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || geolocate_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\n\nfunction GeolocateControl(props) {\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n      containerRef = thisRef.containerRef;\n  var geolocateButtonRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      mapboxGeolocateControl = _useState2[0],\n      createMapboxGeolocateControl = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      supportsGeolocation = _useState4[0],\n      setSupportsGeolocation = _useState4[1];\n\n  (0,react.useEffect)(function () {\n    var control;\n\n    if (context.map) {\n      isGeolocationSupported().then(function (result) {\n        setSupportsGeolocation(result);\n\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n\n          control._updateCamera = function (position) {\n            return updateCamera(position, thisRef);\n          };\n\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n\n    return function () {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n  var triggerGeolocate = (0,react.useCallback)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n  (0,react.useEffect)(function () {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n  (0,react.useEffect)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n  var className = props.className,\n      label = props.label,\n      disabledLabel = props.disabledLabel,\n      trackUserLocation = props.trackUserLocation;\n  var style = (0,react.useMemo)(function () {\n    return geolocate_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    key: "geolocate-control",\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, react.createElement("button", {\n    key: "geolocate",\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",\n    ref: geolocateButtonRef,\n    disabled: !supportsGeolocation,\n    "aria-pressed": !trackUserLocation,\n    type: "button",\n    title: supportsGeolocation ? label : disabledLabel,\n    "aria-label": supportsGeolocation ? label : disabledLabel,\n    onClick: triggerGeolocate\n  }, react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }))));\n}\n\nGeolocateControl.defaultProps = geolocate_control_defaultProps;\n/* harmony default export */ var geolocate_control = (react.memo(GeolocateControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/version.js\nfunction compareVersions(version1, version2) {\n  var v1 = (version1 || \'\').split(\'.\').map(Number);\n  var v2 = (version2 || \'\').split(\'.\').map(Number);\n\n  for (var i = 0; i < 3; i++) {\n    var part1 = v1[i] || 0;\n    var part2 = v2[i] || 0;\n\n    if (part1 < part2) {\n      return -1;\n    }\n\n    if (part1 > part2) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/navigation-control.js\n\n\nfunction navigation_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction navigation_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      navigation_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      navigation_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\nvar navigation_control_noop = function noop() {};\n\nvar navigation_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  showCompass: true,\n  showZoom: true,\n  zoomInLabel: \'Zoom In\',\n  zoomOutLabel: \'Zoom Out\',\n  compassLabel: \'Reset North\'\n});\nvar VERSION_LEGACY = 1;\nvar VERSION_1_6 = 2;\n\nfunction getUIVersion(mapboxVersion) {\n  return compareVersions(mapboxVersion, \'1.6.0\') >= 0 ? VERSION_1_6 : VERSION_LEGACY;\n}\n\nfunction updateViewport(context, props, opts) {\n  var viewport = context.viewport;\n  var mapState = new MapState(Object.assign({}, viewport, opts));\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || navigation_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || navigation_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\n\nfunction renderButton(type, label, callback, children) {\n  return react.createElement("button", {\n    key: type,\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),\n    type: "button",\n    title: label,\n    onClick: callback\n  }, children || react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }));\n}\n\nfunction renderCompass(context) {\n  var uiVersion = (0,react.useMemo)(function () {\n    return context.map ? getUIVersion(context.map.version) : VERSION_1_6;\n  }, [context.map]);\n  var bearing = context.viewport.bearing;\n  var style = {\n    transform: "rotate(".concat(-bearing, "deg)")\n  };\n  return uiVersion === VERSION_1_6 ? react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true",\n    style: style\n  }) : react.createElement("span", {\n    className: "mapboxgl-ctrl-compass-arrow",\n    style: style\n  });\n}\n\nfunction NavigationControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var onZoomIn = function onZoomIn() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom + 1\n    });\n  };\n\n  var onZoomOut = function onZoomOut() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom - 1\n    });\n  };\n\n  var onResetNorth = function onResetNorth() {\n    updateViewport(context, props, {\n      bearing: 0,\n      pitch: 0\n    });\n  };\n\n  var className = props.className,\n      showCompass = props.showCompass,\n      showZoom = props.showZoom,\n      zoomInLabel = props.zoomInLabel,\n      zoomOutLabel = props.zoomOutLabel,\n      compassLabel = props.compassLabel;\n  var style = (0,react.useMemo)(function () {\n    return navigation_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, showZoom && renderButton(\'zoom-in\', zoomInLabel, onZoomIn), showZoom && renderButton(\'zoom-out\', zoomOutLabel, onZoomOut), showCompass && renderButton(\'compass\', compassLabel, onResetNorth, renderCompass(context))));\n}\n\nNavigationControl.defaultProps = navigation_control_defaultProps;\n/* harmony default export */ var navigation_control = (react.memo(NavigationControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/scale-control.js\n\n\n\nfunction scale_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction scale_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      scale_control_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      scale_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\nvar scale_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  maxWidth: 100,\n  unit: \'metric\'\n});\n\nfunction ScaleControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      mapboxScaleControl = _useState2[0],\n      createMapboxScaleControl = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    if (context.map) {\n      var control = new (maplibre_gl_default()).ScaleControl();\n      control._map = context.map;\n      control._container = containerRef.current;\n      createMapboxScaleControl(control);\n    }\n  }, [context.map]);\n\n  if (mapboxScaleControl) {\n    mapboxScaleControl.options = props;\n\n    mapboxScaleControl._onMove();\n  }\n\n  var style = (0,react.useMemo)(function () {\n    return scale_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: props.className\n  }, react.createElement("div", {\n    ref: containerRef,\n    className: "mapboxgl-ctrl mapboxgl-ctrl-scale"\n  }));\n}\n\nScaleControl.defaultProps = scale_control_defaultProps;\n/* harmony default export */ var scale_control = (react.memo(ScaleControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/canvas-overlay.js\n\n\n\n\nvar canvas_overlay_pixelRatio = typeof window !== \'undefined\' && window.devicePixelRatio || 1;\nvar canvas_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction CanvasOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      ctx = _useState2[0],\n      setDrawingContext = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    setDrawingContext(containerRef.current.getContext(\'2d\'));\n  }, []);\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  if (ctx) {\n    ctx.save();\n    ctx.scale(canvas_overlay_pixelRatio, canvas_overlay_pixelRatio);\n    props.redraw({\n      width: viewport.width,\n      height: viewport.height,\n      ctx: ctx,\n      isDragging: isDragging,\n      project: viewport.project,\n      unproject: viewport.unproject\n    });\n    ctx.restore();\n  }\n\n  return react.createElement("canvas", {\n    ref: containerRef,\n    width: viewport.width * canvas_overlay_pixelRatio,\n    height: viewport.height * canvas_overlay_pixelRatio,\n    style: {\n      width: "".concat(viewport.width, "px"),\n      height: "".concat(viewport.height, "px"),\n      position: \'absolute\',\n      left: 0,\n      top: 0\n    }\n  });\n}\n\nCanvasOverlay.defaultProps = canvas_overlay_defaultProps;\n/* harmony default export */ var canvas_overlay = ((/* unused pure expression or super */ null && (CanvasOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/html-overlay.js\n\n\nfunction html_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction html_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      html_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      html_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar html_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction HTMLOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  var style = html_overlay_objectSpread({\n    position: \'absolute\',\n    left: 0,\n    top: 0,\n    width: viewport.width,\n    height: viewport.height\n  }, props.style);\n\n  return react.createElement("div", {\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\n\nHTMLOverlay.defaultProps = html_overlay_defaultProps;\n/* harmony default export */ var html_overlay = ((/* unused pure expression or super */ null && (HTMLOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/svg-overlay.js\n\n\nfunction svg_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction svg_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      svg_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        (0,defineProperty/* default */.Z)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      svg_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar svg_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction SVGOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  var style = svg_overlay_objectSpread({\n    position: \'absolute\',\n    left: 0,\n    top: 0\n  }, props.style);\n\n  return react.createElement("svg", {\n    width: viewport.width,\n    height: viewport.height,\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\n\nSVGOverlay.defaultProps = svg_overlay_defaultProps;\n/* harmony default export */ var svg_overlay = ((/* unused pure expression or super */ null && (SVGOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/set-rtl-text-plugin.js\n\nvar setRTLTextPlugin = (maplibre_gl_default()) ? (maplibre_gl_default()).setRTLTextPlugin : function () {};\n/* harmony default export */ var set_rtl_text_plugin = ((/* unused pure expression or super */ null && (setRTLTextPlugin)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/components/J40Map.module.scss\n// extracted by mini-css-extract-plugin\nvar j40Popup = "J40Map-module--j40Popup--3yJGr";\nvar navigationControls = "J40Map-module--navigationControls--EbBVV";\nvar zoomButton = "J40Map-module--zoomButton--1dRVE";\nvar zoomContainer = "J40Map-module--zoomContainer--3ATqb";\n;// CONCATENATED MODULE: ./node_modules/@turf/helpers/dist/es/index.js\n/**\n * @module helpers\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: earthRadius / 111325,\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   "type": "Point",\n *   "coordinates": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\n\nfunction es_feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var feat = {\n    type: "Feature"\n  };\n\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = "Point";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\n\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n\n  switch (type) {\n    case "Point":\n      return es_point(coordinates).geometry;\n\n    case "LineString":\n      return es_lineString(coordinates).geometry;\n\n    case "Polygon":\n      return polygon(coordinates).geometry;\n\n    case "MultiPoint":\n      return multiPoint(coordinates).geometry;\n\n    case "MultiLineString":\n      return multiLineString(coordinates).geometry;\n\n    case "MultiPolygon":\n      return multiPolygon(coordinates).geometry;\n\n    default:\n      throw new Error(type + " is invalid");\n  }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\n\nfunction es_point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!coordinates) {\n    throw new Error("coordinates is required");\n  }\n\n  if (!Array.isArray(coordinates)) {\n    throw new Error("coordinates must be an Array");\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error("coordinates must be at least 2 numbers long");\n  }\n\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error("coordinates must contain numbers");\n  }\n\n  var geom = {\n    type: "Point",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\n\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return es_point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: \'poly1\' });\n *\n * //=polygon\n */\n\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n\n    if (ring.length < 4) {\n      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error("First and last Position are not equivalent.");\n      }\n    }\n  }\n\n  var geom = {\n    type: "Polygon",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\n\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: \'line 1\'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: \'line 2\'});\n *\n * //=linestring1\n * //=linestring2\n */\n\nfunction es_lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error("coordinates must be an array of two or more positions");\n  }\n\n  var geom = {\n    type: "LineString",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\n\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return es_lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: \'Location A\'});\n * var locationB = turf.point([-75.833, 39.284], {name: \'Location B\'});\n * var locationC = turf.point([-75.534, 39.123], {name: \'Location C\'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\n\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fc = {\n    type: "FeatureCollection"\n  };\n\n  if (options.id) {\n    fc.id = options.id;\n  }\n\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\n\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiLineString",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\n\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiPoint",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\n\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiPolygon",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry("Point", [100, 0]);\n * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\n\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "GeometryCollection",\n    geometries: geometries\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\n\nfunction es_round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n\n  if (precision && !(precision >= 0)) {\n    throw new Error("precision must be a positive number");\n  }\n\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\n\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = "kilometers";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + " units is invalid");\n  }\n\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\n\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = "kilometers";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + " units is invalid");\n  }\n\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\n\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\n\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\n\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\n\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit="kilometers"] of the length\n * @param {Units} [finalUnit="kilometers"] returned unit\n * @returns {number} the converted length\n */\n\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = "kilometers";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = "kilometers";\n  }\n\n  if (!(length >= 0)) {\n    throw new Error("length must be a positive number");\n  }\n\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit="meters"] of the distance\n * @param {Units} [finalUnit="kilometers"] returned unit\n * @returns {number} the converted area\n */\n\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = "meters";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = "kilometers";\n  }\n\n  if (!(area >= 0)) {\n    throw new Error("area must be a positive number");\n  }\n\n  var startFactor = areaFactors[originalUnit];\n\n  if (!startFactor) {\n    throw new Error("invalid original units");\n  }\n\n  var finalFactor = areaFactors[finalUnit];\n\n  if (!finalFactor) {\n    throw new Error("invalid final units");\n  }\n\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber(\'foo\')\n * //=false\n */\n\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject(\'foo\')\n * //=false\n */\n\nfunction es_isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox(\'Foo\')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\n\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error("bbox is required");\n  }\n\n  if (!Array.isArray(bbox)) {\n    throw new Error("bbox must be an Array");\n  }\n\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error("bbox must be an Array of 4 or 6 numbers");\n  }\n\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error("bbox must only contain numbers");\n    }\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId(\'Foo\')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\n\nfunction validateId(id) {\n  if (!id) {\n    throw new Error("id is required");\n  }\n\n  if (["string", "number"].indexOf(typeof id) === -1) {\n    throw new Error("id must be a number or a string");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@turf/meta/dist/es/index.js\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n      k,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      coordIndex = 0,\n      isGeometryCollection,\n      type = geojson.type,\n      isFeatureCollection = type === "FeatureCollection",\n      isFeature = type === "Feature",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it\'s trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don\'t apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it\'s called \'geometry\'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry\n\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n\n        case "Point":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n\n        case "LineString":\n        case "MultiPoint":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === "MultiPoint") multiFeatureIndex++;\n          }\n\n          if (geomType === "LineString") multiFeatureIndex++;\n          break;\n\n        case "Polygon":\n        case "MultiLineString":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n\n            if (geomType === "MultiLineString") multiFeatureIndex++;\n            if (geomType === "Polygon") geometryIndex++;\n          }\n\n          if (geomType === "Polygon") multiFeatureIndex++;\n          break;\n\n        case "MultiPolygon":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n\n              geometryIndex++;\n            }\n\n            multiFeatureIndex++;\n          }\n\n          break;\n\n        case "GeometryCollection":\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          }\n\n          break;\n\n        default:\n          throw new Error("Unknown Geometry Type");\n      }\n    }\n  }\n}\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\n\n\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\n\n\nfunction propEach(geojson, callback) {\n  var i;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n\n      break;\n\n    case "Feature":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\n\n\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: \'bar\'}),\n *   turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\n\n\nfunction featureEach(geojson, callback) {\n  if (geojson.type === "Feature") {\n    callback(geojson, 0);\n  } else if (geojson.type === "FeatureCollection") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: \'bar\'}),\n *   turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\n\n\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\n\n\nfunction geomEach(geojson, callback) {\n  var i,\n      j,\n      g,\n      geometry,\n      stopG,\n      geometryMaybeCollection,\n      isGeometryCollection,\n      featureProperties,\n      featureBBox,\n      featureId,\n      featureIndex = 0,\n      isFeatureCollection = geojson.type === "FeatureCollection",\n      isFeature = geojson.type === "Feature",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it\'s trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don\'t apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it\'s called \'geometry\'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry\n\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n\n      switch (geometry.type) {\n        case "Point":\n        case "LineString":\n        case "MultiPoint":\n        case "Polygon":\n        case "MultiLineString":\n        case "MultiPolygon":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n\n        case "GeometryCollection":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error("Unknown Geometry Type");\n      }\n    } // Only increase `featureIndex` per each feature\n\n\n    featureIndex++;\n  }\n}\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\n\n\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: \'world\'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\n\n\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n\n    switch (type) {\n      case null:\n      case "Point":\n      case "LineString":\n      case "Polygon":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n\n    var geomType; // Callback for multi-geometry\n\n    switch (type) {\n      case "MultiPoint":\n        geomType = "Point";\n        break;\n\n      case "MultiLineString":\n        geomType = "LineString";\n        break;\n\n      case "MultiPolygon":\n        geomType = "Polygon";\n        break;\n    }\n\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: \'world\'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\n\n\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0; // Exclude null Geometries\n\n    if (!feature$$1.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n\n    var type = feature$$1.geometry.type;\n    if (type === "Point" || type === "MultiPoint") return; // Generate 2-vertex line segments\n\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n\n      var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\n\n\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\n\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error("geojson is required");\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n\n    switch (type) {\n      case "LineString":\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n\n      case "Polygon":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n\n        break;\n    }\n  });\n}\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\n\n\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\n\n\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error("options is invalid");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case "Feature":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n    case "Polygon":\n    case "MultiLineString":\n    case "MultiPolygon":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error("geojson is invalid");\n  } // Find SegmentIndex\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n\n    case "Polygon":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n\n    case "MultiLineString":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n\n    case "MultiPolygon":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n\n  throw new Error("geojson is invalid");\n}\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\n\n\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error("options is invalid");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case "Feature":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n    case "Polygon":\n    case "MultiLineString":\n    case "MultiPolygon":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error("geojson is invalid");\n  } // Find Coord Index\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case "Point":\n      return point(coords, properties, options);\n\n    case "MultiPoint":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n\n    case "LineString":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n\n    case "Polygon":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n\n    case "MultiLineString":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n\n    case "MultiPolygon":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n\n  throw new Error("geojson is invalid");\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/@turf/bbox/dist/es/index.js\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\n\nfunction bbox(geojson) {\n  var result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, function (coord) {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\n\nbbox["default"] = bbox;\n/* harmony default export */ var es = (bbox);\n;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n;// CONCATENATED MODULE: ./src/components/J40Map.tsx\n/* eslint-disable no-unused-vars */;var J40Map=function J40Map(_ref){var setDetailViewData=_ref.setDetailViewData;var _useState=(0,react.useState)({latitude:DEFAULT_CENTER[0],longitude:DEFAULT_CENTER[1],zoom:GLOBAL_MIN_ZOOM}),viewport=_useState[0],setViewport=_useState[1];var _useState2=(0,react.useState)(),selectedFeature=_useState2[0],setSelectedFeature=_useState2[1];var context=react.useContext(map_context);var mapRef=(0,react.useRef)();var onClick=function onClick(event){var feature=event.features&&event.features[0];if(feature){var _bbox=es(feature),minLng=_bbox[0],minLat=_bbox[1],maxLng=_bbox[2],maxLat=_bbox[3];var newViewPort=new WebMercatorViewport(viewport);var _newViewPort$fitBound=newViewPort.fitBounds([[minLng,minLat],[maxLng,maxLat]],{padding:40}),longitude=_newViewPort$fitBound.longitude,latitude=_newViewPort$fitBound.latitude,zoom=_newViewPort$fitBound.zoom;var map=mapRef.current.getMap();// If we\'ve selected a new feature, set \'selected\' to false\nif(selectedFeature&&feature.id!==selectedFeature.id){map.setFeatureState({source:selectedFeature.source,sourceLayer:selectedFeature.sourceLayer,id:selectedFeature.id},{selected:false});}map.setFeatureState({source:feature.source,sourceLayer:feature.sourceLayer,id:feature.id},{selected:true});setSelectedFeature(feature);// Needs refining\n// setViewport({\n//   ...viewport,\n//   longitude,\n//   latitude,\n//   zoom,\n//   transitionInterpolator: new LinearInterpolator({\n//     around: [event.offsetCenter.x, event.offsetCenter.y],\n//   }),\n//   transitionDuration: 1000,\n// });\nvar popupInfo={longitude:longitude,latitude:latitude,zoom:zoom,properties:feature.properties};setDetailViewData(popupInfo);}};var onLoad=function onLoad(){if(window.Cypress){window.underlyingMap=mapRef.current.getMap();}};var goToPlace=function goToPlace(bounds){var _WebMercatorViewport$=new WebMercatorViewport(viewport).fitBounds(bounds,{padding:20,offset:[0,-100]}),longitude=_WebMercatorViewport$.longitude,latitude=_WebMercatorViewport$.latitude,zoom=_WebMercatorViewport$.zoom;setViewport(Object.assign({},viewport,{longitude:longitude,latitude:latitude,zoom:zoom,transitionDuration:1000,transitionInterpolator:new ViewportFlyToInterpolator(),transitionEasing:cubicInOut}));};var onClickZoomButton=function onClickZoomButton(event){var buttonID=event.target.id;switch(buttonID){case\'48\':goToPlace(LOWER_48_BOUNDS);break;case\'AK\':goToPlace(ALASKA_BOUNDS);break;case\'HI\':goToPlace(HAWAII_BOUNDS);break;case\'PR\':goToPlace(PUERTO_RICO_BOUNDS);break;default:break;}};return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(interactive_map,Object.assign({},viewport,{className:J40Map_module_namespaceObject.mapContainer,mapStyle:data_mapStyle// minZoom={constants.GLOBAL_MIN_ZOOM}\n// maxZoom={constants.GLOBAL_MAX_ZOOM}\n,mapOptions:{hash:true},width:"68.4vw",height:"52vw",dragRotate:false,touchRotate:false,interactiveLayerIds:[SCORE_LAYER],onViewportChange:setViewport,onClick:onClick,onLoad:onLoad,ref:mapRef}),/*#__PURE__*/react.createElement(navigation_control,{showCompass:false,className:navigationControls})),/*#__PURE__*/react.createElement(components_zoomWarning,{zoomLevel:viewport.zoom}),/*#__PURE__*/react.createElement("div",{className:zoomContainer},/*#__PURE__*/react.createElement("button",{id:\'48\',onClick:onClickZoomButton,className:zoomButton},"48"),/*#__PURE__*/react.createElement("button",{id:\'AK\',onClick:onClickZoomButton,className:zoomButton},"AK"),/*#__PURE__*/react.createElement("button",{id:\'HI\',onClick:onClickZoomButton,className:zoomButton},"HI"),/*#__PURE__*/react.createElement("button",{id:\'PR\',onClick:onClickZoomButton,className:zoomButton},"PR")));};/* harmony default export */ var components_J40Map = (J40Map);\n;// CONCATENATED MODULE: ./src/components/areaDetail.module.scss\n// extracted by mini-css-extract-plugin\nvar areaDetailTable = "areaDetail-module--areaDetailTable--1kW55";\nvar titleContainer = "areaDetail-module--titleContainer--1tUIN";\nvar titleIndicatorName = "areaDetail-module--titleIndicatorName--uAnFV";\nvar areaDetailContainer = "areaDetail-module--areaDetailContainer--15ae9";\nvar areaDetailTableContainer = "areaDetail-module--areaDetailTableContainer--1l8cw";\n;// CONCATENATED MODULE: ./src/components/areaDetail.tsx\nfunction _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=areaDetail_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function areaDetail_unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return areaDetail_arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return areaDetail_arrayLikeToArray(o,minLen);}function areaDetail_arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var AreaDetail=function AreaDetail(_ref){var properties=_ref.properties;var readablePercent=function readablePercent(percent){return""+(percent*100).toFixed(2);};var getCategorization=function getCategorization(percentile){var categorization;if(percentile>=0.75){categorization=\'Prioritized\';}else if(0.60<=percentile&&percentile<0.75){categorization=\'Threshold\';}else{categorization=\'Non-prioritized\';}return categorization;};var getTitleContent=function getTitleContent(){var blockGroup=properties[GEOID_PROPERTY];var score=properties[SCORE_PROPERTY];return/*#__PURE__*/react.createElement("div",{className:titleContainer},/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Census Block Group: "),/*#__PURE__*/react.createElement("span",null,blockGroup)),/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Just Progress Categorization: "),/*#__PURE__*/react.createElement("span",null,getCategorization(score))),/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Cumulative Index Score: "),/*#__PURE__*/react.createElement("span",null,readablePercent(score))));};var getBodyContent=function getBodyContent(){var rows=[];var sortedKeys=Object.entries(properties).sort();for(var _iterator=_createForOfIteratorHelperLoose(sortedKeys),_step;!(_step=_iterator()).done;){var _step$value=_step.value,key=_step$value[0],value=_step$value[1];// We should only format floats\nif(typeof value===\'number\'&&value%1!==0){value=readablePercent(value);}// Filter out all caps\nif(!key.match(/^[A-Z0-9]+$/)){rows.push(/*#__PURE__*/react.createElement("tr",{key:key},/*#__PURE__*/react.createElement("td",null,key),/*#__PURE__*/react.createElement("td",null,value)));}}return rows;};return/*#__PURE__*/react.createElement(react.Fragment,null,properties?/*#__PURE__*/react.createElement("div",{className:areaDetailContainer},getTitleContent(),/*#__PURE__*/react.createElement("div",{className:areaDetailTableContainer},/*#__PURE__*/react.createElement("table",{className:\'usa-table usa-table--borderless \'+areaDetailTable},/*#__PURE__*/react.createElement("thead",null,/*#__PURE__*/react.createElement("tr",null,/*#__PURE__*/react.createElement("th",{scope:"col"},"INDICATOR"),/*#__PURE__*/react.createElement("th",{scope:"col"},"VALUE"))),/*#__PURE__*/react.createElement("tbody",null,getBodyContent())))):\'\');};/* harmony default export */ var areaDetail = (AreaDetail);\n;// CONCATENATED MODULE: ./src/components/mapWrapper.tsx\n;var MapWrapper=function MapWrapper(){var _useState=(0,react.useState)(null),detailViewData=_useState[0],setDetailViewData=_useState[1];return/*#__PURE__*/react.createElement("div",{className:"grid-row"},/*#__PURE__*/react.createElement("div",{className:"grid-col-9"},/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement(components_J40Map,{setDetailViewData:setDetailViewData}))),/*#__PURE__*/react.createElement("div",{className:"grid-col-3"},detailViewData&&/*#__PURE__*/react.createElement(areaDetail,{properties:detailViewData.properties})));};/* harmony default export */ var mapWrapper = (MapWrapper);\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.module.scss\n// extracted by mini-css-extract-plugin\nvar howYouCanHelpContainer = "HowYouCanHelp-module--howYouCanHelpContainer--2kqBa";\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.tsx\nvar HowYouCanHelp=function HowYouCanHelp(){return/*#__PURE__*/react.createElement("div",{className:howYouCanHelpContainer},/*#__PURE__*/react.createElement("h2",null,"How You Can Help Improve the Tool"),/*#__PURE__*/react.createElement("ul",{className:\'usa-list\'},/*#__PURE__*/react.createElement("li",null,"If you have information that could help, we\\u2019d love to hear from you."),/*#__PURE__*/react.createElement("li",null,"View our full set of data sources and methodology where you can add or download sources and check statuses on our data roadmap."),/*#__PURE__*/react.createElement("li",null,"Check out our timeline and send feedback or attend relevant events."),/*#__PURE__*/react.createElement("li",null,"Contact us and share the stories of your community.")));};/* harmony default export */ var components_HowYouCanHelp = (HowYouCanHelp);\n;// CONCATENATED MODULE: ./src/components/mapLegend.module.scss\n// extracted by mini-css-extract-plugin\nvar legendContainer = "mapLegend-module--legendContainer--2N1FC";\nvar swatchContainer = "mapLegend-module--swatchContainer--1yZX1";\nvar legendItem = "mapLegend-module--legendItem--WezUf";\nvar colorSwatch = "mapLegend-module--colorSwatch--oBUN2";\nvar prioritized = "mapLegend-module--prioritized--1I534";\nvar threshold = "mapLegend-module--threshold--1zali";\nvar nonPrioritized = "mapLegend-module--nonPrioritized--2y0Vm";\n;// CONCATENATED MODULE: ./src/components/mapLegend.tsx\nvar MapLegend=function MapLegend(){return/*#__PURE__*/react.createElement("div",{className:legendContainer},/*#__PURE__*/react.createElement("h3",{className:mapLegend_module_namespaceObject.legendHeader},"COLOR KEY"),/*#__PURE__*/react.createElement("div",{className:swatchContainer},/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:prioritized}),/*#__PURE__*/react.createElement("span",null,"Prioritized Community")),/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:threshold}),/*#__PURE__*/react.createElement("span",null,"Threshold Community")),/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:nonPrioritized}),/*#__PURE__*/react.createElement("span",null,"Non-Prioritized Community"))));};/* harmony default export */ var mapLegend = (MapLegend);\n;// CONCATENATED MODULE: ./src/pages/cejst.module.scss\n// extracted by mini-css-extract-plugin\nvar disclaimer = "cejst-module--disclaimer--3LC1y";\n;// CONCATENATED MODULE: ./src/pages/cejst.tsx\nvar CEJSTPage=function CEJSTPage(_ref){var location=_ref.location;// We temporarily removed MapControls, which would enable you to `setFeatures` also, for now\n//   We will bring back later when we have interactive controls.\nreturn/*#__PURE__*/react.createElement(layout/* default */.Z,{location:location},/*#__PURE__*/react.createElement("main",{id:"main-content",role:"main"},/*#__PURE__*/react.createElement("h2",null,"Just Progress communities"),/*#__PURE__*/react.createElement("p",{className:disclaimer},"Just Progress helps identify and prioritize communities across the United States and U.S. territories that have been historically overburdened and underserved. These communities will receive 40% of the benefits from investments in key areas outlined by the",/*#__PURE__*/react.createElement("a",{href:\'https://www.whitehouse.gov/briefing-room/\'+\'presidential-actions/2021/01/27/\'+\'executive-order-on-tackling-the-climate-\'+\'crisis-at-home-and-abroad/\',target:\'_blank\',rel:\'noreferrer\'},"Executive Order on Tackling the Climate Crisis at Home and Abroad"),"."),/*#__PURE__*/react.createElement("h2",null,"Explore the Tool"),/*#__PURE__*/react.createElement(mapWrapper,null),/*#__PURE__*/react.createElement(mapLegend,null),/*#__PURE__*/react.createElement(components_HowYouCanHelp,null)));};/* harmony default export */ var cejst = (CEJSTPage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9kYXRhL2NvbnN0YW50cy50c3g/YmU1YSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9kYXRhL21hcFN0eWxlLnRzeD85ZDk2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvem9vbVdhcm5pbmcubW9kdWxlLnNjc3M/NGIwMCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy91c3dkcy9kaXN0L2ltZy91c2EtaWNvbnMvem9vbV9pbi5zdmc/YzM3YyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL3pvb21XYXJuaW5nLnRzeD9lYzcxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanM/YzMxZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcz8wZDIxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzPzA5ZjAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzPzNkOGMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcz8zODM1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzP2I5M2UiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWM0LmpzPzg5YmIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL21hdGgtdXRpbHMuanM/ZDkwNiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanM/NDU4OSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzIuanM/MWE3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanM/ODkwMiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vYXNzZXJ0LmpzP2FhN2EiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL3dlYi1tZXJjYXRvci11dGlscy5qcz83MzUyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9maXQtYm91bmRzLmpzPzgxN2UiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2dldC1ib3VuZHMuanM/NDBmMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vd2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzPzFhZDYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL25vcm1hbGl6ZS12aWV3cG9ydC1wcm9wcy5qcz9jM2Q4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9mbHktdG8tdmlld3BvcnQuanM/M2MyOCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vaW5kZXguanM/ZTViMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy92aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0L21vZHVsZS5qcz9lMjQ1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzPzZmZWEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2dsb2JhbHMuanM/ZTdhZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc3R5bGUtdXRpbHMuanM/ZTJkYSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vbWFwYm94L21hcGJveC5qcz85YzdkIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9tYXRoLXV0aWxzLmpzP2Y5MWEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL2Fzc2VydC5qcz84MDQ3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9tYXAtc3RhdGUuanM/NGZiMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLWNvbnN0cmFpbnRzLmpzPzIxY2IiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbWFwLWNvbnRleHQuanM/YzY3YSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdC5qcz80ZjcxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90ZXJyYWluLmpzPzEwMWIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc3RhdGljLW1hcC5qcz82OGQwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yLmpzPzRhZDQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vdHJhbnNpdGlvbi11dGlscy5qcz84ZDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL3ZpZXdwb3J0LWZseS10by1pbnRlcnBvbGF0b3IuanM/NDg3MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi9saW5lYXItaW50ZXJwb2xhdG9yLmpzPzRiMGUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vaW5kZXguanM/MmJiOSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi1tYW5hZ2VyLmpzP2MzMzQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXItb3ZlcnJpZGVzLmpzPzNjNzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXIuYnJvd3Nlci5qcz9iNjk4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vY29uc3RhbnRzLmpzP2Y0MjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9nbG9iYWxzLmpzP2UxNDEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvd2hlZWwtaW5wdXQuanM/MDUzZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2lucHV0cy9tb3ZlLWlucHV0LmpzP2JiNDAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMva2V5LWlucHV0LmpzPzQzMmEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvY29udGV4dG1lbnUtaW5wdXQuanM/NWVkMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2V2ZW50LXV0aWxzLmpzPzI1NjIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9ldmVudC1yZWdpc3RyYXIuanM/NDc1MyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2V2ZW50LW1hbmFnZXIuanM/ZDE3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLWNvbnRyb2xsZXIuanM/MmM1MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAuanM/ODZkYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9zb3VyY2UuanM/NmVlNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzP2NjYjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/MTVmZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanM/NTNjYSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZGVlcC1lcXVhbC5qcz82NTAyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2xheWVyLmpzPzlmZjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sLmpzPzgzYjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYmFzZS1jb250cm9sLmpzP2MzNTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZHJhZ2dhYmxlLWNvbnRyb2wuanM/MmY3NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvY3Jpc3AtcGl4ZWwuanM/ODhhZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9tYXJrZXIuanM/MDA4ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZHluYW1pYy1wb3NpdGlvbi5qcz9hZDM5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3BvcHVwLmpzPzk5MzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYXR0cmlidXRpb24tY29udHJvbC5qcz8yMzEyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2Z1bGxzY3JlZW4tY29udHJvbC5qcz8xMDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9nZW9sb2NhdGUtdXRpbHMuanM/ZDM2YiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbC5qcz9hYzMwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy92ZXJzaW9uLmpzP2IyNzgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1jb250cm9sLmpzP2ExYzUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbC5qcz9lNzIwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9jYW52YXMtb3ZlcmxheS5qcz84NTMzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9odG1sLW92ZXJsYXkuanM/Y2Q3ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vb3ZlcmxheXMvc3ZnLW92ZXJsYXkuanM/OGU1MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc2V0LXJ0bC10ZXh0LXBsdWdpbi5qcz8wMGNmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9pbmRleC5qcz9jMWIzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSjQwTWFwLm1vZHVsZS5zY3NzP2I3ZGIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvaGVscGVycy9kaXN0L2VzL2luZGV4LmpzPzI5MjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvbWV0YS9kaXN0L2VzL2luZGV4LmpzPzRlNTgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQHR1cmYvYmJveC9kaXN0L2VzL2luZGV4LmpzP2NlMWMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanM/ZTQyZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0o0ME1hcC50c3g/YWY3NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL2FyZWFEZXRhaWwubW9kdWxlLnNjc3M/NGM3MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL2FyZWFEZXRhaWwudHN4PzI5NTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9tYXBXcmFwcGVyLnRzeD8xNWI4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSG93WW91Q2FuSGVscC5tb2R1bGUuc2Nzcz9jY2NiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSG93WW91Q2FuSGVscC50c3g/OTBiNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL21hcExlZ2VuZC5tb2R1bGUuc2Nzcz9iY2JjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvbWFwTGVnZW5kLnRzeD84MTYxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL3BhZ2VzL2NlanN0Lm1vZHVsZS5zY3NzPzYxZTMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvcGFnZXMvY2Vqc3QudHN4P2UxZGYiXSwibmFtZXMiOlsiU0NPUkVfUFJPUEVSVFkiLCJHRU9JRF9QUk9QRVJUWSIsIlNDT1JFX0xBWUVSIiwiR0xPQkFMX01JTl9aT09NIiwiR0xPQkFMX01BWF9aT09NIiwiR0xPQkFMX01JTl9aT09NX0xPVyIsIkdMT0JBTF9NQVhfWk9PTV9MT1ciLCJHTE9CQUxfTUlOX1pPT01fSElHSCIsIkdMT0JBTF9NQVhfWk9PTV9ISUdIIiwiR0xPQkFMX01BWF9CT1VORFMiLCJMT1dFUl80OF9CT1VORFMiLCJBTEFTS0FfQk9VTkRTIiwiSEFXQUlJX0JPVU5EUyIsIlBVRVJUT19SSUNPX0JPVU5EUyIsIkdVQU1fQk9VTkRTIiwiTUFSSUFOQV9JU0xBTkRfQk9VTkRTIiwiQU1FUklDQU5fU0FNT0FfQk9VTkRTIiwiREVGQVVMVF9DRU5URVIiLCJERUZBVUxUX0xBWUVSX09QQUNJVFkiLCJERUZBVUxUX09VVExJTkVfQ09MT1IiLCJNSU5fQ09MT1IiLCJNRURfQ09MT1IiLCJNQVhfQ09MT1IiLCJCT1JERVJfSElHSExJR0hUX0NPTE9SIiwiaGV4VG9IU0xBIiwiaGV4IiwiYWxwaGEiLCJjaHJvbWEiLCJjc3MiLCJtYWtlUGFpbnQiLCJmaWVsZCIsIm1pblJhbXAiLCJtZWRSYW1wIiwibWF4UmFtcCIsInBhaW50RGVzY3JpcHRvciIsImNvbnN0YW50cyIsIm1hcFN0eWxlIiwiWm9vbVdhcm5pbmciLCJ6b29tTGV2ZWwiLCJzdHlsZXMiLCJ6b29tSWNvbiIsIko0ME1hcCIsInNldERldGFpbFZpZXdEYXRhIiwidXNlU3RhdGUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJ2aWV3cG9ydCIsInNldFZpZXdwb3J0Iiwic2VsZWN0ZWRGZWF0dXJlIiwic2V0U2VsZWN0ZWRGZWF0dXJlIiwiY29udGV4dCIsIlJlYWN0IiwiTWFwQ29udGV4dCIsIm1hcFJlZiIsInVzZVJlZiIsIm9uQ2xpY2siLCJldmVudCIsImZlYXR1cmUiLCJmZWF0dXJlcyIsImJib3giLCJtaW5MbmciLCJtaW5MYXQiLCJtYXhMbmciLCJtYXhMYXQiLCJuZXdWaWV3UG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJmaXRCb3VuZHMiLCJwYWRkaW5nIiwibWFwIiwiY3VycmVudCIsImdldE1hcCIsImlkIiwic2V0RmVhdHVyZVN0YXRlIiwic291cmNlIiwic291cmNlTGF5ZXIiLCJzZWxlY3RlZCIsInBvcHVwSW5mbyIsInByb3BlcnRpZXMiLCJvbkxvYWQiLCJ3aW5kb3ciLCJDeXByZXNzIiwidW5kZXJseWluZ01hcCIsImdvVG9QbGFjZSIsImJvdW5kcyIsIm9mZnNldCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25JbnRlcnBvbGF0b3IiLCJGbHlUb0ludGVycG9sYXRvciIsInRyYW5zaXRpb25FYXNpbmciLCJkMyIsIm9uQ2xpY2tab29tQnV0dG9uIiwiYnV0dG9uSUQiLCJ0YXJnZXQiLCJoYXNoIiwiQXJlYURldGFpbCIsInJlYWRhYmxlUGVyY2VudCIsInBlcmNlbnQiLCJ0b0ZpeGVkIiwiZ2V0Q2F0ZWdvcml6YXRpb24iLCJwZXJjZW50aWxlIiwiY2F0ZWdvcml6YXRpb24iLCJnZXRUaXRsZUNvbnRlbnQiLCJibG9ja0dyb3VwIiwic2NvcmUiLCJnZXRCb2R5Q29udGVudCIsInJvd3MiLCJzb3J0ZWRLZXlzIiwiT2JqZWN0IiwiZW50cmllcyIsInNvcnQiLCJrZXkiLCJ2YWx1ZSIsIm1hdGNoIiwicHVzaCIsIk1hcFdyYXBwZXIiLCJkZXRhaWxWaWV3RGF0YSIsIkhvd1lvdUNhbkhlbHAiLCJNYXBMZWdlbmQiLCJDRUpTVFBhZ2UiLCJsb2NhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPLEdBQU1BLGVBQWMsQ0FBRyxzQkFBdkIsQ0FDQSxHQUFNQyxlQUFjLENBQUcsU0FBdkIsQ0FDQSxHQUFNQyxZQUFXLENBQUcsT0FBcEIsQ0FHUDtBQUNPLEdBQU1DLGdCQUFlLENBQUcsQ0FBeEIsQ0FDQSxHQUFNQyxnQkFBZSxDQUFHLEVBQXhCLENBQ0EsR0FBTUMsb0JBQW1CLENBQUcsQ0FBNUIsQ0FDQSxHQUFNQyxvQkFBbUIsQ0FBRyxDQUE1QixDQUNBLEdBQU1DLHFCQUFvQixDQUFHLENBQTdCLENBQ0EsR0FBTUMscUJBQW9CLENBQUcsRUFBN0IsQ0FFUDtBQUNBO0FBQ08sR0FBTUMsa0JBQWlCLENBQUcsaURBQy9CLENBQUMsQ0FBQyxVQUFGLENBQWMsUUFBZCxDQUQrQixDQUUvQixDQUFDLENBQUMsSUFBRixDQUFRLFNBQVIsQ0FGK0IsQ0FBMUIsR0FLQSxHQUFNQyxnQkFBZSxDQUFHLENBQzdCLENBQUMsQ0FBQyxXQUFGLENBQWUsVUFBZixDQUQ2QixDQUU3QixDQUFDLENBQUMsVUFBRixDQUFjLFVBQWQsQ0FGNkIsQ0FBeEIsQ0FLQSxHQUFNQyxjQUFhLENBQUcsQ0FDM0IsQ0FBQyxDQUFDLFVBQUYsQ0FBYyxTQUFkLENBRDJCLENBRTNCLENBQUMsQ0FBQyxVQUFGLENBQWMsU0FBZCxDQUYyQixDQUF0QixDQUtBLEdBQU1DLGNBQWEsQ0FBRyxDQUMzQixDQUFDLENBQUMsVUFBRixDQUFjLFNBQWQsQ0FEMkIsQ0FFM0IsQ0FBQyxDQUFDLFVBQUYsQ0FBYyxTQUFkLENBRjJCLENBQXRCLENBS0EsR0FBTUMsbUJBQWtCLENBQUcsQ0FDaEMsQ0FBQyxDQUFDLFNBQUYsQ0FBYSxRQUFiLENBRGdDLENBRWhDLENBQUMsQ0FBQyxTQUFGLENBQWEsU0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixX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Q0FwQkQsQ0FzQkEsOENBQWUrRSxTQUFmLEU7O0FDekJBO0FBQ08sbUQ7O0FDV1AsR0FBTUMsVUFBUyxDQUFHLFFBQVpBLFVBQVksTUFBK0IsSUFBN0JDLFNBQTZCLE1BQTdCQSxRQUE2QixDQUMvQztBQUNBO0FBQ0EsbUJBQ0Usb0JBQUMscUJBQUQsRUFBUSxRQUFRLENBQUVBLFFBQWxCLGVBQ0UsNEJBQU0sRUFBRSxDQUFDLGNBQVQsQ0FBd0IsSUFBSSxDQUFDLE1BQTdCLGVBQ0UsMERBREYsY0FFRSx5QkFBRyxTQUFTLENBQUVqRixVQUFkLGtSQUtFLHlCQUNFLElBQUksQ0FBRSw0Q0FDTixrQ0FETSxDQUVOLDBDQUZNLENBR04sNEJBSkYsQ0FLRSxNQUFNLENBQUUsUUFMVixDQU1FLEdBQUcsQ0FBRSxZQU5QLHNFQUxGLEtBRkYsY0FpQkUsaURBakJGLGNBa0JFLG9CQUFDLFVBQUQsTUFsQkYsY0FtQkUsb0JBQUMsU0FBRCxNQW5CRixjQW9CRSxvQkFBQyx3QkFBRCxNQXBCRixDQURGLENBREYsQ0EwQkQsQ0E3QkQsQ0ErQkEsMENBQWVnRixTQUFmIiwiZmlsZSI6Ijk2OTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgU0NPUkVfUFJPUEVSVFkgPSAnU2NvcmUgRCAocGVyY2VudGlsZSknO1xuZXhwb3J0IGNvbnN0IEdFT0lEX1BST1BFUlRZID0gJ0dFT0lEMTAnO1xuZXhwb3J0IGNvbnN0IFNDT1JFX0xBWUVSID0gJ3Njb3JlJztcbmV4cG9ydCB0eXBlIEo0MFByb3BlcnRpZXMgPSB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG4vLyBab29tXG5leHBvcnQgY29uc3QgR0xPQkFMX01JTl9aT09NID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT00gPSAyMjtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fTE9XID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT01fTE9XID0gOTtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fSElHSCA9IDk7XG5leHBvcnQgY29uc3QgR0xPQkFMX01BWF9aT09NX0hJR0ggPSAxMjtcblxuLy8gQm91bmRzIC0tXG4vLyBGcm9tIGh0dHBzOi8vYW50aG9ueWxvdWlzZGFnb3N0aW5vLmNvbS9ib3VuZGluZy1ib3hlcy1mb3ItYWxsLXVzLXN0YXRlcy9cbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX0JPVU5EUyA9IFtcbiAgWy0xODAuMTE4MzA2LCA1LjQ5OTU1MF0sXG4gIFstNjUuMCwgODMuMTYyMTAyXSxcbl07XG5cbmV4cG9ydCBjb25zdCBMT1dFUl80OF9CT1VORFMgPSBbXG4gIFstMTI0Ljc4NDQwNzksIDI0Ljc0MzMxOTVdLFxuICBbLTY2Ljk1MTM4MTIsIDQ5LjM0NTc4NjhdLFxuXTtcblxuZXhwb3J0IGNvbnN0IEFMQVNLQV9CT1VORFMgPSBbXG4gIFstMTgzLjg1Njg4OCwgNTAuODc1MzExXSxcbiAgWy0xNDAuOTMyNjE3LCA3MS45NTg3OTddLFxuXTtcblxuZXhwb3J0IGNvbnN0IEhBV0FJSV9CT1VORFMgPSBbXG4gIFstMTY4LjExODMwNiwgMTguNzQ4MTE1XSxcbiAgWy0xNTQuNzU3ODgxLCAyMi4zNzg0MTNdLFxuXTtcblxuZXhwb3J0IGNvbnN0IFBVRVJUT19SSUNPX0JPVU5EUyA9IFtcbiAgWy02Ny45NDU0MDQsIDE3Ljg4MzI4XSxcbiAgWy02NS4yMjA3MDMsIDE4LjUxNTY4M10sXG5dO1xuXG5leHBvcnQgY29uc3QgR1VBTV9CT1VORFMgPSBbXG4gIFstMjE1LjM4OTcwOSwgMTMuMjI1OTA5XSxcbiAgWy0yMTUuMDQwODk0LCAxMy42NjMzMzVdLFxuXTtcblxuZXhwb3J0IGNvbnN0IE1BUklBTkFfSVNMQU5EX0JPVU5EUyA9IFtcbiAgWy0yMTUuMzEzNDQ5LCAxNC4wMDc4MDFdLFxuICBbLTIxMy43NDI0MDQsIDE5Ljc1MDMyNl0sXG5dO1xuXG5leHBvcnQgY29uc3QgQU1FUklDQU5fU0FNT0FfQk9VTkRTID0gW1xuICBbLTE3MS4wODk4NzQsIC0xNC41NDg2OTldLFxuICBbLTE2OC4xNDMzLCAtMTEuMDQ2OTM0XSxcbl07XG5cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0VOVEVSID0gWzMyLjQ2ODcxMjYsIC04Ni41MDIxMzZdO1xuXG4vLyBPcGFjaXR5XG5leHBvcnQgY29uc3QgREVGQVVMVF9MQVlFUl9PUEFDSVRZID0gMC42O1xuXG4vLyBDb2xvcnNcbmV4cG9ydCBjb25zdCBERUZBVUxUX09VVExJTkVfQ09MT1IgPSAnIzRFQTVDRic7XG5leHBvcnQgY29uc3QgTUlOX0NPTE9SID0gJyNGRkZGRkYnO1xuZXhwb3J0IGNvbnN0IE1FRF9DT0xPUiA9ICcjRDFEQUU2JztcbmV4cG9ydCBjb25zdCBNQVhfQ09MT1IgPSAnIzc2OEZCMyc7XG5leHBvcnQgY29uc3QgQk9SREVSX0hJR0hMSUdIVF9DT0xPUiA9ICcjMDBCREUzJztcbiIsImltcG9ydCB7U3R5bGUsIEZpbGxQYWludH0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IGNocm9tYSBmcm9tICdjaHJvbWEtanMnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL2RhdGEvY29uc3RhbnRzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIGhleFRvSFNMQShoZXg6c3RyaW5nLCBhbHBoYTpudW1iZXIpIHtcbiAgcmV0dXJuIGNocm9tYShoZXgpLmFscGhhKGFscGhhKS5jc3MoJ2hzbCcpO1xufVxuXG4vKipcbiAqIGBNYWtlUGFpbnRgIGdlbmVyYXRlcyBhIHpvb20tZmFkZWQgTWFwbGlicmUgc3R5bGUgZm9ybWF0dGVkIGxheWVyIGdpdmVuIGEgc2V0IG9mIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIDogdGhlIGZpZWxkIHdpdGhpbiB0aGUgZGF0YSB0byBjb25zdWx0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmFtcCA6IHRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgY2FuIGFzc3VtZVxuICogQHBhcmFtIHtudW1iZXJ9IG1lZFJhbXAgOiB0aGUgbWVkaXVtIHZhbHVlIHRoaXMgY2FuIGFzc3VtZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJhbXAgOiB0aGUgbWF4aW11bSB2YWx1ZSB0aGlzIGNhbiBhc3N1bWVcbiAqIEByZXR1cm4ge0ZpbGxQYWludH0gYSBtYXBsaWJyZWdsIGZpbGwgbGF5ZXJcbiAqKi9cbmZ1bmN0aW9uIG1ha2VQYWludCh7XG4gIGZpZWxkLFxuICBtaW5SYW1wLFxuICBtZWRSYW1wLFxuICBtYXhSYW1wLFxufToge1xuICAgIGZpZWxkOiBzdHJpbmc7XG4gICAgbWluUmFtcDogbnVtYmVyO1xuICAgIG1lZFJhbXA6IG51bWJlcjtcbiAgICBtYXhSYW1wOiBudW1iZXI7XG4gIH0pOiBGaWxsUGFpbnQge1xuICBjb25zdCBwYWludERlc2NyaXB0b3IgOiBGaWxsUGFpbnQgPSB7XG4gICAgJ2ZpbGwtY29sb3InOiBbXG4gICAgICAnc3RlcCcsXG4gICAgICBbJ3RvLW51bWJlcicsIFtcbiAgICAgICAgJ2dldCcsXG4gICAgICAgIGZpZWxkLFxuICAgICAgXV0sXG4gICAgICBoZXhUb0hTTEEoY29uc3RhbnRzLk1JTl9DT0xPUiwgY29uc3RhbnRzLkRFRkFVTFRfTEFZRVJfT1BBQ0lUWSApLFxuICAgICAgbWluUmFtcCxcbiAgICAgIGhleFRvSFNMQShjb25zdGFudHMuTUlOX0NPTE9SLCBjb25zdGFudHMuREVGQVVMVF9MQVlFUl9PUEFDSVRZICksXG4gICAgICBtZWRSYW1wLFxuICAgICAgaGV4VG9IU0xBKGNvbnN0YW50cy5NRURfQ09MT1IsIGNvbnN0YW50cy5ERUZBVUxUX0xBWUVSX09QQUNJVFkgKSxcbiAgICAgIG1heFJhbXAsXG4gICAgICBoZXhUb0hTTEEoY29uc3RhbnRzLk1BWF9DT0xPUiwgY29uc3RhbnRzLkRFRkFVTFRfTEFZRVJfT1BBQ0lUWSApLFxuICAgIF0sXG4gIH07XG4gIHJldHVybiBwYWludERlc2NyaXB0b3I7XG59XG5cbmNvbnN0IG1hcFN0eWxlIDogU3R5bGUgPSB7XG4gICd2ZXJzaW9uJzogOCxcbiAgJ3NvdXJjZXMnOiB7XG4gICAgJ2NhcnRvJzoge1xuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgJ2h0dHBzOi8vYS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ucG5nJyxcbiAgICAgICAgJ2h0dHBzOi8vYi5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ucG5nJyxcbiAgICAgICAgJ2h0dHBzOi8vYy5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ucG5nJyxcbiAgICAgICAgJ2h0dHBzOi8vZC5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ucG5nJyxcbiAgICAgIF0sXG4gICAgfSxcbiAgICAnZ2VvJzoge1xuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgJ2h0dHBzOi8vbXQwLmdvb2dsZS5jb20vdnQvbHlycz1wJmhsPWVuJng9e3h9Jnk9e3l9Jno9e3p9JyxcbiAgICAgIF0sXG4gICAgfSxcbiAgICAnc2NvcmUnOiB7XG4gICAgICAndHlwZSc6ICd2ZWN0b3InLFxuICAgICAgJ3Byb21vdGVJZCc6ICdHRU9JRDEwJyxcbiAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgJ2h0dHBzOi8vZDJ6amlkNm41amEycHQuY2xvdWRmcm9udC5uZXQvMDYyOV9kZW1vL3t6fS97eH0ve3l9LnBiZicsXG4gICAgICAgIC8vIEZvciBsb2NhbCBkZXZlbG9wbWVudCwgdXNlOlxuICAgICAgICAvLyAnaHR0cDovL2xvY2FsaG9zdDo4MDgwL2RhdGEvdGxfMjAxMF9iZ193aXRoX2RhdGEve3p9L3t4fS97eX0ucGJmJyxcbiAgICAgIF0sXG4gICAgfSxcbiAgICAnbGFiZWxzJzoge1xuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy1hLmdsb2JhbC5zc2wuZmFzdGx5Lm5ldC9saWdodF9vbmx5X2xhYmVscy97en0ve3h9L3t5fUAyeC5wbmcnLFxuICAgICAgICAnaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWIuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9QDJ4LnBuZycsXG4gICAgICAgICdodHRwczovL2NhcnRvZGItYmFzZW1hcHMtYy5nbG9iYWwuc3NsLmZhc3RseS5uZXQvbGlnaHRfb25seV9sYWJlbHMve3p9L3t4fS97eX1AMngucG5nJyxcbiAgICAgICAgJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy1kLmdsb2JhbC5zc2wuZmFzdGx5Lm5ldC9saWdodF9vbmx5X2xhYmVscy97en0ve3h9L3t5fUAyeC5wbmcnLFxuICAgICAgXSxcbiAgICB9LFxuICB9LFxuICAnbGF5ZXJzJzogW1xuICAgIHtcbiAgICAgICdpZCc6ICdjYXJ0bycsXG4gICAgICAnc291cmNlJzogJ2NhcnRvJyxcbiAgICAgICd0eXBlJzogJ3Jhc3RlcicsXG4gICAgICAvLyAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00gLSAxLFxuICAgIH0sXG4gICAge1xuICAgICAgJ2lkJzogJ2dlbycsXG4gICAgICAnc291cmNlJzogJ2dlbycsXG4gICAgICAndHlwZSc6ICdyYXN0ZXInLFxuICAgICAgLy8gJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NIC0gMSxcbiAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgIC8vIE1ha2UgdGhlIGxheWVyIHZpc2libGUgYnkgZGVmYXVsdC5cbiAgICAgICAgJ3Zpc2liaWxpdHknOiAnbm9uZScsXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgJ2lkJzogJ3Njb3JlJyxcbiAgICAgICdzb3VyY2UnOiAnc2NvcmUnLFxuICAgICAgJ3NvdXJjZS1sYXllcic6ICdibG9ja3MnLFxuICAgICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgICBbJz4nLCBjb25zdGFudHMuU0NPUkVfUFJPUEVSVFksIDAuNl0sXG4gICAgICAgIC8vIFsnaW4nLCAnU1RBVEVGUDEwJywgJzAxJywgJzMwJywgJzM0JywgJzM1JywgJzM2J10sXG4gICAgICBdLFxuICAgICAgJ3BhaW50JzogbWFrZVBhaW50KHtcbiAgICAgICAgZmllbGQ6IGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWSxcbiAgICAgICAgbWluUmFtcDogMCxcbiAgICAgICAgbWVkUmFtcDogMC42LFxuICAgICAgICBtYXhSYW1wOiAwLjc1LFxuICAgICAgfSksXG4gICAgICAvLyAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICAvLyAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgfSxcbiAgICB7XG4gICAgICAnaWQnOiAnc2NvcmUtaGlnaGxpZ2h0cycsXG4gICAgICAnc291cmNlJzogJ3Njb3JlJyxcbiAgICAgICdzb3VyY2UtbGF5ZXInOiAnYmxvY2tzJyxcbiAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0gsXG4gICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCcsXG4gICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICB9LFxuICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAnbGluZS1jb2xvcic6IGNvbnN0YW50cy5ERUZBVUxUX09VVExJTkVfQ09MT1IsXG4gICAgICAgICdsaW5lLXdpZHRoJzogMC44LFxuICAgICAgICAnbGluZS1vcGFjaXR5JzogMC41LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICdpZCc6ICdzY29yZS1ib3JkZXItaGlnaGxpZ2h0JyxcbiAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgJ3NvdXJjZSc6ICdzY29yZScsXG4gICAgICAnc291cmNlLWxheWVyJzogJ2Jsb2NrcycsXG4gICAgICAnbGF5b3V0Jzoge30sXG4gICAgICAncGFpbnQnOiB7XG4gICAgICAgICdsaW5lLWNvbG9yJzogY29uc3RhbnRzLkJPUkRFUl9ISUdITElHSFRfQ09MT1IsXG4gICAgICAgICdsaW5lLXdpZHRoJzogW1xuICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICBbJ2Jvb2xlYW4nLCBbJ2ZlYXR1cmUtc3RhdGUnLCAnc2VsZWN0ZWQnXSwgZmFsc2VdLFxuICAgICAgICAgIDUuMCxcbiAgICAgICAgICAwLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICdpZCc6ICdsYWJlbHMtb25seScsXG4gICAgICAndHlwZSc6ICdyYXN0ZXInLFxuICAgICAgJ3NvdXJjZSc6ICdsYWJlbHMnLFxuICAgICAgLy8gJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NLFxuICAgIH0sXG4gIF0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXBTdHlsZTtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciB6b29tV2FybmluZyA9IFwiem9vbVdhcm5pbmctbW9kdWxlLS16b29tV2FybmluZy0takdlT2tcIjsiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakkwSWo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQldNSG9pSUdacGJHdzlJbTV2Ym1VaUx6NDhjR0YwYUNCa1BTSk5NVFV1TlNBeE5HZ3RMamM1YkMwdU1qZ3RMakkzUXpFMUxqUXhJREV5TGpVNUlERTJJREV4TGpFeElERTJJRGt1TlNBeE5pQTFMamt4SURFekxqQTVJRE1nT1M0MUlETlRNeUExTGpreElETWdPUzQxSURVdU9URWdNVFlnT1M0MUlERTJZekV1TmpFZ01DQXpMakE1TFM0MU9TQTBMakl6TFRFdU5UZHNMakkzTGpJNGRpNDNPV3cxSURRdU9UbE1NakF1TkRrZ01UbHNMVFF1T1RrdE5YcHRMVFlnTUVNM0xqQXhJREUwSURVZ01URXVPVGtnTlNBNUxqVlROeTR3TVNBMUlEa3VOU0ExSURFMElEY3VNREVnTVRRZ09TNDFJREV4TGprNUlERTBJRGt1TlNBeE5Ib2lMejQ4Y0dGMGFDQmtQU0pOTVRJZ01UQm9MVEoyTWtnNWRpMHlTRGRXT1dneVZqZG9NWFl5YURKMk1Yb2lMejQ4TDNOMlp6ND1cIiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL3pvb21XYXJuaW5nLm1vZHVsZS5zY3NzJztcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHpvb21JY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL3pvb21faW4uc3ZnJztcblxuaW50ZXJmYWNlIElab29tV2FybmluZ1Byb3BzIHtcbiAgICB6b29tTGV2ZWw6IG51bWJlclxufVxuXG5jb25zdCBab29tV2FybmluZyA9ICh7em9vbUxldmVsfTogSVpvb21XYXJuaW5nUHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3pvb21MZXZlbCA8PSA1ID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnpvb21XYXJuaW5nfT5cbiAgICAgICAgICA8aW1nIHNyYz17em9vbUljb259IGFsdD17J3pvb20gaWNvbid9Lz5cbiAgICAgICAgICBab29tIGluIHRvIHRoZSBzdGF0ZSBvciByZWdpb25hbCBsZXZlbCB0byBzZWUgcHJpb3JpdGl6ZWQgY29tbXVuaXRpZXMgb24gdGhlIG1hcC5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICkgOlxuICAgICAgICAnJ1xuICAgICAgfVxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgWm9vbVdhcm5pbmc7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qc1wiO1xuXG4vKipcclxuICogQ29tbW9uIHV0aWxpdGllc1xyXG4gKiBAbW9kdWxlIGdsTWF0cml4XHJcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmV4cG9ydCB2YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IHZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcclxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXHJcbiAqXHJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgQVJSQVlfVFlQRSA9IHR5cGU7XG59XG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxyXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG4vKipcclxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxyXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXHJcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cbmlmICghTWF0aC5oeXBvdCkgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHkgPSAwLFxuICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHkgKz0gYXJndW1lbnRzW2ldICogYXJndW1lbnRzW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydCh5KTtcbn07IiwiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanNcIjtcbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjNFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcclxuICpcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSB4ICogbGVuO1xuICBvdXRbMV0gPSB5ICogbGVuO1xuICBvdXRbMl0gPSB6ICogbGVuO1xuICBvdXRbM10gPSB3ICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCB1LCB2LCB3KSB7XG4gIHZhciBBID0gdlswXSAqIHdbMV0gLSB2WzFdICogd1swXSxcbiAgICAgIEIgPSB2WzBdICogd1syXSAtIHZbMl0gKiB3WzBdLFxuICAgICAgQyA9IHZbMF0gKiB3WzNdIC0gdlszXSAqIHdbMF0sXG4gICAgICBEID0gdlsxXSAqIHdbMl0gLSB2WzJdICogd1sxXSxcbiAgICAgIEUgPSB2WzFdICogd1szXSAtIHZbM10gKiB3WzFdLFxuICAgICAgRiA9IHZbMl0gKiB3WzNdIC0gdlszXSAqIHdbMl07XG4gIHZhciBHID0gdVswXTtcbiAgdmFyIEggPSB1WzFdO1xuICB2YXIgSSA9IHVbMl07XG4gIHZhciBKID0gdVszXTtcbiAgb3V0WzBdID0gSCAqIEYgLSBJICogRSArIEogKiBEO1xuICBvdXRbMV0gPSAtKEcgKiBGKSArIEkgKiBDIC0gSiAqIEI7XG4gIG91dFsyXSA9IEcgKiBFIC0gSCAqIEMgKyBKICogQTtcbiAgb3V0WzNdID0gLShHICogRCkgKyBIICogQiAtIEkgKiBBO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICB2YXIgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7IC8vIE1hcnNhZ2xpYSwgR2VvcmdlLiBDaG9vc2luZyBhIFBvaW50IGZyb20gdGhlIFN1cmZhY2Ugb2YgYVxuICAvLyBTcGhlcmUuIEFubi4gTWF0aC4gU3RhdGlzdC4gNDMgKDE5NzIpLCBuby4gMiwgNjQ1LS02NDYuXG4gIC8vIGh0dHA6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9ldWNsaWQuYW9tcy8xMTc3NjkyNjQ0O1xuXG4gIHZhciB2MSwgdjIsIHYzLCB2NDtcbiAgdmFyIHMxLCBzMjtcblxuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcblxuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcblxuICB2YXIgZCA9IE1hdGguc3FydCgoMSAtIHMxKSAvIHMyKTtcbiAgb3V0WzBdID0gc2NhbGUgKiB2MTtcbiAgb3V0WzFdID0gc2NhbGUgKiB2MjtcbiAgb3V0WzJdID0gc2NhbGUgKiB2MyAqIGQ7XG4gIG91dFszXSA9IHNjYWxlICogdjQgKiBkO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjNChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyB2ZWM0IGZyb20gJ2dsLW1hdHJpeC92ZWM0JztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXQ0KCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVZlY3RvcihtYXRyaXgsIHZlY3Rvcikge1xuICB2YXIgcmVzdWx0ID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLCB2ZWN0b3IsIG1hdHJpeCk7XG4gIHZlYzQuc2NhbGUocmVzdWx0LCByZXN1bHQsIDEgLyByZXN1bHRbM10pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vZCh2YWx1ZSwgZGl2aXNvcikge1xuICB2YXIgbW9kdWx1cyA9IHZhbHVlICUgZGl2aXNvcjtcbiAgcmV0dXJuIG1vZHVsdXMgPCAwID8gZGl2aXNvciArIG1vZHVsdXMgOiBtb2R1bHVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICByZXR1cm4gc3RlcCAqIGVuZCArICgxIC0gc3RlcCkgKiBzdGFydDtcbn0iLCJpbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qc1wiO1xuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogNHg0IE1hdHJpeDxicj5Gb3JtYXQ6IGNvbHVtbi1tYWpvciwgd2hlbiB0eXBlZCBvdXQgaXQgbG9va3MgbGlrZSByb3ctbWFqb3I8YnI+VGhlIG1hdHJpY2VzIGFyZSBiZWluZyBwb3N0IG11bHRpcGxpZWQuXHJcbiAqIEBtb2R1bGUgbWF0NFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIG91dFswXSA9IGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgb3V0WzFdID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbMl0gPSBhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFszXSA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbNV0gPSBhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMik7XG4gIG91dFs2XSA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddID0gYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbOF0gPSBhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSk7XG4gIG91dFs5XSA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9IGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9IGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9IGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdOyAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcblxuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsyXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbM10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzRdO1xuICBiMSA9IGJbNV07XG4gIGIyID0gYls2XTtcbiAgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFs2XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbN10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzhdO1xuICBiMSA9IGJbOV07XG4gIGIyID0gYlsxMF07XG4gIGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzEwXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYlsxMl07XG4gIGIxID0gYlsxM107XG4gIGIyID0gYlsxNF07XG4gIGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTRdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxNV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gIGlmIChhID09PSBvdXQpIHtcbiAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgfSBlbHNlIHtcbiAgICBhMDAgPSBhWzBdO1xuICAgIGEwMSA9IGFbMV07XG4gICAgYTAyID0gYVsyXTtcbiAgICBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07XG4gICAgYTExID0gYVs1XTtcbiAgICBhMTIgPSBhWzZdO1xuICAgIGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTtcbiAgICBhMjEgPSBhWzldO1xuICAgIGEyMiA9IGFbMTBdO1xuICAgIGEyMyA9IGFbMTFdO1xuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuICAgIG91dFszXSA9IGEwMztcbiAgICBvdXRbNF0gPSBhMTA7XG4gICAgb3V0WzVdID0gYTExO1xuICAgIG91dFs2XSA9IGExMjtcbiAgICBvdXRbN10gPSBhMTM7XG4gICAgb3V0WzhdID0gYTIwO1xuICAgIG91dFs5XSA9IGEyMTtcbiAgICBvdXRbMTBdID0gYTIyO1xuICAgIG91dFsxMV0gPSBhMjM7XG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgICAgeSA9IGF4aXNbMV0sXG4gICAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguaHlwb3QoeCwgeSwgeik7XG4gIHZhciBzLCBjLCB0O1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICB2YXIgYjAwLCBiMDEsIGIwMjtcbiAgdmFyIGIxMCwgYjExLCBiMTI7XG4gIHZhciBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcbiAgYTAwID0gYVswXTtcbiAgYTAxID0gYVsxXTtcbiAgYTAyID0gYVsyXTtcbiAgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTtcbiAgYTExID0gYVs1XTtcbiAgYTEyID0gYVs2XTtcbiAgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTtcbiAgYTIxID0gYVs5XTtcbiAgYTIyID0gYVsxMF07XG4gIGEyMyA9IGFbMTFdOyAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcblxuICBiMDAgPSB4ICogeCAqIHQgKyBjO1xuICBiMDEgPSB5ICogeCAqIHQgKyB6ICogcztcbiAgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzO1xuICBiMTEgPSB5ICogeSAqIHQgKyBjO1xuICBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIGIyMSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBiMjIgPSB6ICogeiAqIHQgKyBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgICAgeSA9IGF4aXNbMV0sXG4gICAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguaHlwb3QoeCwgeSwgeik7XG4gIHZhciBzLCBjLCB0O1xuXG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC1zO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgZnJvbSBhIGR1YWwgcXVhdC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgTWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybnMge21hdDR9IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgYSwgdHJhbnNsYXRpb24pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxyXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXHJcbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZVxyXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXHJcbiAqICB0aGUgc2FtZSBhcyB0aGUgc2NhbGluZyB2ZWN0b3JcclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIHZhciBtMTEgPSBtYXRbMF07XG4gIHZhciBtMTIgPSBtYXRbMV07XG4gIHZhciBtMTMgPSBtYXRbMl07XG4gIHZhciBtMjEgPSBtYXRbNF07XG4gIHZhciBtMjIgPSBtYXRbNV07XG4gIHZhciBtMjMgPSBtYXRbNl07XG4gIHZhciBtMzEgPSBtYXRbOF07XG4gIHZhciBtMzIgPSBtYXRbOV07XG4gIHZhciBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcclxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXHJcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcclxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIHZhciBzY2FsaW5nID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGdldFNjYWxpbmcoc2NhbGluZywgbWF0KTtcbiAgdmFyIGlzMSA9IDEgLyBzY2FsaW5nWzBdO1xuICB2YXIgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gIHZhciBpczMgPSAxIC8gc2NhbGluZ1syXTtcbiAgdmFyIHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gIHZhciBzbTEyID0gbWF0WzFdICogaXMyO1xuICB2YXIgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgdmFyIHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gIHZhciBzbTIyID0gbWF0WzVdICogaXMyO1xuICB2YXIgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgdmFyIHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gIHZhciBzbTMyID0gbWF0WzldICogaXMyO1xuICB2YXIgc20zMyA9IG1hdFsxMF0gKiBpczM7XG4gIHZhciB0cmFjZSA9IHNtMTEgKyBzbTIyICsgc20zMztcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMTEgLSBzbTIyIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICB9IGVsc2UgaWYgKHNtMjIgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMF0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMzMgLSBzbTExIC0gc20yMikgKiAyO1xuICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgIG91dFswXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIG91dFsxXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShvdXQsIHEsIHYsIHMpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XHJcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBzIFNjYWxpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICB2YXIgb3ggPSBvWzBdO1xuICB2YXIgb3kgPSBvWzFdO1xuICB2YXIgb3ogPSBvWzJdO1xuICB2YXIgb3V0MCA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICB2YXIgb3V0MSA9ICh4eSArIHd6KSAqIHN4O1xuICB2YXIgb3V0MiA9ICh4eiAtIHd5KSAqIHN4O1xuICB2YXIgb3V0NCA9ICh4eSAtIHd6KSAqIHN5O1xuICB2YXIgb3V0NSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICB2YXIgb3V0NiA9ICh5eiArIHd4KSAqIHN5O1xuICB2YXIgb3V0OCA9ICh4eiArIHd5KSAqIHN6O1xuICB2YXIgb3V0OSA9ICh5eiAtIHd4KSAqIHN6O1xuICB2YXIgb3V0MTAgPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgb3V0WzZdID0gb3V0NjtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gb3V0ODtcbiAgb3V0WzldID0gb3V0OTtcbiAgb3V0WzEwXSA9IG91dDEwO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXQwICogb3ggKyBvdXQ0ICogb3kgKyBvdXQ4ICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dDEgKiBveCArIG91dDUgKiBveSArIG91dDkgKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0MiAqIG94ICsgb3V0NiAqIG95ICsgb3V0MTAgKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICB2YXIgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IG5lYXIgKiAyICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IG5lYXIgKiAyICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyICogMiAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXHJcbiAqIFBhc3NpbmcgbnVsbC91bmRlZmluZWQvbm8gdmFsdWUgZm9yIGZhciB3aWxsIGdlbmVyYXRlIGluZmluaXRlIHByb2plY3Rpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtLCBjYW4gYmUgbnVsbCBvciBJbmZpbml0eVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG5cbiAgaWYgKGZhciAhPSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNF0gPSAyICogZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLTIgKiBuZWFyO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxyXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXHJcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIHZhciB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy5cclxuICogSWYgeW91IHdhbnQgYSBtYXRyaXggdGhhdCBhY3R1YWxseSBtYWtlcyBhbiBvYmplY3QgbG9vayBhdCBhbm90aGVyIG9iamVjdCwgeW91IHNob3VsZCB1c2UgdGFyZ2V0VG8gaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICB2YXIgZXlleCA9IGV5ZVswXTtcbiAgdmFyIGV5ZXkgPSBleWVbMV07XG4gIHZhciBleWV6ID0gZXllWzJdO1xuICB2YXIgdXB4ID0gdXBbMF07XG4gIHZhciB1cHkgPSB1cFsxXTtcbiAgdmFyIHVweiA9IHVwWzJdO1xuICB2YXIgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgdmFyIGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIHZhciBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcbiAgbGVuID0gMSAvIE1hdGguaHlwb3QoejAsIHoxLCB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG4gIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeDAsIHgxLCB4Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB4MCA9IDA7XG4gICAgeDEgPSAwO1xuICAgIHgyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh5MCwgeTEsIHkyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG1hdHJpeCB0aGF0IG1ha2VzIHNvbWV0aGluZyBsb29rIGF0IHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgdmFyIHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIiwgXCIgKyBhWzZdICsgXCIsIFwiICsgYVs3XSArIFwiLCBcIiArIGFbOF0gKyBcIiwgXCIgKyBhWzldICsgXCIsIFwiICsgYVsxMF0gKyBcIiwgXCIgKyBhWzExXSArIFwiLCBcIiArIGFbMTJdICsgXCIsIFwiICsgYVsxM10gKyBcIiwgXCIgKyBhWzE0XSArIFwiLCBcIiArIGFbMTVdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSwgYVs5XSwgYVsxMF0sIGFbMTFdLCBhWzEyXSwgYVsxM10sIGFbMTRdLCBhWzE1XSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0NCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgb3V0WzldID0gYVs5XSAqIGI7XG4gIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICBvdXRbOV0gPSBhWzldICsgYls5XSAqIHNjYWxlO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXSAqIHNjYWxlO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXSAqIHNjYWxlO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXSAqIHNjYWxlO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXSAqIHNjYWxlO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XSAqIHNjYWxlO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiYgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYTggPSBhWzhdLFxuICAgICAgYTkgPSBhWzldLFxuICAgICAgYTEwID0gYVsxMF0sXG4gICAgICBhMTEgPSBhWzExXTtcbiAgdmFyIGExMiA9IGFbMTJdLFxuICAgICAgYTEzID0gYVsxM10sXG4gICAgICBhMTQgPSBhWzE0XSxcbiAgICAgIGExNSA9IGFbMTVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICB2YXIgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICB2YXIgYjggPSBiWzhdLFxuICAgICAgYjkgPSBiWzldLFxuICAgICAgYjEwID0gYlsxMF0sXG4gICAgICBiMTEgPSBiWzExXTtcbiAgdmFyIGIxMiA9IGJbMTJdLFxuICAgICAgYjEzID0gYlsxM10sXG4gICAgICBiMTQgPSBiWzE0XSxcbiAgICAgIGIxNSA9IGJbMTVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiYgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiYgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJiBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiYgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJiBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCBcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmh5cG90LmpzXCI7XG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB4MSA9IGFbMF0sXG4gICAgICB5MSA9IGFbMV0sXG4gICAgICB4MiA9IGJbMF0sXG4gICAgICB5MiA9IGJbMV0sXG4gICAgICAvLyBtYWcgaXMgdGhlIHByb2R1Y3Qgb2YgdGhlIG1hZ25pdHVkZXMgb2YgYSBhbmQgYlxuICBtYWcgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpICogTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKSxcbiAgICAgIC8vIG1hZyAmJi4uIHNob3J0IGNpcmN1aXRzIGlmIG1hZyA9PSAwXG4gIGNvc2luZSA9IG1hZyAmJiAoeDEgKiB4MiArIHkxICogeTIpIC8gbWFnOyAvLyBNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkgY2xhbXBzIHRoZSBjb3NpbmUgYmV0d2VlbiAtMSBhbmQgMVxuXG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qc1wiO1xuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWMzXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxyXG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMl0gKiBNYXRoLnNpbihyYWQpICsgcFswXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSAqIE1hdGguY29zKHJhZCkgLSBwWzBdICogTWF0aC5zaW4ocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KSxcbiAgICAgIG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSxcbiAgICAgIG1hZyA9IG1hZzEgKiBtYWcyLFxuICAgICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcjogYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufSIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnZ2wtbWF0cml4L21hdDQnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBQSV80ID0gUEkgLyA0O1xudmFyIERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xudmFyIFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xudmFyIFRJTEVfU0laRSA9IDUxMjtcbnZhciBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcbnZhciBERUZBVUxUX0FMVElUVURFID0gMS41O1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21Ub1NjYWxlKHpvb20pIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlVG9ab29tKHNjYWxlKSB7XG4gIHJldHVybiBNYXRoLmxvZzIoc2NhbGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxuZ0xhdFRvV29ybGQoX3JlZikge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgIGxuZyA9IF9yZWYyWzBdLFxuICAgICAgbGF0ID0gX3JlZjJbMV07XG5cbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsbmcpKTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXQpICYmIGxhdCA+PSAtOTAgJiYgbGF0IDw9IDkwLCAnaW52YWxpZCBsYXRpdHVkZScpO1xuICB2YXIgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgdmFyIHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIHZhciB4ID0gVElMRV9TSVpFICogKGxhbWJkYTIgKyBQSSkgLyAoMiAqIFBJKTtcbiAgdmFyIHkgPSBUSUxFX1NJWkUgKiAoUEkgKyBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuICByZXR1cm4gW3gsIHldO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoX3JlZjMpIHtcbiAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgeCA9IF9yZWY0WzBdLFxuICAgICAgeSA9IF9yZWY0WzFdO1xuXG4gIHZhciBsYW1iZGEyID0geCAvIFRJTEVfU0laRSAqICgyICogUEkpIC0gUEk7XG4gIHZhciBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoeSAvIFRJTEVfU0laRSAqICgyICogUEkpIC0gUEkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGVyWm9vbShfcmVmNSkge1xuICB2YXIgbGF0aXR1ZGUgPSBfcmVmNS5sYXRpdHVkZTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkpO1xuICB2YXIgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gc2NhbGVUb1pvb20oRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIGxhdENvc2luZSkgLSA5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlU2NhbGVzKF9yZWY2KSB7XG4gIHZhciBsYXRpdHVkZSA9IF9yZWY2LmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlID0gX3JlZjYubG9uZ2l0dWRlLFxuICAgICAgX3JlZjYkaGlnaFByZWNpc2lvbiA9IF9yZWY2LmhpZ2hQcmVjaXNpb24sXG4gICAgICBoaWdoUHJlY2lzaW9uID0gX3JlZjYkaGlnaFByZWNpc2lvbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNiRoaWdoUHJlY2lzaW9uO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSk7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHdvcmxkU2l6ZSA9IFRJTEVfU0laRTtcbiAgdmFyIGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgdmFyIHVuaXRzUGVyRGVncmVlWCA9IHdvcmxkU2l6ZSAvIDM2MDtcbiAgdmFyIHVuaXRzUGVyRGVncmVlWSA9IHVuaXRzUGVyRGVncmVlWCAvIGxhdENvc2luZTtcbiAgdmFyIGFsdFVuaXRzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFIC8gbGF0Q29zaW5lO1xuICByZXN1bHQudW5pdHNQZXJNZXRlciA9IFthbHRVbml0c1Blck1ldGVyLCBhbHRVbml0c1Blck1ldGVyLCBhbHRVbml0c1Blck1ldGVyXTtcbiAgcmVzdWx0Lm1ldGVyc1BlclVuaXQgPSBbMSAvIGFsdFVuaXRzUGVyTWV0ZXIsIDEgLyBhbHRVbml0c1Blck1ldGVyLCAxIC8gYWx0VW5pdHNQZXJNZXRlcl07XG4gIHJlc3VsdC51bml0c1BlckRlZ3JlZSA9IFt1bml0c1BlckRlZ3JlZVgsIHVuaXRzUGVyRGVncmVlWSwgYWx0VW5pdHNQZXJNZXRlcl07XG4gIHJlc3VsdC5kZWdyZWVzUGVyVW5pdCA9IFsxIC8gdW5pdHNQZXJEZWdyZWVYLCAxIC8gdW5pdHNQZXJEZWdyZWVZLCAxIC8gYWx0VW5pdHNQZXJNZXRlcl07XG5cbiAgaWYgKGhpZ2hQcmVjaXNpb24pIHtcbiAgICB2YXIgbGF0Q29zaW5lMiA9IERFR1JFRVNfVE9fUkFESUFOUyAqIE1hdGgudGFuKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKSAvIGxhdENvc2luZTtcbiAgICB2YXIgdW5pdHNQZXJEZWdyZWVZMiA9IHVuaXRzUGVyRGVncmVlWCAqIGxhdENvc2luZTIgLyAyO1xuICAgIHZhciBhbHRVbml0c1BlckRlZ3JlZTIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lMjtcbiAgICB2YXIgYWx0VW5pdHNQZXJNZXRlcjIgPSBhbHRVbml0c1BlckRlZ3JlZTIgLyB1bml0c1BlckRlZ3JlZVkgKiBhbHRVbml0c1Blck1ldGVyO1xuICAgIHJlc3VsdC51bml0c1BlckRlZ3JlZTIgPSBbMCwgdW5pdHNQZXJEZWdyZWVZMiwgYWx0VW5pdHNQZXJEZWdyZWUyXTtcbiAgICByZXN1bHQudW5pdHNQZXJNZXRlcjIgPSBbYWx0VW5pdHNQZXJNZXRlcjIsIDAsIGFsdFVuaXRzUGVyTWV0ZXIyXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gIHZhciBfbG5nTGF0WiA9IF9zbGljZWRUb0FycmF5KGxuZ0xhdFosIDMpLFxuICAgICAgbG9uZ2l0dWRlID0gX2xuZ0xhdFpbMF0sXG4gICAgICBsYXRpdHVkZSA9IF9sbmdMYXRaWzFdLFxuICAgICAgejAgPSBfbG5nTGF0WlsyXTtcblxuICB2YXIgX3h5eiA9IF9zbGljZWRUb0FycmF5KHh5eiwgMyksXG4gICAgICB4ID0gX3h5elswXSxcbiAgICAgIHkgPSBfeHl6WzFdLFxuICAgICAgeiA9IF94eXpbMl07XG5cbiAgdmFyIF9nZXREaXN0YW5jZVNjYWxlcyA9IGdldERpc3RhbmNlU2NhbGVzKHtcbiAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgaGlnaFByZWNpc2lvbjogdHJ1ZVxuICB9KSxcbiAgICAgIHVuaXRzUGVyTWV0ZXIgPSBfZ2V0RGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlcixcbiAgICAgIHVuaXRzUGVyTWV0ZXIyID0gX2dldERpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXIyO1xuXG4gIHZhciB3b3JsZHNwYWNlID0gbG5nTGF0VG9Xb3JsZChsbmdMYXRaKTtcbiAgd29ybGRzcGFjZVswXSArPSB4ICogKHVuaXRzUGVyTWV0ZXJbMF0gKyB1bml0c1Blck1ldGVyMlswXSAqIHkpO1xuICB3b3JsZHNwYWNlWzFdICs9IHkgKiAodW5pdHNQZXJNZXRlclsxXSArIHVuaXRzUGVyTWV0ZXIyWzFdICogeSk7XG4gIHZhciBuZXdMbmdMYXQgPSB3b3JsZFRvTG5nTGF0KHdvcmxkc3BhY2UpO1xuICB2YXIgbmV3WiA9ICh6MCB8fCAwKSArICh6IHx8IDApO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHowKSB8fCBOdW1iZXIuaXNGaW5pdGUoeikgPyBbbmV3TG5nTGF0WzBdLCBuZXdMbmdMYXRbMV0sIG5ld1pdIDogbmV3TG5nTGF0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdNYXRyaXgoX3JlZjcpIHtcbiAgdmFyIGhlaWdodCA9IF9yZWY3LmhlaWdodCxcbiAgICAgIHBpdGNoID0gX3JlZjcucGl0Y2gsXG4gICAgICBiZWFyaW5nID0gX3JlZjcuYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlID0gX3JlZjcuYWx0aXR1ZGUsXG4gICAgICBzY2FsZSA9IF9yZWY3LnNjYWxlLFxuICAgICAgX3JlZjckY2VudGVyID0gX3JlZjcuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjckY2VudGVyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjckY2VudGVyO1xuICB2YXIgdm0gPSBjcmVhdGVNYXQ0KCk7XG4gIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuICBtYXQ0LnJvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgc2NhbGUgLz0gaGVpZ2h0O1xuICBtYXQ0LnNjYWxlKHZtLCB2bSwgW3NjYWxlLCBzY2FsZSwgc2NhbGVdKTtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCB2ZWMzLm5lZ2F0ZShbXSwgY2VudGVyKSk7XG4gIH1cblxuICByZXR1cm4gdm07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMoX3JlZjgpIHtcbiAgdmFyIHdpZHRoID0gX3JlZjgud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmOC5oZWlnaHQsXG4gICAgICBfcmVmOCRhbHRpdHVkZSA9IF9yZWY4LmFsdGl0dWRlLFxuICAgICAgYWx0aXR1ZGUgPSBfcmVmOCRhbHRpdHVkZSA9PT0gdm9pZCAwID8gREVGQVVMVF9BTFRJVFVERSA6IF9yZWY4JGFsdGl0dWRlLFxuICAgICAgX3JlZjgkcGl0Y2ggPSBfcmVmOC5waXRjaCxcbiAgICAgIHBpdGNoID0gX3JlZjgkcGl0Y2ggPT09IHZvaWQgMCA/IDAgOiBfcmVmOCRwaXRjaCxcbiAgICAgIF9yZWY4JG5lYXJaTXVsdGlwbGllciA9IF9yZWY4Lm5lYXJaTXVsdGlwbGllcixcbiAgICAgIG5lYXJaTXVsdGlwbGllciA9IF9yZWY4JG5lYXJaTXVsdGlwbGllciA9PT0gdm9pZCAwID8gMSA6IF9yZWY4JG5lYXJaTXVsdGlwbGllcixcbiAgICAgIF9yZWY4JGZhclpNdWx0aXBsaWVyID0gX3JlZjguZmFyWk11bHRpcGxpZXIsXG4gICAgICBmYXJaTXVsdGlwbGllciA9IF9yZWY4JGZhclpNdWx0aXBsaWVyID09PSB2b2lkIDAgPyAxIDogX3JlZjgkZmFyWk11bHRpcGxpZXI7XG4gIHZhciBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgdmFyIGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICB2YXIgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLm1pbihNYXRoLm1heChNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YsIDAuMDEpLCBNYXRoLlBJIC0gMC4wMSkpO1xuICB2YXIgZmFyWiA9IE1hdGguc2luKHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG4gIHJldHVybiB7XG4gICAgZm92OiAyICogaGFsZkZvdixcbiAgICBhc3BlY3Q6IHdpZHRoIC8gaGVpZ2h0LFxuICAgIGZvY2FsRGlzdGFuY2U6IGFsdGl0dWRlLFxuICAgIG5lYXI6IG5lYXJaTXVsdGlwbGllcixcbiAgICBmYXI6IGZhclogKiBmYXJaTXVsdGlwbGllclxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgoX3JlZjkpIHtcbiAgdmFyIHdpZHRoID0gX3JlZjkud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmOS5oZWlnaHQsXG4gICAgICBwaXRjaCA9IF9yZWY5LnBpdGNoLFxuICAgICAgYWx0aXR1ZGUgPSBfcmVmOS5hbHRpdHVkZSxcbiAgICAgIG5lYXJaTXVsdGlwbGllciA9IF9yZWY5Lm5lYXJaTXVsdGlwbGllcixcbiAgICAgIGZhclpNdWx0aXBsaWVyID0gX3JlZjkuZmFyWk11bHRpcGxpZXI7XG5cbiAgdmFyIF9nZXRQcm9qZWN0aW9uUGFyYW1ldCA9IGdldFByb2plY3Rpb25QYXJhbWV0ZXJzKHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgYWx0aXR1ZGU6IGFsdGl0dWRlLFxuICAgIHBpdGNoOiBwaXRjaCxcbiAgICBuZWFyWk11bHRpcGxpZXI6IG5lYXJaTXVsdGlwbGllcixcbiAgICBmYXJaTXVsdGlwbGllcjogZmFyWk11bHRpcGxpZXJcbiAgfSksXG4gICAgICBmb3YgPSBfZ2V0UHJvamVjdGlvblBhcmFtZXQuZm92LFxuICAgICAgYXNwZWN0ID0gX2dldFByb2plY3Rpb25QYXJhbWV0LmFzcGVjdCxcbiAgICAgIG5lYXIgPSBfZ2V0UHJvamVjdGlvblBhcmFtZXQubmVhcixcbiAgICAgIGZhciA9IF9nZXRQcm9qZWN0aW9uUGFyYW1ldC5mYXI7XG5cbiAgdmFyIHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKFtdLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb1BpeGVscyh4eXosIHBpeGVsUHJvamVjdGlvbk1hdHJpeCkge1xuICB2YXIgX3h5ejIgPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgeCA9IF94eXoyWzBdLFxuICAgICAgeSA9IF94eXoyWzFdLFxuICAgICAgX3h5ejIkID0gX3h5ejJbMl0sXG4gICAgICB6ID0gX3h5ejIkID09PSB2b2lkIDAgPyAwIDogX3h5ejIkO1xuXG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpICYmIE51bWJlci5pc0Zpbml0ZSh6KSk7XG4gIHJldHVybiB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpeGVsc1RvV29ybGQoeHl6LCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCkge1xuICB2YXIgdGFyZ2V0WiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICB2YXIgX3h5ejMgPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgeCA9IF94eXozWzBdLFxuICAgICAgeSA9IF94eXozWzFdLFxuICAgICAgeiA9IF94eXozWzJdO1xuXG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpLCAnaW52YWxpZCBwaXhlbCBjb29yZGluYXRlJyk7XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgIHZhciBjb29yZCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbiAgICByZXR1cm4gY29vcmQ7XG4gIH1cblxuICB2YXIgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICB2YXIgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMSwgMV0pO1xuICB2YXIgejAgPSBjb29yZDBbMl07XG4gIHZhciB6MSA9IGNvb3JkMVsyXTtcbiAgdmFyIHQgPSB6MCA9PT0gejEgPyAwIDogKCh0YXJnZXRaIHx8IDApIC0gejApIC8gKHoxIC0gejApO1xuICByZXR1cm4gdmVjMi5sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpdEJvdW5kcyhfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgX3JlZiRtaW5FeHRlbnQgPSBfcmVmLm1pbkV4dGVudCxcbiAgICAgIG1pbkV4dGVudCA9IF9yZWYkbWluRXh0ZW50ID09PSB2b2lkIDAgPyAwIDogX3JlZiRtaW5FeHRlbnQsXG4gICAgICBfcmVmJG1heFpvb20gPSBfcmVmLm1heFpvb20sXG4gICAgICBtYXhab29tID0gX3JlZiRtYXhab29tID09PSB2b2lkIDAgPyAyNCA6IF9yZWYkbWF4Wm9vbSxcbiAgICAgIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBhZGRpbmcsXG4gICAgICBfcmVmJG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX3JlZiRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9yZWYkb2Zmc2V0O1xuXG4gIHZhciBfYm91bmRzID0gX3NsaWNlZFRvQXJyYXkoYm91bmRzLCAyKSxcbiAgICAgIF9ib3VuZHMkID0gX3NsaWNlZFRvQXJyYXkoX2JvdW5kc1swXSwgMiksXG4gICAgICB3ZXN0ID0gX2JvdW5kcyRbMF0sXG4gICAgICBzb3V0aCA9IF9ib3VuZHMkWzFdLFxuICAgICAgX2JvdW5kcyQyID0gX3NsaWNlZFRvQXJyYXkoX2JvdW5kc1sxXSwgMiksXG4gICAgICBlYXN0ID0gX2JvdW5kcyQyWzBdLFxuICAgICAgbm9ydGggPSBfYm91bmRzJDJbMV07XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZShwYWRkaW5nKSkge1xuICAgIHZhciBwID0gcGFkZGluZztcbiAgICBwYWRkaW5nID0ge1xuICAgICAgdG9wOiBwLFxuICAgICAgYm90dG9tOiBwLFxuICAgICAgbGVmdDogcCxcbiAgICAgIHJpZ2h0OiBwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcudG9wKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5ib3R0b20pICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLmxlZnQpICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnJpZ2h0KSk7XG4gIH1cblxuICB2YXIgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGxvbmdpdHVkZTogMCxcbiAgICBsYXRpdHVkZTogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuICB2YXIgbncgPSB2aWV3cG9ydC5wcm9qZWN0KFt3ZXN0LCBub3J0aF0pO1xuICB2YXIgc2UgPSB2aWV3cG9ydC5wcm9qZWN0KFtlYXN0LCBzb3V0aF0pO1xuICB2YXIgc2l6ZSA9IFtNYXRoLm1heChNYXRoLmFicyhzZVswXSAtIG53WzBdKSwgbWluRXh0ZW50KSwgTWF0aC5tYXgoTWF0aC5hYnMoc2VbMV0gLSBud1sxXSksIG1pbkV4dGVudCldO1xuICB2YXIgdGFyZ2V0U2l6ZSA9IFt3aWR0aCAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMiwgaGVpZ2h0IC0gcGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSAtIE1hdGguYWJzKG9mZnNldFsxXSkgKiAyXTtcbiAgYXNzZXJ0KHRhcmdldFNpemVbMF0gPiAwICYmIHRhcmdldFNpemVbMV0gPiAwKTtcbiAgdmFyIHNjYWxlWCA9IHRhcmdldFNpemVbMF0gLyBzaXplWzBdO1xuICB2YXIgc2NhbGVZID0gdGFyZ2V0U2l6ZVsxXSAvIHNpemVbMV07XG4gIHZhciBvZmZzZXRYID0gKHBhZGRpbmcucmlnaHQgLSBwYWRkaW5nLmxlZnQpIC8gMiAvIHNjYWxlWDtcbiAgdmFyIG9mZnNldFkgPSAocGFkZGluZy5ib3R0b20gLSBwYWRkaW5nLnRvcCkgLyAyIC8gc2NhbGVZO1xuICB2YXIgY2VudGVyID0gWyhzZVswXSArIG53WzBdKSAvIDIgKyBvZmZzZXRYLCAoc2VbMV0gKyBud1sxXSkgLyAyICsgb2Zmc2V0WV07XG4gIHZhciBjZW50ZXJMbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QoY2VudGVyKTtcbiAgdmFyIHpvb20gPSBNYXRoLm1pbihtYXhab29tLCB2aWV3cG9ydC56b29tICsgTWF0aC5sb2cyKE1hdGguYWJzKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkpKTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh6b29tKSk7XG4gIHJldHVybiB7XG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJMbmdMYXRbMF0sXG4gICAgbGF0aXR1ZGU6IGNlbnRlckxuZ0xhdFsxXSxcbiAgICB6b29tOiB6b29tXG4gIH07XG59IiwiaW1wb3J0IHsgd29ybGRUb0xuZ0xhdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0IHsgdHJhbnNmb3JtVmVjdG9yIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbnZhciBERUdSRUVTX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRzKHZpZXdwb3J0KSB7XG4gIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgd2lkdGggPSB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodCA9IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgIHVucHJvamVjdCA9IHZpZXdwb3J0LnVucHJvamVjdDtcbiAgdmFyIHVucHJvamVjdE9wcyA9IHtcbiAgICB0YXJnZXRaOiB6XG4gIH07XG4gIHZhciBib3R0b21MZWZ0ID0gdW5wcm9qZWN0KFswLCBoZWlnaHRdLCB1bnByb2plY3RPcHMpO1xuICB2YXIgYm90dG9tUmlnaHQgPSB1bnByb2plY3QoW3dpZHRoLCBoZWlnaHRdLCB1bnByb2plY3RPcHMpO1xuICB2YXIgdG9wTGVmdDtcbiAgdmFyIHRvcFJpZ2h0O1xuICB2YXIgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyB2aWV3cG9ydC5hbHRpdHVkZSk7XG4gIHZhciBhbmdsZVRvR3JvdW5kID0gKDkwIC0gdmlld3BvcnQucGl0Y2gpICogREVHUkVFU19UT19SQURJQU5TO1xuXG4gIGlmIChoYWxmRm92ID4gYW5nbGVUb0dyb3VuZCAtIDAuMDEpIHtcbiAgICB0b3BMZWZ0ID0gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgMCwgeik7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCB3aWR0aCwgeik7XG4gIH0gZWxzZSB7XG4gICAgdG9wTGVmdCA9IHVucHJvamVjdChbMCwgMF0sIHVucHJvamVjdE9wcyk7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3QoW3dpZHRoLCAwXSwgdW5wcm9qZWN0T3BzKTtcbiAgfVxuXG4gIHJldHVybiBbYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCB0b3BMZWZ0XTtcbn1cblxuZnVuY3Rpb24gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgeCwgdGFyZ2V0Wikge1xuICB2YXIgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB2aWV3cG9ydC5waXhlbFVucHJvamVjdGlvbk1hdHJpeDtcbiAgdmFyIGNvb3JkMCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIDAsIDEsIDFdKTtcbiAgdmFyIGNvb3JkMSA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHZpZXdwb3J0LmhlaWdodCwgMSwgMV0pO1xuICB2YXIgeiA9IHRhcmdldFogKiB2aWV3cG9ydC5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICB2YXIgdCA9ICh6IC0gY29vcmQwWzJdKSAvIChjb29yZDFbMl0gLSBjb29yZDBbMl0pO1xuICB2YXIgY29vcmQgPSB2ZWMyLmxlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcbiAgdmFyIHJlc3VsdCA9IHdvcmxkVG9MbmdMYXQoY29vcmQpO1xuICByZXN1bHRbMl0gPSB0YXJnZXRaO1xuICByZXR1cm4gcmVzdWx0O1xufSIsImltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyB6b29tVG9TY2FsZSwgcGl4ZWxzVG9Xb3JsZCwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCwgd29ybGRUb1BpeGVscywgZ2V0UHJvamVjdGlvbk1hdHJpeCwgZ2V0RGlzdGFuY2VTY2FsZXMsIGdldFZpZXdNYXRyaXggfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgX2ZpdEJvdW5kcyBmcm9tICcuL2ZpdC1ib3VuZHMnO1xuaW1wb3J0IGdldEJvdW5kcyBmcm9tICcuL2dldC1ib3VuZHMnO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tICdnbC1tYXRyaXgvbWF0NCc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xuXG52YXIgV2ViTWVyY2F0b3JWaWV3cG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViTWVyY2F0b3JWaWV3cG9ydCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9LFxuICAgICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgICBfcmVmJGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGUgPSBfcmVmJGxhdGl0dWRlID09PSB2b2lkIDAgPyAwIDogX3JlZiRsYXRpdHVkZSxcbiAgICAgICAgX3JlZiRsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3JlZiRsb25naXR1ZGUgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGxvbmdpdHVkZSxcbiAgICAgICAgX3JlZiR6b29tID0gX3JlZi56b29tLFxuICAgICAgICB6b29tID0gX3JlZiR6b29tID09PSB2b2lkIDAgPyAwIDogX3JlZiR6b29tLFxuICAgICAgICBfcmVmJHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgICAgcGl0Y2ggPSBfcmVmJHBpdGNoID09PSB2b2lkIDAgPyAwIDogX3JlZiRwaXRjaCxcbiAgICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgICBiZWFyaW5nID0gX3JlZiRiZWFyaW5nID09PSB2b2lkIDAgPyAwIDogX3JlZiRiZWFyaW5nLFxuICAgICAgICBfcmVmJGFsdGl0dWRlID0gX3JlZi5hbHRpdHVkZSxcbiAgICAgICAgYWx0aXR1ZGUgPSBfcmVmJGFsdGl0dWRlID09PSB2b2lkIDAgPyAxLjUgOiBfcmVmJGFsdGl0dWRlLFxuICAgICAgICBfcmVmJHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmJHBvc2l0aW9uID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRwb3NpdGlvbixcbiAgICAgICAgX3JlZiRuZWFyWk11bHRpcGxpZXIgPSBfcmVmLm5lYXJaTXVsdGlwbGllcixcbiAgICAgICAgbmVhclpNdWx0aXBsaWVyID0gX3JlZiRuZWFyWk11bHRpcGxpZXIgPT09IHZvaWQgMCA/IDAuMDIgOiBfcmVmJG5lYXJaTXVsdGlwbGllcixcbiAgICAgICAgX3JlZiRmYXJaTXVsdGlwbGllciA9IF9yZWYuZmFyWk11bHRpcGxpZXIsXG4gICAgICAgIGZhclpNdWx0aXBsaWVyID0gX3JlZiRmYXJaTXVsdGlwbGllciA9PT0gdm9pZCAwID8gMS4wMSA6IF9yZWYkZmFyWk11bHRpcGxpZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViTWVyY2F0b3JWaWV3cG9ydCk7XG5cbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdmFyIHNjYWxlID0gem9vbVRvU2NhbGUoem9vbSk7XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgdmFyIGRpc3RhbmNlU2NhbGVzID0gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICB9KTtcbiAgICB2YXIgY2VudGVyID0gbG5nTGF0VG9Xb3JsZChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0pO1xuICAgIGNlbnRlclsyXSA9IDA7XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHZlYzMuYWRkKGNlbnRlciwgY2VudGVyLCB2ZWMzLm11bChbXSwgcG9zaXRpb24sIGRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXIpKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcGl0Y2g6IHBpdGNoLFxuICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlLFxuICAgICAgbmVhclpNdWx0aXBsaWVyOiBuZWFyWk11bHRpcGxpZXIsXG4gICAgICBmYXJaTXVsdGlwbGllcjogZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcbiAgICB0aGlzLnZpZXdNYXRyaXggPSBnZXRWaWV3TWF0cml4KHtcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlXG4gICAgfSk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgdGhpcy5tZXRlck9mZnNldCA9IHBvc2l0aW9uIHx8IFswLCAwLCAwXTtcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzID0gZGlzdGFuY2VTY2FsZXM7XG5cbiAgICB0aGlzLl9pbml0TWF0cmljZXMoKTtcblxuICAgIHRoaXMuZXF1YWxzID0gdGhpcy5lcXVhbHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3QgPSB0aGlzLnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVucHJvamVjdCA9IHRoaXMudW5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0UG9zaXRpb24gPSB0aGlzLnByb2plY3RQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0UG9zaXRpb24gPSB0aGlzLnVucHJvamVjdFBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJNZXJjYXRvclZpZXdwb3J0LCBbe1xuICAgIGtleTogXCJfaW5pdE1hdHJpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0TWF0cmljZXMoKSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHByb2plY3Rpb25NYXRyaXggPSB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG4gICAgICAgICAgdmlld01hdHJpeCA9IHRoaXMudmlld01hdHJpeDtcbiAgICAgIHZhciB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCBwcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHZpZXdNYXRyaXgpO1xuICAgICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcbiAgICAgIHZhciBtID0gY3JlYXRlTWF0NCgpO1xuICAgICAgbWF0NC5zY2FsZShtLCBtLCBbd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgMV0pO1xuICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgICBtYXQ0Lm11bHRpcGx5KG0sIG0sIHZwbSk7XG4gICAgICB2YXIgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuXG4gICAgICBpZiAoIW1JbnZlcnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuICAgICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFdlYk1lcmNhdG9yVmlld3BvcnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiYgbWF0NC5lcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJiBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9qZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3QoeHl6KSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAgIF9yZWYyJHRvcExlZnQgPSBfcmVmMi50b3BMZWZ0LFxuICAgICAgICAgIHRvcExlZnQgPSBfcmVmMiR0b3BMZWZ0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkdG9wTGVmdDtcblxuICAgICAgdmFyIHdvcmxkUG9zaXRpb24gPSB0aGlzLnByb2plY3RQb3NpdGlvbih4eXopO1xuICAgICAgdmFyIGNvb3JkID0gd29ybGRUb1BpeGVscyh3b3JsZFBvc2l0aW9uLCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAgIHZhciBfY29vcmQgPSBfc2xpY2VkVG9BcnJheShjb29yZCwgMiksXG4gICAgICAgICAgeCA9IF9jb29yZFswXSxcbiAgICAgICAgICB5ID0gX2Nvb3JkWzFdO1xuXG4gICAgICB2YXIgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHkyXSA6IFt4LCB5MiwgY29vcmRbMl1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnByb2plY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wcm9qZWN0KHh5eikge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICBfcmVmMyR0b3BMZWZ0ID0gX3JlZjMudG9wTGVmdCxcbiAgICAgICAgICB0b3BMZWZ0ID0gX3JlZjMkdG9wTGVmdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJHRvcExlZnQsXG4gICAgICAgICAgX3JlZjMkdGFyZ2V0WiA9IF9yZWYzLnRhcmdldFosXG4gICAgICAgICAgdGFyZ2V0WiA9IF9yZWYzJHRhcmdldFogPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYzJHRhcmdldFo7XG5cbiAgICAgIHZhciBfeHl6ID0gX3NsaWNlZFRvQXJyYXkoeHl6LCAzKSxcbiAgICAgICAgICB4ID0gX3h5elswXSxcbiAgICAgICAgICB5ID0gX3h5elsxXSxcbiAgICAgICAgICB6ID0gX3h5elsyXTtcblxuICAgICAgdmFyIHkyID0gdG9wTGVmdCA/IHkgOiB0aGlzLmhlaWdodCAtIHk7XG4gICAgICB2YXIgdGFyZ2V0WldvcmxkID0gdGFyZ2V0WiAmJiB0YXJnZXRaICogdGhpcy5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICAgICAgdmFyIGNvb3JkID0gcGl4ZWxzVG9Xb3JsZChbeCwgeTIsIHpdLCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaV29ybGQpO1xuXG4gICAgICB2YXIgX3RoaXMkdW5wcm9qZWN0UG9zaXRpID0gdGhpcy51bnByb2plY3RQb3NpdGlvbihjb29yZCksXG4gICAgICAgICAgX3RoaXMkdW5wcm9qZWN0UG9zaXRpMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHVucHJvamVjdFBvc2l0aSwgMyksXG4gICAgICAgICAgWCA9IF90aGlzJHVucHJvamVjdFBvc2l0aTJbMF0sXG4gICAgICAgICAgWSA9IF90aGlzJHVucHJvamVjdFBvc2l0aTJbMV0sXG4gICAgICAgICAgWiA9IF90aGlzJHVucHJvamVjdFBvc2l0aTJbMl07XG5cbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICAgICAgcmV0dXJuIFtYLCBZLCBaXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRaKSA/IFtYLCBZLCB0YXJnZXRaXSA6IFtYLCBZXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvamVjdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3RQb3NpdGlvbih4eXopIHtcbiAgICAgIHZhciBfbG5nTGF0VG9Xb3JsZCA9IGxuZ0xhdFRvV29ybGQoeHl6KSxcbiAgICAgICAgICBfbG5nTGF0VG9Xb3JsZDIgPSBfc2xpY2VkVG9BcnJheShfbG5nTGF0VG9Xb3JsZCwgMiksXG4gICAgICAgICAgWCA9IF9sbmdMYXRUb1dvcmxkMlswXSxcbiAgICAgICAgICBZID0gX2xuZ0xhdFRvV29ybGQyWzFdO1xuXG4gICAgICB2YXIgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnByb2plY3RQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnByb2plY3RQb3NpdGlvbih4eXopIHtcbiAgICAgIHZhciBfd29ybGRUb0xuZ0xhdCA9IHdvcmxkVG9MbmdMYXQoeHl6KSxcbiAgICAgICAgICBfd29ybGRUb0xuZ0xhdDIgPSBfc2xpY2VkVG9BcnJheShfd29ybGRUb0xuZ0xhdCwgMiksXG4gICAgICAgICAgWCA9IF93b3JsZFRvTG5nTGF0MlswXSxcbiAgICAgICAgICBZID0gX3dvcmxkVG9MbmdMYXQyWzFdO1xuXG4gICAgICB2YXIgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclVuaXRbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9qZWN0RmxhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICAgIHJldHVybiBsbmdMYXRUb1dvcmxkKGxuZ0xhdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVucHJvamVjdEZsYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wcm9qZWN0RmxhdCh4eSkge1xuICAgICAgcmV0dXJuIHdvcmxkVG9MbmdMYXQoeHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oX3JlZjQpIHtcbiAgICAgIHZhciBsbmdMYXQgPSBfcmVmNC5sbmdMYXQsXG4gICAgICAgICAgcG9zID0gX3JlZjQucG9zO1xuICAgICAgdmFyIGZyb21Mb2NhdGlvbiA9IHBpeGVsc1RvV29ybGQocG9zLCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIHZhciB0b0xvY2F0aW9uID0gbG5nTGF0VG9Xb3JsZChsbmdMYXQpO1xuICAgICAgdmFyIHRyYW5zbGF0ZSA9IHZlYzIuYWRkKFtdLCB0b0xvY2F0aW9uLCB2ZWMyLm5lZ2F0ZShbXSwgZnJvbUxvY2F0aW9uKSk7XG4gICAgICB2YXIgbmV3Q2VudGVyID0gdmVjMi5hZGQoW10sIHRoaXMuY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgICAgcmV0dXJuIHdvcmxkVG9MbmdMYXQobmV3Q2VudGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9jYXRpb25BdFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvY2F0aW9uQXRQb2ludChfcmVmNSkge1xuICAgICAgdmFyIGxuZ0xhdCA9IF9yZWY1LmxuZ0xhdCxcbiAgICAgICAgICBwb3MgPSBfcmVmNS5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgICAgbG5nTGF0OiBsbmdMYXQsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZml0Qm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdEJvdW5kcyhib3VuZHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIHZhciBfZml0Qm91bmRzMiA9IF9maXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGJvdW5kczogYm91bmRzXG4gICAgICB9LCBvcHRpb25zKSksXG4gICAgICAgICAgbG9uZ2l0dWRlID0gX2ZpdEJvdW5kczIubG9uZ2l0dWRlLFxuICAgICAgICAgIGxhdGl0dWRlID0gX2ZpdEJvdW5kczIubGF0aXR1ZGUsXG4gICAgICAgICAgem9vbSA9IF9maXRCb3VuZHMyLnpvb207XG5cbiAgICAgIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICAgIHpvb206IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRzKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb3JuZXJzID0gdGhpcy5nZXRCb3VuZGluZ1JlZ2lvbihvcHRpb25zKTtcbiAgICAgIHZhciB3ZXN0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvcm5lcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwWzBdO1xuICAgICAgfSkpKTtcbiAgICAgIHZhciBlYXN0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvcm5lcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwWzBdO1xuICAgICAgfSkpKTtcbiAgICAgIHZhciBzb3V0aCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShjb3JuZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcFsxXTtcbiAgICAgIH0pKSk7XG4gICAgICB2YXIgbm9ydGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoY29ybmVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHBbMV07XG4gICAgICB9KSkpO1xuICAgICAgcmV0dXJuIFtbd2VzdCwgc291dGhdLCBbZWFzdCwgbm9ydGhdXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdSZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWdpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gZ2V0Qm91bmRzKHRoaXMsIG9wdGlvbnMueiB8fCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViTWVyY2F0b3JWaWV3cG9ydDtcbn0oKTtcblxuZXhwb3J0IHsgV2ViTWVyY2F0b3JWaWV3cG9ydCBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbnZhciBNQVhfTEFUSVRVREUgPSA4NS4wNTExMztcbnZhciBNSU5fTEFUSVRVREUgPSAtODUuMDUxMTM7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemVWaWV3cG9ydFByb3BzKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSA9IF9yZWYubGF0aXR1ZGUsXG4gICAgICB6b29tID0gX3JlZi56b29tLFxuICAgICAgX3JlZiRwaXRjaCA9IF9yZWYucGl0Y2gsXG4gICAgICBwaXRjaCA9IF9yZWYkcGl0Y2ggPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBpdGNoLFxuICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgYmVhcmluZyA9IF9yZWYkYmVhcmluZyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkYmVhcmluZztcblxuICBpZiAobG9uZ2l0dWRlIDwgLTE4MCB8fCBsb25naXR1ZGUgPiAxODApIHtcbiAgICBsb25naXR1ZGUgPSBtb2QobG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG5cbiAgaWYgKGJlYXJpbmcgPCAtMTgwIHx8IGJlYXJpbmcgPiAxODApIHtcbiAgICBiZWFyaW5nID0gbW9kKGJlYXJpbmcgKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cblxuICB2YXIgZmxhdFZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgem9vbTogem9vbVxuICB9KTtcbiAgdmFyIHRvcFkgPSBmbGF0Vmlld3BvcnQucHJvamVjdChbbG9uZ2l0dWRlLCBNQVhfTEFUSVRVREVdKVsxXTtcbiAgdmFyIGJvdHRvbVkgPSBmbGF0Vmlld3BvcnQucHJvamVjdChbbG9uZ2l0dWRlLCBNSU5fTEFUSVRVREVdKVsxXTtcbiAgdmFyIHNoaWZ0WSA9IDA7XG5cbiAgaWYgKGJvdHRvbVkgLSB0b3BZIDwgaGVpZ2h0KSB7XG4gICAgem9vbSArPSBNYXRoLmxvZzIoaGVpZ2h0IC8gKGJvdHRvbVkgLSB0b3BZKSk7XG4gICAgZmxhdFZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIHpvb206IHpvb21cbiAgICB9KTtcbiAgICB0b3BZID0gZmxhdFZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgTUFYX0xBVElUVURFXSlbMV07XG4gICAgYm90dG9tWSA9IGZsYXRWaWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIE1JTl9MQVRJVFVERV0pWzFdO1xuICB9XG5cbiAgaWYgKHRvcFkgPiAwKSB7XG4gICAgc2hpZnRZID0gdG9wWTtcbiAgfSBlbHNlIGlmIChib3R0b21ZIDwgaGVpZ2h0KSB7XG4gICAgc2hpZnRZID0gYm90dG9tWSAtIGhlaWdodDtcbiAgfVxuXG4gIGlmIChzaGlmdFkpIHtcbiAgICBsYXRpdHVkZSA9IGZsYXRWaWV3cG9ydC51bnByb2plY3QoW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMiArIHNoaWZ0WV0pWzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgIHpvb206IHpvb20sXG4gICAgcGl0Y2g6IHBpdGNoLFxuICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgfTtcbn0iLCJmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uIHMoKSB7XG4gICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gZShfZTIpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBfZTI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiBmKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuaW1wb3J0IHsgbGVycCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyBzY2FsZVRvWm9vbSwgem9vbVRvU2NhbGUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbnZhciBFUFNJTE9OID0gMC4wMTtcbnZhciBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbSddO1xudmFyIERFRkFVTFRfT1BUUyA9IHtcbiAgY3VydmU6IDEuNDE0LFxuICBzcGVlZDogMS4yXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmx5VG9WaWV3cG9ydChzdGFydFByb3BzLCBlbmRQcm9wcywgdCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciB2aWV3cG9ydCA9IHt9O1xuXG4gIHZhciBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEgPSBnZXRGbHlUb1RyYW5zaXRpb25QYXJhbXMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIG9wdHMpLFxuICAgICAgc3RhcnRab29tID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnN0YXJ0Wm9vbSxcbiAgICAgIHN0YXJ0Q2VudGVyWFkgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEuc3RhcnRDZW50ZXJYWSxcbiAgICAgIHVEZWx0YSA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS51RGVsdGEsXG4gICAgICB3MCA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS53MCxcbiAgICAgIHUxID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnUxLFxuICAgICAgUyA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS5TLFxuICAgICAgcmhvID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnJobyxcbiAgICAgIHJobzIgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEucmhvMixcbiAgICAgIHIwID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnIwO1xuXG4gIGlmICh1MSA8IEVQU0lMT04pIHtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICAgIHZhciBlbmRWYWx1ZSA9IGVuZFByb3BzW2tleV07XG4gICAgICAgIHZpZXdwb3J0W2tleV0gPSBsZXJwKHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCB0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0O1xuICB9XG5cbiAgdmFyIHMgPSB0ICogUztcbiAgdmFyIHcgPSBNYXRoLmNvc2gocjApIC8gTWF0aC5jb3NoKHIwICsgcmhvICogcyk7XG4gIHZhciB1ID0gdzAgKiAoKE1hdGguY29zaChyMCkgKiBNYXRoLnRhbmgocjAgKyByaG8gKiBzKSAtIE1hdGguc2luaChyMCkpIC8gcmhvMikgLyB1MTtcbiAgdmFyIHNjYWxlSW5jcmVtZW50ID0gMSAvIHc7XG4gIHZhciBuZXdab29tID0gc3RhcnRab29tICsgc2NhbGVUb1pvb20oc2NhbGVJbmNyZW1lbnQpO1xuICB2YXIgbmV3Q2VudGVyV29ybGQgPSB2ZWMyLnNjYWxlKFtdLCB1RGVsdGEsIHUpO1xuICB2ZWMyLmFkZChuZXdDZW50ZXJXb3JsZCwgbmV3Q2VudGVyV29ybGQsIHN0YXJ0Q2VudGVyWFkpO1xuICB2YXIgbmV3Q2VudGVyID0gd29ybGRUb0xuZ0xhdChuZXdDZW50ZXJXb3JsZCk7XG4gIHZpZXdwb3J0LmxvbmdpdHVkZSA9IG5ld0NlbnRlclswXTtcbiAgdmlld3BvcnQubGF0aXR1ZGUgPSBuZXdDZW50ZXJbMV07XG4gIHZpZXdwb3J0Lnpvb20gPSBuZXdab29tO1xuICByZXR1cm4gdmlld3BvcnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmx5VG9EdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICB2YXIgX29wdHMgPSBvcHRzLFxuICAgICAgc2NyZWVuU3BlZWQgPSBfb3B0cy5zY3JlZW5TcGVlZCxcbiAgICAgIHNwZWVkID0gX29wdHMuc3BlZWQsXG4gICAgICBtYXhEdXJhdGlvbiA9IF9vcHRzLm1heER1cmF0aW9uO1xuXG4gIHZhciBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEyID0gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKSxcbiAgICAgIFMgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEyLlMsXG4gICAgICByaG8gPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEyLnJobztcblxuICB2YXIgbGVuZ3RoID0gMTAwMCAqIFM7XG4gIHZhciBkdXJhdGlvbjtcblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHNjcmVlblNwZWVkKSkge1xuICAgIGR1cmF0aW9uID0gbGVuZ3RoIC8gKHNjcmVlblNwZWVkIC8gcmhvKTtcbiAgfSBlbHNlIHtcbiAgICBkdXJhdGlvbiA9IGxlbmd0aCAvIHNwZWVkO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtYXhEdXJhdGlvbikgJiYgZHVyYXRpb24gPiBtYXhEdXJhdGlvbiA/IDAgOiBkdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICB2YXIgcmhvID0gb3B0cy5jdXJ2ZTtcbiAgdmFyIHN0YXJ0Wm9vbSA9IHN0YXJ0UHJvcHMuem9vbTtcbiAgdmFyIHN0YXJ0Q2VudGVyID0gW3N0YXJ0UHJvcHMubG9uZ2l0dWRlLCBzdGFydFByb3BzLmxhdGl0dWRlXTtcbiAgdmFyIHN0YXJ0U2NhbGUgPSB6b29tVG9TY2FsZShzdGFydFpvb20pO1xuICB2YXIgZW5kWm9vbSA9IGVuZFByb3BzLnpvb207XG4gIHZhciBlbmRDZW50ZXIgPSBbZW5kUHJvcHMubG9uZ2l0dWRlLCBlbmRQcm9wcy5sYXRpdHVkZV07XG4gIHZhciBzY2FsZSA9IHpvb21Ub1NjYWxlKGVuZFpvb20gLSBzdGFydFpvb20pO1xuICB2YXIgc3RhcnRDZW50ZXJYWSA9IGxuZ0xhdFRvV29ybGQoc3RhcnRDZW50ZXIpO1xuICB2YXIgZW5kQ2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKGVuZENlbnRlcik7XG4gIHZhciB1RGVsdGEgPSB2ZWMyLnN1YihbXSwgZW5kQ2VudGVyWFksIHN0YXJ0Q2VudGVyWFkpO1xuICB2YXIgdzAgPSBNYXRoLm1heChzdGFydFByb3BzLndpZHRoLCBzdGFydFByb3BzLmhlaWdodCk7XG4gIHZhciB3MSA9IHcwIC8gc2NhbGU7XG4gIHZhciB1MSA9IHZlYzIubGVuZ3RoKHVEZWx0YSkgKiBzdGFydFNjYWxlO1xuXG4gIHZhciBfdTEgPSBNYXRoLm1heCh1MSwgRVBTSUxPTik7XG5cbiAgdmFyIHJobzIgPSByaG8gKiByaG87XG4gIHZhciBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzIgKiByaG8yICogX3UxICogX3UxKSAvICgyICogdzAgKiByaG8yICogX3UxKTtcbiAgdmFyIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvMiAqIHJobzIgKiBfdTEgKiBfdTEpIC8gKDIgKiB3MSAqIHJobzIgKiBfdTEpO1xuICB2YXIgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApO1xuICB2YXIgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICB2YXIgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgcmV0dXJuIHtcbiAgICBzdGFydFpvb206IHN0YXJ0Wm9vbSxcbiAgICBzdGFydENlbnRlclhZOiBzdGFydENlbnRlclhZLFxuICAgIHVEZWx0YTogdURlbHRhLFxuICAgIHcwOiB3MCxcbiAgICB1MTogdTEsXG4gICAgUzogUyxcbiAgICByaG86IHJobyxcbiAgICByaG8yOiByaG8yLFxuICAgIHIwOiByMCxcbiAgICByMTogcjFcbiAgfTtcbn0iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRCb3VuZHMgfSBmcm9tICcuL2dldC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaXRCb3VuZHMgfSBmcm9tICcuL2ZpdC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBub3JtYWxpemVWaWV3cG9ydFByb3BzIH0gZnJvbSAnLi9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbHlUb1ZpZXdwb3J0LCBnZXRGbHlUb0R1cmF0aW9uIH0gZnJvbSAnLi9mbHktdG8tdmlld3BvcnQnO1xuZXhwb3J0IHsgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCwgd29ybGRUb1BpeGVscywgcGl4ZWxzVG9Xb3JsZCwgem9vbVRvU2NhbGUsIHNjYWxlVG9ab29tLCBnZXRNZXRlclpvb20sIGdldERpc3RhbmNlU2NhbGVzLCBhZGRNZXRlcnNUb0xuZ0xhdCwgZ2V0Vmlld01hdHJpeCwgZ2V0UHJvamVjdGlvbk1hdHJpeCwgZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7IiwiZXhwb3J0IHsgV2ViTWVyY2F0b3JWaWV3cG9ydCBhcyBkZWZhdWx0IH0gZnJvbSAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yJztcbmV4cG9ydCAqIGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7IiwiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXG52YXIgTWFwU2hpbSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE1hcDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xuICAgIHZhciByZXN1bHQgPSAtMTtcbiAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvKipcclxuICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAqL1xuXG4gICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XG5cbiAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcclxuICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcclxuICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICovXG5cblxuICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGN0eCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oKVxuICApO1xufSgpO1xuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cblxuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50OyAvLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxuXG52YXIgZ2xvYmFsJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblxuXG4gIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufSgpO1xuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXG5cblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcbiAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcbiAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxuICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpO1xuICAgIH0sIDEwMDAgLyA2MCk7XG4gIH07XG59KCk7IC8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxuXG5cbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cblxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2UsXG4gICAgICBsYXN0Q2FsbFRpbWUgPSAwO1xuICAvKipcclxuICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcbiAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcbiAgICAgIHByb3h5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBwcm94eSgpIHtcbiAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cbiAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxuICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcbiAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cblxuXG4gICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XG4gICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XG4gICAgfVxuXG4gICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xuICB9XG5cbiAgcmV0dXJuIHByb3h5O1xufSAvLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cblxuXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwOyAvLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXG5cbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddOyAvLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cblxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXG5cbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICovXG5cbiAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICovXG5cbiAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XG4gICAgfSAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cblxuXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHRoaXMuY29ubmVjdF8oKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xuICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTsgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cblxuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0gLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxuXG5cbiAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpOyAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcbiAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxuXG4gICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICogZW50cmllcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXG4gICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xuICAgIH0pOyAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcbiAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXG4gICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcbiAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xuICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cblxuICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xuICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxuICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcbiAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXG4gICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cblxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XG5cbiAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xuICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xuICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXG4gICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cbiAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XG5cbiAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcbiAgICB9XG5cbiAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XG4gICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICB9O1xuICAvKipcclxuICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSxcbiAgICAgICAgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7IC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXG5cbiAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcbiAgfTtcbiAgLyoqXHJcbiAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XG59KCk7XG4vKipcclxuICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gKi9cblxuXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gZnVuY3Rpb24gZGVmaW5lQ29uZmlndXJhYmxlKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cblxuXG52YXIgZ2V0V2luZG93T2YgPSBmdW5jdGlvbiBnZXRXaW5kb3dPZih0YXJnZXQpIHtcbiAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxuICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcbiAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxuICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7IC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXG4gIC8vIHByb3ZpZGVkIGVsZW1lbnQuXG5cbiAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xufTsgLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXG5cblxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cblxuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xuICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XG4gIH0sIDApO1xufVxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xuICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbiAgdmFyIHBhZGRpbmdzID0ge307XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XG4gICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcGFkZGluZ3M7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xuICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XG4gIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xuICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxuICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cbiAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDsgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXG4gIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcbiAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cbiAgLy9cbiAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXG4gIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcbiAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXG4gIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cblxuICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcbiAgICByZXR1cm4gZW1wdHlSZWN0O1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xuICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XG4gIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tOyAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcbiAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxuICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XG4gIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cblxuICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksXG4gICAgICBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpOyAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcbiAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXG5cbiAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcbiAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXG4gICAgLy9cbiAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcbiAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcbiAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxuICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xuICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XG4gICAgfVxuXG4gICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xuICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XG4gICAgfVxuICB9IC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcbiAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxuICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xuICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXG5cblxuICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcbiAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcbiAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxuICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xuICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXG4gICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XG4gICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDsgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXG4gICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcbiAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcbiAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxuICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxuXG4gICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XG4gICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcbiAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbn1cbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5cblxudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxuICAvLyBpbnRlcmZhY2UuXG4gIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7XG4gICAgfTtcbiAgfSAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcbiAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcbn0oKTtcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIGVtcHR5UmVjdDtcbiAgfVxuXG4gIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICpcclxuICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xuICB2YXIgeCA9IF9hLngsXG4gICAgICB5ID0gX2EueSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7IC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxuXG4gIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcbiAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpOyAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxuXG4gIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IGhlaWdodCArIHksXG4gICAgbGVmdDogeFxuICB9KTtcbiAgcmV0dXJuIHJlY3Q7XG59XG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xuXG5cbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xuICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcbiAgICByZXR1cm4gcmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fCByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XG4gICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcblxuICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XG59KCk7XG5cbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7IC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXG4gICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgLy9cbiAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXG4gICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XG4gICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXG5cbiAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBjb250ZW50UmVjdDogY29udGVudFJlY3RcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgKi9cblxuICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcbiAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH0gLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXG5cblxuICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xuICAgIH1cblxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187IC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxuXG4gICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTsgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXG5cbiAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH0gLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXG5cblxuICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xuICAgIH1cblxuICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187IC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXG5cbiAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcblxuICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcbiAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XG4gICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XG4gICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xuICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxuICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XzsgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cblxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcbiAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xuICB9O1xuXG4gIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcbn0oKTsgLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXG5cblxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xuXG52YXIgUmVzaXplT2JzZXJ2ZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xuICAgIH1cblxuICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcbiAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcbiAgfVxuXG4gIHJldHVybiBSZXNpemVPYnNlcnZlcjtcbn0oKTsgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxuXG5cblsnb2JzZXJ2ZScsICd1bm9ic2VydmUnLCAnZGlzY29ubmVjdCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG5cbiAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG52YXIgaW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xuICB9XG5cbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDsiLCJ2YXIgd2luZG93XyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xudmFyIGdsb2JhbF8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbnZhciBkb2N1bWVudF8gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcbmV4cG9ydCB7IHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uIHMoKSB7XG4gICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gZShfZTIpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBfZTI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiBmKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxudmFyIHJlZlByb3BzID0gWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnbWluem9vbScsICdtYXh6b29tJywgJ2ZpbHRlcicsICdsYXlvdXQnXTtcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGlmIChzdHlsZS50b0pTKSB7XG4gICAgc3R5bGUgPSBzdHlsZS50b0pTKCk7XG4gIH1cblxuICB2YXIgbGF5ZXJJbmRleCA9IHt9O1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdHlsZS5sYXllcnMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGxheWVyID0gX3N0ZXAudmFsdWU7XG4gICAgICBsYXllckluZGV4W2xheWVyLmlkXSA9IGxheWVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgdmFyIGxheWVycyA9IHN0eWxlLmxheWVycy5tYXAoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgdmFyIGxheWVyUmVmID0gbGF5ZXJJbmRleFtsYXllci5yZWZdO1xuICAgIHZhciBub3JtYWxpemVkTGF5ZXIgPSBudWxsO1xuXG4gICAgaWYgKCdpbnRlcmFjdGl2ZScgaW4gbGF5ZXIpIHtcbiAgICAgIG5vcm1hbGl6ZWRMYXllciA9IF9vYmplY3RTcHJlYWQoe30sIGxheWVyKTtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkTGF5ZXIuaW50ZXJhY3RpdmU7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyUmVmKSB7XG4gICAgICBub3JtYWxpemVkTGF5ZXIgPSBub3JtYWxpemVkTGF5ZXIgfHwgX29iamVjdFNwcmVhZCh7fSwgbGF5ZXIpO1xuICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRMYXllci5yZWY7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmVmUHJvcHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAocHJvcE5hbWUgaW4gbGF5ZXJSZWYpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRMYXllcltwcm9wTmFtZV0gPSBsYXllclJlZltwcm9wTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZExheWVyIHx8IGxheWVyO1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgIGxheWVyczogbGF5ZXJzXG4gIH0pO1xufSIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGRvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBub3JtYWxpemVTdHlsZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLXV0aWxzJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGV2ZW50KSB7XG4gIGlmIChldmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoZXZlbnQuZXJyb3IpO1xuICB9XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgZ2w6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtYXBib3hBcGlVcmw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogUHJvcFR5cGVzLmJvb2wsXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogUHJvcFR5cGVzLmJvb2wsXG4gIHJldXNlTWFwczogUHJvcFR5cGVzLmJvb2wsXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFByb3BUeXBlcy5mdW5jLFxuICBtYXBPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBtYXBTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gIGFzeW5jUmVuZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdTdGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgem9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgYmVhcmluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIGFsdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogZ2V0QWNjZXNzVG9rZW4oKSxcbiAgbWFwYm94QXBpVXJsOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcbiAgcmV1c2VNYXBzOiBmYWxzZSxcbiAgbWFwT3B0aW9uczoge30sXG4gIG1hcFN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL21hcGJveC9saWdodC12OCcsXG4gIHByZXZlbnRTdHlsZURpZmZpbmc6IGZhbHNlLFxuICB2aXNpYmxlOiB0cnVlLFxuICBhc3luY1JlbmRlcjogZmFsc2UsXG4gIG9uTG9hZDogbm9vcCxcbiAgb25FcnJvcjogZGVmYXVsdE9uRXJyb3IsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIGxvbmdpdHVkZTogMCxcbiAgbGF0aXR1ZGU6IDAsXG4gIHpvb206IDAsXG4gIGJlYXJpbmc6IDAsXG4gIHBpdGNoOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuKCkge1xuICB2YXIgYWNjZXNzVG9rZW4gPSBudWxsO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9hY2Nlc3NfdG9rZW49KFteJlxcL10qKS8pO1xuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cblxuICBpZiAoIWFjY2Vzc1Rva2VuICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuTWFwYm94QWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX01BUEJPWF9BQ0NFU1NfVE9LRU47XG4gIH1cblxuICByZXR1cm4gYWNjZXNzVG9rZW4gfHwgJ25vLXRva2VuJztcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMocHJvcHMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2NvbXBvbmVudCc7XG5cbiAgaWYgKHByb3BzLmRlYnVnKSB7XG4gICAgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgY29tcG9uZW50KTtcbiAgfVxufVxuXG52YXIgTWFwYm94ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBib3gocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcGJveCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZmlyZUxvYWRFdmVudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoe1xuICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgIHRhcmdldDogX3RoaXMuX21hcFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXByb3BzLm1hcGJveGdsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcGJveCBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXBib3hnbCA9IHByb3BzLm1hcGJveGdsO1xuXG4gICAgaWYgKCFNYXBib3guaW5pdGlhbGl6ZWQpIHtcbiAgICAgIE1hcGJveC5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NoZWNrU3R5bGVTaGVldCh0aGlzLm1hcGJveGdsLnZlcnNpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcGJveCwgW3tcbiAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICB0aGlzLl9kZXN0cm95KCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgdGhpcy5fdXBkYXRlKHRoaXMucHJvcHMsIHByb3BzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICBpZiAobWFwLnN0eWxlKSB7XG4gICAgICAgIGlmIChtYXAuX2ZyYW1lKSB7XG4gICAgICAgICAgbWFwLl9mcmFtZS5jYW5jZWwoKTtcblxuICAgICAgICAgIG1hcC5fZnJhbWUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwLl9yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmV1c2UocHJvcHMpIHtcbiAgICAgIHRoaXMuX21hcCA9IE1hcGJveC5zYXZlZE1hcDtcblxuICAgICAgdmFyIG9sZENvbnRhaW5lciA9IHRoaXMuX21hcC5nZXRDb250YWluZXIoKTtcblxuICAgICAgdmFyIG5ld0NvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcbiAgICAgIG5ld0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1tYXAnKTtcblxuICAgICAgd2hpbGUgKG9sZENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3Q29udGFpbmVyLmFwcGVuZENoaWxkKG9sZENvbnRhaW5lci5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICBNYXBib3guc2F2ZWRNYXAgPSBudWxsO1xuXG4gICAgICBpZiAocHJvcHMubWFwU3R5bGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldFN0eWxlKG5vcm1hbGl6ZVN0eWxlKHByb3BzLm1hcFN0eWxlKSwge1xuICAgICAgICAgIGRpZmY6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbWFwLmlzU3R5bGVMb2FkZWQoKSkge1xuICAgICAgICB0aGlzLl9maXJlTG9hZEV2ZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYXAub25jZSgnc3R5bGVkYXRhJywgdGhpcy5fZmlyZUxvYWRFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZShwcm9wcykge1xuICAgICAgaWYgKHByb3BzLnJldXNlTWFwcyAmJiBNYXBib3guc2F2ZWRNYXApIHtcbiAgICAgICAgdGhpcy5fcmV1c2UocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BzLmdsKSB7XG4gICAgICAgICAgdmFyIGdldENvbnRleHQgPSBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dDtcblxuICAgICAgICAgIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQgPSBnZXRDb250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmdsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFwT3B0aW9ucyA9IHtcbiAgICAgICAgICBjb250YWluZXI6IHByb3BzLmNvbnRhaW5lcixcbiAgICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgICB6b29tOiA4LFxuICAgICAgICAgIHBpdGNoOiAwLFxuICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgbWF4Wm9vbTogMjQsXG4gICAgICAgICAgc3R5bGU6IG5vcm1hbGl6ZVN0eWxlKHByb3BzLm1hcFN0eWxlKSxcbiAgICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgdHJhY2tSZXNpemU6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogcHJvcHMuYXR0cmlidXRpb25Db250cm9sLFxuICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogcHJvcHMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb3BzLnRyYW5zZm9ybVJlcXVlc3QpIHtcbiAgICAgICAgICBtYXBPcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QgPSBwcm9wcy50cmFuc2Zvcm1SZXF1ZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IHRoaXMubWFwYm94Z2wuTWFwKE9iamVjdC5hc3NpZ24oe30sIG1hcE9wdGlvbnMsIHByb3BzLm1hcE9wdGlvbnMpKTtcblxuICAgICAgICB0aGlzLl9tYXAub25jZSgnbG9hZCcsIHByb3BzLm9uTG9hZCk7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9uKCdlcnJvcicsIHByb3BzLm9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghTWFwYm94LnNhdmVkTWFwKSB7XG4gICAgICAgIE1hcGJveC5zYXZlZE1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdsb2FkJywgdGhpcy5wcm9wcy5vbkxvYWQpO1xuXG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2Vycm9yJywgdGhpcy5wcm9wcy5vbkVycm9yKTtcblxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdzdHlsZWRhdGEnLCB0aGlzLl9maXJlTG9hZEV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21hcC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemUocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcHMsICdNYXBib3gnKTtcbiAgICAgIHRoaXMubWFwYm94Z2wuYWNjZXNzVG9rZW4gPSBwcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbiB8fCBkZWZhdWx0UHJvcHMubWFwYm94QXBpQWNjZXNzVG9rZW47XG4gICAgICB0aGlzLm1hcGJveGdsLmJhc2VBcGlVcmwgPSBwcm9wcy5tYXBib3hBcGlVcmw7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZShwcm9wcyk7XG5cbiAgICAgIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgICAgICBjb250YWluZXIgPSBfcHJvcHMuY29udGFpbmVyO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRhaW5lciwgJ29mZnNldFdpZHRoJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdjbGllbnRXaWR0aCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnb2Zmc2V0SGVpZ2h0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9tYXAuZ2V0Q2FudmFzKCk7XG5cbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KHt9LCBwcm9wcyk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZU1hcFNpemUoe30sIHByb3BzKTtcblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgbmV3UHJvcHMpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMobmV3UHJvcHMsICdNYXBib3gnKTtcblxuICAgICAgdmFyIHZpZXdwb3J0Q2hhbmdlZCA9IHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICAgIHZhciBzaXplQ2hhbmdlZCA9IHRoaXMuX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgICAgdGhpcy5fdXBkYXRlTWFwU3R5bGUob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgICAgaWYgKCFuZXdQcm9wcy5hc3luY1JlbmRlciAmJiAodmlld3BvcnRDaGFuZ2VkIHx8IHNpemVDaGFuZ2VkKSkge1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gbmV3UHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVNYXBTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTWFwU3R5bGUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgc3R5bGVDaGFuZ2VkID0gb2xkUHJvcHMubWFwU3R5bGUgIT09IG5ld1Byb3BzLm1hcFN0eWxlO1xuXG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShub3JtYWxpemVTdHlsZShuZXdQcm9wcy5tYXBTdHlsZSksIHtcbiAgICAgICAgICBkaWZmOiAhbmV3UHJvcHMucHJldmVudFN0eWxlRGlmZmluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hcFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgc2l6ZUNoYW5nZWQgPSBvbGRQcm9wcy53aWR0aCAhPT0gbmV3UHJvcHMud2lkdGggfHwgb2xkUHJvcHMuaGVpZ2h0ICE9PSBuZXdQcm9wcy5oZWlnaHQ7XG5cbiAgICAgIGlmIChzaXplQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3UHJvcHMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3UHJvcHMuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuX21hcC5yZXNpemUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpemVDaGFuZ2VkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWFwVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hcFZpZXdwb3J0KG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIG9sZFZpZXdTdGF0ZSA9IHRoaXMuX2dldFZpZXdTdGF0ZShvbGRQcm9wcyk7XG5cbiAgICAgIHZhciBuZXdWaWV3U3RhdGUgPSB0aGlzLl9nZXRWaWV3U3RhdGUobmV3UHJvcHMpO1xuXG4gICAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID0gbmV3Vmlld1N0YXRlLmxhdGl0dWRlICE9PSBvbGRWaWV3U3RhdGUubGF0aXR1ZGUgfHwgbmV3Vmlld1N0YXRlLmxvbmdpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmxvbmdpdHVkZSB8fCBuZXdWaWV3U3RhdGUuem9vbSAhPT0gb2xkVmlld1N0YXRlLnpvb20gfHwgbmV3Vmlld1N0YXRlLnBpdGNoICE9PSBvbGRWaWV3U3RhdGUucGl0Y2ggfHwgbmV3Vmlld1N0YXRlLmJlYXJpbmcgIT09IG9sZFZpZXdTdGF0ZS5iZWFyaW5nIHx8IG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmFsdGl0dWRlO1xuXG4gICAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX21hcC5qdW1wVG8odGhpcy5fdmlld1N0YXRlVG9NYXBib3hQcm9wcyhuZXdWaWV3U3RhdGUpKTtcblxuICAgICAgICBpZiAobmV3Vmlld1N0YXRlLmFsdGl0dWRlICE9PSBvbGRWaWV3U3RhdGUuYWx0aXR1ZGUpIHtcbiAgICAgICAgICB0aGlzLl9tYXAudHJhbnNmb3JtLmFsdGl0dWRlID0gbmV3Vmlld1N0YXRlLmFsdGl0dWRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydENoYW5nZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWV3U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpZXdTdGF0ZShwcm9wcykge1xuICAgICAgdmFyIF9yZWYgPSBwcm9wcy52aWV3U3RhdGUgfHwgcHJvcHMsXG4gICAgICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICAgICAgbGF0aXR1ZGUgPSBfcmVmLmxhdGl0dWRlLFxuICAgICAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICAgICAgX3JlZiRwaXRjaCA9IF9yZWYucGl0Y2gsXG4gICAgICAgICAgcGl0Y2ggPSBfcmVmJHBpdGNoID09PSB2b2lkIDAgPyAwIDogX3JlZiRwaXRjaCxcbiAgICAgICAgICBfcmVmJGJlYXJpbmcgPSBfcmVmLmJlYXJpbmcsXG4gICAgICAgICAgYmVhcmluZyA9IF9yZWYkYmVhcmluZyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkYmVhcmluZyxcbiAgICAgICAgICBfcmVmJGFsdGl0dWRlID0gX3JlZi5hbHRpdHVkZSxcbiAgICAgICAgICBhbHRpdHVkZSA9IF9yZWYkYWx0aXR1ZGUgPT09IHZvaWQgMCA/IDEuNSA6IF9yZWYkYWx0aXR1ZGU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgICAgYmVhcmluZzogYmVhcmluZyxcbiAgICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tTdHlsZVNoZWV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1N0eWxlU2hlZXQoKSB7XG4gICAgICB2YXIgbWFwYm94VmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJzAuNDcuMCc7XG5cbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlc3RFbGVtZW50LmNsYXNzTmFtZSA9ICdtYXBib3hnbC1tYXAnO1xuICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgdmFyIGlzQ3NzTG9hZGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGVzdEVsZW1lbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJztcblxuICAgICAgICBpZiAoIWlzQ3NzTG9hZGVkKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIFwiaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdlwiLmNvbmNhdChtYXBib3hWZXJzaW9uLCBcIi9tYXBib3gtZ2wuY3NzXCIpKTtcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHModmlld1N0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjZW50ZXI6IFt2aWV3U3RhdGUubG9uZ2l0dWRlLCB2aWV3U3RhdGUubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiB2aWV3U3RhdGUuem9vbSxcbiAgICAgICAgYmVhcmluZzogdmlld1N0YXRlLmJlYXJpbmcsXG4gICAgICAgIHBpdGNoOiB2aWV3U3RhdGUucGl0Y2hcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcGJveDtcbn0oKTtcblxuX2RlZmluZVByb3BlcnR5KE1hcGJveCwgXCJpbml0aWFsaXplZFwiLCBmYWxzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwicHJvcFR5cGVzXCIsIHByb3BUeXBlcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwic2F2ZWRNYXBcIiwgbnVsbCk7XG5cbmV4cG9ydCB7IE1hcGJveCBhcyBkZWZhdWx0IH07IiwidmFyIEVQU0lMT04gPSAxZS03O1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT047XG59XG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcbiAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gYS5tYXAoZnVuY3Rpb24gKGFpLCBpKSB7XG4gICAgICByZXR1cm4gbGVycChhaSwgYltpXSwgdCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdCAqIGIgKyAoMSAtIHQpICogYTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ3JlYWN0LW1hcC1nbDogYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0LCB7IG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMgfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuZXhwb3J0IHZhciBNQVBCT1hfTElNSVRTID0ge1xuICBtaW5ab29tOiAwLFxuICBtYXhab29tOiAyNCxcbiAgbWluUGl0Y2g6IDAsXG4gIG1heFBpdGNoOiA4NVxufTtcbnZhciBERUZBVUxUX1NUQVRFID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcbnZhciBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSA1O1xudmFyIFBJVENIX0FDQ0VMID0gMS4yO1xuXG52YXIgTWFwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcFN0YXRlKF9yZWYpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgICAgbGF0aXR1ZGUgPSBfcmVmLmxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgICAgem9vbSA9IF9yZWYuem9vbSxcbiAgICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgICBiZWFyaW5nID0gX3JlZiRiZWFyaW5nID09PSB2b2lkIDAgPyBERUZBVUxUX1NUQVRFLmJlYXJpbmcgOiBfcmVmJGJlYXJpbmcsXG4gICAgICAgIF9yZWYkcGl0Y2ggPSBfcmVmLnBpdGNoLFxuICAgICAgICBwaXRjaCA9IF9yZWYkcGl0Y2ggPT09IHZvaWQgMCA/IERFRkFVTFRfU1RBVEUucGl0Y2ggOiBfcmVmJHBpdGNoLFxuICAgICAgICBfcmVmJGFsdGl0dWRlID0gX3JlZi5hbHRpdHVkZSxcbiAgICAgICAgYWx0aXR1ZGUgPSBfcmVmJGFsdGl0dWRlID09PSB2b2lkIDAgPyBERUZBVUxUX1NUQVRFLmFsdGl0dWRlIDogX3JlZiRhbHRpdHVkZSxcbiAgICAgICAgX3JlZiRtYXhab29tID0gX3JlZi5tYXhab29tLFxuICAgICAgICBtYXhab29tID0gX3JlZiRtYXhab29tID09PSB2b2lkIDAgPyBNQVBCT1hfTElNSVRTLm1heFpvb20gOiBfcmVmJG1heFpvb20sXG4gICAgICAgIF9yZWYkbWluWm9vbSA9IF9yZWYubWluWm9vbSxcbiAgICAgICAgbWluWm9vbSA9IF9yZWYkbWluWm9vbSA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5taW5ab29tIDogX3JlZiRtaW5ab29tLFxuICAgICAgICBfcmVmJG1heFBpdGNoID0gX3JlZi5tYXhQaXRjaCxcbiAgICAgICAgbWF4UGl0Y2ggPSBfcmVmJG1heFBpdGNoID09PSB2b2lkIDAgPyBNQVBCT1hfTElNSVRTLm1heFBpdGNoIDogX3JlZiRtYXhQaXRjaCxcbiAgICAgICAgX3JlZiRtaW5QaXRjaCA9IF9yZWYubWluUGl0Y2gsXG4gICAgICAgIG1pblBpdGNoID0gX3JlZiRtaW5QaXRjaCA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5taW5QaXRjaCA6IF9yZWYkbWluUGl0Y2gsXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9yZWYudHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgICB0cmFuc2l0aW9uRWFzaW5nID0gX3JlZi50cmFuc2l0aW9uRWFzaW5nLFxuICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gX3JlZi50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uID0gX3JlZi50cmFuc2l0aW9uSW50ZXJydXB0aW9uLFxuICAgICAgICBzdGFydFBhbkxuZ0xhdCA9IF9yZWYuc3RhcnRQYW5MbmdMYXQsXG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IF9yZWYuc3RhcnRab29tTG5nTGF0LFxuICAgICAgICBzdGFydFJvdGF0ZVBvcyA9IF9yZWYuc3RhcnRSb3RhdGVQb3MsXG4gICAgICAgIHN0YXJ0QmVhcmluZyA9IF9yZWYuc3RhcnRCZWFyaW5nLFxuICAgICAgICBzdGFydFBpdGNoID0gX3JlZi5zdGFydFBpdGNoLFxuICAgICAgICBzdGFydFpvb20gPSBfcmVmLnN0YXJ0Wm9vbTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBTdGF0ZSk7XG5cbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHdpZHRoKSwgJ2B3aWR0aGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSwgJ2BoZWlnaHRgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSksICdgbG9uZ2l0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSksICdgbGF0aXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pLCAnYHpvb21gIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICB0aGlzLl92aWV3cG9ydFByb3BzID0gdGhpcy5fYXBwbHlDb25zdHJhaW50cyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgem9vbTogem9vbSxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICBhbHRpdHVkZTogYWx0aXR1ZGUsXG4gICAgICBtYXhab29tOiBtYXhab29tLFxuICAgICAgbWluWm9vbTogbWluWm9vbSxcbiAgICAgIG1heFBpdGNoOiBtYXhQaXRjaCxcbiAgICAgIG1pblBpdGNoOiBtaW5QaXRjaCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkVhc2luZzogdHJhbnNpdGlvbkVhc2luZyxcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiB0cmFuc2l0aW9uSW50ZXJydXB0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogc3RhcnRQYW5MbmdMYXQsXG4gICAgICBzdGFydFpvb21MbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0Um90YXRlUG9zOiBzdGFydFJvdGF0ZVBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZzogc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaDogc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbTogc3RhcnRab29tXG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBTdGF0ZSwgW3tcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydFByb3BzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5TdGFydChfcmVmMikge1xuICAgICAgdmFyIHBvcyA9IF9yZWYyLnBvcztcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydFBhbkxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuKF9yZWYzKSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjMucG9zLFxuICAgICAgICAgIHN0YXJ0UG9zID0gX3JlZjMuc3RhcnRQb3M7XG5cbiAgICAgIHZhciBzdGFydFBhbkxuZ0xhdCA9IHRoaXMuX3N0YXRlLnN0YXJ0UGFuTG5nTGF0IHx8IHRoaXMuX3VucHJvamVjdChzdGFydFBvcyk7XG5cbiAgICAgIGlmICghc3RhcnRQYW5MbmdMYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRfY2FsY3VsYXRlTmV3TG4gPSB0aGlzLl9jYWxjdWxhdGVOZXdMbmdMYXQoe1xuICAgICAgICBzdGFydFBhbkxuZ0xhdDogc3RhcnRQYW5MbmdMYXQsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSxcbiAgICAgICAgICBfdGhpcyRfY2FsY3VsYXRlTmV3TG4yID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2NhbGN1bGF0ZU5ld0xuLCAyKSxcbiAgICAgICAgICBsb25naXR1ZGUgPSBfdGhpcyRfY2FsY3VsYXRlTmV3TG4yWzBdLFxuICAgICAgICAgIGxhdGl0dWRlID0gX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMlsxXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5FbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuRW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0UGFuTG5nTGF0OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlU3RhcnQoX3JlZjQpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmNC5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRSb3RhdGVQb3M6IHBvcyxcbiAgICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcsXG4gICAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlKF9yZWY1KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjUucG9zLFxuICAgICAgICAgIF9yZWY1JGRlbHRhQW5nbGVYID0gX3JlZjUuZGVsdGFBbmdsZVgsXG4gICAgICAgICAgZGVsdGFBbmdsZVggPSBfcmVmNSRkZWx0YUFuZ2xlWCA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JGRlbHRhQW5nbGVYLFxuICAgICAgICAgIF9yZWY1JGRlbHRhQW5nbGVZID0gX3JlZjUuZGVsdGFBbmdsZVksXG4gICAgICAgICAgZGVsdGFBbmdsZVkgPSBfcmVmNSRkZWx0YUFuZ2xlWSA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JGRlbHRhQW5nbGVZO1xuICAgICAgdmFyIF90aGlzJF9zdGF0ZSA9IHRoaXMuX3N0YXRlLFxuICAgICAgICAgIHN0YXJ0Um90YXRlUG9zID0gX3RoaXMkX3N0YXRlLnN0YXJ0Um90YXRlUG9zLFxuICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IF90aGlzJF9zdGF0ZS5zdGFydEJlYXJpbmcsXG4gICAgICAgICAgc3RhcnRQaXRjaCA9IF90aGlzJF9zdGF0ZS5zdGFydFBpdGNoO1xuXG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydEJlYXJpbmcpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc3RhcnRQaXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdSb3RhdGlvbjtcblxuICAgICAgaWYgKHBvcykge1xuICAgICAgICBuZXdSb3RhdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuX2dldFJvdGF0aW9uUGFyYW1zKHBvcywgc3RhcnRSb3RhdGVQb3MpKSwge30sIHtcbiAgICAgICAgICBzdGFydEJlYXJpbmc6IHN0YXJ0QmVhcmluZyxcbiAgICAgICAgICBzdGFydFBpdGNoOiBzdGFydFBpdGNoXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1JvdGF0aW9uID0ge1xuICAgICAgICAgIGJlYXJpbmc6IHN0YXJ0QmVhcmluZyArIGRlbHRhQW5nbGVYLFxuICAgICAgICAgIHBpdGNoOiBzdGFydFBpdGNoICsgZGVsdGFBbmdsZVlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZShuZXdSb3RhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVFbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21TdGFydChfcmVmNikge1xuICAgICAgdmFyIHBvcyA9IF9yZWY2LnBvcztcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydFpvb21MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpLFxuICAgICAgICBzdGFydFpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShfcmVmNykge1xuICAgICAgdmFyIHBvcyA9IF9yZWY3LnBvcyxcbiAgICAgICAgICBzdGFydFBvcyA9IF9yZWY3LnN0YXJ0UG9zLFxuICAgICAgICAgIHNjYWxlID0gX3JlZjcuc2NhbGU7XG4gICAgICBhc3NlcnQoc2NhbGUgPiAwLCAnYHNjYWxlYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICB2YXIgX3RoaXMkX3N0YXRlMiA9IHRoaXMuX3N0YXRlLFxuICAgICAgICAgIHN0YXJ0Wm9vbSA9IF90aGlzJF9zdGF0ZTIuc3RhcnRab29tLFxuICAgICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IF90aGlzJF9zdGF0ZTIuc3RhcnRab29tTG5nTGF0O1xuXG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydFpvb20pKSB7XG4gICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbTtcbiAgICAgICAgc3RhcnRab29tTG5nTGF0ID0gdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKSB8fCB0aGlzLl91bnByb2plY3QocG9zKTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KHN0YXJ0Wm9vbUxuZ0xhdCwgJ2BzdGFydFpvb21MbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArICdmb3Igem9vbSBiZWhhdmlvciB0byBjYWxjdWxhdGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIG1hcC4nKTtcblxuICAgICAgdmFyIHpvb20gPSB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBzdGFydFpvb206IHN0YXJ0Wm9vbSB8fCAwXG4gICAgICB9KTtcblxuICAgICAgdmFyIHpvb21lZFZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywge1xuICAgICAgICB6b29tOiB6b29tXG4gICAgICB9KSk7XG5cbiAgICAgIHZhciBfem9vbWVkVmlld3BvcnQkZ2V0TWEgPSB6b29tZWRWaWV3cG9ydC5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgICAgbG5nTGF0OiBzdGFydFpvb21MbmdMYXQsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSxcbiAgICAgICAgICBfem9vbWVkVmlld3BvcnQkZ2V0TWEyID0gX3NsaWNlZFRvQXJyYXkoX3pvb21lZFZpZXdwb3J0JGdldE1hLCAyKSxcbiAgICAgICAgICBsb25naXR1ZGUgPSBfem9vbWVkVmlld3BvcnQkZ2V0TWEyWzBdLFxuICAgICAgICAgIGxhdGl0dWRlID0gX3pvb21lZFZpZXdwb3J0JGdldE1hMlsxXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21FbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRab29tTG5nTGF0OiBudWxsLFxuICAgICAgICBzdGFydFpvb206IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VXBkYXRlZE1hcFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRVcGRhdGVkTWFwU3RhdGUobmV3UHJvcHMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwU3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywgdGhpcy5fc3RhdGUsIG5ld1Byb3BzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseUNvbnN0cmFpbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgICB2YXIgbWF4Wm9vbSA9IHByb3BzLm1heFpvb20sXG4gICAgICAgICAgbWluWm9vbSA9IHByb3BzLm1pblpvb20sXG4gICAgICAgICAgem9vbSA9IHByb3BzLnpvb207XG4gICAgICBwcm9wcy56b29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgICB2YXIgbWF4UGl0Y2ggPSBwcm9wcy5tYXhQaXRjaCxcbiAgICAgICAgICBtaW5QaXRjaCA9IHByb3BzLm1pblBpdGNoLFxuICAgICAgICAgIHBpdGNoID0gcHJvcHMucGl0Y2g7XG4gICAgICBwcm9wcy5waXRjaCA9IGNsYW1wKHBpdGNoLCBtaW5QaXRjaCwgbWF4UGl0Y2gpO1xuICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgbm9ybWFsaXplVmlld3BvcnRQcm9wcyhwcm9wcykpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wcm9qZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnByb2plY3QocG9zKSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICAgIHJldHVybiBwb3MgJiYgdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVOZXdMbmdMYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld0xuZ0xhdChfcmVmOCkge1xuICAgICAgdmFyIHN0YXJ0UGFuTG5nTGF0ID0gX3JlZjguc3RhcnRQYW5MbmdMYXQsXG4gICAgICAgICAgcG9zID0gX3JlZjgucG9zO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgICByZXR1cm4gdmlld3BvcnQuZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7XG4gICAgICAgIGxuZ0xhdDogc3RhcnRQYW5MbmdMYXQsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZU5ld1pvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld1pvb20oX3JlZjkpIHtcbiAgICAgIHZhciBzY2FsZSA9IF9yZWY5LnNjYWxlLFxuICAgICAgICAgIHN0YXJ0Wm9vbSA9IF9yZWY5LnN0YXJ0Wm9vbTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wcyA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMsXG4gICAgICAgICAgbWF4Wm9vbSA9IF90aGlzJF92aWV3cG9ydFByb3BzLm1heFpvb20sXG4gICAgICAgICAgbWluWm9vbSA9IF90aGlzJF92aWV3cG9ydFByb3BzLm1pblpvb207XG4gICAgICB2YXIgem9vbSA9IHN0YXJ0Wm9vbSArIE1hdGgubG9nMihzY2FsZSk7XG4gICAgICByZXR1cm4gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyhfcmVmMTApIHtcbiAgICAgIHZhciBkZWx0YVNjYWxlWCA9IF9yZWYxMC5kZWx0YVNjYWxlWCxcbiAgICAgICAgICBkZWx0YVNjYWxlWSA9IF9yZWYxMC5kZWx0YVNjYWxlWSxcbiAgICAgICAgICBzdGFydEJlYXJpbmcgPSBfcmVmMTAuc3RhcnRCZWFyaW5nLFxuICAgICAgICAgIHN0YXJ0UGl0Y2ggPSBfcmVmMTAuc3RhcnRQaXRjaDtcbiAgICAgIGRlbHRhU2NhbGVZID0gY2xhbXAoZGVsdGFTY2FsZVksIC0xLCAxKTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wczIgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICAgIG1pblBpdGNoID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMyLm1pblBpdGNoLFxuICAgICAgICAgIG1heFBpdGNoID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMyLm1heFBpdGNoO1xuICAgICAgdmFyIGJlYXJpbmcgPSBzdGFydEJlYXJpbmcgKyAxODAgKiBkZWx0YVNjYWxlWDtcbiAgICAgIHZhciBwaXRjaCA9IHN0YXJ0UGl0Y2g7XG5cbiAgICAgIGlmIChkZWx0YVNjYWxlWSA+IDApIHtcbiAgICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgZGVsdGFTY2FsZVkgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGFTY2FsZVkgPCAwKSB7XG4gICAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCAtIGRlbHRhU2NhbGVZICogKG1pblBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgICAgYmVhcmluZzogYmVhcmluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uUGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvblBhcmFtcyhwb3MsIHN0YXJ0UG9zKSB7XG4gICAgICB2YXIgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRQb3NbMF07XG4gICAgICB2YXIgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgY2VudGVyWSA9IHBvc1sxXTtcbiAgICAgIHZhciBzdGFydFkgPSBzdGFydFBvc1sxXTtcbiAgICAgIHZhciBfdGhpcyRfdmlld3BvcnRQcm9wczMgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkX3ZpZXdwb3J0UHJvcHMzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJF92aWV3cG9ydFByb3BzMy5oZWlnaHQ7XG4gICAgICB2YXIgZGVsdGFTY2FsZVggPSBkZWx0YVggLyB3aWR0aDtcbiAgICAgIHZhciBkZWx0YVNjYWxlWSA9IDA7XG5cbiAgICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzdGFydFkpID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgZGVsdGFTY2FsZVkgPSBkZWx0YVkgLyAoc3RhcnRZIC0gaGVpZ2h0KSAqIFBJVENIX0FDQ0VMO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhWSA8IDApIHtcbiAgICAgICAgaWYgKHN0YXJ0WSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGRlbHRhU2NhbGVZID0gMSAtIGNlbnRlclkgLyBzdGFydFk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsdGFTY2FsZVkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgtMSwgZGVsdGFTY2FsZVkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhU2NhbGVYOiBkZWx0YVNjYWxlWCxcbiAgICAgICAgZGVsdGFTY2FsZVk6IGRlbHRhU2NhbGVZXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBTdGF0ZTtcbn0oKTtcblxuZXhwb3J0IHsgTWFwU3RhdGUgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuL21hcC1zdGF0ZSc7XG5cbmZ1bmN0aW9uIGRlY2FwaXRhbGl6ZShzKSB7XG4gIHJldHVybiBzWzBdLnRvTG93ZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgdmFyIGNvbnN0cmFpbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBNQVBCT1hfTElNSVRTO1xuXG4gIGZvciAodmFyIGNvbnN0cmFpbnROYW1lIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHR5cGUgPSBjb25zdHJhaW50TmFtZS5zbGljZSgwLCAzKTtcbiAgICB2YXIgcHJvcE5hbWUgPSBkZWNhcGl0YWxpemUoY29uc3RyYWludE5hbWUuc2xpY2UoMykpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtaW4nICYmIHByb3BzW3Byb3BOYW1lXSA8IGNvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbWF4JyAmJiBwcm9wc1twcm9wTmFtZV0gPiBjb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG52YXIgTWFwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICB2aWV3cG9ydDogbnVsbCxcbiAgbWFwOiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBudWxsLFxuICBldmVudE1hbmFnZXI6IG51bGxcbn0pO1xuZXhwb3J0IHZhciBNYXBDb250ZXh0UHJvdmlkZXIgPSBNYXBDb250ZXh0LlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBXcmFwcGVkUHJvdmlkZXIoX3JlZikge1xuICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgbWFwID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldE1hcCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YWx1ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgc2V0TWFwOiBzZXRNYXBcbiAgfSwgY29udGV4dCksIHt9LCB7XG4gICAgbWFwOiBjb250ZXh0ICYmIGNvbnRleHQubWFwIHx8IG1hcFxuICB9LCB2YWx1ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcENvbnRleHRQcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbk1hcENvbnRleHQuUHJvdmlkZXIgPSBXcmFwcGVkUHJvdmlkZXI7XG5leHBvcnQgZGVmYXVsdCBNYXBDb250ZXh0OyIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmV4cG9ydCBkZWZhdWx0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7IiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCBfcmVmKSB7XG4gIHZhciBsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZTtcblxuICBpZiAobWFwICYmIG1hcC5xdWVyeVRlcnJhaW5FbGV2YXRpb24pIHtcbiAgICByZXR1cm4gbWFwLnF1ZXJ5VGVycmFpbkVsZXZhdGlvbihbbG9uZ2l0dWRlLCBsYXRpdHVkZV0pIHx8IDA7XG4gIH1cblxuICByZXR1cm4gMDtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuaW1wb3J0IE1hcGJveCBmcm9tICcuLi9tYXBib3gvbWFwYm94JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgeyBjaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyB9IGZyb20gJy4uL3V0aWxzL21hcC1jb25zdHJhaW50cyc7XG5pbXBvcnQgeyBNQVBCT1hfTElNSVRTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCBNYXBDb250ZXh0LCB7IE1hcENvbnRleHRQcm92aWRlciB9IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBnZXRUZXJyYWluRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdGVycmFpbic7XG52YXIgVE9LRU5fRE9DX1VSTCA9ICdodHRwczovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1tYXAtZ2wvZG9jcy9nZXQtc3RhcnRlZC9tYXBib3gtdG9rZW5zJztcbnZhciBOT19UT0tFTl9XQVJOSU5HID0gJ0EgdmFsaWQgQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IGRhdGEnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdwb3J0KF9yZWYpIHtcbiAgdmFyIG1hcCA9IF9yZWYubWFwLFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgdmFyIHZpZXdwb3J0UHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBwcm9wcy52aWV3U3RhdGUpLCB7fSwge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9KTtcblxuICB2aWV3cG9ydFByb3BzLnBvc2l0aW9uID0gWzAsIDAsIGdldFRlcnJhaW5FbGV2YXRpb24obWFwLCB2aWV3cG9ydFByb3BzKV07XG4gIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydFByb3BzKTtcbn1cbnZhciBVTkFVVEhPUklaRURfRVJST1JfQ09ERSA9IDQwMTtcbnZhciBDT05UQUlORVJfU1RZTEUgPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBoZWlnaHQ6ICcxMDAlJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIE1hcGJveC5kZWZhdWx0UHJvcHMsIHtcbiAgZGlzYWJsZVRva2VuV2FybmluZzogZmFsc2UsXG4gIHZpc2libGU6IHRydWUsXG4gIG9uUmVzaXplOiBub29wLFxuICBjbGFzc05hbWU6ICcnLFxuICBzdHlsZTogbnVsbCxcbiAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzOiBNQVBCT1hfTElNSVRTXG59KTtcblxuZnVuY3Rpb24gTm9Ub2tlbldhcm5pbmcoKSB7XG4gIHZhciBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIndhcm5pbmdcIixcbiAgICBpZDogXCJuby10b2tlbi13YXJuaW5nXCIsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7XG4gICAga2V5OiBcImhlYWRlclwiXG4gIH0sIE5PX1RPS0VOX1dBUk5JTkcpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwidGV4dFwiXG4gIH0sIFwiRm9yIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgeW91ciBiYXNlbWFwLCByZWFkXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAga2V5OiBcImxpbmtcIixcbiAgICBocmVmOiBUT0tFTl9ET0NfVVJMXG4gIH0sIFwiTm90ZSBvbiBNYXAgVG9rZW5zXCIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmSGFuZGxlcyhtYXBib3hSZWYpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRNYXA6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiBtYXBib3hSZWYuY3VycmVudCAmJiBtYXBib3hSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgICB9LFxuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogZnVuY3Rpb24gcXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgbWFwID0gbWFwYm94UmVmLmN1cnJlbnQgJiYgbWFwYm94UmVmLmN1cnJlbnQuZ2V0TWFwKCk7XG4gICAgICByZXR1cm4gbWFwICYmIG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnksIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFN0YXRpY01hcCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHRydWUpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBhY2Nlc3NUb2tlblZhbGlkID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFRva2VuU3RhdGUgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoe1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9KSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIHNpemUgPSBfdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0U2l6ZSA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdmFyIG1hcGJveFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIG1hcERpdlJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIG92ZXJsYXlSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFTdGF0aWNNYXAuc3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcGJveCA9IG5ldyBNYXBib3goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgc2l6ZSksIHt9LCB7XG4gICAgICBtYXBib3hnbDogbWFwYm94Z2wsXG4gICAgICBjb250YWluZXI6IG1hcERpdlJlZi5jdXJyZW50LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihldnQpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBldnQuZXJyb3IgJiYgZXZ0LmVycm9yLnN0YXR1cyB8fCBldnQuc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBVTkFVVEhPUklaRURfRVJST1JfQ09ERSAmJiBhY2Nlc3NUb2tlblZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihOT19UT0tFTl9XQVJOSU5HKTtcbiAgICAgICAgICBzZXRUb2tlblN0YXRlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLm9uRXJyb3IoZXZ0KTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgbWFwYm94UmVmLmN1cnJlbnQgPSBtYXBib3g7XG5cbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnNldE1hcCkge1xuICAgICAgY29udGV4dC5zZXRNYXAobWFwYm94LmdldE1hcCgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIGlmIChlbnRyaWVzWzBdLmNvbnRlbnRSZWN0KSB7XG4gICAgICAgIHZhciBfZW50cmllcyQwJGNvbnRlbnRSZWMgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgX3dpZHRoID0gX2VudHJpZXMkMCRjb250ZW50UmVjLndpZHRoLFxuICAgICAgICAgICAgX2hlaWdodCA9IF9lbnRyaWVzJDAkY29udGVudFJlYy5oZWlnaHQ7XG4gICAgICAgIHNldFNpemUoe1xuICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vblJlc2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hcGJveC5maW5hbGl6ZSgpO1xuICAgICAgbWFwYm94UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveFJlZi5jdXJyZW50KSB7XG4gICAgICBtYXBib3hSZWYuY3VycmVudC5zZXRQcm9wcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgc2l6ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBtYXAgPSBtYXBib3hSZWYuY3VycmVudCAmJiBtYXBib3hSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0UmVmSGFuZGxlcyhtYXBib3hSZWYpO1xuICB9LCBbXSk7XG4gIHZhciBwcmV2ZW50U2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldDtcblxuICAgIGlmICh0YXJnZXQgPT09IG92ZXJsYXlSZWYuY3VycmVudCkge1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvKDAsIDApO1xuICAgIH1cbiAgfSwgW10pO1xuICB2YXIgb3ZlcmxheXMgPSBtYXAgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb250ZXh0KSwge30sIHtcbiAgICAgIHZpZXdwb3J0OiBjb250ZXh0LnZpZXdwb3J0IHx8IGdldFZpZXdwb3J0KF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9LCBzaXplKSksXG4gICAgICBtYXA6IG1hcCxcbiAgICAgIGNvbnRhaW5lcjogY29udGV4dC5jb250YWluZXIgfHwgY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICB9KVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwibWFwLW92ZXJsYXlzXCIsXG4gICAgY2xhc3NOYW1lOiBcIm92ZXJsYXlzXCIsXG4gICAgcmVmOiBvdmVybGF5UmVmLFxuICAgIHN0eWxlOiBDT05UQUlORVJfU1RZTEUsXG4gICAgb25TY3JvbGw6IHByZXZlbnRTY3JvbGxcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzID0gcHJvcHMudmlzaWJpbGl0eUNvbnN0cmFpbnRzO1xuICB2YXIgbWFwQ29udGFpbmVyU3R5bGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICB9LCBzdHlsZSwge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9KTtcbiAgdmFyIHZpc2libGUgPSBwcm9wcy52aXNpYmxlICYmIGNoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzKHByb3BzLnZpZXdTdGF0ZSB8fCBwcm9wcywgdmlzaWJpbGl0eUNvbnN0cmFpbnRzKTtcbiAgdmFyIG1hcFN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgQ09OVEFJTkVSX1NUWUxFLCB7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZSA/ICdpbmhlcml0JyA6ICdoaWRkZW4nXG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIm1hcC1jb250YWluZXJcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZTogbWFwQ29udGFpbmVyU3R5bGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIm1hcC1tYXBib3hcIixcbiAgICByZWY6IG1hcERpdlJlZixcbiAgICBzdHlsZTogbWFwU3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSksIG92ZXJsYXlzLCAhYWNjZXNzVG9rZW5WYWxpZCAmJiAhcHJvcHMuZGlzYWJsZVRva2VuV2FybmluZyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KE5vVG9rZW5XYXJuaW5nLCBudWxsKSk7XG59KTtcblxuU3RhdGljTWFwLnN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG1hcGJveGdsICYmIG1hcGJveGdsLnN1cHBvcnRlZCgpO1xufTtcblxuU3RhdGljTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFN0YXRpY01hcDsiLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiBlKF9lKSB7XG4gICAgICAgICAgdGhyb3cgX2U7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tICcuLi9tYXRoLXV0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vYXNzZXJ0JztcblxudmFyIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcE5hbWVzXCIsIFtdKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2l0aW9uSW50ZXJwb2xhdG9yLCBbe1xuICAgIGtleTogXCJhcmVQcm9wc0VxdWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFyZVByb3BzRXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnByb3BOYW1lcyB8fCBbXSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFlcXVhbHMoY3VycmVudFByb3BzW2tleV0sIG5leHRQcm9wc1trZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcywgdCkge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnaW50ZXJwb2xhdGVQcm9wcyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHJldHVybiBlbmRQcm9wcy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zaXRpb25JbnRlcnBvbGF0b3I7XG59KCk7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgYXMgZGVmYXVsdCB9OyIsInZhciBXUkFQUEVEX0FOR1VMQVJfUFJPUFMgPSB7XG4gIGxvbmdpdHVkZTogMSxcbiAgYmVhcmluZzogMVxufTtcbmV4cG9ydCBmdW5jdGlvbiBtb2QodmFsdWUsIGRpdmlzb3IpIHtcbiAgdmFyIG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkKHByb3ApIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwcm9wKSB8fCBBcnJheS5pc0FycmF5KHByb3ApO1xufVxuXG5mdW5jdGlvbiBpc1dyYXBwZWRBbmd1bGFyUHJvcChwcm9wTmFtZSkge1xuICByZXR1cm4gcHJvcE5hbWUgaW4gV1JBUFBFRF9BTkdVTEFSX1BST1BTO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChwcm9wTmFtZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgaWYgKGlzV3JhcHBlZEFuZ3VsYXJQcm9wKHByb3BOYW1lKSAmJiBNYXRoLmFicyhlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpID4gMTgwKSB7XG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSA8IDAgPyBlbmRWYWx1ZSArIDM2MCA6IGVuZFZhbHVlIC0gMzYwO1xuICB9XG5cbiAgcmV0dXJuIGVuZFZhbHVlO1xufSIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiBlKF9lKSB7XG4gICAgICAgICAgdGhyb3cgX2U7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydCc7XG5pbXBvcnQgVHJhbnNpdGlvbkludGVycG9sYXRvciBmcm9tICcuL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yJztcbmltcG9ydCB7IGZseVRvVmlld3BvcnQsIGdldEZseVRvRHVyYXRpb24gfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IGlzVmFsaWQsIGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGggfSBmcm9tICcuL3RyYW5zaXRpb24tdXRpbHMnO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJy4uL21hdGgtdXRpbHMnO1xudmFyIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMgPSBbJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJywgJ2JlYXJpbmcnLCAncGl0Y2gnXTtcbnZhciBSRVFVSVJFRF9QUk9QUyA9IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ3pvb20nLCAnd2lkdGgnLCAnaGVpZ2h0J107XG52YXIgTElORUFSTFlfSU5URVJQT0xBVEVEX1BST1BTID0gWydiZWFyaW5nJywgJ3BpdGNoJ107XG52YXIgREVGQVVMVF9PUFRTID0ge1xuICBzcGVlZDogMS4yLFxuICBjdXJ2ZTogMS40MTRcbn07XG5cbnZhciBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKF9UcmFuc2l0aW9uSW50ZXJwb2xhdCkge1xuICBfaW5oZXJpdHMoVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciwgX1RyYW5zaXRpb25JbnRlcnBvbGF0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicHJvcE5hbWVzXCIsIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpO1xuXG4gICAgX3RoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIHByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgdmFyIHN0YXJ0Vmlld3BvcnRQcm9wcyA9IHt9O1xuICAgICAgdmFyIGVuZFZpZXdwb3J0UHJvcHMgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFJFUVVJUkVEX1BST1BTKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICAgICAgdmFyIGVuZFZhbHVlID0gZW5kUHJvcHNba2V5XTtcbiAgICAgICAgICBhc3NlcnQoaXNWYWxpZChzdGFydFZhbHVlKSAmJiBpc1ZhbGlkKGVuZFZhbHVlKSwgXCJcIi5jb25jYXQoa2V5LCBcIiBtdXN0IGJlIHN1cHBsaWVkIGZvciB0cmFuc2l0aW9uXCIpKTtcbiAgICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHNba2V5XSA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgZW5kVmlld3BvcnRQcm9wc1trZXldID0gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChrZXksIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKExJTkVBUkxZX0lOVEVSUE9MQVRFRF9QUk9QUyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9zdGFydFZhbHVlID0gc3RhcnRQcm9wc1tfa2V5XSB8fCAwO1xuXG4gICAgICAgICAgdmFyIF9lbmRWYWx1ZSA9IGVuZFByb3BzW19rZXldIHx8IDA7XG5cbiAgICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHNbX2tleV0gPSBfc3RhcnRWYWx1ZTtcbiAgICAgICAgICBlbmRWaWV3cG9ydFByb3BzW19rZXldID0gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChfa2V5LCBfc3RhcnRWYWx1ZSwgX2VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSBmbHlUb1ZpZXdwb3J0KHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0LCB0aGlzLnByb3BzKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihMSU5FQVJMWV9JTlRFUlBPTEFURURfUFJPUFMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIHZpZXdwb3J0W2tleV0gPSBsZXJwKHN0YXJ0UHJvcHNba2V5XSwgZW5kUHJvcHNba2V5XSwgdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbkR1cmF0aW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0Rmx5VG9EdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3I7XG59KFRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuXG5leHBvcnQgeyBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gRigpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi9hc3NlcnQnO1xuaW1wb3J0IFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgZnJvbSAnLi90cmFuc2l0aW9uLWludGVycG9sYXRvcic7XG5pbXBvcnQgeyBpc1ZhbGlkLCBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoIH0gZnJvbSAnLi90cmFuc2l0aW9uLXV0aWxzJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9tYXRoLXV0aWxzJztcbnZhciBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbScsICdiZWFyaW5nJywgJ3BpdGNoJ107XG5cbnZhciBMaW5lYXJJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoX1RyYW5zaXRpb25JbnRlcnBvbGF0KSB7XG4gIF9pbmhlcml0cyhMaW5lYXJJbnRlcnBvbGF0b3IsIF9UcmFuc2l0aW9uSW50ZXJwb2xhdCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMaW5lYXJJbnRlcnBvbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIExpbmVhckludGVycG9sYXRvcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZWFySW50ZXJwb2xhdG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BzOiBvcHRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIF90aGlzLnByb3BOYW1lcyA9IG9wdHMudHJhbnNpdGlvblByb3BzIHx8IFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFM7XG5cbiAgICBpZiAob3B0cy5hcm91bmQpIHtcbiAgICAgIF90aGlzLmFyb3VuZCA9IG9wdHMuYXJvdW5kO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lYXJJbnRlcnBvbGF0b3IsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHZhciBzdGFydFZpZXdwb3J0UHJvcHMgPSB7fTtcbiAgICAgIHZhciBlbmRWaWV3cG9ydFByb3BzID0ge307XG5cbiAgICAgIGlmICh0aGlzLmFyb3VuZCkge1xuICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHMuYXJvdW5kID0gdGhpcy5hcm91bmQ7XG4gICAgICAgIHZhciBhcm91bmRMbmdMYXQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChzdGFydFByb3BzKS51bnByb2plY3QodGhpcy5hcm91bmQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGVuZFZpZXdwb3J0UHJvcHMsIGVuZFByb3BzLCB7XG4gICAgICAgICAgYXJvdW5kOiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChlbmRQcm9wcykucHJvamVjdChhcm91bmRMbmdMYXQpLFxuICAgICAgICAgIGFyb3VuZExuZ0xhdDogYXJvdW5kTG5nTGF0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IHN0YXJ0UHJvcHNba2V5XTtcbiAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgICAgIGFzc2VydChpc1ZhbGlkKHN0YXJ0VmFsdWUpICYmIGlzVmFsaWQoZW5kVmFsdWUpLCBcIlwiLmNvbmNhdChrZXksIFwiIG11c3QgYmUgc3VwcGxpZWQgZm9yIHRyYW5zaXRpb25cIikpO1xuICAgICAgICAgIHN0YXJ0Vmlld3BvcnRQcm9wc1trZXldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICBlbmRWaWV3cG9ydFByb3BzW2tleV0gPSBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoKGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnByb3BOYW1lcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRQcm9wc1trZXldLCBlbmRQcm9wc1trZXldLCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQcm9wcy5hcm91bmQpIHtcbiAgICAgICAgdmFyIF9XZWJNZXJjYXRvclZpZXdwb3J0JCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIGVuZFByb3BzLCB2aWV3cG9ydCkpLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICAgIGxuZ0xhdDogZW5kUHJvcHMuYXJvdW5kTG5nTGF0LFxuICAgICAgICAgIHBvczogbGVycChzdGFydFByb3BzLmFyb3VuZCwgZW5kUHJvcHMuYXJvdW5kLCB0KVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIF9XZWJNZXJjYXRvclZpZXdwb3J0JDIgPSBfc2xpY2VkVG9BcnJheShfV2ViTWVyY2F0b3JWaWV3cG9ydCQsIDIpLFxuICAgICAgICAgICAgbG9uZ2l0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlswXSxcbiAgICAgICAgICAgIGxhdGl0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlsxXTtcblxuICAgICAgICB2aWV3cG9ydC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgICAgIHZpZXdwb3J0LmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZWFySW50ZXJwb2xhdG9yO1xufShUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcblxuZXhwb3J0IHsgTGluZWFySW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciB9IGZyb20gJy4vdmlld3BvcnQtZmx5LXRvLWludGVycG9sYXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmVhckludGVycG9sYXRvciB9IGZyb20gJy4vbGluZWFyLWludGVycG9sYXRvcic7IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9wRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCB4MCkge1xuICB2YXIgeTAgPSBlYXNpbmcoeDApO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSAvICgxIC0geTApICogKGVhc2luZyh0ICogKDEgLSB4MCkgKyB4MCkgLSB5MCk7XG4gIH07XG59XG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRVZFTlRTID0ge1xuICBCUkVBSzogMSxcbiAgU05BUF9UT19FTkQ6IDIsXG4gIElHTk9SRTogMyxcbiAgVVBEQVRFOiA0XG59O1xudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMCxcbiAgdHJhbnNpdGlvbkVhc2luZzogZnVuY3Rpb24gdHJhbnNpdGlvbkVhc2luZyh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3IoKSxcbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogVFJBTlNJVElPTl9FVkVOVFMuQlJFQUssXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBub29wLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IG5vb3AsXG4gIG9uVHJhbnNpdGlvbkVuZDogbm9vcFxufTtcblxudmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hbmltYXRpb25GcmFtZVwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblRyYW5zaXRpb25GcmFtZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuX29uVHJhbnNpdGlvbkZyYW1lKTtcblxuICAgICAgX3RoaXMuX3VwZGF0ZVZpZXdwb3J0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvcHRzLm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvcHRzLm9uU3RhdGVDaGFuZ2UgfHwgbm9vcDtcbiAgICB0aGlzLnRpbWUgPSBvcHRzLmdldFRpbWUgfHwgRGF0ZS5ub3c7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbk1hbmFnZXIsIFt7XG4gICAga2V5OiBcImdldFZpZXdwb3J0SW5UcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0SW5UcmFuc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbkZyYW1lID8gdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbiA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaWV3cG9ydENoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG5cbiAgICAgIGlmICghY3VycmVudFByb3BzIHx8IHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgICAgdmFyIHN0YXJ0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UHJvcHMpO1xuICAgICAgICB2YXIgZW5kUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLlNOQVBfVE9fRU5EKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUuZW5kUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmludGVycnVwdGlvbiA9PT0gVFJBTlNJVElPTl9FVkVOVFMuVVBEQVRFKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRpbWUoKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjdXJyZW50VGltZSAtIHRoaXMuc3RhdGUuc3RhcnRUaW1lKSAvIHRoaXMuc3RhdGUuZHVyYXRpb247XG4gICAgICAgICAgICBlbmRQcm9wcy50cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLnN0YXRlLmR1cmF0aW9uIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5zdGF0ZS5zdGFydFRpbWUpO1xuICAgICAgICAgICAgZW5kUHJvcHMudHJhbnNpdGlvbkVhc2luZyA9IGNyb3BFYXNpbmdGdW5jdGlvbih0aGlzLnN0YXRlLmVhc2luZywgeDApO1xuICAgICAgICAgICAgZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvciA9IHN0YXJ0UHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbmRQcm9wcy5vblRyYW5zaXRpb25TdGFydCgpO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXJUcmFuc2l0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG5cbiAgICAgICAgdGhpcy5fZW5kVHJhbnNpdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1RyYW5zaXRpb25JblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNUcmFuc2l0aW9uRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNUcmFuc2l0aW9uRW5hYmxlZChwcm9wcykge1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gcHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcjtcbiAgICAgIHJldHVybiAodHJhbnNpdGlvbkR1cmF0aW9uID4gMCB8fCB0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdhdXRvJykgJiYgQm9vbGVhbih0cmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVXBkYXRlRHVlVG9DdXJyZW50VHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbnRlcnBvbGF0b3IuYXJlUHJvcHNFcXVhbChwcm9wcywgdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShjdXJyZW50UHJvcHMsIG5leHRQcm9wcykge1xuICAgICAgaWYgKCFjdXJyZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5JR05PUkUgfHwgdGhpcy5faXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKG5leHRQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmFyZVByb3BzRXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyaWdnZXJUcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgYXNzZXJ0KHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQoZW5kUHJvcHMpKTtcblxuICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdHJhbnNpdGlvbkludGVycG9sYXRvci5nZXREdXJhdGlvbiA/IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IuZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIDogZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5pdGlhbFByb3BzID0gZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvci5pbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpO1xuICAgICAgdmFyIGludGVyYWN0aW9uU3RhdGUgPSB7XG4gICAgICAgIGluVHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNab29taW5nOiBzdGFydFByb3BzLnpvb20gIT09IGVuZFByb3BzLnpvb20sXG4gICAgICAgIGlzUGFubmluZzogc3RhcnRQcm9wcy5sb25naXR1ZGUgIT09IGVuZFByb3BzLmxvbmdpdHVkZSB8fCBzdGFydFByb3BzLmxhdGl0dWRlICE9PSBlbmRQcm9wcy5sYXRpdHVkZSxcbiAgICAgICAgaXNSb3RhdGluZzogc3RhcnRQcm9wcy5iZWFyaW5nICE9PSBlbmRQcm9wcy5iZWFyaW5nIHx8IHN0YXJ0UHJvcHMucGl0Y2ggIT09IGVuZFByb3BzLnBpdGNoXG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVuZFByb3BzLnRyYW5zaXRpb25FYXNpbmcsXG4gICAgICAgIGludGVycG9sYXRvcjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgICAgaW50ZXJydXB0aW9uOiBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJydXB0aW9uLFxuICAgICAgICBzdGFydFRpbWU6IHRoaXMudGltZSgpLFxuICAgICAgICBzdGFydFByb3BzOiBpbml0aWFsUHJvcHMuc3RhcnQsXG4gICAgICAgIGVuZFByb3BzOiBpbml0aWFsUHJvcHMuZW5kLFxuICAgICAgICBhbmltYXRpb246IG51bGwsXG4gICAgICAgIHByb3BzSW5UcmFuc2l0aW9uOiB7fVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUoKTtcblxuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKGludGVyYWN0aW9uU3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5kVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5kVHJhbnNpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKHtcbiAgICAgICAgaW5UcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgaXNab29taW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZpZXdwb3J0KCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50aW1lKCk7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHN0YXJ0VGltZSA9IF90aGlzJHN0YXRlLnN0YXJ0VGltZSxcbiAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzJHN0YXRlLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZyA9IF90aGlzJHN0YXRlLmVhc2luZyxcbiAgICAgICAgICBpbnRlcnBvbGF0b3IgPSBfdGhpcyRzdGF0ZS5pbnRlcnBvbGF0b3IsXG4gICAgICAgICAgc3RhcnRQcm9wcyA9IF90aGlzJHN0YXRlLnN0YXJ0UHJvcHMsXG4gICAgICAgICAgZW5kUHJvcHMgPSBfdGhpcyRzdGF0ZS5lbmRQcm9wcztcbiAgICAgIHZhciBzaG91bGRFbmQgPSBmYWxzZTtcbiAgICAgIHZhciB0ID0gKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uO1xuXG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBzaG91bGRFbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gZWFzaW5nKHQpO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gaW50ZXJwb2xhdG9yLmludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpO1xuICAgICAgdmFyIG1hcFN0YXRlID0gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHZpZXdwb3J0KSk7XG4gICAgICB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uID0gbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24sIHRoaXMucHJvcHMpO1xuXG4gICAgICBpZiAoc2hvdWxkRW5kKSB7XG4gICAgICAgIHRoaXMuX2VuZFRyYW5zaXRpb24oKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcbn0oKTtcblxuX2RlZmluZVByb3BlcnR5KFRyYW5zaXRpb25NYW5hZ2VyLCBcImRlZmF1bHRQcm9wc1wiLCBERUZBVUxUX1BST1BTKTtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbk1hbmFnZXIgYXMgZGVmYXVsdCB9OyIsInZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG5mdW5jdGlvbiBzb21lKGFycmF5LCBwcmVkaWN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljdChhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dChQb2ludGVyRXZlbnRJbnB1dCkge1xuICB2YXIgb2xkSGFuZGxlciA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyO1xuXG4gIFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgICBpZiAoZXYuYnV0dG9uID4gMCAmJiBldi50eXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICBpZiAoIXNvbWUoc3RvcmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnBvaW50ZXJJZCA9PT0gZXYucG9pbnRlcklkO1xuICAgICAgfSkpIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2xkSGFuZGxlci5jYWxsKHRoaXMsIGV2KTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlTW91c2VJbnB1dChNb3VzZUlucHV0KSB7XG4gIE1vdXNlSW5wdXQucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPj0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCA9PT0gMCkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xufSIsImltcG9ydCBoYW1tZXJqcyBmcm9tICdoYW1tZXJqcyc7XG5pbXBvcnQgeyBlbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQsIGVuaGFuY2VNb3VzZUlucHV0IH0gZnJvbSAnLi9oYW1tZXItb3ZlcnJpZGVzJztcbmVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dChoYW1tZXJqcy5Qb2ludGVyRXZlbnRJbnB1dCk7XG5lbmhhbmNlTW91c2VJbnB1dChoYW1tZXJqcy5Nb3VzZUlucHV0KTtcbmV4cG9ydCB2YXIgTWFuYWdlciA9IGhhbW1lcmpzLk1hbmFnZXI7XG5leHBvcnQgZGVmYXVsdCBoYW1tZXJqczsiLCJpbXBvcnQgSGFtbWVyIGZyb20gJy4vdXRpbHMvaGFtbWVyJztcbmV4cG9ydCB2YXIgUkVDT0dOSVpFUlMgPSBIYW1tZXIgPyBbW0hhbW1lci5QYW4sIHtcbiAgZXZlbnQ6ICd0cmlwYW4nLFxuICBwb2ludGVyczogMyxcbiAgdGhyZXNob2xkOiAwLFxuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5Sb3RhdGUsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUGluY2gsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuU3dpcGUsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUGFuLCB7XG4gIHRocmVzaG9sZDogMCxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUHJlc3MsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgdGFwczogMixcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGV2ZW50OiAnYW55dGFwJyxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dXSA6IG51bGw7XG5leHBvcnQgdmFyIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAgPSB7XG4gIHRyaXBhbjogWydyb3RhdGUnLCAncGluY2gnLCAncGFuJ10sXG4gIHJvdGF0ZTogWydwaW5jaCddLFxuICBwaW5jaDogWydwYW4nXSxcbiAgcGFuOiBbJ3ByZXNzJywgJ2RvdWJsZXRhcCcsICdhbnl0YXAnLCAndGFwJ10sXG4gIGRvdWJsZXRhcDogWydhbnl0YXAnXSxcbiAgYW55dGFwOiBbJ3RhcCddXG59O1xuZXhwb3J0IHZhciBSRUNPR05JWkVSX0ZBTExCQUNLX01BUCA9IHtcbiAgZG91YmxldGFwOiBbJ3RhcCddXG59O1xuZXhwb3J0IHZhciBCQVNJQ19FVkVOVF9BTElBU0VTID0ge1xuICBwb2ludGVyZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdwb2ludGVybW92ZScsXG4gIHBvaW50ZXJ1cDogJ3BvaW50ZXJ1cCcsXG4gIHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXG4gIHRvdWNobW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdwb2ludGVydXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCdcbn07XG5leHBvcnQgdmFyIElOUFVUX0VWRU5UX1RZUEVTID0ge1xuICBLRVlfRVZFTlRTOiBbJ2tleWRvd24nLCAna2V5dXAnXSxcbiAgTU9VU0VfRVZFTlRTOiBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2VsZWF2ZSddLFxuICBXSEVFTF9FVkVOVFM6IFsnd2hlZWwnLCAnbW91c2V3aGVlbCddXG59O1xuZXhwb3J0IHZhciBFVkVOVF9SRUNPR05JWkVSX01BUCA9IHtcbiAgdGFwOiAndGFwJyxcbiAgYW55dGFwOiAnYW55dGFwJyxcbiAgZG91YmxldGFwOiAnZG91YmxldGFwJyxcbiAgcHJlc3M6ICdwcmVzcycsXG4gIHBpbmNoOiAncGluY2gnLFxuICBwaW5jaGluOiAncGluY2gnLFxuICBwaW5jaG91dDogJ3BpbmNoJyxcbiAgcGluY2hzdGFydDogJ3BpbmNoJyxcbiAgcGluY2htb3ZlOiAncGluY2gnLFxuICBwaW5jaGVuZDogJ3BpbmNoJyxcbiAgcGluY2hjYW5jZWw6ICdwaW5jaCcsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZXN0YXJ0OiAncm90YXRlJyxcbiAgcm90YXRlbW92ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZWVuZDogJ3JvdGF0ZScsXG4gIHJvdGF0ZWNhbmNlbDogJ3JvdGF0ZScsXG4gIHRyaXBhbjogJ3RyaXBhbicsXG4gIHRyaXBhbnN0YXJ0OiAndHJpcGFuJyxcbiAgdHJpcGFubW92ZTogJ3RyaXBhbicsXG4gIHRyaXBhbnVwOiAndHJpcGFuJyxcbiAgdHJpcGFuZG93bjogJ3RyaXBhbicsXG4gIHRyaXBhbmxlZnQ6ICd0cmlwYW4nLFxuICB0cmlwYW5yaWdodDogJ3RyaXBhbicsXG4gIHRyaXBhbmVuZDogJ3RyaXBhbicsXG4gIHRyaXBhbmNhbmNlbDogJ3RyaXBhbicsXG4gIHBhbjogJ3BhbicsXG4gIHBhbnN0YXJ0OiAncGFuJyxcbiAgcGFubW92ZTogJ3BhbicsXG4gIHBhbnVwOiAncGFuJyxcbiAgcGFuZG93bjogJ3BhbicsXG4gIHBhbmxlZnQ6ICdwYW4nLFxuICBwYW5yaWdodDogJ3BhbicsXG4gIHBhbmVuZDogJ3BhbicsXG4gIHBhbmNhbmNlbDogJ3BhbicsXG4gIHN3aXBlOiAnc3dpcGUnLFxuICBzd2lwZWxlZnQ6ICdzd2lwZScsXG4gIHN3aXBlcmlnaHQ6ICdzd2lwZScsXG4gIHN3aXBldXA6ICdzd2lwZScsXG4gIHN3aXBlZG93bjogJ3N3aXBlJ1xufTtcbmV4cG9ydCB2YXIgR0VTVFVSRV9FVkVOVF9BTElBU0VTID0ge1xuICBjbGljazogJ3RhcCcsXG4gIGFueWNsaWNrOiAnYW55dGFwJyxcbiAgZGJsY2xpY2s6ICdkb3VibGV0YXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCcsXG4gIG1vdXNlb3ZlcjogJ3BvaW50ZXJvdmVyJyxcbiAgbW91c2VvdXQ6ICdwb2ludGVyb3V0JyxcbiAgbW91c2VsZWF2ZTogJ3BvaW50ZXJsZWF2ZSdcbn07IiwiZXhwb3J0IHZhciB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG52YXIgd2luZG93XyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xudmFyIGdsb2JhbF8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbnZhciBkb2N1bWVudF8gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcbmV4cG9ydCB7IHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07XG52YXIgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH07XG4gIHdpbmRvd18uYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB3aW5kb3dfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbn0gY2F0Y2ggKGVycikge31cblxuZXhwb3J0IHsgcGFzc2l2ZVN1cHBvcnRlZCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHdpbmRvdywgdXNlckFnZW50LCBwYXNzaXZlU3VwcG9ydGVkIH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xudmFyIFdIRUVMX0VWRU5UUyA9IElOUFVUX0VWRU5UX1RZUEVTLldIRUVMX0VWRU5UUztcbnZhciBFVkVOVF9UWVBFID0gJ3doZWVsJztcbnZhciBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbnZhciBXSEVFTF9ERUxUQV9QRVJfTElORSA9IDQwO1xudmFyIFNISUZUX01VTFRJUExJRVIgPSAwLjI1O1xuXG52YXIgV2hlZWxJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdoZWVsSW5wdXQoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdoZWVsSW5wdXQpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmV2ZW50cyA9IFdIRUVMX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50LCBwYXNzaXZlU3VwcG9ydGVkID8ge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSA6IGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaGVlbElucHV0LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzMi5oYW5kbGVFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRXZlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBldmVudC5kZWx0YVk7XG5cbiAgICAgIGlmICh3aW5kb3cuV2hlZWxFdmVudCkge1xuICAgICAgICBpZiAoZmlyZWZveCAmJiBldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgICB2YWx1ZSAqPSBXSEVFTF9ERUxUQV9QRVJfTElORTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgd2hlZWxQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcblxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSAmJiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogU0hJRlRfTVVMVElQTElFUjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25XaGVlbChldmVudCwgLXZhbHVlLCB3aGVlbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uV2hlZWwoc3JjRXZlbnQsIGRlbHRhLCBwb3NpdGlvbikge1xuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IEVWRU5UX1RZUEUsXG4gICAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgc3JjRXZlbnQ6IHNyY0V2ZW50LFxuICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgdGFyZ2V0OiBzcmNFdmVudC50YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXaGVlbElucHV0O1xufSgpO1xuXG5leHBvcnQgeyBXaGVlbElucHV0IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgeyBJTlBVVF9FVkVOVF9UWVBFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG52YXIgTU9VU0VfRVZFTlRTID0gSU5QVVRfRVZFTlRfVFlQRVMuTU9VU0VfRVZFTlRTO1xudmFyIE1PVkVfRVZFTlRfVFlQRSA9ICdwb2ludGVybW92ZSc7XG52YXIgT1ZFUl9FVkVOVF9UWVBFID0gJ3BvaW50ZXJvdmVyJztcbnZhciBPVVRfRVZFTlRfVFlQRSA9ICdwb2ludGVyb3V0JztcbnZhciBMRUFWRV9FVkVOVF9UWVBFID0gJ3BvaW50ZXJsZWF2ZSc7XG5cbnZhciBNb3ZlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb3ZlSW5wdXQoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdmVJbnB1dCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZUxlYXZlRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlT3V0RXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlT3ZlckV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmV2ZW50cyA9IE1PVVNFX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb3ZlSW5wdXQsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMyLmhhbmRsZUV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVFdmVudFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRUeXBlKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gT1ZFUl9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3ZlckV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gT1VUX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVPdXRFdmVudCA9IGVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgPT09IExFQVZFX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVMZWF2ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlT3ZlckV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlT3V0RXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGVMZWF2ZUV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlT3ZlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU92ZXJFdmVudChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlT3ZlckV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VvdmVyJykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgICAgdHlwZTogT1ZFUl9FVkVOVF9UWVBFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU91dEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU91dEV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5lbmFibGVPdXRFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgICAgdHlwZTogT1VUX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTGVhdmVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5lbmFibGVMZWF2ZUV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICAgIHR5cGU6IExFQVZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW92ZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlTW92ZUV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNT1ZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW92ZUlucHV0O1xufSgpO1xuXG5leHBvcnQgeyBNb3ZlSW5wdXQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbnZhciBLRVlfRVZFTlRTID0gSU5QVVRfRVZFTlRfVFlQRVMuS0VZX0VWRU5UUztcbnZhciBET1dOX0VWRU5UX1RZUEUgPSAna2V5ZG93bic7XG52YXIgVVBfRVZFTlRfVFlQRSA9ICdrZXl1cCc7XG5cbnZhciBLZXlJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleUlucHV0KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlJbnB1dCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZW5hYmxlRG93bkV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZVVwRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZXZlbnRzID0gS0VZX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IG9wdGlvbnMudGFiSW5kZXggfHwgMDtcbiAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLZXlJbnB1dCwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpczIuaGFuZGxlRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUV2ZW50VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBET1dOX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVEb3duRXZlbnQgPSBlbmFibGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBVUF9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlVXBFdmVudCA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXG4gICAgICBpZiAodGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnICYmIHRhcmdldEVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZURvd25FdmVudCAmJiBldmVudC50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgICAgdHlwZTogRE9XTl9FVkVOVF9UWVBFLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5hYmxlVXBFdmVudCAmJiBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGU6IFVQX0VWRU5UX1RZUEUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlJbnB1dDtcbn0oKTtcblxuZXhwb3J0IHsgS2V5SW5wdXQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbnZhciBFVkVOVF9UWVBFID0gJ2NvbnRleHRtZW51JztcblxudmFyIENvbnRleHRtZW51SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZXh0bWVudUlucHV0KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRleHRtZW51SW5wdXQpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb250ZXh0bWVudUlucHV0LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRXZlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgIH0sXG4gICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGV4dG1lbnVJbnB1dDtcbn0oKTtcblxuZXhwb3J0IHsgQ29udGV4dG1lbnVJbnB1dCBhcyBkZWZhdWx0IH07IiwidmFyIERPV05fRVZFTlQgPSAxO1xudmFyIE1PVkVfRVZFTlQgPSAyO1xudmFyIFVQX0VWRU5UID0gNDtcbnZhciBNT1VTRV9FVkVOVFMgPSB7XG4gIHBvaW50ZXJkb3duOiBET1dOX0VWRU5ULFxuICBwb2ludGVybW92ZTogTU9WRV9FVkVOVCxcbiAgcG9pbnRlcnVwOiBVUF9FVkVOVCxcbiAgbW91c2Vkb3duOiBET1dOX0VWRU5ULFxuICBtb3VzZW1vdmU6IE1PVkVfRVZFTlQsXG4gIG1vdXNldXA6IFVQX0VWRU5UXG59O1xudmFyIE1PVVNFX0VWRU5UX1dISUNIX0xFRlQgPSAxO1xudmFyIE1PVVNFX0VWRU5UX1dISUNIX01JRERMRSA9IDI7XG52YXIgTU9VU0VfRVZFTlRfV0hJQ0hfUklHSFQgPSAzO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUID0gMDtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05fTUlERExFID0gMTtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05fUklHSFQgPSAyO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTlNfTEVGVF9NQVNLID0gMTtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05TX1JJR0hUX01BU0sgPSAyO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTlNfTUlERExFX01BU0sgPSA0O1xuZXhwb3J0IGZ1bmN0aW9uIHdoaWNoQnV0dG9ucyhldmVudCkge1xuICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfRVZFTlRTW2V2ZW50LnNyY0V2ZW50LnR5cGVdO1xuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgX2V2ZW50JHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQsXG4gICAgICBidXR0b25zID0gX2V2ZW50JHNyY0V2ZW50LmJ1dHRvbnMsXG4gICAgICBidXR0b24gPSBfZXZlbnQkc3JjRXZlbnQuYnV0dG9uLFxuICAgICAgd2hpY2ggPSBfZXZlbnQkc3JjRXZlbnQud2hpY2g7XG4gIHZhciBsZWZ0QnV0dG9uID0gZmFsc2U7XG4gIHZhciBtaWRkbGVCdXR0b24gPSBmYWxzZTtcbiAgdmFyIHJpZ2h0QnV0dG9uID0gZmFsc2U7XG5cbiAgaWYgKGV2ZW50VHlwZSA9PT0gVVBfRVZFTlQgfHwgZXZlbnRUeXBlID09PSBNT1ZFX0VWRU5UICYmICFOdW1iZXIuaXNGaW5pdGUoYnV0dG9ucykpIHtcbiAgICBsZWZ0QnV0dG9uID0gd2hpY2ggPT09IE1PVVNFX0VWRU5UX1dISUNIX0xFRlQ7XG4gICAgbWlkZGxlQnV0dG9uID0gd2hpY2ggPT09IE1PVVNFX0VWRU5UX1dISUNIX01JRERMRTtcbiAgICByaWdodEJ1dHRvbiA9IHdoaWNoID09PSBNT1VTRV9FVkVOVF9XSElDSF9SSUdIVDtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IE1PVkVfRVZFTlQpIHtcbiAgICBsZWZ0QnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19MRUZUX01BU0spO1xuICAgIG1pZGRsZUJ1dHRvbiA9IEJvb2xlYW4oYnV0dG9ucyAmIE1PVVNFX0VWRU5UX0JVVFRPTlNfTUlERExFX01BU0spO1xuICAgIHJpZ2h0QnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19SSUdIVF9NQVNLKTtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IERPV05fRVZFTlQpIHtcbiAgICBsZWZ0QnV0dG9uID0gYnV0dG9uID09PSBNT1VTRV9FVkVOVF9CVVRUT05fTEVGVDtcbiAgICBtaWRkbGVCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9NSURETEU7XG4gICAgcmlnaHRCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9SSUdIVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVmdEJ1dHRvbjogbGVmdEJ1dHRvbixcbiAgICBtaWRkbGVCdXR0b246IG1pZGRsZUJ1dHRvbixcbiAgICByaWdodEJ1dHRvbjogcmlnaHRCdXR0b25cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgcm9vdEVsZW1lbnQpIHtcbiAgdmFyIHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQ7XG5cbiAgaWYgKCFldmVudC5jZW50ZXIgJiYgIU51bWJlci5pc0Zpbml0ZShzcmNFdmVudC5jbGllbnRYKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IGV2ZW50LmNlbnRlciB8fCB7XG4gICAgeDogc3JjRXZlbnQuY2xpZW50WCxcbiAgICB5OiBzcmNFdmVudC5jbGllbnRZXG4gIH07XG4gIHZhciByZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByZWN0LndpZHRoIC8gcm9vdEVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gcm9vdEVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHZhciBvZmZzZXRDZW50ZXIgPSB7XG4gICAgeDogKGNlbnRlci54IC0gcmVjdC5sZWZ0IC0gcm9vdEVsZW1lbnQuY2xpZW50TGVmdCkgLyBzY2FsZVgsXG4gICAgeTogKGNlbnRlci55IC0gcmVjdC50b3AgLSByb290RWxlbWVudC5jbGllbnRUb3ApIC8gc2NhbGVZXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgb2Zmc2V0Q2VudGVyOiBvZmZzZXRDZW50ZXJcbiAgfTtcbn0iLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgeyB3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9uIH0gZnJvbSAnLi9ldmVudC11dGlscyc7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBzcmNFbGVtZW50OiAncm9vdCcsXG4gIHByaW9yaXR5OiAwXG59O1xuXG52YXIgRXZlbnRSZWdpc3RyYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudFJlZ2lzdHJhcihldmVudE1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRSZWdpc3RyYXIpO1xuXG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlcnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFJlZ2lzdHJhciwgW3tcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9hY3RpdmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodHlwZSwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIHBhc3NpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycyxcbiAgICAgICAgICBoYW5kbGVyc0J5RWxlbWVudCA9IHRoaXMuaGFuZGxlcnNCeUVsZW1lbnQ7XG5cbiAgICAgIGlmIChvcHRzICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgb3B0cy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHNyY0VsZW1lbnQ6IG9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3B0cyA9IG9wdHMgPyBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdHMpIDogREVGQVVMVF9PUFRJT05TO1xuICAgICAgdmFyIGVudHJpZXMgPSBoYW5kbGVyc0J5RWxlbWVudC5nZXQob3B0cy5zcmNFbGVtZW50KTtcblxuICAgICAgaWYgKCFlbnRyaWVzKSB7XG4gICAgICAgIGVudHJpZXMgPSBbXTtcbiAgICAgICAgaGFuZGxlcnNCeUVsZW1lbnQuc2V0KG9wdHMuc3JjRWxlbWVudCwgZW50cmllcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgc3JjRWxlbWVudDogb3B0cy5zcmNFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogb3B0cy5wcmlvcml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgZW50cnkub25jZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXNzaXZlKSB7XG4gICAgICAgIGVudHJ5LnBhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGVudHJ5KTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCAhZW50cnkucGFzc2l2ZTtcbiAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IGVudHJpZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGluc2VydFBvc2l0aW9uID49IDApIHtcbiAgICAgICAgaWYgKGVudHJpZXNbaW5zZXJ0UG9zaXRpb25dLnByaW9yaXR5ID49IGVudHJ5LnByaW9yaXR5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbnNlcnRQb3NpdGlvbi0tO1xuICAgICAgfVxuXG4gICAgICBlbnRyaWVzLnNwbGljZShpbnNlcnRQb3NpdGlvbiArIDEsIDAsIGVudHJ5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzLFxuICAgICAgICAgIGhhbmRsZXJzQnlFbGVtZW50ID0gdGhpcy5oYW5kbGVyc0J5RWxlbWVudDtcblxuICAgICAgZm9yICh2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGhhbmRsZXJzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50eXBlID09PSB0eXBlICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBoYW5kbGVyc0J5RWxlbWVudC5nZXQoZW50cnkuc3JjRWxlbWVudCk7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoZW50cmllcy5pbmRleE9mKGVudHJ5KSwgMSk7XG5cbiAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGhhbmRsZXJzQnlFbGVtZW50LmRlbGV0ZShlbnRyeS5zcmNFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlID0gaGFuZGxlcnMuc29tZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICFlbnRyeS5wYXNzaXZlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWpvbG5pckV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuc3JjRXZlbnQudGFyZ2V0O1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gbWpvbG5pckV2ZW50LnJvb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXQobWpvbG5pckV2ZW50LCB0YXJnZXQpO1xuXG4gICAgICAgIGlmIChtam9sbmlyRXZlbnQuaGFuZGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0KG1qb2xuaXJFdmVudCwgJ3Jvb3QnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXQoZXZlbnQsIHNyY0VsZW1lbnQpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5oYW5kbGVyc0J5RWxlbWVudC5nZXQoc3JjRWxlbWVudCk7XG5cbiAgICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgIGV2ZW50LmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgZXZlbnQuaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZW50cmllc1RvUmVtb3ZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzJGkgPSBlbnRyaWVzW2ldLFxuICAgICAgICAgICAgICB0eXBlID0gX2VudHJpZXMkaS50eXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyID0gX2VudHJpZXMkaS5oYW5kbGVyLFxuICAgICAgICAgICAgICBvbmNlID0gX2VudHJpZXMkaS5vbmNlO1xuICAgICAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgIGVudHJpZXNUb1JlbW92ZS5wdXNoKGVudHJpZXNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbnRyaWVzVG9SZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzVG9SZW1vdmUkX2kgPSBlbnRyaWVzVG9SZW1vdmVbX2ldLFxuICAgICAgICAgICAgICBfdHlwZSA9IF9lbnRyaWVzVG9SZW1vdmUkX2kudHlwZSxcbiAgICAgICAgICAgICAgX2hhbmRsZXIgPSBfZW50cmllc1RvUmVtb3ZlJF9pLmhhbmRsZXI7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoX3R5cGUsIF9oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm9ybWFsaXplRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLmV2ZW50TWFuYWdlci5lbGVtZW50O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB3aGljaEJ1dHRvbnMoZXZlbnQpLCBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgcm9vdEVsZW1lbnQpLCB7XG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICByb290RWxlbWVudDogcm9vdEVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFJlZ2lzdHJhcjtcbn0oKTtcblxuZXhwb3J0IHsgRXZlbnRSZWdpc3RyYXIgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuaW1wb3J0IHsgTWFuYWdlciB9IGZyb20gJy4vdXRpbHMvaGFtbWVyJztcbmltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vaW5wdXRzL3doZWVsLWlucHV0JztcbmltcG9ydCBNb3ZlSW5wdXQgZnJvbSAnLi9pbnB1dHMvbW92ZS1pbnB1dCc7XG5pbXBvcnQgS2V5SW5wdXQgZnJvbSAnLi9pbnB1dHMva2V5LWlucHV0JztcbmltcG9ydCBDb250ZXh0bWVudUlucHV0IGZyb20gJy4vaW5wdXRzL2NvbnRleHRtZW51LWlucHV0JztcbmltcG9ydCBFdmVudFJlZ2lzdHJhciBmcm9tICcuL3V0aWxzL2V2ZW50LXJlZ2lzdHJhcic7XG5pbXBvcnQgeyBCQVNJQ19FVkVOVF9BTElBU0VTLCBFVkVOVF9SRUNPR05JWkVSX01BUCwgR0VTVFVSRV9FVkVOVF9BTElBU0VTLCBSRUNPR05JWkVSUywgUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUCwgUkVDT0dOSVpFUl9GQUxMQkFDS19NQVAgfSBmcm9tICcuL2NvbnN0YW50cyc7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBldmVudHM6IG51bGwsXG4gIHJlY29nbml6ZXJzOiBudWxsLFxuICByZWNvZ25pemVyT3B0aW9uczoge30sXG4gIE1hbmFnZXI6IE1hbmFnZXIsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIHRhYkluZGV4OiAwXG59O1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKCkge1xuICAgIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudE1hbmFnZXIpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdmFyIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudE1hbmFnZXIsIFt7XG4gICAga2V5OiBcInNldEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBNYW5hZ2VyQ2xhc3MgPSBvcHRpb25zLk1hbmFnZXI7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtcbiAgICAgICAgdG91Y2hBY3Rpb246IG9wdGlvbnMudG91Y2hBY3Rpb24sXG4gICAgICAgIHJlY29nbml6ZXJzOiBvcHRpb25zLnJlY29nbml6ZXJzIHx8IFJFQ09HTklaRVJTXG4gICAgICB9KS5vbignaGFtbWVyLmlucHV0JywgdGhpcy5fb25CYXNpY0lucHV0KTtcblxuICAgICAgaWYgKCFvcHRpb25zLnJlY29nbml6ZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAob3RoZXJOYW1lKSB7XG4gICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChvdGhlck5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcmVjb2duaXplck5hbWUgaW4gb3B0aW9ucy5yZWNvZ25pemVyT3B0aW9ucykge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQocmVjb2duaXplck5hbWUpO1xuXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgdmFyIHJlY29nbml6ZXJPcHRpb24gPSBvcHRpb25zLnJlY29nbml6ZXJPcHRpb25zW3JlY29nbml6ZXJOYW1lXTtcbiAgICAgICAgICBkZWxldGUgcmVjb2duaXplck9wdGlvbi5lbmFibGU7XG4gICAgICAgICAgcmVjb2duaXplci5zZXQocmVjb2duaXplck9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53aGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICAgIGVuYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICAgIHRhYkluZGV4OiBvcHRpb25zLnRhYkluZGV4XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dCA9IG5ldyBDb250ZXh0bWVudUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZXZlbnRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGV2ZW50QWxpYXMgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZXZlbnRSZWdpc3RyYXIgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghZXZlbnRSZWdpc3RyYXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKGV2ZW50UmVnaXN0cmFyLnJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLndoZWVsSW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLndoZWVsSW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVJbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBmYWxzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2F0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2F0Y2goZXZlbnQsIGhhbmRsZXIsIG9wdHMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgb3B0cywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdG9nZ2xlUmVjb2duaXplclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlUmVjb2duaXplcihuYW1lLCBlbmFibGVkKSB7XG4gICAgICB2YXIgbWFuYWdlciA9IHRoaXMubWFuYWdlcjtcblxuICAgICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcblxuICAgICAgaWYgKHJlY29nbml6ZXIgJiYgcmVjb2duaXplci5vcHRpb25zLmVuYWJsZSAhPT0gZW5hYmxlZCkge1xuICAgICAgICByZWNvZ25pemVyLnNldCh7XG4gICAgICAgICAgZW5hYmxlOiBlbmFibGVkXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmFsbGJhY2tSZWNvZ25pemVycyA9IFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQW25hbWVdO1xuXG4gICAgICAgIGlmIChmYWxsYmFja1JlY29nbml6ZXJzICYmICF0aGlzLm9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgICAgICBmYWxsYmFja1JlY29nbml6ZXJzLmZvckVhY2goZnVuY3Rpb24gKG90aGVyTmFtZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVjb2duaXplciA9IG1hbmFnZXIuZ2V0KG90aGVyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICAgICAgcmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53aGVlbElucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICAgIHRoaXMua2V5SW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgICAgdGhpcy5jb250ZXh0bWVudUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEV2ZW50SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBvbmNlLCBwYXNzaXZlKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzID0gaGFuZGxlcjtcblxuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdLCBvcHRzLCBvbmNlLCBwYXNzaXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIsXG4gICAgICAgICAgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICB2YXIgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgICB2YXIgZXZlbnRSZWdpc3RyYXIgPSBldmVudHMuZ2V0KGV2ZW50QWxpYXMpO1xuXG4gICAgICBpZiAoIWV2ZW50UmVnaXN0cmFyKSB7XG4gICAgICAgIGV2ZW50UmVnaXN0cmFyID0gbmV3IEV2ZW50UmVnaXN0cmFyKHRoaXMpO1xuICAgICAgICBldmVudHMuc2V0KGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyKTtcbiAgICAgICAgZXZlbnRSZWdpc3RyYXIucmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuXG4gICAgICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCBldmVudFJlZ2lzdHJhci5oYW5kbGVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnRSZWdpc3RyYXIuYWRkKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBvbmNlLCBwYXNzaXZlKTtcblxuICAgICAgaWYgKCFldmVudFJlZ2lzdHJhci5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihldmVudFJlZ2lzdHJhci5yZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgIHZhciBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAgIHZhciBldmVudFJlZ2lzdHJhciA9IGV2ZW50cy5nZXQoZXZlbnRBbGlhcyk7XG5cbiAgICAgIGlmICghZXZlbnRSZWdpc3RyYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudFJlZ2lzdHJhci5yZW1vdmUoZXZlbnQsIGhhbmRsZXIpO1xuXG4gICAgICBpZiAoZXZlbnRSZWdpc3RyYXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyTmFtZSA9IGV2ZW50UmVnaXN0cmFyLnJlY29nbml6ZXJOYW1lO1xuICAgICAgICB2YXIgaXNSZWNvZ25pemVyVXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZWggPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChlaC5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWUgJiYgIWVoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpc1JlY29nbml6ZXJVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNSZWNvZ25pemVyVXNlZCkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25CYXNpY0lucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICAgIHZhciBzcmNFdmVudCA9IGV2ZW50LnNyY0V2ZW50O1xuICAgICAgdmFyIGFsaWFzID0gQkFTSUNfRVZFTlRfQUxJQVNFU1tzcmNFdmVudC50eXBlXTtcblxuICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KGFsaWFzLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbk90aGVyRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uT3RoZXJFdmVudChldmVudCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCB7IEV2ZW50TWFuYWdlciBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuL21hcC1zdGF0ZSc7XG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyLCB7IFRSQU5TSVRJT05fRVZFTlRTIH0gZnJvbSAnLi90cmFuc2l0aW9uLW1hbmFnZXInO1xudmFyIE5PX1RSQU5TSVRJT05fUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMFxufTtcbmV4cG9ydCB2YXIgTElORUFSX1RSQU5TSVRJT05fUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxuICB0cmFuc2l0aW9uRWFzaW5nOiBmdW5jdGlvbiB0cmFuc2l0aW9uRWFzaW5nKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IExpbmVhckludGVycG9sYXRvcigpLFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBUUkFOU0lUSU9OX0VWRU5UUy5CUkVBS1xufTtcbnZhciBERUZBVUxUX0lORVJUSUEgPSAzMDA7XG5cbnZhciBJTkVSVElBX0VBU0lORyA9IGZ1bmN0aW9uIElORVJUSUFfRUFTSU5HKHQpIHtcbiAgcmV0dXJuIDEgLSAoMSAtIHQpICogKDEgLSB0KTtcbn07XG5cbnZhciBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIFRSSVBMRV9QQU46IFsndHJpcGFuc3RhcnQnLCAndHJpcGFubW92ZScsICd0cmlwYW5lbmQnXSxcbiAgRE9VQkxFX1RBUDogWydkb3VibGV0YXAnXSxcbiAgS0VZQk9BUkQ6IFsna2V5ZG93biddXG59O1xuXG52YXIgTWFwQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFwQ29udHJvbGxlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcENvbnRyb2xsZXIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjcm9sbFpvb21cIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFnUGFuXCIsIHRydWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ1JvdGF0ZVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdWJsZUNsaWNrWm9vbVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoWm9vbVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoUm90YXRlXCIsIGZhbHNlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleWJvYXJkXCIsIHRydWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVyYWN0aW9uU3RhdGVcIiwge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ldmVudHNcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NldEludGVyYWN0aW9uU3RhdGVcIiwgZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKF90aGlzLl9pbnRlcmFjdGlvblN0YXRlLCBuZXdTdGF0ZSk7XG5cbiAgICAgIGlmIChfdGhpcy5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLm9uU3RhdGVDaGFuZ2UoX3RoaXMuX2ludGVyYWN0aW9uU3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uVHJhbnNpdGlvblwiLCBmdW5jdGlvbiAobmV3Vmlld3BvcnQsIG9sZFZpZXdwb3J0KSB7XG4gICAgICBfdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCBfdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld3BvcnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICBvblZpZXdwb3J0Q2hhbmdlOiB0aGlzLl9vblRyYW5zaXRpb24sXG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9zZXRJbnRlcmFjdGlvblN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMubWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKCk7XG4gICAgICB2YXIgZXZlbnRTdGFydEJsb2NrZWQgPSB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZDtcblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3Bhbm1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblBhbihldmVudCk7XG5cbiAgICAgICAgY2FzZSAncGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3BpbmNoc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0QmxvY2tlZCA/IGZhbHNlIDogdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcblxuICAgICAgICBjYXNlICdwaW5jaG1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoKGV2ZW50KTtcblxuICAgICAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3RyaXBhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3RyaXBhbm1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblRyaXBsZVBhbihldmVudCk7XG5cbiAgICAgICAgY2FzZSAndHJpcGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25UcmlwbGVQYW5FbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcblxuICAgICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uV2hlZWwoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VudGVyKGV2ZW50KSB7XG4gICAgICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICAgICAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgICAgICAgIHkgPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLnk7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Z1bmN0aW9uS2V5UHJlc3NlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkge1xuICAgICAgdmFyIHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQ7XG4gICAgICByZXR1cm4gQm9vbGVhbihzcmNFdmVudC5tZXRhS2V5IHx8IHNyY0V2ZW50LmFsdEtleSB8fCBzcmNFdmVudC5jdHJsS2V5IHx8IHNyY0V2ZW50LnNoaWZ0S2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmxvY2tFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2tFdmVudHModGltZW91dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9ldmVudFN0YXJ0QmxvY2tlZCA9PT0gdGltZXIpIHtcbiAgICAgICAgICBfdGhpczIuX2V2ZW50U3RhcnRCbG9ja2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgICB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZCA9IHRpbWVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgZXh0cmFQcm9wcywgaW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgICAgdmFyIG9sZFZpZXdwb3J0ID0gdGhpcy5tYXBTdGF0ZSBpbnN0YW5jZW9mIE1hcFN0YXRlID8gdGhpcy5tYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkgOiB0aGlzLm1hcFN0YXRlO1xuXG4gICAgICB2YXIgbmV3Vmlld3BvcnQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5ld01hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKSksIGV4dHJhUHJvcHMpO1xuXG4gICAgICB2YXIgdmlld1N0YXRlQ2hhbmdlZCA9IE9iamVjdC5rZXlzKG5ld1ZpZXdwb3J0KS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9sZFZpZXdwb3J0W2tleV0gIT09IG5ld1ZpZXdwb3J0W2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV3TWFwU3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25TdGF0ZShpbnRlcmFjdGlvblN0YXRlKTtcblxuICAgICAgaWYgKHZpZXdTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCB0aGlzLl9pbnRlcmFjdGlvblN0YXRlLCBvbGRWaWV3cG9ydCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcFN0YXRlKG92ZXJyaWRlcykge1xuICAgICAgcmV0dXJuIG5ldyBNYXBTdGF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5tYXBTdGF0ZVByb3BzKSwgdGhpcy5fc3RhdGUpLCBvdmVycmlkZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEcmFnZ2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RyYWdnaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aW9uU3RhdGUuaXNEcmFnZ2luZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gb3B0aW9ucy5vblZpZXdwb3J0Q2hhbmdlLFxuICAgICAgICAgIG9uU3RhdGVDaGFuZ2UgPSBvcHRpb25zLm9uU3RhdGVDaGFuZ2UsXG4gICAgICAgICAgX29wdGlvbnMkZXZlbnRNYW5hZ2VyID0gb3B0aW9ucy5ldmVudE1hbmFnZXIsXG4gICAgICAgICAgZXZlbnRNYW5hZ2VyID0gX29wdGlvbnMkZXZlbnRNYW5hZ2VyID09PSB2b2lkIDAgPyB0aGlzLmV2ZW50TWFuYWdlciA6IF9vcHRpb25zJGV2ZW50TWFuYWdlcixcbiAgICAgICAgICBfb3B0aW9ucyRpc0ludGVyYWN0aXYgPSBvcHRpb25zLmlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgaXNJbnRlcmFjdGl2ZSA9IF9vcHRpb25zJGlzSW50ZXJhY3RpdiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGlzSW50ZXJhY3RpdixcbiAgICAgICAgICBfb3B0aW9ucyRzY3JvbGxab29tID0gb3B0aW9ucy5zY3JvbGxab29tLFxuICAgICAgICAgIHNjcm9sbFpvb20gPSBfb3B0aW9ucyRzY3JvbGxab29tID09PSB2b2lkIDAgPyB0aGlzLnNjcm9sbFpvb20gOiBfb3B0aW9ucyRzY3JvbGxab29tLFxuICAgICAgICAgIF9vcHRpb25zJGRyYWdQYW4gPSBvcHRpb25zLmRyYWdQYW4sXG4gICAgICAgICAgZHJhZ1BhbiA9IF9vcHRpb25zJGRyYWdQYW4gPT09IHZvaWQgMCA/IHRoaXMuZHJhZ1BhbiA6IF9vcHRpb25zJGRyYWdQYW4sXG4gICAgICAgICAgX29wdGlvbnMkZHJhZ1JvdGF0ZSA9IG9wdGlvbnMuZHJhZ1JvdGF0ZSxcbiAgICAgICAgICBkcmFnUm90YXRlID0gX29wdGlvbnMkZHJhZ1JvdGF0ZSA9PT0gdm9pZCAwID8gdGhpcy5kcmFnUm90YXRlIDogX29wdGlvbnMkZHJhZ1JvdGF0ZSxcbiAgICAgICAgICBfb3B0aW9ucyRkb3VibGVDbGlja1ogPSBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSxcbiAgICAgICAgICBkb3VibGVDbGlja1pvb20gPSBfb3B0aW9ucyRkb3VibGVDbGlja1ogPT09IHZvaWQgMCA/IHRoaXMuZG91YmxlQ2xpY2tab29tIDogX29wdGlvbnMkZG91YmxlQ2xpY2taLFxuICAgICAgICAgIF9vcHRpb25zJHRvdWNoWm9vbSA9IG9wdGlvbnMudG91Y2hab29tLFxuICAgICAgICAgIHRvdWNoWm9vbSA9IF9vcHRpb25zJHRvdWNoWm9vbSA9PT0gdm9pZCAwID8gdGhpcy50b3VjaFpvb20gOiBfb3B0aW9ucyR0b3VjaFpvb20sXG4gICAgICAgICAgX29wdGlvbnMkdG91Y2hSb3RhdGUgPSBvcHRpb25zLnRvdWNoUm90YXRlLFxuICAgICAgICAgIHRvdWNoUm90YXRlID0gX29wdGlvbnMkdG91Y2hSb3RhdGUgPT09IHZvaWQgMCA/IHRoaXMudG91Y2hSb3RhdGUgOiBfb3B0aW9ucyR0b3VjaFJvdGF0ZSxcbiAgICAgICAgICBfb3B0aW9ucyRrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQsXG4gICAgICAgICAga2V5Ym9hcmQgPSBfb3B0aW9ucyRrZXlib2FyZCA9PT0gdm9pZCAwID8gdGhpcy5rZXlib2FyZCA6IF9vcHRpb25zJGtleWJvYXJkO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb25WaWV3cG9ydENoYW5nZTtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSB0aGlzLm1hcFN0YXRlUHJvcHMgfHwge307XG4gICAgICB2YXIgZGltZW5zaW9uQ2hhbmdlZCA9IHByZXZPcHRpb25zLmhlaWdodCAhPT0gb3B0aW9ucy5oZWlnaHQgfHwgcHJldk9wdGlvbnMud2lkdGggIT09IG9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLm1hcFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuXG4gICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm1hcFN0YXRlID0gcHJldk9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3IE1hcFN0YXRlKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJhbnNpdGlvbk1hbmFnZXIucHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlKG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIgIT09IGV2ZW50TWFuYWdlcikge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKHRoaXMuZXZlbnRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihzY3JvbGxab29tKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QQU4sIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkcmFnUGFuIHx8IGRyYWdSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBJTkNILCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hab29tIHx8IHRvdWNoUm90YXRlKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5UUklQTEVfUEFOLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkb3VibGVDbGlja1pvb20pKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLktFWUJPQVJELCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oa2V5Ym9hcmQpKTtcbiAgICAgIHRoaXMuc2Nyb2xsWm9vbSA9IHNjcm9sbFpvb207XG4gICAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgICAgdGhpcy5kcmFnUm90YXRlID0gZHJhZ1JvdGF0ZTtcbiAgICAgIHRoaXMuZG91YmxlQ2xpY2tab29tID0gZG91YmxlQ2xpY2tab29tO1xuICAgICAgdGhpcy50b3VjaFpvb20gPSB0b3VjaFpvb207XG4gICAgICB0aGlzLnRvdWNoUm90YXRlID0gdG91Y2hSb3RhdGU7XG4gICAgICB0aGlzLmtleWJvYXJkID0ga2V5Ym9hcmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIGlmIChfdGhpczMuX2V2ZW50c1tldmVudE5hbWVdICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgICBfdGhpczMuX2V2ZW50c1tldmVudE5hbWVdID0gZW5hYmxlZDtcblxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuZXZlbnRNYW5hZ2VyLm9mZihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB0aGlzLl9wYW5Sb3RhdGUgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB8fCBldmVudC5yaWdodEJ1dHRvbjtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMubWFwU3RhdGUucm90YXRlU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSkgOiB0aGlzLm1hcFN0YXRlLnBhblN0YXJ0KHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMuX29uUGFuUm90YXRlKGV2ZW50KSA6IHRoaXMuX29uUGFuTW92ZShldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhbkVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcGFuUm90YXRlID8gdGhpcy5fb25QYW5Sb3RhdGVFbmQoZXZlbnQpIDogdGhpcy5fb25QYW5Nb3ZlRW5kKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5Nb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ1Bhbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNQYW5uaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Nb3ZlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhbk1vdmVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdQYW4pIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9IHRoaXMuZHJhZ1Bhbi5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkZHJhZ1BhbiRpbmVydGlhO1xuXG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSArIGV2ZW50LnZlbG9jaXR5WCAqIGluZXJ0aWEgLyAyLCBwb3NbMV0gKyBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSkucGFuRW5kKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhbm5pbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbkVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhblJvdGF0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5Sb3RhdGVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdSb3RhdGUkaW5lciA9IHRoaXMuZHJhZ1JvdGF0ZS5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJGRyYWdSb3RhdGUkaW5lciA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkZHJhZ1JvdGF0ZSRpbmVyO1xuXG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSArIGV2ZW50LnZlbG9jaXR5WCAqIGluZXJ0aWEgLyAyLCBwb3NbMV0gKyBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSkucm90YXRlRW5kKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW5FbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25XaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25XaGVlbChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkc2Nyb2xsWm9vbSA9IHRoaXMuc2Nyb2xsWm9vbSxcbiAgICAgICAgICBfdGhpcyRzY3JvbGxab29tJHNwZWUgPSBfdGhpcyRzY3JvbGxab29tLnNwZWVkLFxuICAgICAgICAgIHNwZWVkID0gX3RoaXMkc2Nyb2xsWm9vbSRzcGVlID09PSB2b2lkIDAgPyAwLjAxIDogX3RoaXMkc2Nyb2xsWm9vbSRzcGVlLFxuICAgICAgICAgIF90aGlzJHNjcm9sbFpvb20kc21vbyA9IF90aGlzJHNjcm9sbFpvb20uc21vb3RoLFxuICAgICAgICAgIHNtb290aCA9IF90aGlzJHNjcm9sbFpvb20kc21vbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfdGhpcyRzY3JvbGxab29tJHNtb287XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhO1xuICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhICogc3BlZWQpKSk7XG5cbiAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbSh7XG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgIGFyb3VuZDogcG9zXG4gICAgICAgIH0pLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHNtb290aCA/IDI1MCA6IDFcbiAgICAgIH0pLCB7XG4gICAgICAgIGlzUGFubmluZzogdHJ1ZSxcbiAgICAgICAgaXNab29taW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QaW5jaFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb21TdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KS5yb3RhdGVTdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uO1xuICAgICAgdGhpcy5fbGFzdFBpbmNoRXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGluY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGluY2goZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMudG91Y2hab29tICYmICF0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZTtcblxuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGV2ZW50LnNjYWxlO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICBuZXdNYXBTdGF0ZSA9IG5ld01hcFN0YXRlLnpvb20oe1xuICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gZXZlbnQucm90YXRpb247XG4gICAgICAgIG5ld01hcFN0YXRlID0gbmV3TWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICBkZWx0YUFuZ2xlWDogdGhpcy5fc3RhcnRQaW5jaFJvdGF0aW9uIC0gcm90YXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgaXNQYW5uaW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNab29taW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNSb3RhdGluZzogQm9vbGVhbih0aGlzLnRvdWNoUm90YXRlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9sYXN0UGluY2hFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBpbmNoRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBfdGhpcyR0b3VjaFpvb20kaW5lcnQgPSB0aGlzLnRvdWNoWm9vbS5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJHRvdWNoWm9vbSRpbmVydCA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkdG91Y2hab29tJGluZXJ0O1xuICAgICAgICB2YXIgX2xhc3RQaW5jaEV2ZW50ID0gdGhpcy5fbGFzdFBpbmNoRXZlbnQ7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgX2xhc3RQaW5jaEV2ZW50ICYmIGV2ZW50LnNjYWxlICE9PSBfbGFzdFBpbmNoRXZlbnQuc2NhbGUpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuXG4gICAgICAgICAgdmFyIF9uZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlRW5kKCk7XG5cbiAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nMihldmVudC5zY2FsZSk7XG5cbiAgICAgICAgICB2YXIgdmVsb2NpdHlaID0gKHogLSBNYXRoLmxvZzIoX2xhc3RQaW5jaEV2ZW50LnNjYWxlKSkgLyAoZXZlbnQuZGVsdGFUaW1lIC0gX2xhc3RQaW5jaEV2ZW50LmRlbHRhVGltZSk7XG5cbiAgICAgICAgICB2YXIgZW5kU2NhbGUgPSBNYXRoLnBvdygyLCB6ICsgdmVsb2NpdHlaICogaW5lcnRpYSAvIDIpO1xuICAgICAgICAgIF9uZXdNYXBTdGF0ZSA9IF9uZXdNYXBTdGF0ZS56b29tKHtcbiAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgc2NhbGU6IGVuZFNjYWxlXG4gICAgICAgICAgfSkuem9vbUVuZCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKSwge30sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgICAgICBhcm91bmQ6IHBvc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFubmluZzogQm9vbGVhbih0aGlzLnRvdWNoWm9vbSksXG4gICAgICAgICAgICBpc1pvb21pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbUVuZCgpLnJvdGF0ZUVuZCgpO1xuICAgICAgdGhpcy5fc3RhdGUuc3RhcnRQaW5jaFJvdGF0aW9uID0gMDtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogZmFsc2UsXG4gICAgICAgIGlzWm9vbWluZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0UGluY2hFdmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZVN0YXJ0KHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25UcmlwbGVQYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVHJpcGxlUGFuKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHBvc1swXSAtPSBldmVudC5kZWx0YVg7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZSh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRyaXBsZVBhbkVuZChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyR0b3VjaFJvdGF0ZSRpbmUgPSB0aGlzLnRvdWNoUm90YXRlLmluZXJ0aWEsXG4gICAgICAgICAgICBpbmVydGlhID0gX3RoaXMkdG91Y2hSb3RhdGUkaW5lID09PSB2b2lkIDAgPyBERUZBVUxUX0lORVJUSUEgOiBfdGhpcyR0b3VjaFJvdGF0ZSRpbmU7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHlZKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSwgcG9zWzFdICs9IGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcblxuICAgICAgICAgIHZhciBfbmV3TWFwU3RhdGUyID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICAgICAgcG9zOiBlbmRQb3NcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlMiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZUVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRvdWJsZVRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIGlzWm9vbU91dCA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtcbiAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgIHNjYWxlOiBpc1pvb21PdXQgPyAwLjUgOiAyXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE9iamVjdC5hc3NpZ24oe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgIGFyb3VuZDogcG9zXG4gICAgICAgIH0pXG4gICAgICB9KSwge1xuICAgICAgICBpc1pvb21pbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbktleURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmtleWJvYXJkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmNLZXkgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcbiAgICAgIHZhciBfdGhpcyRrZXlib2FyZCA9IHRoaXMua2V5Ym9hcmQsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkem9vbVNwID0gX3RoaXMka2V5Ym9hcmQuem9vbVNwZWVkLFxuICAgICAgICAgIHpvb21TcGVlZCA9IF90aGlzJGtleWJvYXJkJHpvb21TcCA9PT0gdm9pZCAwID8gMiA6IF90aGlzJGtleWJvYXJkJHpvb21TcCxcbiAgICAgICAgICBfdGhpcyRrZXlib2FyZCRtb3ZlU3AgPSBfdGhpcyRrZXlib2FyZC5tb3ZlU3BlZWQsXG4gICAgICAgICAgbW92ZVNwZWVkID0gX3RoaXMka2V5Ym9hcmQkbW92ZVNwID09PSB2b2lkIDAgPyAxMDAgOiBfdGhpcyRrZXlib2FyZCRtb3ZlU3AsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkcm90YXRlID0gX3RoaXMka2V5Ym9hcmQucm90YXRlU3BlZWRYLFxuICAgICAgICAgIHJvdGF0ZVNwZWVkWCA9IF90aGlzJGtleWJvYXJkJHJvdGF0ZSA9PT0gdm9pZCAwID8gMTUgOiBfdGhpcyRrZXlib2FyZCRyb3RhdGUsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkcm90YXRlMiA9IF90aGlzJGtleWJvYXJkLnJvdGF0ZVNwZWVkWSxcbiAgICAgICAgICByb3RhdGVTcGVlZFkgPSBfdGhpcyRrZXlib2FyZCRyb3RhdGUyID09PSB2b2lkIDAgPyAxMCA6IF90aGlzJGtleWJvYXJkJHJvdGF0ZTI7XG4gICAgICB2YXIgbWFwU3RhdGVQcm9wcyA9IHRoaXMubWFwU3RhdGVQcm9wcztcbiAgICAgIHZhciBuZXdNYXBTdGF0ZTtcblxuICAgICAgc3dpdGNoIChldmVudC5zcmNFdmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTg5OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKSAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxODc6XG4gICAgICAgICAgaWYgKGZ1bmNLZXkpIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSArIE1hdGgubG9nMih6b29tU3BlZWQpICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSArIE1hdGgubG9nMih6b29tU3BlZWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBiZWFyaW5nOiBtYXBTdGF0ZVByb3BzLmJlYXJpbmcgLSByb3RhdGVTcGVlZFhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbbW92ZVNwZWVkLCAwXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgYmVhcmluZzogbWFwU3RhdGVQcm9wcy5iZWFyaW5nICsgcm90YXRlU3BlZWRYXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICAgIHBvczogWy1tb3ZlU3BlZWQsIDBdLFxuICAgICAgICAgICAgICBzdGFydFBvczogWzAsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBwaXRjaDogbWFwU3RhdGVQcm9wcy5waXRjaCArIHJvdGF0ZVNwZWVkWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgICBwb3M6IFswLCBtb3ZlU3BlZWRdLFxuICAgICAgICAgICAgICBzdGFydFBvczogWzAsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBwaXRjaDogbWFwU3RhdGVQcm9wcy5waXRjaCAtIHJvdGF0ZVNwZWVkWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgICBwb3M6IFswLCAtbW92ZVNwZWVkXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcENvbnRyb2xsZXI7XG59KCk7XG5cbmV4cG9ydCB7IE1hcENvbnRyb2xsZXIgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgU3RhdGljTWFwLCB7IGdldFZpZXdwb3J0IH0gZnJvbSAnLi9zdGF0aWMtbWFwJztcbmltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4uL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTWFwQ29udGV4dCwgeyBNYXBDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IE1hcENvbnRyb2xsZXIgZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBnZXRUZXJyYWluRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdGVycmFpbic7XG52YXIgcHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLnByb3BUeXBlcywge1xuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25FbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUGFuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICB0b3VjaFpvb206IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIHRvdWNoUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBrZXlib2FyZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgb25Ib3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRibENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Db250ZXh0TWVudTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVG91Y2hFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlT3V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25XaGVlbDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvdWNoQWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBldmVudFJlY29nbml6ZXJPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgaW50ZXJhY3RpdmVMYXllcklkczogUHJvcFR5cGVzLmFycmF5LFxuICBnZXRDdXJzb3I6IFByb3BUeXBlcy5mdW5jLFxuICBjb250cm9sbGVyOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNYXBDb250cm9sbGVyKVxufSk7XG5cbnZhciBnZXREZWZhdWx0Q3Vyc29yID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEN1cnNvcihfcmVmKSB7XG4gIHZhciBpc0RyYWdnaW5nID0gX3JlZi5pc0RyYWdnaW5nLFxuICAgICAgaXNIb3ZlcmluZyA9IF9yZWYuaXNIb3ZlcmluZztcbiAgcmV0dXJuIGlzRHJhZ2dpbmcgPyAnZ3JhYmJpbmcnIDogaXNIb3ZlcmluZyA/ICdwb2ludGVyJyA6ICdncmFiJztcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0aWNNYXAuZGVmYXVsdFByb3BzLCBNQVBCT1hfTElNSVRTLCBUcmFuc2l0aW9uTWFuYWdlci5kZWZhdWx0UHJvcHMsIHtcbiAgb25WaWV3U3RhdGVDaGFuZ2U6IG51bGwsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uTmF0aXZlQ2xpY2s6IG51bGwsXG4gIG9uSG92ZXI6IG51bGwsXG4gIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSxcbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb206IHRydWUsXG4gIHRvdWNoUm90YXRlOiBmYWxzZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGV2ZW50UmVjb2duaXplck9wdGlvbnM6IHt9LFxuICBjbGlja1JhZGl1czogMCxcbiAgZ2V0Q3Vyc29yOiBnZXREZWZhdWx0Q3Vyc29yXG59KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmxuZ0xhdCB8fCAhZXZlbnQub2Zmc2V0Q2VudGVyKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIF9ldmVudCRvZmZzZXRDZW50ZXIgPSBldmVudC5vZmZzZXRDZW50ZXIsXG4gICAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgICAgeSA9IF9ldmVudCRvZmZzZXRDZW50ZXIueTtcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIHBvcyA9IFt4LCB5XTtcbiAgZXZlbnQucG9pbnQgPSBwb3M7XG4gIHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG4gIHZhciBsb2NhdGlvbiA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MsIHtcbiAgICB0YXJnZXRaOiB2aWV3cG9ydC5tZXRlck9mZnNldFsyXVxuICB9KTtcbiAgZXZlbnQubG5nTGF0ID0gW2xvY2F0aW9uWzBdLCBsb2NhdGlvblsxXV07XG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0RmVhdHVyZXMocG9zKSB7XG4gIHZhciBtYXAgPSB0aGlzLm1hcDtcblxuICBpZiAoIW1hcCB8fCAhcG9zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcbiAgdmFyIHNpemUgPSB0aGlzLnByb3BzLmNsaWNrUmFkaXVzO1xuXG4gIGlmICh0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHMpIHtcbiAgICBxdWVyeVBhcmFtcy5sYXllcnMgPSB0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHNpemUgPyBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSArIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdIC0gc2l6ZV1dIDogcG9zLCBxdWVyeVBhcmFtcyk7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkV2ZW50KGNhbGxiYWNrTmFtZSwgZXZlbnQpIHtcbiAgdmFyIGZ1bmMgPSB0aGlzLnByb3BzW2NhbGxiYWNrTmFtZV07XG5cbiAgaWYgKGZ1bmMpIHtcbiAgICBmdW5jKG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoU3RhcnQnIDogJ29uTW91c2VEb3duJywgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICBvbkV2ZW50LmNhbGwodGhpcywgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAnb25Ub3VjaEVuZCcgOiAnb25Nb3VzZVVwJywgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoTW92ZScgOiAnb25Nb3VzZU1vdmUnLCBldmVudCk7XG5cbiAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbkhvdmVyID0gX3RoaXMkcHJvcHMub25Ib3ZlcixcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllcklkcyA9IF90aGlzJHByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICBpZiAoaW50ZXJhY3RpdmVMYXllcklkcyB8fCBvbkhvdmVyKSB7XG4gICAgICBmZWF0dXJlcyA9IGdldEZlYXR1cmVzLmNhbGwodGhpcywgZXZlbnQucG9pbnQpO1xuICAgIH1cblxuICAgIHZhciBpc0hvdmVyaW5nID0gQm9vbGVhbihpbnRlcmFjdGl2ZUxheWVySWRzICYmIGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDApO1xuICAgIHZhciBpc0VudGVyaW5nID0gaXNIb3ZlcmluZyAmJiAhdGhpcy5zdGF0ZS5pc0hvdmVyaW5nO1xuICAgIHZhciBpc0V4aXRpbmcgPSAhaXNIb3ZlcmluZyAmJiB0aGlzLnN0YXRlLmlzSG92ZXJpbmc7XG5cbiAgICBpZiAob25Ib3ZlciB8fCBpc0VudGVyaW5nKSB7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICBpZiAob25Ib3Zlcikge1xuICAgICAgICBvbkhvdmVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFbnRlcmluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlRW50ZXInLCBldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlTGVhdmUnLCBldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRW50ZXJpbmcgfHwgaXNFeGl0aW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNIb3ZlcmluZzogaXNIb3ZlcmluZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlckNsaWNrKGV2ZW50KSB7XG4gIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgb25DbGljayA9IF90aGlzJHByb3BzMi5vbkNsaWNrLFxuICAgICAgb25OYXRpdmVDbGljayA9IF90aGlzJHByb3BzMi5vbk5hdGl2ZUNsaWNrLFxuICAgICAgb25EYmxDbGljayA9IF90aGlzJHByb3BzMi5vbkRibENsaWNrLFxuICAgICAgZG91YmxlQ2xpY2tab29tID0gX3RoaXMkcHJvcHMyLmRvdWJsZUNsaWNrWm9vbTtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgaXNEb3VibGVDbGlja0VuYWJsZWQgPSBvbkRibENsaWNrIHx8IGRvdWJsZUNsaWNrWm9vbTtcblxuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdhbnljbGljayc6XG4gICAgICBjYWxsYmFja3MucHVzaChvbk5hdGl2ZUNsaWNrKTtcblxuICAgICAgaWYgKCFpc0RvdWJsZUNsaWNrRW5hYmxlZCkge1xuICAgICAgICBjYWxsYmFja3MucHVzaChvbkNsaWNrKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjbGljayc6XG4gICAgICBpZiAoaXNEb3VibGVDbGlja0VuYWJsZWQpIHtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2gob25DbGljayk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgfVxuXG4gIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5maWx0ZXIoQm9vbGVhbik7XG5cbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGV2ZW50LmZlYXR1cmVzID0gZ2V0RmVhdHVyZXMuY2FsbCh0aGlzLCBldmVudC5wb2ludCk7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICByZXR1cm4gY2IoZXZlbnQpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0TWFwOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5nZXRNYXAsXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5xdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgfTtcbn1cblxudmFyIEludGVyYWN0aXZlTWFwID0gZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgcGFyZW50Q29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBjb250cm9sbGVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzLmNvbnRyb2xsZXIgfHwgbmV3IE1hcENvbnRyb2xsZXIoKTtcbiAgfSwgW10pO1xuICB2YXIgZXZlbnRNYW5hZ2VyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXIobnVsbCwge1xuICAgICAgdG91Y2hBY3Rpb246IHByb3BzLnRvdWNoQWN0aW9uLFxuICAgICAgcmVjb2duaXplck9wdGlvbnM6IHByb3BzLmV2ZW50UmVjb2duaXplck9wdGlvbnNcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgZXZlbnRDYW52YXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzdGF0aWNNYXBSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdmFyIF90aGlzUmVmID0gdXNlUmVmKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgc3RhdGU6IHtcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0aGlzUmVmID0gX3RoaXNSZWYuY3VycmVudDtcbiAgdGhpc1JlZi5wcm9wcyA9IHByb3BzO1xuICB0aGlzUmVmLm1hcCA9IHN0YXRpY01hcFJlZi5jdXJyZW50ICYmIHN0YXRpY01hcFJlZi5jdXJyZW50LmdldE1hcCgpO1xuXG4gIHRoaXNSZWYuc2V0U3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICB0aGlzUmVmLnN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzUmVmLnN0YXRlKSwgbmV3U3RhdGUpO1xuICAgIGV2ZW50Q2FudmFzUmVmLmN1cnJlbnQuc3R5bGUuY3Vyc29yID0gcHJvcHMuZ2V0Q3Vyc29yKHRoaXNSZWYuc3RhdGUpO1xuICB9O1xuXG4gIHZhciBpblJlbmRlciA9IHRydWU7XG4gIHZhciB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZDtcbiAgdmFyIHN0YXRlVXBkYXRlUmVxdWVzdGVkO1xuXG4gIHZhciBoYW5kbGVWaWV3cG9ydENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVZpZXdwb3J0Q2hhbmdlKHZpZXdTdGF0ZSwgaW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld1N0YXRlKSB7XG4gICAgaWYgKGluUmVuZGVyKSB7XG4gICAgICB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCA9IFt2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF90aGlzUmVmJHByb3BzID0gdGhpc1JlZi5wcm9wcyxcbiAgICAgICAgb25WaWV3U3RhdGVDaGFuZ2UgPSBfdGhpc1JlZiRwcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZSA9IF90aGlzUmVmJHByb3BzLm9uVmlld3BvcnRDaGFuZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpZXdTdGF0ZSwgJ3Bvc2l0aW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgZ2V0VGVycmFpbkVsZXZhdGlvbih0aGlzUmVmLm1hcCwgdmlld1N0YXRlKV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob25WaWV3U3RhdGVDaGFuZ2UpIHtcbiAgICAgIG9uVmlld1N0YXRlQ2hhbmdlKHtcbiAgICAgICAgdmlld1N0YXRlOiB2aWV3U3RhdGUsXG4gICAgICAgIGludGVyYWN0aW9uU3RhdGU6IGludGVyYWN0aW9uU3RhdGUsXG4gICAgICAgIG9sZFZpZXdTdGF0ZTogb2xkVmlld1N0YXRlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob25WaWV3cG9ydENoYW5nZSkge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSh2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKTtcbiAgfSwgW10pO1xuICB2YXIgY29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudENvbnRleHQpLCB7fSwge1xuICAgICAgZXZlbnRNYW5hZ2VyOiBldmVudE1hbmFnZXIsXG4gICAgICBjb250YWluZXI6IHBhcmVudENvbnRleHQuY29udGFpbmVyIHx8IGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRcbiAgICB9KTtcbiAgfSwgW3BhcmVudENvbnRleHQsIGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRdKTtcbiAgY29udGV4dC5vblZpZXdwb3J0Q2hhbmdlID0gaGFuZGxlVmlld3BvcnRDaGFuZ2U7XG4gIGNvbnRleHQudmlld3BvcnQgPSBwYXJlbnRDb250ZXh0LnZpZXdwb3J0IHx8IGdldFZpZXdwb3J0KHRoaXNSZWYpO1xuICB0aGlzUmVmLnZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydDtcblxuICB2YXIgaGFuZGxlSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUludGVyYWN0aW9uU3RhdGVDaGFuZ2UoaW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgIHZhciBfaW50ZXJhY3Rpb25TdGF0ZSRpc0QgPSBpbnRlcmFjdGlvblN0YXRlLmlzRHJhZ2dpbmcsXG4gICAgICAgIGlzRHJhZ2dpbmcgPSBfaW50ZXJhY3Rpb25TdGF0ZSRpc0QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2ludGVyYWN0aW9uU3RhdGUkaXNEO1xuXG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXNSZWYuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpc1JlZi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpblJlbmRlcikge1xuICAgICAgc3RhdGVVcGRhdGVSZXF1ZXN0ZWQgPSBpbnRlcmFjdGlvblN0YXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzUmVmLnByb3BzLm9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTtcblxuICAgIGlmIChvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZShpbnRlcmFjdGlvblN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUNvbnRyb2xsZXJPcHRzID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbGxlck9wdHMoKSB7XG4gICAgaWYgKHRoaXNSZWYud2lkdGggJiYgdGhpc1JlZi5oZWlnaHQpIHtcbiAgICAgIGNvbnRyb2xsZXIuc2V0T3B0aW9ucyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpc1JlZi5wcm9wcyksIHRoaXNSZWYucHJvcHMudmlld1N0YXRlKSwge30sIHtcbiAgICAgICAgaXNJbnRlcmFjdGl2ZTogQm9vbGVhbih0aGlzUmVmLnByb3BzLm9uVmlld1N0YXRlQ2hhbmdlIHx8IHRoaXNSZWYucHJvcHMub25WaWV3cG9ydENoYW5nZSksXG4gICAgICAgIG9uVmlld3BvcnRDaGFuZ2U6IGhhbmRsZVZpZXdwb3J0Q2hhbmdlLFxuICAgICAgICBvblN0YXRlQ2hhbmdlOiBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlLFxuICAgICAgICBldmVudE1hbmFnZXI6IGV2ZW50TWFuYWdlcixcbiAgICAgICAgd2lkdGg6IHRoaXNSZWYud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpc1JlZi5oZWlnaHRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHRoaXNSZWYud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzUmVmLmhlaWdodCA9IGhlaWdodDtcbiAgICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICAgIHRoaXNSZWYucHJvcHMub25SZXNpemUoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50TWFuYWdlci5zZXRFbGVtZW50KGV2ZW50Q2FudmFzUmVmLmN1cnJlbnQpO1xuICAgIGV2ZW50TWFuYWdlci5vbih7XG4gICAgICBwb2ludGVyZG93bjogb25Qb2ludGVyRG93bi5iaW5kKHRoaXNSZWYpLFxuICAgICAgcG9pbnRlcm1vdmU6IG9uUG9pbnRlck1vdmUuYmluZCh0aGlzUmVmKSxcbiAgICAgIHBvaW50ZXJ1cDogb25Qb2ludGVyVXAuYmluZCh0aGlzUmVmKSxcbiAgICAgIHBvaW50ZXJsZWF2ZTogb25FdmVudC5iaW5kKHRoaXNSZWYsICdvbk1vdXNlT3V0JyksXG4gICAgICBjbGljazogb25Qb2ludGVyQ2xpY2suYmluZCh0aGlzUmVmKSxcbiAgICAgIGFueWNsaWNrOiBvblBvaW50ZXJDbGljay5iaW5kKHRoaXNSZWYpLFxuICAgICAgZGJsY2xpY2s6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25EYmxDbGljaycpLFxuICAgICAgd2hlZWw6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25XaGVlbCcpLFxuICAgICAgY29udGV4dG1lbnU6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25Db250ZXh0TWVudScpXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmlld3BvcnRVcGRhdGVSZXF1ZXN0ZWQpIHtcbiAgICAgIGhhbmRsZVZpZXdwb3J0Q2hhbmdlLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KHZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkKSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlVXBkYXRlUmVxdWVzdGVkKSB7XG4gICAgICBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlKHN0YXRlVXBkYXRlUmVxdWVzdGVkKTtcbiAgICB9XG4gIH0pO1xuICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBnZXRDdXJzb3IgPSBwcm9wcy5nZXRDdXJzb3I7XG4gIHZhciBldmVudENhbnZhc1N0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sIHN0eWxlKSwge30sIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpc1JlZi5zdGF0ZSlcbiAgICB9KTtcbiAgfSwgW3N0eWxlLCB3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3IsIHRoaXNSZWYuc3RhdGVdKTtcblxuICBpZiAoIXZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkIHx8ICF0aGlzUmVmLl9jaGlsZCkge1xuICAgIHRoaXNSZWYuX2NoaWxkID0gUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IFwiZXZlbnQtY2FudmFzXCIsXG4gICAgICByZWY6IGV2ZW50Q2FudmFzUmVmLFxuICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRpY01hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgc3R5bGU6IG51bGwsXG4gICAgICBvblJlc2l6ZTogb25SZXNpemUsXG4gICAgICByZWY6IHN0YXRpY01hcFJlZlxuICAgIH0pKSkpO1xuICB9XG5cbiAgaW5SZW5kZXIgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXNSZWYuX2NoaWxkO1xufSk7XG5JbnRlcmFjdGl2ZU1hcC5zdXBwb3J0ZWQgPSBTdGF0aWNNYXAuc3VwcG9ydGVkO1xuSW50ZXJhY3RpdmVNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuSW50ZXJhY3RpdmVNYXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3RpdmVNYXA7IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBzb3VyY2VDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlU291cmNlKG1hcCwgaWQsIHByb3BzKSB7XG4gIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIHByb3BzKTtcblxuICAgIGRlbGV0ZSBvcHRpb25zLmlkO1xuICAgIGRlbGV0ZSBvcHRpb25zLmNoaWxkcmVuO1xuICAgIG1hcC5hZGRTb3VyY2UoaWQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBtYXAuZ2V0U291cmNlKGlkKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnc291cmNlIGlkIGNoYW5nZWQnKTtcbiAgYXNzZXJ0KHByb3BzLnR5cGUgPT09IHByZXZQcm9wcy50eXBlLCAnc291cmNlIHR5cGUgY2hhbmdlZCcpO1xuICB2YXIgY2hhbmdlZEtleSA9ICcnO1xuICB2YXIgY2hhbmdlZEtleUNvdW50ID0gMDtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2lkJyAmJiAhZGVlcEVxdWFsKHByZXZQcm9wc1trZXldLCBwcm9wc1trZXldKSkge1xuICAgICAgY2hhbmdlZEtleSA9IGtleTtcbiAgICAgIGNoYW5nZWRLZXlDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2hhbmdlZEtleUNvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIGlmICh0eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICBzb3VyY2Uuc2V0RGF0YShwcm9wcy5kYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgc291cmNlLnVwZGF0ZUltYWdlKHtcbiAgICAgIHVybDogcHJvcHMudXJsLFxuICAgICAgY29vcmRpbmF0ZXM6IHByb3BzLmNvb3JkaW5hdGVzXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoKHR5cGUgPT09ICdjYW52YXMnIHx8IHR5cGUgPT09ICd2aWRlbycpICYmIGNoYW5nZWRLZXlDb3VudCA9PT0gMSAmJiBjaGFuZ2VkS2V5ID09PSAnY29vcmRpbmF0ZXMnKSB7XG4gICAgc291cmNlLnNldENvb3JkaW5hdGVzKHByb3BzLmNvb3JkaW5hdGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndmVjdG9yJyAmJiBzb3VyY2Uuc2V0VXJsKSB7XG4gICAgc3dpdGNoIChjaGFuZ2VkS2V5KSB7XG4gICAgICBjYXNlICd1cmwnOlxuICAgICAgICBzb3VyY2Uuc2V0VXJsKHByb3BzLnVybCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aWxlcyc6XG4gICAgICAgIHNvdXJjZS5zZXRUaWxlcyhwcm9wcy50aWxlcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gdXBkYXRlIDxTb3VyY2U+IHByb3A6IFwiLmNvbmNhdChjaGFuZ2VkS2V5KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gU291cmNlKHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIHByb3BzUmVmID0gdXNlUmVmKHtcbiAgICBpZDogcHJvcHMuaWQsXG4gICAgdHlwZTogcHJvcHMudHlwZVxuICB9KTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNldFN0eWxlTG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgaWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHMuaWQgfHwgXCJqc3gtc291cmNlLVwiLmNvbmNhdChzb3VyY2VDb3VudGVyKyspO1xuICB9LCBbXSk7XG4gIHZhciBtYXAgPSBjb250ZXh0Lm1hcDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwKSB7XG4gICAgICB2YXIgZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0eWxlTG9hZGVkKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb24gKyAxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG1hcC5vbignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFwLm9mZignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQgJiYgbWFwLmdldFNvdXJjZShpZCkpIHtcbiAgICAgICAgICAgIG1hcC5yZW1vdmVTb3VyY2UoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFttYXAsIGlkXSk7XG4gIHZhciBzb3VyY2UgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRTb3VyY2UoaWQpO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJvcHNSZWYuY3VycmVudCk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gY3JlYXRlU291cmNlKG1hcCwgaWQsIHByb3BzKTtcbiAgfVxuXG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIHNvdXJjZSAmJiBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZCAmJiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHNvdXJjZTogaWRcbiAgICB9KTtcbiAgfSkgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYSB8fCAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMCwgX2FLZXlzID0gYUtleXM7IF9pIDwgX2FLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGtleSA9IF9hS2V5c1tfaV07XG5cbiAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBMQVlFUl9UWVBFUyA9IFsnZmlsbCcsICdsaW5lJywgJ3N5bWJvbCcsICdjaXJjbGUnLCAnZmlsbC1leHRydXNpb24nLCAncmFzdGVyJywgJ2JhY2tncm91bmQnLCAnaGVhdG1hcCcsICdoaWxsc2hhZGUnLCAnc2t5J107XG52YXIgcHJvcFR5cGVzID0ge1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoTEFZRVJfVFlQRVMpLmlzUmVxdWlyZWQsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzb3VyY2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJlZm9yZUlkOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5mdW5jdGlvbiBkaWZmTGF5ZXJTdHlsZXMobWFwLCBpZCwgcHJvcHMsIHByZXZQcm9wcykge1xuICB2YXIgX3Byb3BzJGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICAgIGxheW91dCA9IF9wcm9wcyRsYXlvdXQgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJGxheW91dCxcbiAgICAgIF9wcm9wcyRwYWludCA9IHByb3BzLnBhaW50LFxuICAgICAgcGFpbnQgPSBfcHJvcHMkcGFpbnQgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHBhaW50LFxuICAgICAgZmlsdGVyID0gcHJvcHMuZmlsdGVyLFxuICAgICAgbWluem9vbSA9IHByb3BzLm1pbnpvb20sXG4gICAgICBtYXh6b29tID0gcHJvcHMubWF4em9vbSxcbiAgICAgIGJlZm9yZUlkID0gcHJvcHMuYmVmb3JlSWQsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJsYXlvdXRcIiwgXCJwYWludFwiLCBcImZpbHRlclwiLCBcIm1pbnpvb21cIiwgXCJtYXh6b29tXCIsIFwiYmVmb3JlSWRcIl0pO1xuXG4gIGlmIChiZWZvcmVJZCAhPT0gcHJldlByb3BzLmJlZm9yZUlkKSB7XG4gICAgbWFwLm1vdmVMYXllcihpZCwgYmVmb3JlSWQpO1xuICB9XG5cbiAgaWYgKGxheW91dCAhPT0gcHJldlByb3BzLmxheW91dCkge1xuICAgIHZhciBwcmV2TGF5b3V0ID0gcHJldlByb3BzLmxheW91dCB8fCB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBsYXlvdXQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGxheW91dFtrZXldLCBwcmV2TGF5b3V0W2tleV0pKSB7XG4gICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShpZCwga2V5LCBsYXlvdXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2tleSBpbiBwcmV2TGF5b3V0KSB7XG4gICAgICBpZiAoIWxheW91dC5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoaWQsIF9rZXksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhaW50ICE9PSBwcmV2UHJvcHMucGFpbnQpIHtcbiAgICB2YXIgcHJldlBhaW50ID0gcHJldlByb3BzLnBhaW50IHx8IHt9O1xuXG4gICAgZm9yICh2YXIgX2tleTIgaW4gcGFpbnQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKHBhaW50W19rZXkyXSwgcHJldlBhaW50W19rZXkyXSkpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkyLCBwYWludFtfa2V5Ml0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rZXkzIGluIHByZXZQYWludCkge1xuICAgICAgaWYgKCFwYWludC5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkzLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZGVlcEVxdWFsKGZpbHRlciwgcHJldlByb3BzLmZpbHRlcikpIHtcbiAgICBtYXAuc2V0RmlsdGVyKGlkLCBmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKG1pbnpvb20gIT09IHByZXZQcm9wcy5taW56b29tIHx8IG1heHpvb20gIT09IHByZXZQcm9wcy5tYXh6b29tKSB7XG4gICAgbWFwLnNldExheWVyWm9vbVJhbmdlKGlkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgfVxuXG4gIGZvciAodmFyIF9rZXk0IGluIG90aGVyUHJvcHMpIHtcbiAgICBpZiAoIWRlZXBFcXVhbChvdGhlclByb3BzW19rZXk0XSwgcHJldlByb3BzW19rZXk0XSkpIHtcbiAgICAgIG1hcC5zZXRMYXllclByb3BlcnR5KGlkLCBfa2V5NCwgb3RoZXJQcm9wc1tfa2V5NF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMYXllcihtYXAsIGlkLCBwcm9wcykge1xuICBpZiAobWFwLnN0eWxlICYmIG1hcC5zdHlsZS5fbG9hZGVkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIGlkOiBpZFxuICAgIH0pO1xuXG4gICAgZGVsZXRlIG9wdGlvbnMuYmVmb3JlSWQ7XG4gICAgbWFwLmFkZExheWVyKG9wdGlvbnMsIHByb3BzLmJlZm9yZUlkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXllcihtYXAsIGlkLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnbGF5ZXIgaWQgY2hhbmdlZCcpO1xuICBhc3NlcnQocHJvcHMudHlwZSA9PT0gcHJldlByb3BzLnR5cGUsICdsYXllciB0eXBlIGNoYW5nZWQnKTtcblxuICB0cnkge1xuICAgIGRpZmZMYXllclN0eWxlcyhtYXAsIGlkLCBwcm9wcywgcHJldlByb3BzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICB9XG59XG5cbnZhciBsYXllckNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBMYXllcihwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBwcm9wc1JlZiA9IHVzZVJlZih7XG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIHR5cGU6IHByb3BzLnR5cGVcbiAgfSk7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKDApLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBzZXRTdHlsZUxvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzLmlkIHx8IFwianN4LWxheWVyLVwiLmNvbmNhdChsYXllckNvdW50ZXIrKyk7XG4gIH0sIFtdKTtcbiAgdmFyIG1hcCA9IGNvbnRleHQubWFwO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXApIHtcbiAgICAgIHZhciBmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gc2V0U3R5bGVMb2FkZWQoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbWFwLm9uKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAub2ZmKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG5cbiAgICAgICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCkge1xuICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW21hcF0pO1xuICB2YXIgbGF5ZXIgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRMYXllcihpZCk7XG5cbiAgaWYgKGxheWVyKSB7XG4gICAgdXBkYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMsIHByb3BzUmVmLmN1cnJlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZUxheWVyKG1hcCwgaWQsIHByb3BzKTtcbiAgfVxuXG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIG51bGw7XG59XG5cbkxheWVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbmV4cG9ydCBkZWZhdWx0IExheWVyOyIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hcENvbnRleHQgZnJvbSAnLi9tYXAtY29udGV4dCc7XG5leHBvcnQgdmFyIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogdHJ1ZSxcbiAgY2FwdHVyZUNsaWNrOiB0cnVlLFxuICBjYXB0dXJlRG91YmxlQ2xpY2s6IHRydWUsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5leHBvcnQgdmFyIG1hcENvbnRyb2xQcm9wVHlwZXMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0dXJlRHJhZzogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVEb3VibGVDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIG9uTW91bnQodGhpc1JlZikge1xuICB2YXIgcmVmID0gdGhpc1JlZi5jb250YWluZXJSZWYuY3VycmVudDtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG5cbiAgaWYgKCFyZWYgfHwgIWV2ZW50TWFuYWdlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlU2Nyb2xsKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm9uU2Nyb2xsKSB7XG4gICAgICAgIHByb3BzLm9uU2Nyb2xsKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYW5zdGFydDogZnVuY3Rpb24gcGFuc3RhcnQoZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuXG4gICAgICBpZiAocHJvcHMuY2FwdHVyZURyYWcpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25EcmFnU3RhcnQpIHtcbiAgICAgICAgcHJvcHMub25EcmFnU3RhcnQoZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueWNsaWNrOiBmdW5jdGlvbiBhbnljbGljayhldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICBwcm9wcy5vbkNsaWNrKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuXG4gICAgICBpZiAocHJvcHMuY2FwdHVyZUNsaWNrKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgcHJvcHMub25DbGljayhldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uIGRibGNsaWNrKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcblxuICAgICAgaWYgKHByb3BzLmNhcHR1cmVEb3VibGVDbGljaykge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5vbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgIHByb3BzLm9uRG91YmxlQ2xpY2soZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiBwb2ludGVybW92ZShldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlUG9pbnRlck1vdmUpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25Qb2ludGVyTW92ZSkge1xuICAgICAgICBwcm9wcy5vblBvaW50ZXJNb3ZlKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBldmVudE1hbmFnZXIud2F0Y2goZXZlbnRzLCByZWYpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50TWFuYWdlci5vZmYoZXZlbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTWFwQ29udHJvbCgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdGhpc1JlZiA9IHVzZVJlZih7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHN0YXRlOiB7fSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmXG4gIH0pO1xuXG4gIHZhciB0aGlzUmVmID0gX3RoaXNSZWYuY3VycmVudDtcbiAgdGhpc1JlZi5wcm9wcyA9IHByb3BzO1xuICB0aGlzUmVmLmNvbnRleHQgPSBjb250ZXh0O1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvbk1vdW50KHRoaXNSZWYpO1xuICB9LCBbY29udGV4dC5ldmVudE1hbmFnZXJdKTtcbiAgcmV0dXJuIHRoaXNSZWY7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQdXJlQ29tcG9uZW50LCBjcmVhdGVSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuXG5mdW5jdGlvbiBDb250cm9sKHByb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHByb3BzLmluc3RhbmNlO1xuXG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgaW5zdGFuY2UuX2NvbnRleHQgPSBjb250ZXh0O1xuICBpbnN0YW5jZS5fY29udGFpbmVyUmVmID0gY29udGFpbmVyUmVmO1xuICByZXR1cm4gaW5zdGFuY2UuX3JlbmRlcigpO1xufVxuXG52YXIgQmFzZUNvbnRyb2wgPSBmdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJhc2VDb250cm9sLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCYXNlQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gQmFzZUNvbnRyb2woKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDb250cm9sKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2NvbnRleHRcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jb250YWluZXJSZWZcIiwgY3JlYXRlUmVmKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vblNjcm9sbFwiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uRHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25EYmxDbGlja1wiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uQ2xpY2tcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vblBvaW50ZXJNb3ZlXCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ29udHJvbCwgW3tcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcmVuZGVyKCkgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sLCBfZXh0ZW5kcyh7XG4gICAgICAgIGluc3RhbmNlOiB0aGlzXG4gICAgICB9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIG9uU2Nyb2xsOiB0aGlzLl9vblNjcm9sbCxcbiAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRibENsaWNrOiB0aGlzLl9vbkRibENsaWNrLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDb250cm9sO1xufShQdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcInByb3BUeXBlc1wiLCBtYXBDb250cm9sUHJvcFR5cGVzKTtcblxuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcImRlZmF1bHRQcm9wc1wiLCBtYXBDb250cm9sRGVmYXVsdFByb3BzKTtcblxuZXhwb3J0IHsgQmFzZUNvbnRyb2wgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB2YXIgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xQcm9wVHlwZXMsIHtcbiAgZHJhZ2dhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25EcmFnOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvZmZzZXRMZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXJcbn0pO1xuZXhwb3J0IHZhciBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuICBvZmZzZXRMZWZ0OiAwLFxuICBvZmZzZXRUb3A6IDBcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCkge1xuICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICAgIHggPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLngsXG4gICAgICB5ID0gX2V2ZW50JG9mZnNldENlbnRlci55O1xuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lcikge1xuICB2YXIgX2V2ZW50JGNlbnRlciA9IGV2ZW50LmNlbnRlcixcbiAgICAgIHggPSBfZXZlbnQkY2VudGVyLngsXG4gICAgICB5ID0gX2V2ZW50JGNlbnRlci55O1xuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gW3JlY3QubGVmdCAtIHgsIHJlY3QudG9wIC0geV07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ0xuZ0xhdChkcmFnUG9zLCBkcmFnT2Zmc2V0LCBwcm9wcywgY29udGV4dCkge1xuICB2YXIgeCA9IGRyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdIC0gcHJvcHMub2Zmc2V0TGVmdDtcbiAgdmFyIHkgPSBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXSAtIHByb3BzLm9mZnNldFRvcDtcbiAgcmV0dXJuIGNvbnRleHQudmlld3BvcnQudW5wcm9qZWN0KFt4LCB5XSk7XG59XG5cbmZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50LCBfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBjYWxsYmFja3MgPSBfcmVmLmNhbGxiYWNrcyxcbiAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfcmVmLmNvbnRhaW5lclJlZjtcbiAgdmFyIGRyYWdnYWJsZSA9IHByb3BzLmRyYWdnYWJsZTtcblxuICBpZiAoIWRyYWdnYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IGdldERyYWdFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgdmFyIGRyYWdPZmZzZXQgPSBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhkcmFnUG9zKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChkcmFnT2Zmc2V0KTtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZ1N0YXJ0ICYmIGRyYWdPZmZzZXQpIHtcbiAgICB2YXIgY2FsbGJhY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICBjYWxsYmFja0V2ZW50LmxuZ0xhdCA9IGdldERyYWdMbmdMYXQoZHJhZ1BvcywgZHJhZ09mZnNldCwgcHJvcHMsIGNvbnRleHQpO1xuICAgIGNhbGxiYWNrcy5vbkRyYWdTdGFydChjYWxsYmFja0V2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkRyYWcoZXZlbnQsIF9yZWYyKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgY2FsbGJhY2tzID0gX3JlZjIuY2FsbGJhY2tzLFxuICAgICAgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0O1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdmFyIGRyYWdQb3MgPSBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCk7XG4gIHN0YXRlLnNldERyYWdQb3MoZHJhZ1Bvcyk7XG4gIHZhciBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZyAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7XG4gICAgY2FsbGJhY2tFdmVudC5sbmdMYXQgPSBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KTtcbiAgICBjYWxsYmFja3Mub25EcmFnKGNhbGxiYWNrRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRHJhZ0VuZChldmVudCwgX3JlZjMpIHtcbiAgdmFyIHByb3BzID0gX3JlZjMucHJvcHMsXG4gICAgICBjYWxsYmFja3MgPSBfcmVmMy5jYWxsYmFja3MsXG4gICAgICBzdGF0ZSA9IF9yZWYzLnN0YXRlLFxuICAgICAgY29udGV4dCA9IF9yZWYzLmNvbnRleHQ7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3MsXG4gICAgICBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhudWxsKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChudWxsKTtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZ0VuZCAmJiBkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICB2YXIgY2FsbGJhY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICBjYWxsYmFja0V2ZW50LmxuZ0xhdCA9IGdldERyYWdMbmdMYXQoZHJhZ1BvcywgZHJhZ09mZnNldCwgcHJvcHMsIGNvbnRleHQpO1xuICAgIGNhbGxiYWNrcy5vbkRyYWdFbmQoY2FsbGJhY2tFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25EcmFnQ2FuY2VsKGV2ZW50LCBfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHN0YXRlLnNldERyYWdQb3MobnVsbCk7XG4gIHN0YXRlLnNldERyYWdPZmZzZXQobnVsbCk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKHRoaXNSZWYpIHtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG5cbiAgaWYgKCFldmVudE1hbmFnZXIgfHwgIXRoaXNSZWYuc3RhdGUuZHJhZ1Bvcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIHBhbm1vdmU6IGZ1bmN0aW9uIHBhbm1vdmUoZXZ0KSB7XG4gICAgICByZXR1cm4gb25EcmFnKGV2dCwgdGhpc1JlZik7XG4gICAgfSxcbiAgICBwYW5lbmQ6IGZ1bmN0aW9uIHBhbmVuZChldnQpIHtcbiAgICAgIHJldHVybiBvbkRyYWdFbmQoZXZ0LCB0aGlzUmVmKTtcbiAgICB9LFxuICAgIHBhbmNhbmNlbDogZnVuY3Rpb24gcGFuY2FuY2VsKGV2dCkge1xuICAgICAgcmV0dXJuIG9uRHJhZ0NhbmNlbChldnQsIHRoaXNSZWYpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNYW5hZ2VyLndhdGNoKGV2ZW50cyk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRNYW5hZ2VyLm9mZihldmVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VEcmFnZ2FibGVDb250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgZHJhZ1BvcyA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXREcmFnUG9zID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgICAgZHJhZ09mZnNldCA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXREcmFnT2Zmc2V0ID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgdGhpc1JlZiA9IHVzZU1hcENvbnRyb2woX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0XG4gIH0pKTtcbiAgdGhpc1JlZi5jYWxsYmFja3MgPSBwcm9wcztcbiAgdGhpc1JlZi5zdGF0ZS5kcmFnUG9zID0gZHJhZ1BvcztcbiAgdGhpc1JlZi5zdGF0ZS5zZXREcmFnUG9zID0gc2V0RHJhZ1BvcztcbiAgdGhpc1JlZi5zdGF0ZS5kcmFnT2Zmc2V0ID0gZHJhZ09mZnNldDtcbiAgdGhpc1JlZi5zdGF0ZS5zZXREcmFnT2Zmc2V0ID0gc2V0RHJhZ09mZnNldDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJFdmVudHModGhpc1JlZik7XG4gIH0sIFt0aGlzUmVmLmNvbnRleHQuZXZlbnRNYW5hZ2VyLCBCb29sZWFuKGRyYWdQb3MpXSk7XG4gIHJldHVybiB0aGlzUmVmO1xufSIsInZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbmV4cG9ydCB2YXIgY3Jpc3BQaXhlbCA9IGZ1bmN0aW9uIGNyaXNwUGl4ZWwoc2l6ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChzaXplICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xufTtcbmV4cG9ydCB2YXIgY3Jpc3BQZXJjZW50YWdlID0gZnVuY3Rpb24gY3Jpc3BQZXJjZW50YWdlKGVsLCBwZXJjZW50YWdlKSB7XG4gIHZhciBkaW1lbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd4JztcblxuICBpZiAoZWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcGVyY2VudGFnZTtcbiAgfVxuXG4gIHZhciBvcmlnU2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ3gnID8gZWwub2Zmc2V0V2lkdGggOiBlbC5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBjcmlzcFBpeGVsKHBlcmNlbnRhZ2UgLyAxMDAgKiBvcmlnU2l6ZSkgLyBvcmlnU2l6ZSAqIDEwMDtcbn07IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZURyYWdnYWJsZUNvbnRyb2wsIHsgZHJhZ2dhYmxlQ29udHJvbERlZmF1bHRQcm9wcywgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vZHJhZ2dhYmxlLWNvbnRyb2wnO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJydcbn0pO1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuICB2YXIgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUgPSBwcm9wcy5sYXRpdHVkZSxcbiAgICAgIG9mZnNldExlZnQgPSBwcm9wcy5vZmZzZXRMZWZ0LFxuICAgICAgb2Zmc2V0VG9wID0gcHJvcHMub2Zmc2V0VG9wO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3MsXG4gICAgICBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICAgIG1hcCA9IGNvbnRleHQubWFwO1xuXG4gIGlmIChkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICByZXR1cm4gW2RyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdLCBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXV07XG4gIH1cblxuICB2YXIgYWx0aXR1ZGUgPSBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwge1xuICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBsYXRpdHVkZVxuICB9KTtcblxuICB2YXIgX3ZpZXdwb3J0JHByb2plY3QgPSB2aWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZV0pLFxuICAgICAgX3ZpZXdwb3J0JHByb2plY3QyID0gX3NsaWNlZFRvQXJyYXkoX3ZpZXdwb3J0JHByb2plY3QsIDIpLFxuICAgICAgeCA9IF92aWV3cG9ydCRwcm9qZWN0MlswXSxcbiAgICAgIHkgPSBfdmlld3BvcnQkcHJvamVjdDJbMV07XG5cbiAgeCArPSBvZmZzZXRMZWZ0O1xuICB5ICs9IG9mZnNldFRvcDtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gTWFya2VyKHByb3BzKSB7XG4gIHZhciB0aGlzUmVmID0gdXNlRHJhZ2dhYmxlQ29udHJvbChwcm9wcyk7XG4gIHZhciBzdGF0ZSA9IHRoaXNSZWYuc3RhdGUsXG4gICAgICBjb250YWluZXJSZWYgPSB0aGlzUmVmLmNvbnRhaW5lclJlZjtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBkcmFnZ2FibGUgPSBwcm9wcy5kcmFnZ2FibGU7XG4gIHZhciBkcmFnUG9zID0gc3RhdGUuZHJhZ1BvcztcblxuICB2YXIgX2dldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpc1JlZiksXG4gICAgICBfZ2V0UG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2dldFBvc2l0aW9uLCAyKSxcbiAgICAgIHggPSBfZ2V0UG9zaXRpb24yWzBdLFxuICAgICAgeSA9IF9nZXRQb3NpdGlvbjJbMV07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjcmlzcFBpeGVsKHgpLCBcInB4LCBcIikuY29uY2F0KGNyaXNwUGl4ZWwoeSksIFwicHgpXCIpO1xuICB2YXIgY3Vyc29yID0gZHJhZ2dhYmxlID8gZHJhZ1BvcyA/ICdncmFiYmluZycgOiAnZ3JhYicgOiAnYXV0byc7XG4gIHZhciBjb250cm9sID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBjdXJzb3I6IGN1cnNvclxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLW1hcmtlciBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICAgIHJlZjogdGhpc1JlZi5jb250YWluZXJSZWYsXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH0sIFtjaGlsZHJlbiwgY2xhc3NOYW1lXSk7XG4gIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcblxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBjb250YWluZXIuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5cbk1hcmtlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKE1hcmtlcik7IiwiZXhwb3J0IHZhciBBTkNIT1JfUE9TSVRJT04gPSB7XG4gIHRvcDoge1xuICAgIHg6IDAuNSxcbiAgICB5OiAwXG4gIH0sXG4gICd0b3AtbGVmdCc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgJ3RvcC1yaWdodCc6IHtcbiAgICB4OiAxLFxuICAgIHk6IDBcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgeDogMC41LFxuICAgIHk6IDFcbiAgfSxcbiAgJ2JvdHRvbS1sZWZ0Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMVxuICB9LFxuICAnYm90dG9tLXJpZ2h0Jzoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9LFxuICBsZWZ0OiB7XG4gICAgeDogMCxcbiAgICB5OiAwLjVcbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICB4OiAxLFxuICAgIHk6IDAuNVxuICB9XG59O1xudmFyIEFOQ0hPUl9UWVBFUyA9IE9iamVjdC5rZXlzKEFOQ0hPUl9QT1NJVElPTik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RHluYW1pY1Bvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBzZWxmV2lkdGggPSBfcmVmLnNlbGZXaWR0aCxcbiAgICAgIHNlbGZIZWlnaHQgPSBfcmVmLnNlbGZIZWlnaHQsXG4gICAgICBhbmNob3IgPSBfcmVmLmFuY2hvcixcbiAgICAgIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBhZGRpbmc7XG4gIHZhciBfQU5DSE9SX1BPU0lUSU9OJGFuY2ggPSBBTkNIT1JfUE9TSVRJT05bYW5jaG9yXSxcbiAgICAgIGFuY2hvclggPSBfQU5DSE9SX1BPU0lUSU9OJGFuY2gueCxcbiAgICAgIGFuY2hvclkgPSBfQU5DSE9SX1BPU0lUSU9OJGFuY2gueTtcbiAgdmFyIHRvcCA9IHkgLSBhbmNob3JZICogc2VsZkhlaWdodDtcbiAgdmFyIGJvdHRvbSA9IHRvcCArIHNlbGZIZWlnaHQ7XG4gIHZhciBjdXRvZmZZID0gTWF0aC5tYXgoMCwgcGFkZGluZyAtIHRvcCkgKyBNYXRoLm1heCgwLCBib3R0b20gLSBoZWlnaHQgKyBwYWRkaW5nKTtcblxuICBpZiAoY3V0b2ZmWSA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclkgPSBhbmNob3JZO1xuICAgIHZhciBtaW5DdXRvZmYgPSBjdXRvZmZZO1xuXG4gICAgZm9yIChhbmNob3JZID0gMDsgYW5jaG9yWSA8PSAxOyBhbmNob3JZICs9IDAuNSkge1xuICAgICAgdG9wID0geSAtIGFuY2hvclkgKiBzZWxmSGVpZ2h0O1xuICAgICAgYm90dG9tID0gdG9wICsgc2VsZkhlaWdodDtcbiAgICAgIGN1dG9mZlkgPSBNYXRoLm1heCgwLCBwYWRkaW5nIC0gdG9wKSArIE1hdGgubWF4KDAsIGJvdHRvbSAtIGhlaWdodCArIHBhZGRpbmcpO1xuXG4gICAgICBpZiAoY3V0b2ZmWSA8IG1pbkN1dG9mZikge1xuICAgICAgICBtaW5DdXRvZmYgPSBjdXRvZmZZO1xuICAgICAgICBiZXN0QW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jaG9yWSA9IGJlc3RBbmNob3JZO1xuICB9XG5cbiAgdmFyIHhTdGVwID0gMC41O1xuXG4gIGlmIChhbmNob3JZID09PSAwLjUpIHtcbiAgICBhbmNob3JYID0gTWF0aC5mbG9vcihhbmNob3JYKTtcbiAgICB4U3RlcCA9IDE7XG4gIH1cblxuICB2YXIgbGVmdCA9IHggLSBhbmNob3JYICogc2VsZldpZHRoO1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgc2VsZldpZHRoO1xuICB2YXIgY3V0b2ZmWCA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSBsZWZ0KSArIE1hdGgubWF4KDAsIHJpZ2h0IC0gd2lkdGggKyBwYWRkaW5nKTtcblxuICBpZiAoY3V0b2ZmWCA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclggPSBhbmNob3JYO1xuICAgIHZhciBfbWluQ3V0b2ZmID0gY3V0b2ZmWDtcblxuICAgIGZvciAoYW5jaG9yWCA9IDA7IGFuY2hvclggPD0gMTsgYW5jaG9yWCArPSB4U3RlcCkge1xuICAgICAgbGVmdCA9IHggLSBhbmNob3JYICogc2VsZldpZHRoO1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgc2VsZldpZHRoO1xuICAgICAgY3V0b2ZmWCA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSBsZWZ0KSArIE1hdGgubWF4KDAsIHJpZ2h0IC0gd2lkdGggKyBwYWRkaW5nKTtcblxuICAgICAgaWYgKGN1dG9mZlggPCBfbWluQ3V0b2ZmKSB7XG4gICAgICAgIF9taW5DdXRvZmYgPSBjdXRvZmZYO1xuICAgICAgICBiZXN0QW5jaG9yWCA9IGFuY2hvclg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jaG9yWCA9IGJlc3RBbmNob3JYO1xuICB9XG5cbiAgcmV0dXJuIEFOQ0hPUl9UWVBFUy5maW5kKGZ1bmN0aW9uIChwb3NpdGlvblR5cGUpIHtcbiAgICB2YXIgYW5jaG9yUG9zaXRpb24gPSBBTkNIT1JfUE9TSVRJT05bcG9zaXRpb25UeXBlXTtcbiAgICByZXR1cm4gYW5jaG9yUG9zaXRpb24ueCA9PT0gYW5jaG9yWCAmJiBhbmNob3JQb3NpdGlvbi55ID09PSBhbmNob3JZO1xuICB9KSB8fCBhbmNob3I7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1Bvc2l0aW9uLCBBTkNIT1JfUE9TSVRJT04gfSBmcm9tICcuLi91dGlscy9keW5hbWljLXBvc2l0aW9uJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbmltcG9ydCB7IGNyaXNwUGVyY2VudGFnZSwgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG9mZnNldExlZnQ6IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdGlwU2l6ZTogMTAsXG4gIGFuY2hvcjogJ2JvdHRvbScsXG4gIGR5bmFtaWNQb3NpdGlvbjogdHJ1ZSxcbiAgc29ydEJ5RGVwdGg6IGZhbHNlLFxuICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlKCkge31cbn0pO1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgeCA9IF9yZWYyWzBdLFxuICAgICAgeSA9IF9yZWYyWzFdO1xuXG4gIHZhciBhbmNob3IgPSBwcm9wcy5hbmNob3IsXG4gICAgICBkeW5hbWljUG9zaXRpb24gPSBwcm9wcy5keW5hbWljUG9zaXRpb24sXG4gICAgICB0aXBTaXplID0gcHJvcHMudGlwU2l6ZTtcblxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZHluYW1pY1Bvc2l0aW9uID8gZ2V0RHluYW1pY1Bvc2l0aW9uKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBwYWRkaW5nOiB0aXBTaXplLFxuICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICBzZWxmV2lkdGg6IGVsLmNsaWVudFdpZHRoLFxuICAgICAgc2VsZkhlaWdodDogZWwuY2xpZW50SGVpZ2h0XG4gICAgfSkgOiBhbmNob3I7XG4gIH1cblxuICByZXR1cm4gYW5jaG9yO1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmMywgcG9zaXRpb25UeXBlKSB7XG4gIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAzKSxcbiAgICAgIHggPSBfcmVmNFswXSxcbiAgICAgIHkgPSBfcmVmNFsxXSxcbiAgICAgIHogPSBfcmVmNFsyXTtcblxuICB2YXIgb2Zmc2V0TGVmdCA9IHByb3BzLm9mZnNldExlZnQsXG4gICAgICBvZmZzZXRUb3AgPSBwcm9wcy5vZmZzZXRUb3AsXG4gICAgICBzb3J0QnlEZXB0aCA9IHByb3BzLnNvcnRCeURlcHRoO1xuICB2YXIgYW5jaG9yUG9zaXRpb24gPSBBTkNIT1JfUE9TSVRJT05bcG9zaXRpb25UeXBlXTtcbiAgdmFyIGxlZnQgPSB4ICsgb2Zmc2V0TGVmdDtcbiAgdmFyIHRvcCA9IHkgKyBvZmZzZXRUb3A7XG4gIHZhciB4UGVyY2VudGFnZSA9IGNyaXNwUGVyY2VudGFnZShlbCwgLWFuY2hvclBvc2l0aW9uLnggKiAxMDApO1xuICB2YXIgeVBlcmNlbnRhZ2UgPSBjcmlzcFBlcmNlbnRhZ2UoZWwsIC1hbmNob3JQb3NpdGlvbi55ICogMTAwLCAneScpO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdHJhbnNmb3JtOiBcIlxcbiAgICAgIHRyYW5zbGF0ZShcIi5jb25jYXQoeFBlcmNlbnRhZ2UsIFwiJSwgXCIpLmNvbmNhdCh5UGVyY2VudGFnZSwgXCIlKVxcbiAgICAgIHRyYW5zbGF0ZShcIikuY29uY2F0KGNyaXNwUGl4ZWwobGVmdCksIFwicHgsIFwiKS5jb25jYXQoY3Jpc3BQaXhlbCh0b3ApLCBcInB4KVxcbiAgICBcIiksXG4gICAgZGlzcGxheTogdW5kZWZpbmVkLFxuICAgIHpJbmRleDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFzb3J0QnlEZXB0aCkge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGlmICh6ID4gMSB8fCB6IDwgLTEgfHwgeCA8IDAgfHwgeCA+IHZpZXdwb3J0LndpZHRoIHx8IHkgPCAwIHx8IHkgPiB2aWV3cG9ydC5oZWlnaHQpIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnpJbmRleCA9IE1hdGguZmxvb3IoKDEgLSB6KSAvIDIgKiAxMDAwMDApO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGV2dCwgX3JlZjUpIHtcbiAgdmFyIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICBjb250ZXh0ID0gX3JlZjUuY29udGV4dDtcblxuICBpZiAocHJvcHMuY2xvc2VPbkNsaWNrIHx8IGV2dC50YXJnZXQuY2xhc3NOYW1lID09PSAnbWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uJykge1xuICAgIHByb3BzLm9uQ2xvc2UoKTtcblxuICAgIGlmIChjb250ZXh0LmV2ZW50TWFuYWdlcikge1xuICAgICAgY29udGV4dC5ldmVudE1hbmFnZXIub25jZSgnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sIGV2dC50YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBQb3B1cChwcm9wcykge1xuICB2YXIgY29udGVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHRoaXNSZWYgPSB1c2VNYXBDb250cm9sKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgIG9uQ2xpY2s6IG9uQ2xpY2tcbiAgfSkpO1xuICB2YXIgY29udGV4dCA9IHRoaXNSZWYuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNldExvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gIH0sIFtjb250ZW50UmVmLmN1cnJlbnRdKTtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICAgIG1hcCA9IGNvbnRleHQubWFwO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUgPSBwcm9wcy5sYXRpdHVkZSxcbiAgICAgIHRpcFNpemUgPSBwcm9wcy50aXBTaXplLFxuICAgICAgY2xvc2VCdXR0b24gPSBwcm9wcy5jbG9zZUJ1dHRvbixcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBhbHRpdHVkZSA9IHByb3BzLmFsdGl0dWRlO1xuXG4gIGlmIChhbHRpdHVkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYWx0aXR1ZGUgPSBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwge1xuICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwb3NpdGlvbiA9IHZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlXSk7XG4gIHZhciBwb3NpdGlvblR5cGUgPSBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGNvbnRlbnRSZWYuY3VycmVudCwgcG9zaXRpb24pO1xuICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGNvbnRhaW5lclJlZi5jdXJyZW50LCBwb3NpdGlvbiwgcG9zaXRpb25UeXBlKTtcbiAgdmFyIG9uUmVhY3RDbGljayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuICFjb250ZXh0LmV2ZW50TWFuYWdlciAmJiBvbkNsaWNrKGUsIHRoaXNSZWYpO1xuICB9LCBbY29udGV4dC5ldmVudE1hbmFnZXJdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cCBtYXBib3hnbC1wb3B1cC1hbmNob3ItXCIuY29uY2F0KHBvc2l0aW9uVHlwZSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpLFxuICAgIHN0eWxlOiBjb250YWluZXJTdHlsZSxcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwidGlwXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwLXRpcFwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogdGlwU2l6ZVxuICAgIH1cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cC1jb250ZW50XCIsXG4gICAgb25DbGljazogb25SZWFjdENsaWNrXG4gIH0sIGNsb3NlQnV0dG9uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogXCJjbG9zZS1idXR0b25cIixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uXCIsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIlxceEQ3XCIpLCBjaGlsZHJlbikpO1xufVxuXG5Qb3B1cC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFBvcHVwKTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgdG9nZ2xlTGFiZWw6ICdUb2dnbGUgQXR0cmlidXRpb24nXG59KTtcblxuZnVuY3Rpb24gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2wob3B0cywgbWFwLCBjb250YWluZXIsIGF0dHJpYnV0aW9uQ29udGFpbmVyKSB7XG4gIHZhciBjb250cm9sID0gbmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uQ29udHJvbChvcHRzKTtcbiAgY29udHJvbC5fbWFwID0gbWFwO1xuICBjb250cm9sLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIGNvbnRyb2wuX2lubmVyQ29udGFpbmVyID0gYXR0cmlidXRpb25Db250YWluZXI7XG5cbiAgY29udHJvbC5fdXBkYXRlQXR0cmlidXRpb25zKCk7XG5cbiAgY29udHJvbC5fdXBkYXRlRWRpdExpbmsoKTtcblxuICBtYXAub24oJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuICBtYXAub24oJ3NvdXJjZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKSB7XG4gIGNvbnRyb2wuX21hcC5vZmYoJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuXG4gIGNvbnRyb2wuX21hcC5vZmYoJ3NvdXJjZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbn1cblxuZnVuY3Rpb24gQXR0cmlidXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIGlubmVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlsxXTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sO1xuXG4gICAgaWYgKGNvbnRleHQubWFwKSB7XG4gICAgICBjb250cm9sID0gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2woe1xuICAgICAgICBjdXN0b21BdHRyaWJ1dGlvbjogcHJvcHMuY3VzdG9tQXR0cmlidXRpb25cbiAgICAgIH0sIGNvbnRleHQubWFwLCBjb250YWluZXJSZWYuY3VycmVudCwgaW5uZXJDb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb250cm9sICYmIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKTtcbiAgICB9O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIGNvbXBhY3QgPSBwcm9wcy5jb21wYWN0ID09PSB1bmRlZmluZWQgPyBjb250ZXh0LnZpZXdwb3J0LndpZHRoIDw9IDY0MCA6IHByb3BzLmNvbXBhY3Q7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjb21wYWN0ICYmIHNob3dDb21wYWN0KSB7XG4gICAgICBzZXRTaG93Q29tcGFjdChmYWxzZSk7XG4gICAgfVxuICB9LCBbY29tcGFjdF0pO1xuICB2YXIgdG9nZ2xlQXR0cmlidXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNob3dDb21wYWN0KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogc2hvd0NvbXBhY3QsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1hdHRyaWIgXCIuY29uY2F0KGNvbXBhY3QgPyAnbWFwYm94Z2wtY29tcGFjdCcgOiAnJywgXCIgXCIpLmNvbmNhdChzaG93Q29tcGFjdCA/ICdtYXBib3hnbC1jb21wYWN0LXNob3cnIDogJycpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtYXR0cmliLWJ1dHRvblwiLFxuICAgIHRpdGxlOiBwcm9wcy50b2dnbGVMYWJlbCxcbiAgICBvbkNsaWNrOiB0b2dnbGVBdHRyaWJ1dGlvblxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBpbm5lckNvbnRhaW5lclJlZixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1hdHRyaWItaW5uZXJcIixcbiAgICByb2xlOiBcImxpc3RcIlxuICB9KSkpO1xufVxuXG5BdHRyaWJ1dGlvbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhBdHRyaWJ1dGlvbkNvbnRyb2wpOyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgY29udGFpbmVyOiBudWxsLFxuICBsYWJlbDogJ1RvZ2dsZSBmdWxsc2NyZWVuJ1xufSk7XG5cbmZ1bmN0aW9uIEZ1bGxzY3JlZW5Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgaXNGdWxsc2NyZWVuID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldElzRnVsbHNjcmVlbiA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBzaG93QnV0dG9uID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldFNob3dCdXR0b24gPSBfdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBfdXNlU3RhdGU2ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlNSwgMiksXG4gICAgICBtYXBib3hGdWxsc2NyZWVuQ29udHJvbCA9IF91c2VTdGF0ZTZbMF0sXG4gICAgICBjcmVhdGVNYXBib3hGdWxsc2NyZWVuQ29udHJvbCA9IF91c2VTdGF0ZTZbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbCA9IG5ldyBtYXBib3hnbC5GdWxsc2NyZWVuQ29udHJvbCgpO1xuICAgIGNyZWF0ZU1hcGJveEZ1bGxzY3JlZW5Db250cm9sKGNvbnRyb2wpO1xuICAgIHNldFNob3dCdXR0b24oY29udHJvbC5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCgpKTtcblxuICAgIHZhciBvbkZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBvbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gIWNvbnRyb2wuX2Z1bGxzY3JlZW47XG4gICAgICBjb250cm9sLl9mdWxsc2NyZWVuID0gbmV4dFN0YXRlO1xuICAgICAgc2V0SXNGdWxsc2NyZWVuKG5leHRTdGF0ZSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoY29udHJvbC5fZnVsbHNjcmVlbmNoYW5nZSwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjb250cm9sLl9mdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICB2YXIgb25DbGlja0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiBvbkNsaWNrRnVsbHNjcmVlbigpIHtcbiAgICBpZiAobWFwYm94RnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sLl9jb250YWluZXIgPSBwcm9wcy5jb250YWluZXIgfHwgY29udGV4dC5jb250YWluZXI7XG5cbiAgICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sLl9vbkNsaWNrRnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG5cbiAgaWYgKCFzaG93QnV0dG9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbDtcbiAgdmFyIHR5cGUgPSBpc0Z1bGxzY3JlZW4gPyAnc2hyaW5rJyA6ICdmdWxsc2NyZWVuJztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAga2V5OiB0eXBlLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC1cIi5jb25jYXQodHlwZSksXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICB0aXRsZTogbGFiZWwsXG4gICAgb25DbGljazogb25DbGlja0Z1bGxzY3JlZW5cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb25cIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pKSkpO1xufVxuXG5GdWxsc2NyZWVuQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEZ1bGxzY3JlZW5Db250cm9sKTsiLCJ2YXIgc3VwcG9ydGVkO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR2VvbG9jYXRpb25TdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydGVkKTtcbiAgfVxuXG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLnBlcm1pc3Npb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICBuYW1lOiAnZ2VvbG9jYXRpb24nXG4gICAgfSkudGhlbihmdW5jdGlvbiAocCkge1xuICAgICAgc3VwcG9ydGVkID0gcC5zdGF0ZSAhPT0gJ2RlbmllZCc7XG4gICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH0pO1xuICB9XG5cbiAgc3VwcG9ydGVkID0gQm9vbGVhbih3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdXBwb3J0ZWQpO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCB7IExJTkVBUl9UUkFOU0lUSU9OX1BST1BTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCB9IGZyb20gJy4uL3V0aWxzL2dlb2xvY2F0ZS11dGlscyc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbGFiZWw6ICdGaW5kIE15IExvY2F0aW9uJyxcbiAgZGlzYWJsZWRMYWJlbDogJ0xvY2F0aW9uIE5vdCBBdmFpbGFibGUnLFxuICBhdXRvOiBmYWxzZSxcbiAgcG9zaXRpb25PcHRpb25zOiB7XG4gICAgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZSxcbiAgICB0aW1lb3V0OiA2MDAwXG4gIH0sXG4gIGZpdEJvdW5kc09wdGlvbnM6IHtcbiAgICBtYXhab29tOiAxNVxuICB9LFxuICB0cmFja1VzZXJMb2NhdGlvbjogZmFsc2UsXG4gIHNob3dVc2VyTG9jYXRpb246IHRydWUsXG4gIHNob3dBY2N1cmFjeUNpcmNsZTogdHJ1ZSxcbiAgb25HZW9sb2NhdGU6IGZ1bmN0aW9uIG9uR2VvbG9jYXRlKCkge31cbn0pO1xuXG5mdW5jdGlvbiBnZXRCb3VuZHMocG9zaXRpb24pIHtcbiAgdmFyIGNlbnRlciA9IG5ldyBtYXBib3hnbC5MbmdMYXQocG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlKTtcbiAgdmFyIHJhZGl1cyA9IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeTtcbiAgdmFyIGJvdW5kcyA9IGNlbnRlci50b0JvdW5kcyhyYWRpdXMpO1xuICByZXR1cm4gW1tib3VuZHMuX25lLmxuZywgYm91bmRzLl9uZS5sYXRdLCBbYm91bmRzLl9zdy5sbmcsIGJvdW5kcy5fc3cubGF0XV07XG59XG5cbmZ1bmN0aW9uIHNldHVwTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250ZXh0LCBwcm9wcywgZ2VvbG9jYXRlQnV0dG9uKSB7XG4gIHZhciBjb250cm9sID0gbmV3IG1hcGJveGdsLkdlb2xvY2F0ZUNvbnRyb2wocHJvcHMpO1xuICBjb250cm9sLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udHJvbC5fbWFwID0ge1xuICAgIG9uOiBmdW5jdGlvbiBvbigpIHt9LFxuICAgIF9nZXRVSVN0cmluZzogZnVuY3Rpb24gX2dldFVJU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICBjb250cm9sLl9zZXR1cFVJKHRydWUpO1xuXG4gIGNvbnRyb2wuX21hcCA9IGNvbnRleHQubWFwO1xuICBjb250cm9sLl9nZW9sb2NhdGVCdXR0b24gPSBnZW9sb2NhdGVCdXR0b247XG4gIHZhciBldmVudE1hbmFnZXIgPSBjb250ZXh0LmV2ZW50TWFuYWdlcjtcblxuICBpZiAoY29udHJvbC5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmIGV2ZW50TWFuYWdlcikge1xuICAgIGV2ZW50TWFuYWdlci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29udHJvbC5fd2F0Y2hTdGF0ZSA9PT0gJ0FDVElWRV9MT0NLJykge1xuICAgICAgICBjb250cm9sLl93YXRjaFN0YXRlID0gJ0JBQ0tHUk9VTkQnO1xuICAgICAgICBnZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZCcpO1xuICAgICAgICBnZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb250cm9sLm9uKCdnZW9sb2NhdGUnLCBwcm9wcy5vbkdlb2xvY2F0ZSk7XG4gIHJldHVybiBjb250cm9sO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEocG9zaXRpb24sIF9yZWYpIHtcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gIHZhciBib3VuZHMgPSBnZXRCb3VuZHMocG9zaXRpb24pO1xuXG4gIHZhciBfY29udGV4dCR2aWV3cG9ydCRmaXQgPSBjb250ZXh0LnZpZXdwb3J0LmZpdEJvdW5kcyhib3VuZHMsIHByb3BzLmZpdEJvdW5kc09wdGlvbnMpLFxuICAgICAgbG9uZ2l0dWRlID0gX2NvbnRleHQkdmlld3BvcnQkZml0LmxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlID0gX2NvbnRleHQkdmlld3BvcnQkZml0LmxhdGl0dWRlLFxuICAgICAgem9vbSA9IF9jb250ZXh0JHZpZXdwb3J0JGZpdC56b29tO1xuXG4gIHZhciBuZXdWaWV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LnZpZXdwb3J0LCB7XG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgIHpvb206IHpvb21cbiAgfSk7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShuZXdWaWV3U3RhdGUpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gR2VvbG9jYXRlQ29udHJvbChwcm9wcykge1xuICB2YXIgdGhpc1JlZiA9IHVzZU1hcENvbnRyb2wocHJvcHMpO1xuICB2YXIgY29udGV4dCA9IHRoaXNSZWYuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuICB2YXIgZ2VvbG9jYXRlQnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBjcmVhdGVNYXBib3hHZW9sb2NhdGVDb250cm9sID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIHN1cHBvcnRzR2VvbG9jYXRpb24gPSBfdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0U3VwcG9ydHNHZW9sb2NhdGlvbiA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbDtcblxuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzZXRTdXBwb3J0c0dlb2xvY2F0aW9uKHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKGdlb2xvY2F0ZUJ1dHRvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29udHJvbCA9IHNldHVwTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250ZXh0LCBwcm9wcywgZ2VvbG9jYXRlQnV0dG9uUmVmLmN1cnJlbnQpO1xuXG4gICAgICAgICAgY29udHJvbC5fdXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FtZXJhKHBvc2l0aW9uLCB0aGlzUmVmKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY3JlYXRlTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuX2NsZWFyV2F0Y2goKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIHRyaWdnZXJHZW9sb2NhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wub3B0aW9ucyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBtYXBib3hHZW9sb2NhdGVDb250cm9sLnRyaWdnZXIoKTtcbiAgICB9XG4gIH0sIFttYXBib3hHZW9sb2NhdGVDb250cm9sXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BzLmF1dG8pIHtcbiAgICAgIHRyaWdnZXJHZW9sb2NhdGUoKTtcbiAgICB9XG4gIH0sIFttYXBib3hHZW9sb2NhdGVDb250cm9sLCBwcm9wcy5hdXRvXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wuX29uWm9vbSgpO1xuICAgIH1cbiAgfSwgW2NvbnRleHQudmlld3BvcnQuem9vbV0pO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGRpc2FibGVkTGFiZWwgPSBwcm9wcy5kaXNhYmxlZExhYmVsLFxuICAgICAgdHJhY2tVc2VyTG9jYXRpb24gPSBwcm9wcy50cmFja1VzZXJMb2NhdGlvbjtcbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJnZW9sb2NhdGUtY29udHJvbFwiLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBrZXk6IFwiZ2VvbG9jYXRlXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZVwiLFxuICAgIHJlZjogZ2VvbG9jYXRlQnV0dG9uUmVmLFxuICAgIGRpc2FibGVkOiAhc3VwcG9ydHNHZW9sb2NhdGlvbixcbiAgICBcImFyaWEtcHJlc3NlZFwiOiAhdHJhY2tVc2VyTG9jYXRpb24sXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICB0aXRsZTogc3VwcG9ydHNHZW9sb2NhdGlvbiA/IGxhYmVsIDogZGlzYWJsZWRMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxcIjogc3VwcG9ydHNHZW9sb2NhdGlvbiA/IGxhYmVsIDogZGlzYWJsZWRMYWJlbCxcbiAgICBvbkNsaWNrOiB0cmlnZ2VyR2VvbG9jYXRlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSkpKTtcbn1cblxuR2VvbG9jYXRlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEdlb2xvY2F0ZUNvbnRyb2wpOyIsImV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIHZhciB2MSA9ICh2ZXJzaW9uMSB8fCAnJykuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHYyID0gKHZlcnNpb24yIHx8ICcnKS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdmFyIHBhcnQxID0gdjFbaV0gfHwgMDtcbiAgICB2YXIgcGFydDIgPSB2MltpXSB8fCAwO1xuXG4gICAgaWYgKHBhcnQxIDwgcGFydDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGFydDEgPiBwYXJ0Mikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQgeyBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyB9IGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9sbGVyJztcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24nO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIHNob3dDb21wYXNzOiB0cnVlLFxuICBzaG93Wm9vbTogdHJ1ZSxcbiAgem9vbUluTGFiZWw6ICdab29tIEluJyxcbiAgem9vbU91dExhYmVsOiAnWm9vbSBPdXQnLFxuICBjb21wYXNzTGFiZWw6ICdSZXNldCBOb3J0aCdcbn0pO1xudmFyIFZFUlNJT05fTEVHQUNZID0gMTtcbnZhciBWRVJTSU9OXzFfNiA9IDI7XG5cbmZ1bmN0aW9uIGdldFVJVmVyc2lvbihtYXBib3hWZXJzaW9uKSB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMobWFwYm94VmVyc2lvbiwgJzEuNi4wJykgPj0gMCA/IFZFUlNJT05fMV82IDogVkVSU0lPTl9MRUdBQ1k7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCBvcHRzKSB7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQ7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB2aWV3cG9ydCwgb3B0cykpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQnV0dG9uKHR5cGUsIGxhYmVsLCBjYWxsYmFjaywgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogdHlwZSxcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uIG1hcGJveGdsLWN0cmwtXCIuY29uY2F0KHR5cGUpLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgdGl0bGU6IGxhYmVsLFxuICAgIG9uQ2xpY2s6IGNhbGxiYWNrXG4gIH0sIGNoaWxkcmVuIHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbXBhc3MoY29udGV4dCkge1xuICB2YXIgdWlWZXJzaW9uID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQubWFwID8gZ2V0VUlWZXJzaW9uKGNvbnRleHQubWFwLnZlcnNpb24pIDogVkVSU0lPTl8xXzY7XG4gIH0sIFtjb250ZXh0Lm1hcF0pO1xuICB2YXIgYmVhcmluZyA9IGNvbnRleHQudmlld3BvcnQuYmVhcmluZztcbiAgdmFyIHN0eWxlID0ge1xuICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoXCIuY29uY2F0KC1iZWFyaW5nLCBcImRlZylcIilcbiAgfTtcbiAgcmV0dXJuIHVpVmVyc2lvbiA9PT0gVkVSU0lPTl8xXzYgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvblwiLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWNvbXBhc3MtYXJyb3dcIixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE5hdmlnYXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIG9uWm9vbUluID0gZnVuY3Rpb24gb25ab29tSW4oKSB7XG4gICAgdXBkYXRlVmlld3BvcnQoY29udGV4dCwgcHJvcHMsIHtcbiAgICAgIHpvb206IGNvbnRleHQudmlld3BvcnQuem9vbSArIDFcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb25ab29tT3V0ID0gZnVuY3Rpb24gb25ab29tT3V0KCkge1xuICAgIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCB7XG4gICAgICB6b29tOiBjb250ZXh0LnZpZXdwb3J0Lnpvb20gLSAxXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9uUmVzZXROb3J0aCA9IGZ1bmN0aW9uIG9uUmVzZXROb3J0aCgpIHtcbiAgICB1cGRhdGVWaWV3cG9ydChjb250ZXh0LCBwcm9wcywge1xuICAgICAgYmVhcmluZzogMCxcbiAgICAgIHBpdGNoOiAwXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIHNob3dDb21wYXNzID0gcHJvcHMuc2hvd0NvbXBhc3MsXG4gICAgICBzaG93Wm9vbSA9IHByb3BzLnNob3dab29tLFxuICAgICAgem9vbUluTGFiZWwgPSBwcm9wcy56b29tSW5MYWJlbCxcbiAgICAgIHpvb21PdXRMYWJlbCA9IHByb3BzLnpvb21PdXRMYWJlbCxcbiAgICAgIGNvbXBhc3NMYWJlbCA9IHByb3BzLmNvbXBhc3NMYWJlbDtcbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBzaG93Wm9vbSAmJiByZW5kZXJCdXR0b24oJ3pvb20taW4nLCB6b29tSW5MYWJlbCwgb25ab29tSW4pLCBzaG93Wm9vbSAmJiByZW5kZXJCdXR0b24oJ3pvb20tb3V0Jywgem9vbU91dExhYmVsLCBvblpvb21PdXQpLCBzaG93Q29tcGFzcyAmJiByZW5kZXJCdXR0b24oJ2NvbXBhc3MnLCBjb21wYXNzTGFiZWwsIG9uUmVzZXROb3J0aCwgcmVuZGVyQ29tcGFzcyhjb250ZXh0KSkpKTtcbn1cblxuTmF2aWdhdGlvbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhOYXZpZ2F0aW9uQ29udHJvbCk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG1heFdpZHRoOiAxMDAsXG4gIHVuaXQ6ICdtZXRyaWMnXG59KTtcblxuZnVuY3Rpb24gU2NhbGVDb250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBtYXBib3hTY2FsZUNvbnRyb2wgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgY3JlYXRlTWFwYm94U2NhbGVDb250cm9sID0gX3VzZVN0YXRlMlsxXTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuU2NhbGVDb250cm9sKCk7XG4gICAgICBjb250cm9sLl9tYXAgPSBjb250ZXh0Lm1hcDtcbiAgICAgIGNvbnRyb2wuX2NvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgY3JlYXRlTWFwYm94U2NhbGVDb250cm9sKGNvbnRyb2wpO1xuICAgIH1cbiAgfSwgW2NvbnRleHQubWFwXSk7XG5cbiAgaWYgKG1hcGJveFNjYWxlQ29udHJvbCkge1xuICAgIG1hcGJveFNjYWxlQ29udHJvbC5vcHRpb25zID0gcHJvcHM7XG5cbiAgICBtYXBib3hTY2FsZUNvbnRyb2wuX29uTW92ZSgpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtc2NhbGVcIlxuICB9KSk7XG59XG5cblNjYWxlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFNjYWxlQ29udHJvbCk7IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbnZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogZmFsc2UsXG4gIGNhcHR1cmVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVEb3VibGVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIENhbnZhc092ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGN0eCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXREcmF3aW5nQ29udGV4dCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXREcmF3aW5nQ29udGV4dChjb250YWluZXJSZWYuY3VycmVudC5nZXRDb250ZXh0KCcyZCcpKTtcbiAgfSwgW10pO1xuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcblxuICBpZiAoY3R4KSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgcHJvcHMucmVkcmF3KHtcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgY3R4OiBjdHgsXG4gICAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgICAgcHJvamVjdDogdmlld3BvcnQucHJvamVjdCxcbiAgICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGggKiBwaXhlbFJhdGlvLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHZpZXdwb3J0LndpZHRoLCBcInB4XCIpLFxuICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdCh2aWV3cG9ydC5oZWlnaHQsIFwicHhcIiksXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9XG4gIH0pO1xufVxuXG5DYW52YXNPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IENhbnZhc092ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gSFRNTE92ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcblxuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcblxuICB2YXIgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHRcbiAgfSwgcHJvcHMuc3R5bGUpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgcHJvcHMucmVkcmF3KHtcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICBwcm9qZWN0OiB2aWV3cG9ydC5wcm9qZWN0LFxuICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gIH0pKTtcbn1cblxuSFRNTE92ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgSFRNTE92ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gU1ZHT3ZlcmxheShwcm9wcykge1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuXG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgICBpc0RyYWdnaW5nID0gY29udGV4dC5pc0RyYWdnaW5nO1xuXG4gIHZhciBzdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH0sIHByb3BzLnN0eWxlKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBwcm9wcy5yZWRyYXcoe1xuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgIHByb2plY3Q6IHZpZXdwb3J0LnByb2plY3QsXG4gICAgdW5wcm9qZWN0OiB2aWV3cG9ydC51bnByb2plY3RcbiAgfSkpO1xufVxuXG5TVkdPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFNWR092ZXJsYXk7IiwiaW1wb3J0IG1hcGJveGdsIGZyb20gJy4vbWFwYm94Z2wnO1xudmFyIHNldFJUTFRleHRQbHVnaW4gPSBtYXBib3hnbCA/IG1hcGJveGdsLnNldFJUTFRleHRQbHVnaW4gOiBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydCBkZWZhdWx0IHNldFJUTFRleHRQbHVnaW47IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnRlcmFjdGl2ZU1hcCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGF0aWNNYXAgfSBmcm9tICcuL2NvbXBvbmVudHMvc3RhdGljLW1hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNvdXJjZSB9IGZyb20gJy4vY29tcG9uZW50cy9zb3VyY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXllciB9IGZyb20gJy4vY29tcG9uZW50cy9sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2Jhc2UtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcmtlciB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJrZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3B1cCB9IGZyb20gJy4vY29tcG9uZW50cy9wb3B1cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF0dHJpYnV0aW9uQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9hdHRyaWJ1dGlvbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVsbHNjcmVlbkNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2VvbG9jYXRlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5hdmlnYXRpb25Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL25hdmlnYXRpb24tY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjYWxlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9zY2FsZS1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvY2FudmFzLW92ZXJsYXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIVE1MT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvaHRtbC1vdmVybGF5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU1ZHT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvc3ZnLW92ZXJsYXknO1xuZXhwb3J0IHsgVFJBTlNJVElPTl9FVkVOVFMgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5leHBvcnQgeyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yLCBMaW5lYXJJbnRlcnBvbGF0b3IsIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgYXMgRmx5VG9JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9tYXAtY29udHJvbGxlcic7XG5leHBvcnQgeyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNldFJUTFRleHRQbHVnaW4gfSBmcm9tICcuL3V0aWxzL3NldC1ydGwtdGV4dC1wbHVnaW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250ZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL21hcC1jb250ZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX3VzZU1hcENvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX01hcENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFwLWNvbnRleHQnOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBqNDBQb3B1cCA9IFwiSjQwTWFwLW1vZHVsZS0tajQwUG9wdXAtLTN5SkdyXCI7XG5leHBvcnQgdmFyIG5hdmlnYXRpb25Db250cm9scyA9IFwiSjQwTWFwLW1vZHVsZS0tbmF2aWdhdGlvbkNvbnRyb2xzLS1FYkJWVlwiO1xuZXhwb3J0IHZhciB6b29tQnV0dG9uID0gXCJKNDBNYXAtbW9kdWxlLS16b29tQnV0dG9uLS0xZFJWRVwiO1xuZXhwb3J0IHZhciB6b29tQ29udGFpbmVyID0gXCJKNDBNYXAtbW9kdWxlLS16b29tQ29udGFpbmVyLS0zQVRxYlwiOyIsIi8qKlxuICogQG1vZHVsZSBoZWxwZXJzXG4gKi9cblxuLyoqXG4gKiBFYXJ0aCBSYWRpdXMgdXNlZCB3aXRoIHRoZSBIYXJ2ZXNpbmUgZm9ybXVsYSBhbmQgYXBwcm94aW1hdGVzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBFYXJ0aC5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBlYXJ0aFJhZGl1cyA9IDYzNzEwMDguODtcbi8qKlxuICogVW5pdCBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBlYXJ0aCByYWRpdXMuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IHZhciBmYWN0b3JzID0ge1xuICBjZW50aW1ldGVyczogZWFydGhSYWRpdXMgKiAxMDAsXG4gIGNlbnRpbWV0cmVzOiBlYXJ0aFJhZGl1cyAqIDEwMCxcbiAgZGVncmVlczogZWFydGhSYWRpdXMgLyAxMTEzMjUsXG4gIGZlZXQ6IGVhcnRoUmFkaXVzICogMy4yODA4NCxcbiAgaW5jaGVzOiBlYXJ0aFJhZGl1cyAqIDM5LjM3LFxuICBraWxvbWV0ZXJzOiBlYXJ0aFJhZGl1cyAvIDEwMDAsXG4gIGtpbG9tZXRyZXM6IGVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgbWV0ZXJzOiBlYXJ0aFJhZGl1cyxcbiAgbWV0cmVzOiBlYXJ0aFJhZGl1cyxcbiAgbWlsZXM6IGVhcnRoUmFkaXVzIC8gMTYwOS4zNDQsXG4gIG1pbGxpbWV0ZXJzOiBlYXJ0aFJhZGl1cyAqIDEwMDAsXG4gIG1pbGxpbWV0cmVzOiBlYXJ0aFJhZGl1cyAqIDEwMDAsXG4gIG5hdXRpY2FsbWlsZXM6IGVhcnRoUmFkaXVzIC8gMTg1MixcbiAgcmFkaWFuczogMSxcbiAgeWFyZHM6IGVhcnRoUmFkaXVzICogMS4wOTM2XG59O1xuLyoqXG4gKiBVbml0cyBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIGJhc2VkIG9uIDEgbWV0ZXIuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IHZhciB1bml0c0ZhY3RvcnMgPSB7XG4gIGNlbnRpbWV0ZXJzOiAxMDAsXG4gIGNlbnRpbWV0cmVzOiAxMDAsXG4gIGRlZ3JlZXM6IDEgLyAxMTEzMjUsXG4gIGZlZXQ6IDMuMjgwODQsXG4gIGluY2hlczogMzkuMzcsXG4gIGtpbG9tZXRlcnM6IDEgLyAxMDAwLFxuICBraWxvbWV0cmVzOiAxIC8gMTAwMCxcbiAgbWV0ZXJzOiAxLFxuICBtZXRyZXM6IDEsXG4gIG1pbGVzOiAxIC8gMTYwOS4zNDQsXG4gIG1pbGxpbWV0ZXJzOiAxMDAwLFxuICBtaWxsaW1ldHJlczogMTAwMCxcbiAgbmF1dGljYWxtaWxlczogMSAvIDE4NTIsXG4gIHJhZGlhbnM6IDEgLyBlYXJ0aFJhZGl1cyxcbiAgeWFyZHM6IDEuMDkzNjEzM1xufTtcbi8qKlxuICogQXJlYSBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIGJhc2VkIG9uIDEgc3F1YXJlIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCB2YXIgYXJlYUZhY3RvcnMgPSB7XG4gIGFjcmVzOiAwLjAwMDI0NzEwNSxcbiAgY2VudGltZXRlcnM6IDEwMDAwLFxuICBjZW50aW1ldHJlczogMTAwMDAsXG4gIGZlZXQ6IDEwLjc2MzkxMDQxNyxcbiAgaGVjdGFyZXM6IDAuMDAwMSxcbiAgaW5jaGVzOiAxNTUwLjAwMzEwMDAwNixcbiAga2lsb21ldGVyczogMC4wMDAwMDEsXG4gIGtpbG9tZXRyZXM6IDAuMDAwMDAxLFxuICBtZXRlcnM6IDEsXG4gIG1ldHJlczogMSxcbiAgbWlsZXM6IDMuODZlLTcsXG4gIG1pbGxpbWV0ZXJzOiAxMDAwMDAwLFxuICBtaWxsaW1ldHJlczogMTAwMDAwMCxcbiAgeWFyZHM6IDEuMTk1OTkwMDQ2XG59O1xuLyoqXG4gKiBXcmFwcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBpbiBhIEdlb0pTT04ge0BsaW5rIEZlYXR1cmV9LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGlucHV0IGdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmV9IGEgR2VvSlNPTiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0ge1xuICogICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDUwXVxuICogfTtcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZShnZW9tZXRyeSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBmZWF0ID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuaWQgPT09IDAgfHwgb3B0aW9ucy5pZCkge1xuICAgIGZlYXQuaWQgPSBvcHRpb25zLmlkO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgIGZlYXQuYmJveCA9IG9wdGlvbnMuYmJveDtcbiAgfVxuXG4gIGZlYXQucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gIGZlYXQuZ2VvbWV0cnkgPSBnZW9tO1xuICByZXR1cm4gZmVhdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBmcm9tIGEgR2VvbWV0cnkgc3RyaW5nIHR5cGUgJiBjb29yZGluYXRlcy5cbiAqIEZvciBHZW9tZXRyeUNvbGxlY3Rpb24gdHlwZSB1c2UgYGhlbHBlcnMuZ2VvbWV0cnlDb2xsZWN0aW9uYFxuICpcbiAqIEBuYW1lIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBHZW9tZXRyeSBUeXBlXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtHZW9tZXRyeX0gYSBHZW9KU09OIEdlb21ldHJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHR5cGUgPSBcIlBvaW50XCI7XG4gKiB2YXIgY29vcmRpbmF0ZXMgPSBbMTEwLCA1MF07XG4gKiB2YXIgZ2VvbWV0cnkgPSB0dXJmLmdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzKTtcbiAqIC8vID0+IGdlb21ldHJ5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzLCBfb3B0aW9ucykge1xuICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIF9vcHRpb25zID0ge307XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgIHJldHVybiBwb2ludChjb29yZGluYXRlcykuZ2VvbWV0cnk7XG5cbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuXG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIHJldHVybiBwb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcblxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbXVsdGlQb2ludChjb29yZGluYXRlcykuZ2VvbWV0cnk7XG5cbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcblxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIHJldHVybiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgaW52YWxpZFwiKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFBvaW50fSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhIFBvc2l0aW9uLlxuICpcbiAqIEBuYW1lIHBvaW50XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9zaXRpb24gKGVhY2ggaW4gZGVjaW1hbCBkZWdyZWVzKVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gYSBQb2ludCBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0gdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSk7XG4gKlxuICogLy89cG9pbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBpcyByZXF1aXJlZFwiKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShjb29yZGluYXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICB9XG5cbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nXCIpO1xuICB9XG5cbiAgaWYgKCFpc051bWJlcihjb29yZGluYXRlc1swXSkgfHwgIWlzTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgY29udGFpbiBudW1iZXJzXCIpO1xuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJQb2ludFwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvaW50IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGVhY2ggRmVhdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBQb2ludCBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucG9pbnRzKFtcbiAqICAgWy03NSwgMzldLFxuICogICBbLTgwLCA0NV0sXG4gKiAgIFstNzgsIDUwXVxuICogXSk7XG4gKlxuICogLy89cG9pbnRzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50cyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgcmV0dXJuIHBvaW50KGNvb3JkcywgcHJvcGVydGllcyk7XG4gIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2x5Z29ufSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBMaW5lYXJSaW5ncy5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gUG9seWdvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSwgeyBuYW1lOiAncG9seTEnIH0pO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBjb29yZGluYXRlc18xID0gY29vcmRpbmF0ZXM7IF9pIDwgY29vcmRpbmF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzXzFbX2ldO1xuXG4gICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBMaW5lYXJSaW5nIG9mIGEgUG9seWdvbiBtdXN0IGhhdmUgNCBvciBtb3JlIFBvc2l0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nW3JpbmcubGVuZ3RoIC0gMV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIENoZWNrIGlmIGZpcnN0IHBvaW50IG9mIFBvbHlnb24gY29udGFpbnMgdHdvIG51bWJlcnNcbiAgICAgIGlmIChyaW5nW3JpbmcubGVuZ3RoIC0gMV1bal0gIT09IHJpbmdbMF1bal0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYW5kIGxhc3QgUG9zaXRpb24gYXJlIG5vdCBlcXVpdmFsZW50LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvbHlnb24gY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgcG9seWdvbnNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLnBvbHlnb25zKFtcbiAqICAgW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSxcbiAqICAgW1tbLTE1LCA0Ml0sIFstMTQsIDQ2XSwgWy0xMiwgNDFdLCBbLTE3LCA0NF0sIFstMTUsIDQyXV1dLFxuICogXSk7XG4gKlxuICogLy89cG9seWdvbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbnMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHJldHVybiBwb2x5Z29uKGNvb3JkcywgcHJvcGVydGllcyk7XG4gIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBQb3NpdGlvbnMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IExpbmVTdHJpbmcgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5nMSA9IHR1cmYubGluZVN0cmluZyhbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSwge25hbWU6ICdsaW5lIDEnfSk7XG4gKiB2YXIgbGluZXN0cmluZzIgPSB0dXJmLmxpbmVTdHJpbmcoW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV0sIHtuYW1lOiAnbGluZSAyJ30pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHdvIG9yIG1vcmUgcG9zaXRpb25zXCIpO1xuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIExpbmVTdHJpbmd9IHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSBhbiBBcnJheSBvZiBMaW5lU3RyaW5nIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIGxpbmVTdHJpbmdzXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248TGluZVN0cmluZz59IExpbmVTdHJpbmcgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZXN0cmluZ3MgPSB0dXJmLmxpbmVTdHJpbmdzKFtcbiAqICAgW1stMjQsIDYzXSwgWy0yMywgNjBdLCBbLTI1LCA2NV0sIFstMjAsIDY5XV0sXG4gKiAgIFtbLTE0LCA0M10sIFstMTMsIDQwXSwgWy0xNSwgNDVdLCBbLTEwLCA0OV1dXG4gKiBdKTtcbiAqXG4gKiAvLz1saW5lc3RyaW5nc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5ncyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgfSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSB7QGxpbmsgRmVhdHVyZXxGZWF0dXJlc30gYW5kIGNyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmVbXX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBGZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBsb2NhdGlvbkEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdLCB7bmFtZTogJ0xvY2F0aW9uIEEnfSk7XG4gKiB2YXIgbG9jYXRpb25CID0gdHVyZi5wb2ludChbLTc1LjgzMywgMzkuMjg0XSwge25hbWU6ICdMb2NhdGlvbiBCJ30pO1xuICogdmFyIGxvY2F0aW9uQyA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10sIHtuYW1lOiAnTG9jYXRpb24gQyd9KTtcbiAqXG4gKiB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICBsb2NhdGlvbkEsXG4gKiAgIGxvY2F0aW9uQixcbiAqICAgbG9jYXRpb25DXG4gKiBdKTtcbiAqXG4gKiAvLz1jb2xsZWN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgZmMgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICBmYy5pZCA9IG9wdGlvbnMuaWQ7XG4gIH1cblxuICBpZiAob3B0aW9ucy5iYm94KSB7XG4gICAgZmMuYmJveCA9IG9wdGlvbnMuYmJveDtcbiAgfVxuXG4gIGZjLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gIHJldHVybiBmYztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBhIE11bHRpTGluZVN0cmluZyBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbW1swLDBdLFsxMCwxMF1dXSk7XG4gKlxuICogLy89bXVsdGlMaW5lXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvaW50Pn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvaW50XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvaW50Pn0gYSBNdWx0aVBvaW50IGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUHQgPSB0dXJmLm11bHRpUG9pbnQoW1swLDBdLFsxMCwxMF1dKTtcbiAqXG4gKiAvLz1tdWx0aVB0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpUG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2ludFwiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9seWdvbj59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvbHlnb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYSBtdWx0aXBvbHlnb24gZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQb2x5ID0gdHVyZi5tdWx0aVBvbHlnb24oW1tbWzAsMF0sWzAsMTBdLFsxMCwxMF0sWzEwLDBdLFswLDBdXV1dKTtcbiAqXG4gKiAvLz1tdWx0aVBvbHlcbiAqXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpUG9seWdvbihjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGdlb21ldHJ5Q29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheTxHZW9tZXRyeT59IGdlb21ldHJpZXMgYW4gYXJyYXkgb2YgR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYSBHZW9KU09OIEdlb21ldHJ5Q29sbGVjdGlvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0gdHVyZi5nZW9tZXRyeShcIlBvaW50XCIsIFsxMDAsIDBdKTtcbiAqIHZhciBsaW5lID0gdHVyZi5nZW9tZXRyeShcIkxpbmVTdHJpbmdcIiwgW1sxMDEsIDBdLCBbMTAyLCAxXV0pO1xuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmdlb21ldHJ5Q29sbGVjdGlvbihbcHQsIGxpbmVdKTtcbiAqXG4gKiAvLyA9PiBjb2xsZWN0aW9uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFxuICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIFJvdW5kIG51bWJlciB0byBwcmVjaXNpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gUHJlY2lzaW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByb3VuZGVkIG51bWJlclxuICogQGV4YW1wbGVcbiAqIHR1cmYucm91bmQoMTIwLjQzMjEpXG4gKiAvLz0xMjBcbiAqXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxLCAyKVxuICogLy89MTIwLjQzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG51bSwgcHJlY2lzaW9uKSB7XG4gIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkge1xuICAgIHByZWNpc2lvbiA9IDA7XG4gIH1cblxuICBpZiAocHJlY2lzaW9uICYmICEocHJlY2lzaW9uID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJlY2lzaW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cblxuICB2YXIgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gfHwgMCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSByYWRpYW5zIHRvIGEgbW9yZSBmcmllbmRseSB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9MZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2VcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFuc1RvTGVuZ3RoKHJhZGlhbnMsIHVuaXRzKSB7XG4gIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7XG4gICAgdW5pdHMgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuXG4gIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzXTtcblxuICBpZiAoIWZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcih1bml0cyArIFwiIHVuaXRzIGlzIGludmFsaWRcIik7XG4gIH1cblxuICByZXR1cm4gcmFkaWFucyAqIGZhY3Rvcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgaWYgKHVuaXRzID09PSB2b2lkIDApIHtcbiAgICB1bml0cyA9IFwia2lsb21ldGVyc1wiO1xuICB9XG5cbiAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHNdO1xuXG4gIGlmICghZmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZSAvIGZhY3Rvcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0ZXJzLCBraWxvbWV0cmVzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aFRvRGVncmVlcyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgcmV0dXJuIHJhZGlhbnNUb0RlZ3JlZXMobGVuZ3RoVG9SYWRpYW5zKGRpc3RhbmNlLCB1bml0cykpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbnkgYmVhcmluZyBhbmdsZSBmcm9tIHRoZSBub3J0aCBsaW5lIGRpcmVjdGlvbiAocG9zaXRpdmUgY2xvY2t3aXNlKVxuICogYW5kIHJldHVybnMgYW4gYW5nbGUgYmV0d2VlbiAwLTM2MCBkZWdyZWVzIChwb3NpdGl2ZSBjbG9ja3dpc2UpLCAwIGJlaW5nIHRoZSBub3J0aCBsaW5lXG4gKlxuICogQG5hbWUgYmVhcmluZ1RvQXppbXV0aFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgYW5nbGUsIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJlYXJpbmdUb0F6aW11dGgoYmVhcmluZykge1xuICB2YXIgYW5nbGUgPSBiZWFyaW5nICUgMzYwO1xuXG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSAzNjA7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIHJhZGlhbnMgdG8gZGVncmVlc1xuICpcbiAqIEBuYW1lIHJhZGlhbnNUb0RlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXMgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgdmFyIGRlZ3JlZXMgPSByYWRpYW5zICUgKDIgKiBNYXRoLlBJKTtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAxODAgLyBNYXRoLlBJO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhbmdsZSBpbiBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqXG4gKiBAbmFtZSBkZWdyZWVzVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcykge1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgJSAzNjA7XG4gIHJldHVybiByYWRpYW5zICogTWF0aC5QSSAvIDE4MDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsZW5ndGggdG8gdGhlIHJlcXVlc3RlZCB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtVbml0c30gW29yaWdpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gb2YgdGhlIGxlbmd0aFxuICogQHBhcmFtIHtVbml0c30gW2ZpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gcmV0dXJuZWQgdW5pdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbnZlcnRlZCBsZW5ndGhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydExlbmd0aChsZW5ndGgsIG9yaWdpbmFsVW5pdCwgZmluYWxVbml0KSB7XG4gIGlmIChvcmlnaW5hbFVuaXQgPT09IHZvaWQgMCkge1xuICAgIG9yaWdpbmFsVW5pdCA9IFwia2lsb21ldGVyc1wiO1xuICB9XG5cbiAgaWYgKGZpbmFsVW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgZmluYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7XG4gIH1cblxuICBpZiAoIShsZW5ndGggPj0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuXG4gIHJldHVybiByYWRpYW5zVG9MZW5ndGgobGVuZ3RoVG9SYWRpYW5zKGxlbmd0aCwgb3JpZ2luYWxVbml0KSwgZmluYWxVbml0KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBhcmVhIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBraWxvbWV0ZXJzLCBraWxvbWV0cmVzLCBtZXRlcnMsIG1ldHJlcywgY2VudGltZXRyZXMsIG1pbGxpbWV0ZXJzLCBhY3JlcywgbWlsZXMsIHlhcmRzLCBmZWV0LCBpbmNoZXMsIGhlY3RhcmVzXG4gKiBAcGFyYW0ge251bWJlcn0gYXJlYSB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJtZXRlcnNcIl0gb2YgdGhlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge1VuaXRzfSBbZmluYWxVbml0PVwia2lsb21ldGVyc1wiXSByZXR1cm5lZCB1bml0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29udmVydGVkIGFyZWFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEFyZWEoYXJlYSwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgaWYgKG9yaWdpbmFsVW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgb3JpZ2luYWxVbml0ID0gXCJtZXRlcnNcIjtcbiAgfVxuXG4gIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkge1xuICAgIGZpbmFsVW5pdCA9IFwia2lsb21ldGVyc1wiO1xuICB9XG5cbiAgaWYgKCEoYXJlYSA+PSAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFyZWEgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuXG4gIHZhciBzdGFydEZhY3RvciA9IGFyZWFGYWN0b3JzW29yaWdpbmFsVW5pdF07XG5cbiAgaWYgKCFzdGFydEZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3JpZ2luYWwgdW5pdHNcIik7XG4gIH1cblxuICB2YXIgZmluYWxGYWN0b3IgPSBhcmVhRmFjdG9yc1tmaW5hbFVuaXRdO1xuXG4gIGlmICghZmluYWxGYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbmFsIHVuaXRzXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFyZWEgLyBzdGFydEZhY3RvciAqIGZpbmFsRmFjdG9yO1xufVxuLyoqXG4gKiBpc051bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gbnVtIE51bWJlciB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB0dXJmLmlzTnVtYmVyKDEyMylcbiAqIC8vPXRydWVcbiAqIHR1cmYuaXNOdW1iZXIoJ2ZvbycpXG4gKiAvLz1mYWxzZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihudW0pIHtcbiAgcmV0dXJuICFpc05hTihudW0pICYmIG51bSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShudW0pO1xufVxuLyoqXG4gKiBpc09iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdmFyaWFibGUgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc09iamVjdCh7ZWxldmF0aW9uOiAxMH0pXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzT2JqZWN0KCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgcmV0dXJuICEhaW5wdXQgJiYgaW5wdXQuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbi8qKlxuICogVmFsaWRhdGUgQkJveFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggQkJveCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIEVycm9yIGlmIEJCb3ggaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVCQm94KFstMTgwLCAtNDAsIDExMCwgNTBdKVxuICogLy89T0tcbiAqIHZhbGlkYXRlQkJveChbLTE4MCwgLTQwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3goJ0ZvbycpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KDUpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KG51bGwpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQkJveChiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYmJveCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3QgYmUgYW4gQXJyYXlcIik7XG4gIH1cblxuICBpZiAoYmJveC5sZW5ndGggIT09IDQgJiYgYmJveC5sZW5ndGggIT09IDYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3QgYmUgYW4gQXJyYXkgb2YgNCBvciA2IG51bWJlcnNcIik7XG4gIH1cblxuICBiYm94LmZvckVhY2goZnVuY3Rpb24gKG51bSkge1xuICAgIGlmICghaXNOdW1iZXIobnVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IG9ubHkgY29udGFpbiBudW1iZXJzXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFZhbGlkYXRlIElkXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgSWQgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyBFcnJvciBpZiBJZCBpcyBub3QgdmFsaWRcbiAqIEBleGFtcGxlXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDAsIDExMCwgNTBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoWy0xODAsIC00MF0pXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVJZCgnRm9vJylcbiAqIC8vPU9LXG4gKiB2YWxpZGF0ZUlkKDUpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZChudWxsKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQodW5kZWZpbmVkKVxuICogLy89RXJyb3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJZChpZCkge1xuICBpZiAoIWlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICBpZiAoW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluZGV4T2YodHlwZW9mIGlkKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xuICB9XG59IiwiaW1wb3J0IHsgZmVhdHVyZSwgcG9pbnQsIGxpbmVTdHJpbmcsIGlzT2JqZWN0IH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG4vKipcbiAqIENhbGxiYWNrIGZvciBjb29yZEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgY29vcmRFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBmaW5hbCBjb29yZGluYXRlIG9mIExpbmVhclJpbmdzIHRoYXQgd3JhcHMgdGhlIHJpbmcgaW4gaXRzIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudENvb3JkXG4gKiAgIC8vPWNvb3JkSW5kZXhcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGNvb3JkRWFjaChnZW9qc29uLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBHZW9KU09OXG4gIGlmIChnZW9qc29uID09PSBudWxsKSByZXR1cm47XG4gIHZhciBqLFxuICAgICAgayxcbiAgICAgIGwsXG4gICAgICBnZW9tZXRyeSxcbiAgICAgIHN0b3BHLFxuICAgICAgY29vcmRzLFxuICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICB3cmFwU2hyaW5rID0gMCxcbiAgICAgIGNvb3JkSW5kZXggPSAwLFxuICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICB0eXBlID0gZ2VvanNvbi50eXBlLFxuICAgICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IHR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGlzRmVhdHVyZSA9IHR5cGUgPT09IFwiRmVhdHVyZVwiLFxuICAgICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCA6IDE7IC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cblxuICBmb3IgKHZhciBmZWF0dXJlSW5kZXggPSAwOyBmZWF0dXJlSW5kZXggPCBzdG9wOyBmZWF0dXJlSW5kZXgrKykge1xuICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeSA6IGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uO1xuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiIDogZmFsc2U7XG4gICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcblxuICAgIGZvciAodmFyIGdlb21JbmRleCA9IDA7IGdlb21JbmRleCA8IHN0b3BHOyBnZW9tSW5kZXgrKykge1xuICAgICAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDtcbiAgICAgIHZhciBnZW9tZXRyeUluZGV4ID0gMDtcbiAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2dlb21JbmRleF0gOiBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbjsgLy8gSGFuZGxlcyBudWxsIEdlb21ldHJ5IC0tIFNraXBzIHRoaXMgZ2VvbWV0cnlcblxuICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgdmFyIGdlb21UeXBlID0gZ2VvbWV0cnkudHlwZTtcbiAgICAgIHdyYXBTaHJpbmsgPSBleGNsdWRlV3JhcENvb3JkICYmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIgfHwgZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpID8gMSA6IDA7XG5cbiAgICAgIHN3aXRjaCAoZ2VvbVR5cGUpIHtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgIGlmIChjYWxsYmFjayhjb29yZHMsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoIC0gd3JhcFNocmluazsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb29yZHNbal1ba10sIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBnZW9tZXRyeUluZGV4ID0gMDtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgY29vcmRzW2pdW2tdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGwrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb29yZHNbal1ba11bbF0sIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChjb29yZEVhY2goZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9tZXRyeSBUeXBlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgY29vcmRSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBjb29yZFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBTdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICpcbiAqIEBuYW1lIGNvb3JkUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEdlb21ldHJ5fEZlYXR1cmV9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVdyYXBDb29yZD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudENvb3JkXG4gKiAgIC8vPWNvb3JkSW5kZXhcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRDb29yZDtcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gY29vcmRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgZXhjbHVkZVdyYXBDb29yZCkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAgICBpZiAoY29vcmRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRDb29yZDtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpO1xuICB9LCBleGNsdWRlV3JhcENvb3JkKTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wRWFjaFxuICpcbiAqIEBjYWxsYmFjayBwcm9wRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBwcm9wRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYucHJvcEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9wRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICB2YXIgaTtcblxuICBzd2l0Y2ggKGdlb2pzb24udHlwZSkge1xuICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgZm9yIChpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGdlb2pzb24uZmVhdHVyZXNbaV0ucHJvcGVydGllcywgaSkgPT09IGZhbHNlKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgY2FsbGJhY2soZ2VvanNvbi5wcm9wZXJ0aWVzLCAwKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgcHJvcFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHsqfSBjdXJyZW50UHJvcGVydGllcyBUaGUgY3VycmVudCBQcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAbmFtZSBwcm9wUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLnByb3BSZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudFByb3BlcnRpZXNcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50UHJvcGVydGllc1xuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIHByb3BFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRQcm9wZXJ0aWVzO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmVhdHVyZUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBmZWF0dXJlRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgIGNhbGxiYWNrKGdlb2pzb24sIDApO1xuICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXSwgaSkgPT09IGZhbHNlKSBicmVhaztcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5mZWF0dXJlUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudEZlYXR1cmVcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZmVhdHVyZVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBHZXQgYWxsIGNvb3JkaW5hdGVzIGZyb20gYW55IEdlb0pTT04gb2JqZWN0LlxuICpcbiAqIEBuYW1lIGNvb3JkQWxsXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGUgcG9zaXRpb24gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHZhciBjb29yZHMgPSB0dXJmLmNvb3JkQWxsKGZlYXR1cmVzKTtcbiAqIC8vPSBbWzI2LCAzN10sIFszNiwgNTNdXVxuICovXG5cblxuZnVuY3Rpb24gY29vcmRBbGwoZ2VvanNvbikge1xuICB2YXIgY29vcmRzID0gW107XG4gIGNvb3JkRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICBjb29yZHMucHVzaChjb29yZCk7XG4gIH0pO1xuICByZXR1cm4gY29vcmRzO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBnZW9tRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICB2YXIgaSxcbiAgICAgIGosXG4gICAgICBnLFxuICAgICAgZ2VvbWV0cnksXG4gICAgICBzdG9wRyxcbiAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgIGZlYXR1cmVCQm94LFxuICAgICAgZmVhdHVyZUlkLFxuICAgICAgZmVhdHVyZUluZGV4ID0gMCxcbiAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGlzRmVhdHVyZSA9IGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIsXG4gICAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoIDogMTsgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgLy8gaXMgYmVjYXVzZSBpdCdzIHRyeWluZyB0byBiZSBmYXN0LiBHZW9KU09OIHN1cHBvcnRzIG11bHRpcGxlIGtpbmRzXG4gIC8vIG9mIG9iamVjdHMgYXQgaXRzIHJvb3Q6IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlcywgR2VvbWV0cmllcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAvLyBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGBmb3JgIGxvb3BzIHlvdSBzZWUgYmVsb3cgYWN0dWFsbHkganVzdCBkb24ndCBhcHBseVxuICAvLyB0byBjZXJ0YWluIGlucHV0cy4gRm9yIGluc3RhbmNlLCBpZiB5b3UgZ2l2ZSB0aGlzIGp1c3QgYVxuICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAvLyBpcyBncmFkdWFsbHkgcmVuYW1lIHRoZSBpbnB1dCB1bnRpbCBpdCdzIGNhbGxlZCAnZ2VvbWV0cnknLlxuICAvL1xuICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgLy8gZmV3IG51bWJlcnMgYW5kIGJvb2xlYW5zLCByYXRoZXIgdGhhbiBhbnkgdGVtcG9yYXJ5IGFycmF5cyBhcyB3b3VsZFxuICAvLyBiZSByZXF1aXJlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGFwcHJvYWNoLlxuXG4gIGZvciAoaSA9IDA7IGkgPCBzdG9wOyBpKyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5IDogaXNGZWF0dXJlID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb247XG4gICAgZmVhdHVyZVByb3BlcnRpZXMgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzIDogaXNGZWF0dXJlID8gZ2VvanNvbi5wcm9wZXJ0aWVzIDoge307XG4gICAgZmVhdHVyZUJCb3ggPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5iYm94IDogaXNGZWF0dXJlID8gZ2VvanNvbi5iYm94IDogdW5kZWZpbmVkO1xuICAgIGZlYXR1cmVJZCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmlkIDogaXNGZWF0dXJlID8gZ2VvanNvbi5pZCA6IHVuZGVmaW5lZDtcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xuICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ10gOiBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbjsgLy8gSGFuZGxlIG51bGwgR2VvbWV0cnlcblxuICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhudWxsLCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb21ldHJ5IFR5cGVcIik7XG4gICAgICB9XG4gICAgfSAvLyBPbmx5IGluY3JlYXNlIGBmZWF0dXJlSW5kZXhgIHBlciBlYWNoIGZlYXR1cmVcblxuXG4gICAgZmVhdHVyZUluZGV4Kys7XG4gIH1cbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGdlb21SZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBnZW9tUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBjdXJyZW50R2VvbWV0cnkgVGhlIGN1cnJlbnQgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZVByb3BlcnRpZXMgVGhlIGN1cnJlbnQgRmVhdHVyZSBQcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmVhdHVyZUJCb3ggVGhlIGN1cnJlbnQgRmVhdHVyZSBCQm94IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZmVhdHVyZUlkIFRoZSBjdXJyZW50IEZlYXR1cmUgSWQgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBnZW9tUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZ2VvbVJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRHZW9tZXRyeVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89ZmVhdHVyZVByb3BlcnRpZXNcbiAqICAgLy89ZmVhdHVyZUJCb3hcbiAqICAgLy89ZmVhdHVyZUlkXG4gKiAgIHJldHVybiBjdXJyZW50R2VvbWV0cnlcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZ2VvbVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBnZW9tRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRHZW9tZXRyeTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmbGF0dGVuRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IGZsYXR0ZW5lZCBmZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5FYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlbkVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZmxhdHRlbkVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgZ2VvbUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIHByb3BlcnRpZXMsIGJib3gsIGlkKSB7XG4gICAgLy8gQ2FsbGJhY2sgZm9yIHNpbmdsZSBnZW9tZXRyeVxuICAgIHZhciB0eXBlID0gZ2VvbWV0cnkgPT09IG51bGwgPyBudWxsIDogZ2VvbWV0cnkudHlwZTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgaWYgKGNhbGxiYWNrKGZlYXR1cmUoZ2VvbWV0cnksIHByb3BlcnRpZXMsIHtcbiAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9KSwgZmVhdHVyZUluZGV4LCAwKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnZW9tVHlwZTsgLy8gQ2FsbGJhY2sgZm9yIG11bHRpLWdlb21ldHJ5XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGdlb21UeXBlID0gXCJQb2ludFwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiTGluZVN0cmluZ1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9seWdvblwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IDA7IG11bHRpRmVhdHVyZUluZGV4IDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBtdWx0aUZlYXR1cmVJbmRleCsrKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzW211bHRpRmVhdHVyZUluZGV4XTtcbiAgICAgIHZhciBnZW9tID0ge1xuICAgICAgICB0eXBlOiBnZW9tVHlwZSxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVcbiAgICAgIH07XG4gICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzKSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZsYXR0ZW5SZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmbGF0dGVuUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGZsYXR0ZW5lZCBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZmxhdHRlblJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5tdWx0aVBvaW50KFtbNDAsIDMwXSwgWzM2LCA1M11dLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5mbGF0dGVuUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRGZWF0dXJlXG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBtdWx0aUZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRGZWF0dXJlO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIDItdmVydGV4IGxpbmUgc2VnbWVudCBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICpcbiAqIC8vIEl0ZXJhdGUgb3ZlciBHZW9KU09OIGJ5IDItdmVydGV4IHNlZ21lbnRzXG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIC8vPXNlZ21lbnRJbmRleFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciB0b3RhbCA9IDA7XG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0b3RhbCsrO1xuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBzZWdtZW50RWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICBmbGF0dGVuRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZmVhdHVyZSQkMSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgIHZhciBzZWdtZW50SW5kZXggPSAwOyAvLyBFeGNsdWRlIG51bGwgR2VvbWV0cmllc1xuXG4gICAgaWYgKCFmZWF0dXJlJCQxLmdlb21ldHJ5KSByZXR1cm47IC8vIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cblxuICAgIHZhciB0eXBlID0gZmVhdHVyZSQkMS5nZW9tZXRyeS50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIlBvaW50XCIgfHwgdHlwZSA9PT0gXCJNdWx0aVBvaW50XCIpIHJldHVybjsgLy8gR2VuZXJhdGUgMi12ZXJ0ZXggbGluZSBzZWdtZW50c1xuXG4gICAgdmFyIHByZXZpb3VzQ29vcmRzO1xuICAgIHZhciBwcmV2aW91c0ZlYXR1cmVJbmRleCA9IDA7XG4gICAgdmFyIHByZXZpb3VzTXVsdGlJbmRleCA9IDA7XG4gICAgdmFyIHByZXZHZW9tSW5kZXggPSAwO1xuICAgIGlmIChjb29yZEVhY2goZmVhdHVyZSQkMSwgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4Q29vcmQsIG11bHRpUGFydEluZGV4Q29vcmQsIGdlb21ldHJ5SW5kZXgpIHtcbiAgICAgIC8vIFNpbXVsYXRpbmcgYSBtZXRhLmNvb3JkUmVkdWNlKCkgc2luY2UgYHJlZHVjZWAgb3BlcmF0aW9ucyBjYW5ub3QgYmUgc3RvcHBlZCBieSByZXR1cm5pbmcgYGZhbHNlYFxuICAgICAgaWYgKHByZXZpb3VzQ29vcmRzID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZUluZGV4ID4gcHJldmlvdXNGZWF0dXJlSW5kZXggfHwgbXVsdGlQYXJ0SW5kZXhDb29yZCA+IHByZXZpb3VzTXVsdGlJbmRleCB8fCBnZW9tZXRyeUluZGV4ID4gcHJldkdlb21JbmRleCkge1xuICAgICAgICBwcmV2aW91c0Nvb3JkcyA9IGN1cnJlbnRDb29yZDtcbiAgICAgICAgcHJldmlvdXNGZWF0dXJlSW5kZXggPSBmZWF0dXJlSW5kZXg7XG4gICAgICAgIHByZXZpb3VzTXVsdGlJbmRleCA9IG11bHRpUGFydEluZGV4Q29vcmQ7XG4gICAgICAgIHByZXZHZW9tSW5kZXggPSBnZW9tZXRyeUluZGV4O1xuICAgICAgICBzZWdtZW50SW5kZXggPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IGxpbmVTdHJpbmcoW3ByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRdLCBmZWF0dXJlJCQxLnByb3BlcnRpZXMpO1xuICAgICAgaWYgKGNhbGxiYWNrKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc2VnbWVudEluZGV4Kys7XG4gICAgICBwcmV2aW91c0Nvb3JkcyA9IGN1cnJlbnRDb29yZDtcbiAgICB9KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBzZWdtZW50UmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSAyLXZlcnRleCBsaW5lIHNlZ21lbnQgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgY3VycmVudEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dKTtcbiAqXG4gKiAvLyBJdGVyYXRlIG92ZXIgR2VvSlNPTiBieSAyLXZlcnRleCBzZWdtZW50c1xuICogdHVyZi5zZWdtZW50UmVkdWNlKHBvbHlnb24sIGZ1bmN0aW9uIChwcmV2aW91c1NlZ21lbnQsIGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAqICAgLy89IHByZXZpb3VzU2VnbWVudFxuICogICAvLz0gY3VycmVudFNlZ21lbnRcbiAqICAgLy89IGZlYXR1cmVJbmRleFxuICogICAvLz0gbXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89IGdlb21ldHJ5SW5kZXhcbiAqICAgLy89IHNlZ21lbnRJbmRleFxuICogICByZXR1cm4gY3VycmVudFNlZ21lbnRcbiAqIH0pO1xuICpcbiAqIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzXG4gKiB2YXIgaW5pdGlhbFZhbHVlID0gMFxuICogdmFyIHRvdGFsID0gdHVyZi5zZWdtZW50UmVkdWNlKHBvbHlnb24sIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlKSB7XG4gKiAgICAgcHJldmlvdXNWYWx1ZSsrO1xuICogICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICogfSwgaW5pdGlhbFZhbHVlKTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHNlZ21lbnRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgc2VnbWVudEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAgICBpZiAoc3RhcnRlZCA9PT0gZmFsc2UgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50U2VnbWVudDtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICBzdGFydGVkID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgbGluZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgbGluZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50TGluZSBUaGUgY3VycmVudCBMaW5lU3RyaW5nfExpbmVhclJpbmcgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGxpbmUgb3IgcmluZyBjb29yZGluYXRlcyBpbiBMaW5lU3RyaW5nLCBQb2x5Z29uLCBNdWx0aUxpbmVTdHJpbmcsIE11bHRpUG9seWdvbiBGZWF0dXJlcyBvciBHZW9tZXRyaWVzLFxuICogc2ltaWxhciB0byBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGxpbmVFYWNoXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgW1syNiwgMzddLCBbMzUsIDQ1XV0sXG4gKiAgIFtbMzYsIDUzXSwgWzM4LCA1MF0sIFs0MSwgNTVdXVxuICogXSk7XG4gKlxuICogdHVyZi5saW5lRWFjaChtdWx0aUxpbmUsIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50TGluZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBsaW5lRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAvLyB2YWxpZGF0aW9uXG4gIGlmICghZ2VvanNvbikgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyByZXF1aXJlZFwiKTtcbiAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUkJDEsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZSQkMS5nZW9tZXRyeSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciB0eXBlID0gZmVhdHVyZSQkMS5nZW9tZXRyeS50eXBlO1xuICAgIHZhciBjb29yZHMgPSBmZWF0dXJlJCQxLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZSQkMSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgMCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBmb3IgKHZhciBnZW9tZXRyeUluZGV4ID0gMDsgZ2VvbWV0cnlJbmRleCA8IGNvb3Jkcy5sZW5ndGg7IGdlb21ldHJ5SW5kZXgrKykge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhsaW5lU3RyaW5nKGNvb3Jkc1tnZW9tZXRyeUluZGV4XSwgZmVhdHVyZSQkMS5wcm9wZXJ0aWVzKSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgbGluZVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIGxpbmVSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudExpbmUgVGhlIGN1cnJlbnQgTGluZVN0cmluZ3xMaW5lYXJSaW5nIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGxpbmVSZWR1Y2VcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbj59IGdlb2pzb24gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzEyLDQ4XSxbMiw0MV0sWzI0LDM4XSxbMTIsNDhdXSwgW1s5LDQ0XSxbMTMsNDFdLFsxMyw0NV0sWzksNDRdXV0pLFxuICogICB0dXJmLnBvbHlnb24oW1tbNSwgNV0sIFswLCAwXSwgWzIsIDJdLCBbNCwgNF0sIFs1LCA1XV1dKVxuICogXSk7XG4gKlxuICogdHVyZi5saW5lUmVkdWNlKG11bHRpUG9seSwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudExpbmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRMaW5lXG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGxpbmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGluZUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRMaW5lO2Vsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgMi12ZXJ0ZXggTGluZVN0cmluZyBTZWdtZW50IGZyb20gYSBHZW9KU09OIHVzaW5nIGBAdHVyZi9tZXRhYCBpbmRleGVzLlxuICpcbiAqIE5lZ2F0aXZlIGluZGV4ZXMgYXJlIHBlcm1pdHRlZC5cbiAqIFBvaW50ICYgTXVsdGlQb2ludCB3aWxsIGFsd2F5cyByZXR1cm4gbnVsbC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gQW55IEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmVhdHVyZUluZGV4PTBdIEZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleD0wXSBNdWx0aS1GZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZ2VvbWV0cnlJbmRleD0wXSBHZW9tZXRyeSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNlZ21lbnRJbmRleD0wXSBTZWdtZW50IEluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIFByb3BlcnRpZXMgdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QkJveH0gW29wdGlvbnMuYmJveD17fV0gVHJhbnNsYXRlIEJCb3ggdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IDItdmVydGV4IEdlb0pTT04gRmVhdHVyZSBMaW5lU3RyaW5nXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lKTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWzEwLCAxMF0sIFs1MCwgMzBdXT4+XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCBvZiAybmQgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogMX0pO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIExhc3QgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogLTEsIHNlZ21lbnRJbmRleDogLTF9KTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWy01MCwgLTMwXSwgWy0zMCwgLTQwXV0+PlxuICovXG5cblxuZnVuY3Rpb24gZmluZFNlZ21lbnQoZ2VvanNvbiwgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBnZW9tZXRyeUluZGV4ID0gb3B0aW9ucy5nZW9tZXRyeUluZGV4IHx8IDA7XG4gIHZhciBzZWdtZW50SW5kZXggPSBvcHRpb25zLnNlZ21lbnRJbmRleCB8fCAwOyAvLyBGaW5kIEZlYXR1cmVJbmRleFxuXG4gIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xuICB2YXIgZ2VvbWV0cnk7XG5cbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGlmIChmZWF0dXJlSW5kZXggPCAwKSBmZWF0dXJlSW5kZXggPSBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCArIGZlYXR1cmVJbmRleDtcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5wcm9wZXJ0aWVzO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0uZ2VvbWV0cnk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJGZWF0dXJlXCI6XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLnByb3BlcnRpZXM7XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpO1xuICB9IC8vIEZpbmQgU2VnbWVudEluZGV4XG5cblxuICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHMubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKFtjb29yZHNbc2VnbWVudEluZGV4XSwgY29vcmRzW3NlZ21lbnRJbmRleCArIDFdXSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG5cbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhbY29vcmRzW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4XSwgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAoZ2VvbWV0cnlJbmRleCA8IDApIGdlb21ldHJ5SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4XSwgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpO1xufVxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgUG9pbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29vcmRJbmRleD0wXSBDb29yZCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBQb2ludFxuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIFBvaW50XG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFsxMCwgMTBdPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIHRoZSAybmQgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0xMCwgLTEwXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIGxhc3QgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBjb29yZEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbLTMwLCAtNDBdPj5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRQb2ludChnZW9qc29uLCBvcHRpb25zKSB7XG4gIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgaXMgaW52YWxpZFwiKTtcbiAgdmFyIGZlYXR1cmVJbmRleCA9IG9wdGlvbnMuZmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IG9wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIGdlb21ldHJ5SW5kZXggPSBvcHRpb25zLmdlb21ldHJ5SW5kZXggfHwgMDtcbiAgdmFyIGNvb3JkSW5kZXggPSBvcHRpb25zLmNvb3JkSW5kZXggfHwgMDsgLy8gRmluZCBGZWF0dXJlSW5kZXhcblxuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIGdlb21ldHJ5O1xuXG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbiAgfSAvLyBGaW5kIENvb3JkIEluZGV4XG5cblxuICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHMubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAoZ2VvbWV0cnlJbmRleCA8IDApIGdlb21ldHJ5SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCAtIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XVtjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG59XG5cbmV4cG9ydCB7IGNvb3JkRWFjaCwgY29vcmRSZWR1Y2UsIHByb3BFYWNoLCBwcm9wUmVkdWNlLCBmZWF0dXJlRWFjaCwgZmVhdHVyZVJlZHVjZSwgY29vcmRBbGwsIGdlb21FYWNoLCBnZW9tUmVkdWNlLCBmbGF0dGVuRWFjaCwgZmxhdHRlblJlZHVjZSwgc2VnbWVudEVhY2gsIHNlZ21lbnRSZWR1Y2UsIGxpbmVFYWNoLCBsaW5lUmVkdWNlLCBmaW5kU2VnbWVudCwgZmluZFBvaW50IH07IiwiaW1wb3J0IHsgY29vcmRFYWNoIH0gZnJvbSBcIkB0dXJmL21ldGFcIjtcbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgZmVhdHVyZXMsIGNhbGN1bGF0ZXMgdGhlIGJib3ggb2YgYWxsIGlucHV0IGZlYXR1cmVzLCBhbmQgcmV0dXJucyBhIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAbmFtZSBiYm94XG4gKiBAcGFyYW0ge0dlb0pTT059IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QkJveH0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB0dXJmLmxpbmVTdHJpbmcoW1stNzQsIDQwXSwgWy03OCwgNDJdLCBbLTgyLCAzNV1dKTtcbiAqIHZhciBiYm94ID0gdHVyZi5iYm94KGxpbmUpO1xuICogdmFyIGJib3hQb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihiYm94KTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZSwgYmJveFBvbHlnb25dXG4gKi9cblxuZnVuY3Rpb24gYmJveChnZW9qc29uKSB7XG4gIHZhciByZXN1bHQgPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGNvb3JkRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICBpZiAocmVzdWx0WzBdID4gY29vcmRbMF0pIHtcbiAgICAgIHJlc3VsdFswXSA9IGNvb3JkWzBdO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRbMV0gPiBjb29yZFsxXSkge1xuICAgICAgcmVzdWx0WzFdID0gY29vcmRbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdFsyXSA8IGNvb3JkWzBdKSB7XG4gICAgICByZXN1bHRbMl0gPSBjb29yZFswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0WzNdIDwgY29vcmRbMV0pIHtcbiAgICAgIHJlc3VsdFszXSA9IGNvb3JkWzFdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmJib3hbXCJkZWZhdWx0XCJdID0gYmJveDtcbmV4cG9ydCBkZWZhdWx0IGJib3g7IiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZVJlZn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcFN0eWxlIGZyb20gJy4uL2RhdGEvbWFwU3R5bGUnO1xuaW1wb3J0IFpvb21XYXJuaW5nIGZyb20gJy4vem9vbVdhcm5pbmcnO1xuaW1wb3J0IHtNYXAsIE1hcGJveEdlb0pTT05GZWF0dXJlfSBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQgUmVhY3RNYXBHTCwge1xuICBNYXBFdmVudCxcbiAgVmlld3BvcnRQcm9wcyxcbiAgV2ViTWVyY2F0b3JWaWV3cG9ydCxcbiAgTmF2aWdhdGlvbkNvbnRyb2wsXG4gIE1hcFJlZixcbiAgTWFwQ29udGV4dCwgRmx5VG9JbnRlcnBvbGF0b3J9IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vSjQwTWFwLm1vZHVsZS5zY3NzJztcbmltcG9ydCAnbWFwbGlicmUtZ2wvZGlzdC9tYXBsaWJyZS1nbC5jc3MnO1xuaW1wb3J0IGJib3ggZnJvbSAnQHR1cmYvYmJveCc7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMy1lYXNlJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBDeXByZXNzPzogb2JqZWN0O1xuICAgIHVuZGVybHlpbmdNYXA6IE1hcDtcbiAgfVxufVxuXG5pbnRlcmZhY2UgSUo0ME1hcCB7XG4gIHNldERldGFpbFZpZXdEYXRhOiBGdW5jdGlvblxufTtcblxuXG5jb25zdCBKNDBNYXAgPSAoe3NldERldGFpbFZpZXdEYXRhfTogSUo0ME1hcCkgPT4ge1xuICBjb25zdCBbdmlld3BvcnQsIHNldFZpZXdwb3J0XSA9IHVzZVN0YXRlPFZpZXdwb3J0UHJvcHM+KHtcbiAgICBsYXRpdHVkZTogY29uc3RhbnRzLkRFRkFVTFRfQ0VOVEVSWzBdLFxuICAgIGxvbmdpdHVkZTogY29uc3RhbnRzLkRFRkFVTFRfQ0VOVEVSWzFdLFxuICAgIHpvb206IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gIH0pO1xuXG4gIGNvbnN0IFtzZWxlY3RlZEZlYXR1cmUsIHNldFNlbGVjdGVkRmVhdHVyZV0gPSB1c2VTdGF0ZTxNYXBib3hHZW9KU09ORmVhdHVyZT4oKTtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxNYXBSZWY+KCk7XG5cbiAgY29uc3Qgb25DbGljayA9IChldmVudDogTWFwRXZlbnQpID0+IHtcbiAgICBjb25zdCBmZWF0dXJlID0gZXZlbnQuZmVhdHVyZXMgJiYgZXZlbnQuZmVhdHVyZXNbMF07XG4gICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgIGNvbnN0IFttaW5MbmcsIG1pbkxhdCwgbWF4TG5nLCBtYXhMYXRdID0gYmJveChmZWF0dXJlKTtcbiAgICAgIGNvbnN0IG5ld1ZpZXdQb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnQpO1xuICAgICAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219ID0gbmV3Vmlld1BvcnQuZml0Qm91bmRzKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFttaW5MbmcsIG1pbkxhdF0sXG4gICAgICAgICAgICBbbWF4TG5nLCBtYXhMYXRdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGFkZGluZzogNDAsXG4gICAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBjb25zdCBtYXAgPSBtYXBSZWYuY3VycmVudC5nZXRNYXAoKTtcblxuICAgICAgLy8gSWYgd2UndmUgc2VsZWN0ZWQgYSBuZXcgZmVhdHVyZSwgc2V0ICdzZWxlY3RlZCcgdG8gZmFsc2VcbiAgICAgIGlmIChzZWxlY3RlZEZlYXR1cmUgJiYgZmVhdHVyZS5pZCAhPT0gc2VsZWN0ZWRGZWF0dXJlLmlkKSB7XG4gICAgICAgIG1hcC5zZXRGZWF0dXJlU3RhdGUoe1xuICAgICAgICAgIHNvdXJjZTogc2VsZWN0ZWRGZWF0dXJlLnNvdXJjZSxcbiAgICAgICAgICBzb3VyY2VMYXllcjogc2VsZWN0ZWRGZWF0dXJlLnNvdXJjZUxheWVyLFxuICAgICAgICAgIGlkOiBzZWxlY3RlZEZlYXR1cmUuaWQsXG4gICAgICAgIH0sIHtzZWxlY3RlZDogZmFsc2V9KTtcbiAgICAgIH1cbiAgICAgIG1hcC5zZXRGZWF0dXJlU3RhdGUoe1xuICAgICAgICBzb3VyY2U6IGZlYXR1cmUuc291cmNlLFxuICAgICAgICBzb3VyY2VMYXllcjogZmVhdHVyZS5zb3VyY2VMYXllcixcbiAgICAgICAgaWQ6IGZlYXR1cmUuaWQsXG4gICAgICB9LCB7c2VsZWN0ZWQ6IHRydWV9KTtcbiAgICAgIHNldFNlbGVjdGVkRmVhdHVyZShmZWF0dXJlKTtcblxuICAgICAgLy8gTmVlZHMgcmVmaW5pbmdcbiAgICAgIC8vIHNldFZpZXdwb3J0KHtcbiAgICAgIC8vICAgLi4udmlld3BvcnQsXG4gICAgICAvLyAgIGxvbmdpdHVkZSxcbiAgICAgIC8vICAgbGF0aXR1ZGUsXG4gICAgICAvLyAgIHpvb20sXG4gICAgICAvLyAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgLy8gICAgIGFyb3VuZDogW2V2ZW50Lm9mZnNldENlbnRlci54LCBldmVudC5vZmZzZXRDZW50ZXIueV0sXG4gICAgICAvLyAgIH0pLFxuICAgICAgLy8gICB0cmFuc2l0aW9uRHVyYXRpb246IDEwMDAsXG4gICAgICAvLyB9KTtcblxuICAgICAgY29uc3QgcG9wdXBJbmZvID0ge1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICB9O1xuICAgICAgc2V0RGV0YWlsVmlld0RhdGEocG9wdXBJbmZvKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25Mb2FkID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3cuQ3lwcmVzcykge1xuICAgICAgd2luZG93LnVuZGVybHlpbmdNYXAgPSBtYXBSZWYuY3VycmVudC5nZXRNYXAoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ29Ub1BsYWNlID0gKGJvdW5kczogW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dKSA9PiB7XG4gICAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnQpXG4gICAgICAgIC5maXRCb3VuZHMoYm91bmRzLCB7XG4gICAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgICAgb2Zmc2V0OiBbMCwgLTEwMF0sXG4gICAgICAgIH0pO1xuICAgIHNldFZpZXdwb3J0KHtcbiAgICAgIC4uLnZpZXdwb3J0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IEZseVRvSW50ZXJwb2xhdG9yKCksXG4gICAgICB0cmFuc2l0aW9uRWFzaW5nOiBkMy5lYXNlQ3ViaWMsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9uQ2xpY2tab29tQnV0dG9uID0gKGV2ZW50OiBNYXBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbklEID0gZXZlbnQudGFyZ2V0LmlkO1xuICAgIHN3aXRjaCAoYnV0dG9uSUQpIHtcbiAgICAgIGNhc2UgJzQ4JzpcbiAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5MT1dFUl80OF9CT1VORFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FLJzpcbiAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5BTEFTS0FfQk9VTkRTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdISSc6XG4gICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuSEFXQUlJX0JPVU5EUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUFInOlxuICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLlBVRVJUT19SSUNPX0JPVU5EUyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8UmVhY3RNYXBHTFxuICAgICAgICB7Li4udmlld3BvcnR9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1hcENvbnRhaW5lcn1cbiAgICAgICAgbWFwU3R5bGU9e21hcFN0eWxlfVxuICAgICAgICAvLyBtaW5ab29tPXtjb25zdGFudHMuR0xPQkFMX01JTl9aT09NfVxuICAgICAgICAvLyBtYXhab29tPXtjb25zdGFudHMuR0xPQkFMX01BWF9aT09NfVxuICAgICAgICBtYXBPcHRpb25zPXt7aGFzaDogdHJ1ZX19XG4gICAgICAgIHdpZHRoPVwiNjguNHZ3XCJcbiAgICAgICAgaGVpZ2h0PVwiNTJ2d1wiXG4gICAgICAgIGRyYWdSb3RhdGU9e2ZhbHNlfVxuICAgICAgICB0b3VjaFJvdGF0ZT17ZmFsc2V9XG4gICAgICAgIGludGVyYWN0aXZlTGF5ZXJJZHM9e1tjb25zdGFudHMuU0NPUkVfTEFZRVJdfVxuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPXtzZXRWaWV3cG9ydH1cbiAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgb25Mb2FkPXtvbkxvYWR9XG4gICAgICAgIHJlZj17bWFwUmVmfVxuICAgICAgPlxuICAgICAgICB7Lyoge3BvcHVwSW5mbyAmJiAoXG4gICAgICAgICAgPFBvcHVwXG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5qNDBQb3B1cH1cbiAgICAgICAgICAgIHRpcFNpemU9ezV9XG4gICAgICAgICAgICBhbmNob3I9XCJ0b3BcIlxuICAgICAgICAgICAgbG9uZ2l0dWRlPXtwb3B1cEluZm8ubG9uZ2l0dWRlfVxuICAgICAgICAgICAgbGF0aXR1ZGU9e3BvcHVwSW5mby5sYXRpdHVkZX1cbiAgICAgICAgICAgIGNsb3NlT25DbGljaz17dHJ1ZX1cbiAgICAgICAgICAgIG9uQ2xvc2U9e3NldFBvcHVwSW5mb31cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8QXJlYURldGFpbCBwcm9wZXJ0aWVzPXtwb3B1cEluZm8ucHJvcGVydGllc30gLz5cbiAgICAgICAgICA8L1BvcHVwPlxuICAgICAgICApfSAqL31cblxuICAgICAgICA8TmF2aWdhdGlvbkNvbnRyb2xcbiAgICAgICAgICBzaG93Q29tcGFzcz17ZmFsc2V9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubmF2aWdhdGlvbkNvbnRyb2xzfVxuICAgICAgICAvPlxuICAgICAgPC9SZWFjdE1hcEdMPlxuICAgICAgPFpvb21XYXJuaW5nIHpvb21MZXZlbD17dmlld3BvcnQuem9vbSF9IC8+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnpvb21Db250YWluZXJ9PlxuICAgICAgICA8YnV0dG9uIGlkPXsnNDgnfSBvbkNsaWNrPXtvbkNsaWNrWm9vbUJ1dHRvbn0gY2xhc3NOYW1lPXtzdHlsZXMuem9vbUJ1dHRvbn0+NDg8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBpZD17J0FLJ30gb25DbGljaz17b25DbGlja1pvb21CdXR0b259IGNsYXNzTmFtZT17c3R5bGVzLnpvb21CdXR0b259PkFLPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gaWQ9eydISSd9IG9uQ2xpY2s9e29uQ2xpY2tab29tQnV0dG9ufSBjbGFzc05hbWU9e3N0eWxlcy56b29tQnV0dG9ufT5ISTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGlkPXsnUFInfSBvbkNsaWNrPXtvbkNsaWNrWm9vbUJ1dHRvbn0gY2xhc3NOYW1lPXtzdHlsZXMuem9vbUJ1dHRvbn0+UFI8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSjQwTWFwO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGFyZWFEZXRhaWxUYWJsZSA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWFyZWFEZXRhaWxUYWJsZS0tMWtXNTVcIjtcbmV4cG9ydCB2YXIgdGl0bGVDb250YWluZXIgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS10aXRsZUNvbnRhaW5lci0tMXRVSU5cIjtcbmV4cG9ydCB2YXIgdGl0bGVJbmRpY2F0b3JOYW1lID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tdGl0bGVJbmRpY2F0b3JOYW1lLS11QW5GVlwiO1xuZXhwb3J0IHZhciBhcmVhRGV0YWlsQ29udGFpbmVyID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tYXJlYURldGFpbENvbnRhaW5lci0tMTVhZTlcIjtcbmV4cG9ydCB2YXIgYXJlYURldGFpbFRhYmxlQ29udGFpbmVyID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tYXJlYURldGFpbFRhYmxlQ29udGFpbmVyLS0xbDhjd1wiOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9kYXRhL2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9hcmVhRGV0YWlsLm1vZHVsZS5zY3NzJztcblxuaW50ZXJmYWNlIElBcmVhRGV0YWlsUHJvcHMge1xuICBwcm9wZXJ0aWVzOiBjb25zdGFudHMuSjQwUHJvcGVydGllcyxcbn1cblxuXG5jb25zdCBBcmVhRGV0YWlsID0gKHtwcm9wZXJ0aWVzfTpJQXJlYURldGFpbFByb3BzKSA9PiB7XG4gIGNvbnN0IHJlYWRhYmxlUGVyY2VudCA9IChwZXJjZW50OiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gYCR7KHBlcmNlbnQgKiAxMDApLnRvRml4ZWQoMil9YDtcbiAgfTtcblxuICBjb25zdCBnZXRDYXRlZ29yaXphdGlvbiA9IChwZXJjZW50aWxlOiBudW1iZXIpID0+IHtcbiAgICBsZXQgY2F0ZWdvcml6YXRpb247XG4gICAgaWYgKHBlcmNlbnRpbGUgPj0gMC43NSApIHtcbiAgICAgIGNhdGVnb3JpemF0aW9uID0gJ1ByaW9yaXRpemVkJztcbiAgICB9IGVsc2UgaWYgKDAuNjAgPD0gcGVyY2VudGlsZSAmJiBwZXJjZW50aWxlIDwgMC43NSkge1xuICAgICAgY2F0ZWdvcml6YXRpb24gPSAnVGhyZXNob2xkJztcbiAgICB9IGVsc2Uge1xuICAgICAgY2F0ZWdvcml6YXRpb24gPSAnTm9uLXByaW9yaXRpemVkJztcbiAgICB9XG4gICAgcmV0dXJuIGNhdGVnb3JpemF0aW9uO1xuICB9O1xuXG4gIGNvbnN0IGdldFRpdGxlQ29udGVudCA9ICgpID0+IHtcbiAgICBjb25zdCBibG9ja0dyb3VwID0gcHJvcGVydGllc1tjb25zdGFudHMuR0VPSURfUFJPUEVSVFldO1xuICAgIGNvbnN0IHNjb3JlID0gcHJvcGVydGllc1tjb25zdGFudHMuU0NPUkVfUFJPUEVSVFldIGFzIG51bWJlcjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMudGl0bGVJbmRpY2F0b3JOYW1lfT5DZW5zdXMgQmxvY2sgR3JvdXA6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57YmxvY2tHcm91cH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlSW5kaWNhdG9yTmFtZX0+SnVzdCBQcm9ncmVzcyBDYXRlZ29yaXphdGlvbjogPC9zcGFuPlxuICAgICAgICAgIDxzcGFuPntnZXRDYXRlZ29yaXphdGlvbihzY29yZSl9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUluZGljYXRvck5hbWV9PkN1bXVsYXRpdmUgSW5kZXggU2NvcmU6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57cmVhZGFibGVQZXJjZW50KHNjb3JlKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBnZXRCb2R5Q29udGVudCA9ICgpID0+IHtcbiAgICBjb25zdCByb3dzID0gW107XG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpLnNvcnQoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc29ydGVkS2V5cykge1xuICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgZm9ybWF0IGZsb2F0c1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICAgIHZhbHVlID0gcmVhZGFibGVQZXJjZW50KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIG91dCBhbGwgY2Fwc1xuICAgICAgaWYgKCFrZXkubWF0Y2goL15bQS1aMC05XSskLykpIHtcbiAgICAgICAgcm93cy5wdXNoKDx0ciBrZXk9e2tleX0gPlxuICAgICAgICAgIDx0ZD57a2V5fTwvdGQ+XG4gICAgICAgICAgPHRkPnt2YWx1ZX08L3RkPlxuICAgICAgICA8L3RyPik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3Byb3BlcnRpZXMgP1xuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcmVhRGV0YWlsQ29udGFpbmVyfT5cbiAgICAgICAge2dldFRpdGxlQ29udGVudCgpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFyZWFEZXRhaWxUYWJsZUNvbnRhaW5lcn0+XG4gICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17J3VzYS10YWJsZSB1c2EtdGFibGUtLWJvcmRlcmxlc3MgJyArIHN0eWxlcy5hcmVhRGV0YWlsVGFibGV9PlxuICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+SU5ESUNBVE9SPC90aD5cbiAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5WQUxVRTwvdGg+XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICB7Z2V0Qm9keUNvbnRlbnQoKX1cbiAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj4gOlxuICAgICcnIH1cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFyZWFEZXRhaWw7XG4iLCJpbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEo0ME1hcCBmcm9tICcuL0o0ME1hcCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0IEFyZWFEZXRhaWwgZnJvbSAnLi9hcmVhRGV0YWlsJztcblxuaW50ZXJmYWNlIElEZXRhaWxWaWV3SW50ZXJmYWNlIHtcbiAgbGF0aXR1ZGU6IG51bWJlclxuICBsb25naXR1ZGU6IG51bWJlclxuICB6b29tOiBudW1iZXJcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXMsXG59O1xuXG5cbmNvbnN0IE1hcFdyYXBwZXIgPSAoKSA9PiB7XG4gIGNvbnN0IFtkZXRhaWxWaWV3RGF0YSwgc2V0RGV0YWlsVmlld0RhdGFdID0gdXNlU3RhdGU8SURldGFpbFZpZXdJbnRlcmZhY2U+KG51bGwpO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZC1yb3dcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZC1jb2wtOVwiPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIDxKNDBNYXAgc2V0RGV0YWlsVmlld0RhdGE9e3NldERldGFpbFZpZXdEYXRhfS8+XG4gICAgICAgICAgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkLWNvbC0zXCI+XG4gICAgICAgIHtkZXRhaWxWaWV3RGF0YSAmJlxuICAgICAgICAgIDxBcmVhRGV0YWlsIHByb3BlcnRpZXM9e2RldGFpbFZpZXdEYXRhLnByb3BlcnRpZXN9IC8+XG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBNYXBXcmFwcGVyO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGhvd1lvdUNhbkhlbHBDb250YWluZXIgPSBcIkhvd1lvdUNhbkhlbHAtbW9kdWxlLS1ob3dZb3VDYW5IZWxwQ29udGFpbmVyLS0ya3FCYVwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9Ib3dZb3VDYW5IZWxwLm1vZHVsZS5zY3NzJztcblxuY29uc3QgSG93WW91Q2FuSGVscCA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhvd1lvdUNhbkhlbHBDb250YWluZXJ9PlxuICAgICAgPGgyPkhvdyBZb3UgQ2FuIEhlbHAgSW1wcm92ZSB0aGUgVG9vbDwvaDI+XG4gICAgICA8dWwgY2xhc3NOYW1lPXsndXNhLWxpc3QnfT5cbiAgICAgICAgPGxpPklmIHlvdSBoYXZlIGluZm9ybWF0aW9uIHRoYXQgY291bGQgaGVscCwgd2XigJlkIGxvdmUgdG8gaGVhciBmcm9tIHlvdS48L2xpPlxuICAgICAgICA8bGk+VmlldyBvdXIgZnVsbCBzZXQgb2YgZGF0YSBzb3VyY2VzIGFuZCBtZXRob2RvbG9neVxuICAgICAgICAgICAgd2hlcmUgeW91IGNhbiBhZGQgb3IgZG93bmxvYWQgc291cmNlcyBhbmQgY2hlY2sgc3RhdHVzZXMgb24gb3VyIGRhdGEgcm9hZG1hcC48L2xpPlxuICAgICAgICA8bGk+Q2hlY2sgb3V0IG91ciB0aW1lbGluZSBhbmQgc2VuZCBmZWVkYmFjayBvciBhdHRlbmQgcmVsZXZhbnQgZXZlbnRzLjwvbGk+XG4gICAgICAgIDxsaT5Db250YWN0IHVzIGFuZCBzaGFyZSB0aGUgc3RvcmllcyBvZiB5b3VyIGNvbW11bml0eS48L2xpPlxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvd1lvdUNhbkhlbHA7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgbGVnZW5kQ29udGFpbmVyID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1sZWdlbmRDb250YWluZXItLTJOMUZDXCI7XG5leHBvcnQgdmFyIHN3YXRjaENvbnRhaW5lciA9IFwibWFwTGVnZW5kLW1vZHVsZS0tc3dhdGNoQ29udGFpbmVyLS0xeVpYMVwiO1xuZXhwb3J0IHZhciBsZWdlbmRJdGVtID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1sZWdlbmRJdGVtLS1XZXpVZlwiO1xuZXhwb3J0IHZhciBjb2xvclN3YXRjaCA9IFwibWFwTGVnZW5kLW1vZHVsZS0tY29sb3JTd2F0Y2gtLW9CVU4yXCI7XG5leHBvcnQgdmFyIHByaW9yaXRpemVkID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1wcmlvcml0aXplZC0tMUk1MzRcIjtcbmV4cG9ydCB2YXIgdGhyZXNob2xkID0gXCJtYXBMZWdlbmQtbW9kdWxlLS10aHJlc2hvbGQtLTF6YWxpXCI7XG5leHBvcnQgdmFyIG5vblByaW9yaXRpemVkID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1ub25Qcmlvcml0aXplZC0tMnkwVm1cIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vbWFwTGVnZW5kLm1vZHVsZS5zY3NzJztcblxuY29uc3QgTWFwTGVnZW5kID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kQ29udGFpbmVyfT5cbiAgICAgIDxoMyBjbGFzc05hbWU9e3N0eWxlcy5sZWdlbmRIZWFkZXJ9PkNPTE9SIEtFWTwvaDM+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnN3YXRjaENvbnRhaW5lcn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kSXRlbX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2xvclN3YXRjaH0gaWQ9e3N0eWxlcy5wcmlvcml0aXplZH0gLz5cbiAgICAgICAgICA8c3Bhbj5Qcmlvcml0aXplZCBDb21tdW5pdHk8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmxlZ2VuZEl0ZW19PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sb3JTd2F0Y2h9IGlkPXtzdHlsZXMudGhyZXNob2xkfSAvPlxuICAgICAgICAgIDxzcGFuPlRocmVzaG9sZCBDb21tdW5pdHk8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmxlZ2VuZEl0ZW19PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sb3JTd2F0Y2h9IGlkPXtzdHlsZXMubm9uUHJpb3JpdGl6ZWR9IC8+XG4gICAgICAgICAgPHNwYW4+Tm9uLVByaW9yaXRpemVkIENvbW11bml0eTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcExlZ2VuZDtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBkaXNjbGFpbWVyID0gXCJjZWpzdC1tb2R1bGUtLWRpc2NsYWltZXItLTNMQzF5XCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vY29tcG9uZW50cy9sYXlvdXQnO1xuaW1wb3J0IE1hcFdyYXBwZXIgZnJvbSAnLi4vY29tcG9uZW50cy9tYXBXcmFwcGVyJztcbmltcG9ydCBIb3dZb3VDYW5IZWxwIGZyb20gJy4uL2NvbXBvbmVudHMvSG93WW91Q2FuSGVscCc7XG5pbXBvcnQgTWFwTGVnZW5kIGZyb20gJy4uL2NvbXBvbmVudHMvbWFwTGVnZW5kJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL2NlanN0Lm1vZHVsZS5zY3NzJztcblxuXG5pbnRlcmZhY2UgSU1hcFBhZ2VQcm9wcyB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuY29uc3QgQ0VKU1RQYWdlID0gKHtsb2NhdGlvbn06IElNYXBQYWdlUHJvcHMpID0+IHtcbiAgLy8gV2UgdGVtcG9yYXJpbHkgcmVtb3ZlZCBNYXBDb250cm9scywgd2hpY2ggd291bGQgZW5hYmxlIHlvdSB0byBgc2V0RmVhdHVyZXNgIGFsc28sIGZvciBub3dcbiAgLy8gICBXZSB3aWxsIGJyaW5nIGJhY2sgbGF0ZXIgd2hlbiB3ZSBoYXZlIGludGVyYWN0aXZlIGNvbnRyb2xzLlxuICByZXR1cm4gKFxuICAgIDxMYXlvdXQgbG9jYXRpb249e2xvY2F0aW9ufT5cbiAgICAgIDxtYWluIGlkPVwibWFpbi1jb250ZW50XCIgcm9sZT1cIm1haW5cIj5cbiAgICAgICAgPGgyPkp1c3QgUHJvZ3Jlc3MgY29tbXVuaXRpZXM8L2gyPlxuICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5kaXNjbGFpbWVyfT5cbiAgICAgICAgICBKdXN0IFByb2dyZXNzIGhlbHBzIGlkZW50aWZ5IGFuZCBwcmlvcml0aXplIGNvbW11bml0aWVzIGFjcm9zcyB0aGVcbiAgICAgICAgICBVbml0ZWQgU3RhdGVzIGFuZCBVLlMuIHRlcnJpdG9yaWVzIHRoYXQgaGF2ZSBiZWVuIGhpc3RvcmljYWxseVxuICAgICAgICAgIG92ZXJidXJkZW5lZCBhbmQgdW5kZXJzZXJ2ZWQuIFRoZXNlIGNvbW11bml0aWVzIHdpbGwgcmVjZWl2ZSA0MCUgb2ZcbiAgICAgICAgICB0aGUgYmVuZWZpdHMgZnJvbSBpbnZlc3RtZW50cyBpbiBrZXkgYXJlYXMgb3V0bGluZWQgYnkgdGhlXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGhyZWY9eydodHRwczovL3d3dy53aGl0ZWhvdXNlLmdvdi9icmllZmluZy1yb29tLycgK1xuICAgICAgICAgICAgJ3ByZXNpZGVudGlhbC1hY3Rpb25zLzIwMjEvMDEvMjcvJyArXG4gICAgICAgICAgICAnZXhlY3V0aXZlLW9yZGVyLW9uLXRhY2tsaW5nLXRoZS1jbGltYXRlLScgK1xuICAgICAgICAgICAgJ2NyaXNpcy1hdC1ob21lLWFuZC1hYnJvYWQvJ31cbiAgICAgICAgICAgIHRhcmdldD17J19ibGFuayd9XG4gICAgICAgICAgICByZWw9eydub3JlZmVycmVyJ30+XG4gICAgICAgICAgICBFeGVjdXRpdmUgT3JkZXIgb24gVGFja2xpbmcgdGhlIENsaW1hdGUgQ3Jpc2lzIGF0IEhvbWUgYW5kXG4gICAgICAgICAgICBBYnJvYWQ8L2E+LlxuICAgICAgICA8L3A+XG4gICAgICAgIDxoMj5FeHBsb3JlIHRoZSBUb29sPC9oMj5cbiAgICAgICAgPE1hcFdyYXBwZXIvPlxuICAgICAgICA8TWFwTGVnZW5kIC8+XG4gICAgICAgIDxIb3dZb3VDYW5IZWxwIC8+XG4gICAgICA8L21haW4+XG4gICAgPC9MYXlvdXQ+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDRUpTVFBhZ2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9693\n')}}]);